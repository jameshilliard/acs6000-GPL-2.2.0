/* -*- linux-c -*- */
/**
 * @file response.c
 *
 * Handles the management and transfomation of cacpd-protocol
 * data into in-memory data structures.
 *
 * @author Hugh Nelson
 *
 * @ingroup libcacpdparser
 */

#define _GNU_SOURCE

#include <stdio.h>
#include <string.h>
#include <glib-2.0/glib.h>
#include <glib/gprintf.h>
#include <dlog.h>

#include "libcacpdparser/cacpdparser.h"
#include "response_priv.h"

#define DLOG_CONTEXT "cacpclient"

/// Response code index.
#define STAT 0

/// Message index.
#define MSG  1

struct cacpdclient_command_response
{
	/**
	 * Holds a list of cont_line structures that comprise
	 * the user data of a given response.
	 *
	 * @todo Turn this into a hash table.
	 */
	GList* cont_lines;

	/**
	 * Holds the parsed response code.
	 */
	enum cacpdclient_transaction_result_code result_code;

	/**
	 * Holds the message received after the response code, or NULL
         * if there is no message.  Example: "sanity check failed"
	 */
	gchar* msg;
};

/**
 * Holds one line of a cacpd response.
 */
typedef struct
{
	/** Holds the id string for the response line. Usually,
	 * this entry is auto-generated by cacpd.*/
	gchar* id;
	/** Holds the text returned by cacpd for the content of the
	 * line. */
	gchar* value;
} cont_line;

cacpdclient_command_response *create_command_response()
{
    cacpdclient_command_response *resp = (cacpdclient_command_response *)malloc(sizeof(cacpdclient_command_response));
    resp->cont_lines = NULL;
    resp->result_code = CACP_RESULT_NONE;
    resp->msg = NULL;

    return resp;
}
cacpdclient_command_response *create_command_response_ok()
{
    cacpdclient_command_response *resp = (cacpdclient_command_response *)malloc(sizeof(cacpdclient_command_response));
    resp->cont_lines = NULL;
    resp->result_code = CACP_RESULT_OK;
    resp->msg = NULL;

    return resp;
}

const char const *cacpdclient_result_code_description(enum cacpdclient_transaction_result_code result_code)
{
    switch(result_code) {
    case CACP_RESULT_OK:
        return "OK";

    case CACP_RESULT_ERR:
        return "ERR";

    case CACP_RESULT_MALFORMED_REQUEST:
        return "BAD";

    case CACP_RESULT_MALFORMED_RESPONSE:
        return "(invalid response)";

    case CACP_RESULT_CONNECTION_FAILED:
        return "(connection failed)";

    case CACP_RESULT_SESSION_TERMINATED:
        return "(session terminated by server)";

    case CACP_RESULT_NODE_EXISTS:
        return "(node exists)";

    case CACP_RESULT_NODE_NOT_FOUND:
        return "(node not found)";

    case CACP_RESULT_SANITY_CHECK_FAILED:
        return "(sanity check failed)";

    case CACP_RESULT_PERMISSION_DENIED:
        return "(permission denied)";

    case CACP_RESULT_COMMIT_CONFLICT:
        return "(commit conflict)";

    case CACP_RESULT_AUTHENTICATION_FAILED:
        return "(authentication failed)";

    case CACP_RESULT_NONE:
        return "(no response)";
    }

    return "???";
}

char *cacpdclient_response_get_result_description(cacpdclient_command_response *resp)
{
	char *result = NULL;
	if (resp->msg)
		asprintf(&result, "%s (message: \"%s\")",
			cacpdclient_result_code_description(resp->result_code),
			resp->msg);

	if (!result)
		result = strdup(cacpdclient_result_code_description(resp->result_code));

	return result;
}

enum cacpdclient_transaction_result_code result_code_for_string(const char const *str)
{
	if (!strncmp("OK ", str, 3) || !strcmp("OK", str))
		return CACP_RESULT_OK;
	else if (!strncmp("ERR ", str, 4) || !strcmp("ERR", str)) {
		if (!strcmp("ERR sanity check failed", str))
			return CACP_RESULT_SANITY_CHECK_FAILED;
		else if (!strcmp("ERR commit conflict", str))
			return CACP_RESULT_COMMIT_CONFLICT;
		else if (!strcmp("ERR parameter not found", str) ||
			!strcmp("ERR result=2 No such file or directory", str))
			return CACP_RESULT_NODE_NOT_FOUND;
		else if (!strcmp("ERR result=6 File exists", str))
			return CACP_RESULT_NODE_EXISTS;
		else
			return CACP_RESULT_ERR;
	} else if (!strcmp("NO permission denied", str) ||
			!strcmp("NO you do not have write permission", str))
		return CACP_RESULT_PERMISSION_DENIED;
	else if (!strcmp("NO auth failed", str))
		return CACP_RESULT_AUTHENTICATION_FAILED;
	else if (!strcmp("NO invalid session id", str) ||
			 !strcmp("NO timed out", str) ||
			!strcmp("NO logged out", str))
		return CACP_RESULT_SESSION_TERMINATED;
	else if (!strncmp("BAD ", str, 4))
		return CACP_RESULT_MALFORMED_REQUEST;
	else if (!strncmp("INUSE ", str, 6))
		return CACP_RESULT_SESSION_TERMINATED;

	return CACP_RESULT_MALFORMED_RESPONSE;
}

/**
 * Handles a final line, and concludes processing of an element.
 *
 * @param msg Any message associated with the status code.
 */
void handle_final(cacpdclient_command_response *resp, gchar* msg)
{
	resp->cont_lines  = g_list_reverse( resp->cont_lines );
	gchar** frag = g_strsplit( msg, " ", 2 );

	resp->msg = frag[ MSG ]; 

	resp->result_code = result_code_for_string(msg);

	dlog_printf(DLOG_DEBUG, DLOG_CONTEXT, "Got a complete response.  Result=\"%s\", message=\"%s\".",
		cacpdclient_result_code_description(resp->result_code), resp->msg);
	free( frag[ STAT ] );
	free( frag );
}

/**
 * Handle continuation line.  This function does several things.
 * First, it examines the header, and determines if this line
 * belongs to the current element.  If not, it will create a new
 * sub-element.  Second, If a new sub-element is to be created, 
 * it will add the current sub-element to the current element.
 *
 * @param header A cacpd continuation header, the one with a dot.
 *
 * @param content A string to be added to a list of strings that
 * will form a sub-element.
 */
void handle_cont( cacpdclient_command_response *el, gchar* header, gchar* content )
{
	cont_line* cl = g_malloc0( sizeof( cont_line ) );

	// Split the header code into a prefix and suffix.
	gchar** split_header = g_strsplit( header, ".",	2 );
	gchar* suffix = split_header[ 1 ];
	
	cl->id    = g_strdup( suffix );
	cl->value = g_strdup(content);

	g_strfreev( split_header );

	el->cont_lines = g_list_prepend( el->cont_lines, cl );
}

/**
 * Gets the value of a cacpd parameter from the response document.
 *
 * @return Value of a cacpd parameter.
 */
gchar *cacpdclient_response_get_value(cacpdclient_command_response *resp) {
    GList* lineList = NULL;
    GList* firstLine = NULL;
    cont_line* line = NULL;
    gchar *value = NULL;
    
    if (resp) {
        lineList = resp->cont_lines;
        firstLine = g_list_first(lineList);
        if (firstLine) {
            line = firstLine->data;
            if (line) {
                value = line->value;
            }
        }
    }
    return value;
}

/**
 * Gets a list of values from the response.
 *
 * @param [in] resp The response from which to obtain the list.
 * @param [in] id The identifier for the subresponse to list, or NULL to
 *      simply get all subresponses in one list.
 *
 * @return List of entries of a CACPD node.
 */
static GSList *cacpdclient_response_get_list_for_id_match(cacpdclient_command_response *resp, const char const *id, int match_start_only) {
    GSList *output = NULL;
    int len = 0;

    if (id)
        len = strlen(id);
    
    if (resp) {
        GList *p;
	dlog_printf(DLOG_DEBUG, DLOG_CONTEXT, "Getting list for id %s\"%s\".\n",
                (match_start_only ? "starting with " : ""), id);

        for(p = g_list_first(resp->cont_lines); p; p = g_list_next(p)) {
            cont_line *line = p->data;
            dlog_printf(DLOG_DEBUG, DLOG_CONTEXT, "  line id = \"%s\".\n", line->id);

            int include;
            if (!id)
                include = 1;
            else if (match_start_only)
                include = !strncmp(id, line->id, len);
            else
                include = !strcmp(id, line->id);

            if (include){
		dlog_printf(DLOG_DEBUG, DLOG_CONTEXT, "    included in result \"%s\".\n", line->value);
                output = g_slist_prepend(output, line->value);
            }
        }
        output = g_slist_reverse(output);
	dlog_printf(DLOG_DEBUG, DLOG_CONTEXT, "List complete.");
    }
    return output;
}

GSList *cacpdclient_response_get_list_for_id(cacpdclient_command_response *resp, const char const *id) {
    return cacpdclient_response_get_list_for_id_match(resp, id, 0);
}

GSList *cacpdclient_response_get_list_for_id_starting_with(cacpdclient_command_response *resp, const char const *id) {
    return cacpdclient_response_get_list_for_id_match(resp, id, 1);
}

GSList *cacpdclient_response_get_list(cacpdclient_command_response *resp) {
    return cacpdclient_response_get_list_for_id(resp, NULL);
}

/**
 * Gets the list of choices from the response document.
 *
 * @return List of choices of a CACPD parameter.
 */
GSList *cacpdclient_response_get_choices(cacpdclient_command_response *resp) {
    return cacpdclient_response_get_list_for_id_starting_with(resp, "choices.");
}

enum cacpdclient_transaction_result_code cacpdclient_response_get_result_code(cacpdclient_command_response *resp)
{
    return resp->result_code;
}

char *cacpdclient_response_get_message(cacpdclient_command_response *resp)
{
    return resp->msg;
}

/**
 * Makes a copy of all the response text in the given list.
 * If you (humble caller) want a copy of all of the list contents, this
 * function provides an easy way to obtain it.  Use this if you still want to
 * use one of these lists after the response has been destroyed.
 *
 * @param [in] orig A list of strings, as returned by cacpdclient_response_get_list_for...
 *      or cacpdclient_response_get_choices.
 * @return The same GSList as was passed in, but upon return, the caller will
 *      own the list contents as well.
 */
GSList *cacpdclient_copy_response_list(GSList *orig)
{
    GSList *p;
    for (p = orig; p; p = g_slist_next(p))
	    p->data = strdup(p->data);

    return orig;
}

//
// Destroy
/**
 * Callback function used to destroy a cont_line structure.
 *
 * @param ptr A pointer to the list element containing the cont_line to destroy.
 *
 * @param unused unused
 */
static void destroyContLine(gpointer ptr, gpointer unused)
{
	cont_line *cl = (cont_line *)ptr;
	if(cl){
		if(cl->id) free(cl->id);
		if(cl->value) free(cl->value);
		free(cl);
	}
}

void cacpdclient_destroy_command_response(cacpdclient_command_response *resp)
{
	if(resp){
		if(resp->msg)
			free( resp->msg );
		
		g_list_foreach( resp->cont_lines, destroyContLine, NULL );
		g_list_free( resp->cont_lines );
		free(resp);
	}
}

//
// Get
//
// Display
/**
 * Callback function that displays a cont_line on stdout.
 *
 * @param data A gpointer that points to a cont_line. 
 *
 * @param unused An unused gpointer.  This parameter is here so
 * this function can be used as a callback.
 */
static void displayContLine( gpointer data, gpointer unused )
{
	cont_line* cl = data;
	g_printf( "id: [%s] value: [%s]\n", cl->id, cl->value );
}

/**
 * Callback function for display document that displays
 * a command response.
 *
 * @param elem The command response to be displayed.
 *
 * @param unused An unused gpointer.  This parameter is here so
 * this function can be used as a callback.
 */
void displayResponse(cacpdclient_command_response* curr)
{
	g_printf( "\n---COMMAND RESPONSE---\n"            );
	g_printf( "result:     [%s]\n",  cacpdclient_result_code_description(curr->result_code)  );
	g_printf( "msg:        [%s]\n",  (curr->msg ? curr->msg : "(none received)")       );
	g_printf( "cont_lines:\n"                         );

	g_list_foreach( curr->cont_lines, displayContLine, NULL );

	g_printf( "-------------\n" );
}

char* cacpdclient_login_response_extract_session(cacpdclient_command_response *resp) {
    char *retval = NULL;
    GSList *list = cacpdclient_response_get_list_for_id(resp, "1");
    GSList *l;
    
    for (l = list; l; l = g_slist_next(l))
        if (!strncmp("SESSION ", l->data, strlen("SESSION "))) {
            retval = strdup((char *)(l->data + strlen("SESSION ")));
            break;
        }

    g_slist_free(list);

    return retval;
}
