/*****************************************************************
 * File: gsp_auth_util.cc
 *
 * Copyright (C) 2007 Avocent Corporation
 *
 * www.avocent.com
 *
 * Description: gsp_auth_util.cc
 *
 ****************************************************************/

#include <cstdlib>
#include <cerrno>
#include <cstdio>
#include <cstring>
#include <ctime>

#include <string>
#include <sstream>
#include <vector>
#include <list>

#include <sys/types.h>
#include <sys/ipc.h>
#include <unistd.h>
#include <libgen.h> /* basename() */

#include <md5.h>

#include <cyc++.h>
#include <gsp_auth.h>

#include "auth_priv.h"

const int gsp_auth::util::auth_counters::INITIAL_REF_ID = 1;
const int gsp_auth::util::auth_counters::INITIAL_UID = 10001;
const std::string gsp_auth::util::auth_counters::
NOT_AUTHORIZED_CREATE_ERR = "Not authorized to create ref ID storage";

gsp_auth::util::auth_counters::auth_counters() : s(0), r(0), cdata(0)
{
	bool clear_shmem = false;
	uid_t uid = geteuid();
	enum gsp_auth::util::ipc_stat ret;

	// Set up the semaphores we'll need
	s = new gsp_auth::util::sem(PROJECT_ID(FTOK_AUTHCNT_SEMS));

	/* Don't even bother to create the semaphore if we're not
	   root; the attach will fail if the semaphore doesn't exist */
	if (uid == 0) {
		ret = s->screate(SEM_NUM_SEMS(2), SEM_FLAG(0600));
		if (ret == gsp_auth::util::STAT_IPC_CREATE_EXCL) {
			clear_shmem = true;
		}
	} else {
		throw app_error(NOT_AUTHORIZED_CREATE_ERR);
	}
	
	// Make sure we're initializing one-at-a-time
	s->op(SEM_NUM(SEM_AUTHCNT_CREATE), SEM_OP::PEND());
	
	try {
		/* Attach to user table in shared memory; create it if
		 * it doesn't exist */
		r = new gsp_auth::util::shmem(PROJECT_ID(FTOK_AUTHCNT_SHM));
		
		r->screate(SHM_SZ(sizeof(counter_data)), SHM_FLAG(0600));
		
		void *mem = r->attach();
		cdata = new (mem) counter_data;
		
		if (clear_shmem) {
			cdata->ref_id = INITIAL_REF_ID;
			cdata->next_uid = INITIAL_UID;
		}
	} catch (...) {
		s->op(SEM_NUM(SEM_AUTHCNT_CREATE), SEM_OP::REL());
		throw;
	}
	
	/* We're done initializing */
	s->op(SEM_NUM(SEM_AUTHCNT_CREATE), SEM_OP::REL());
}

unsigned int gsp_auth::util::auth_counters::get_ref_id()
{
	unsigned int id;

	lock();
	id = cdata->ref_id++;
	unlock();

	return(id);
}

uid_t gsp_auth::util::auth_counters::get_next_uid()
{
	uid_t id;

	lock();
	id = cdata->next_uid++;
	unlock();

	return(id);
}

const std::string
gsp_auth::util::delim_parser::EMPTY_STR_ERR = "Empty string; nothing to parse";

void gsp_auth::util::delim_parser::parse()
{
        char *str, *tmp, *next;
        int index;

	if (raw_str.empty()) throw app_error(EMPTY_STR_ERR);

        tmp = strdup(raw_str.c_str());

	if (TERMINATOR) {
		/* Replace the terminator with \0 */
		next = strchr(tmp, TERMINATOR);
		if (next) *next = '\0';
	}

        for (index = 0, str = tmp; str; index++, str = next) {
                next = strchr(str, DELIMITER);
                if (next) *next++ = '\0';
		while ((*str == ' ') || (*str == '\t')) str++;

		parsed_items.push_back(str);
        }
        free(tmp);
	tmp = 0;
}

void gsp_auth::util::delim_parser::unparse()
{
	if (parsed_items.empty()) throw app_error("Group list empty");

	raw_str.clear();

	typedef std::list<std::string>::const_iterator I;

	for (I li = parsed_items.begin(); li != parsed_items.end(); ++li) {
		raw_str += *li + DELIMITER;
	}
	raw_str.erase(raw_str.end()-1); // Get rid of trailing delim
}

const char gsp_auth::group::remote_group::GROUP_NAME_DELIMITER = ',';
const char gsp_auth::group::remote_group::GROUP_NAME_TERMINATOR = ';';

/* Generates a random number between 1-9 */
int gsp_auth::util::unique_id::random_number_generate()
{
        return(1 + (int)(9.0*rand()/(RAND_MAX+1.0)));
}

/* Populates a buffer buf with sz random numbers */
void gsp_auth::util::unique_id::random_sequence_generate(char *buf, int sz)
{
	/* Using the reference ID as a seed helps to give us the entropy we
	 * need.  This number is incremented by the session code with every
	 * session creation so it's unique per session */
	gsp_auth::util::auth_counters r;
	unsigned int seed = r.get_ref_id_raw();

        srand(time(0) + seed);

        for (int i = 0; i < sz; i++) {
                buf[i] = random_number_generate();
        }
}

/* Generate unique ID given a text buffer such as a username or
   an IP address; this session ID should be more random than that
   generated by session_id_generate().  This function returns the
   length of the session ID stored and copies the SID into a
   user-supplied buffer that should be of at least MD5_DIGEST_LEN*2 + 1
   bytes in size. */
std::string gsp_auth::util::unique_id::generate(const char *seed, int seed_sz)
{
        time_t t;
        char time_str[26];
        char random_blob[128];
	char *buf = 0;
	int buf_sz = ERROR;
	md5_state_t state;
	md5_byte_t digest[MD5_DIGEST_LEN];
	int di;
	char hex_output[GSP_SID_SZ + 1];
	char *offset = 0;

        if (seed_sz < 0) throw app_error("Invalid seed");

        t = time(0);
        if (ctime_r(&t, time_str) == 0) {
		std::ostringstream err_msg;
		err_msg << "c_time_r " << strerror(errno);
		throw app_error(err_msg.str());
	}

        random_sequence_generate(random_blob, sizeof(random_blob));

        buf_sz = sizeof(time_str) + sizeof(random_blob) +
		seed_sz + sizeof(pid_t);
        buf = (char *)malloc(buf_sz);

	/* Construct the buffer we will hash */
	offset = buf;
        memcpy(buf, time_str, sizeof(time_str));
	offset += sizeof(time_str);
        memcpy(offset, random_blob, sizeof(random_blob));
	offset += sizeof(random_blob);
	if (seed && (seed_sz > 0)) {
		memcpy(offset, seed, seed_sz);
		offset += seed_sz;
	}
	pid_t pid = getpid();
	memcpy(offset, &pid, sizeof(pid_t));
	offset += sizeof(pid_t);

	/* Hash the buffer with md5 */
	md5_init(&state);
	md5_append(&state, (const md5_byte_t *)buf, buf_sz);
	md5_finish(&state, digest);

	free(buf);
	buf = 0;

	for (di = 0; di < MD5_DIGEST_LEN; ++di) {
		sprintf(hex_output + (di*2), "%02x", digest[di]);
	}

        return(hex_output);
}

/* A simpler unique ID without a seed */
std::string gsp_auth::util::unique_id::generate()
{
	return(generate(0, 0));
}

const std::string gsp_auth::util::session_id::
NULL_SID_DATA_ERR = "sid_info not set";

/* Generate session ID */
void gsp_auth::util::session_id::generate(std::string s)
{
	if (sinfo == 0) throw app_error(NULL_SID_DATA_ERR);

	if (s.empty()) {
		sinfo->set_sid(gsp_auth::util::unique_id::generate());
	} else {
		sinfo->set_sid(gsp_auth::util::unique_id::
			       generate(s.c_str(), s.size()));
	}
}

gsp_auth::util::ssh_authmethod::ssh_authmethod()
{
	static const am_attr attrs[] = {
		{ GSP_AUTH_ATTR_STRONG_SEC },
		{ GSP_AUTH_ATTR_STRONG_SEC },
		{ GSP_AUTH_ATTR_STRONG_SEC },
		{ GSP_AUTH_ATTR_STRONG_SEC },
	};

	ssham["publickey"] = attrs[0];
	ssham["gssapi-with-mic"] = attrs[1];
	ssham["adsap2"] = attrs[2];
	ssham["rsa"] = attrs[3];
}

int gsp_auth::util::ssh_authmethod::get_flags(const std::string &s)
{
	int flags = 0;

	if (ssham.find(s) != ssham.end()) {
		const am_attr &attr = ssham[s];
		flags = attr.flags;
	}
	
	return(flags);
}

const int gsp_auth::util::sem::INIT_VAL = 1;

enum gsp_auth::util::ipc_stat
gsp_auth::util::sem::screate(const SEM_NUM_SEMS &nsems,
			     const SEM_FLAG &flag)
{
	enum ipc_stat ret = STAT_IPC_ERROR;
	SEM_FLAG crflag(flag.val | IPC_CREAT | IPC_EXCL);

	try {
		cyc_sem::create(nsems, crflag); // call base class create
		set_all(SEM_VAL(INIT_VAL));
		
		ret = STAT_IPC_CREATE_EXCL;
	} catch (app_error e) {
		try {
			attach();
		} catch (...) { throw; }

		ret = STAT_IPC_ATTACH_EXISTING;
	}

	return(ret);
}

enum gsp_auth::util::ipc_stat
gsp_auth::util::shmem::screate(const SHM_SZ &sz,
		 	       const SHM_FLAG &flag)
{
	enum ipc_stat ret = STAT_IPC_ERROR;
	SHM_FLAG crflag(flag.val | IPC_CREAT | IPC_EXCL);
	
	try {
		cyc_shmem::create(sz, crflag); // call base class create
		
		ret = STAT_IPC_CREATE_EXCL;
	} catch (app_error e) {
		try {
			cyc_shmem::create(sz, flag);
		} catch (...) { throw; }

		ret = STAT_IPC_ATTACH_EXISTING;
	}

	return(ret);
}

void gsp_auth::util::shm_destroy(const SHM_ID &shmid)
{
	if (shmid.val < 0) return;

	try {
		cyc_shmem shmem(shmid);

		shmem.destroy();
	} catch (...) {
		/* There's nothing useful to do if we get
		 * a failure here. */
	}
}

key_t gsp_auth::util::get_ipc_key(const PROJECT_ID &p)
{
	/* This should be a file that never changes throughout
	 * the time the appliance is running */
	const std::string IPC_FILE("/");
	key_t ret;
	
	if ((ret = ftok(IPC_FILE.c_str(), p.val)) == -1) {
		std::ostringstream err_msg;
		err_msg << __func__ << ": " << strerror(errno);
		throw app_error(err_msg.str());
	}
	
	return(ret);
}

gid_t gsp_auth::util::get_default_gid()
{
	gid_t gid = 99;
	std::vector<std::string> groups;

	groups.push_back("users");
	groups.push_back("nogroup");
	groups.push_back("nobody");

	typedef std::vector<std::string>::const_iterator I;
	for (I gi = groups.begin(); gi != groups.end(); ++gi) {
		try {
			avo::util::avogroup gr(*gi);
			gid = gr.get_gid();
			break;
		} catch (...) {}
	}

	return(gid);
}

void gsp_auth::util::update_psd(gsp_auth::session::priv_session_data *psd,
			        const gsp_auth::util::USERNAME &un,
				const gsp_auth::util::AUTH_TYPE &at,
				const gsp_auth::util::CURR_AUTH_TYPE &cat)
{
	psd->set_auth_type(at.val);
	psd->set_curr_auth_type(cat.val);

	if (! un.val.empty()) {
		try {
			avo::util::password pwd(un.val);
			psd->set_uid(pwd.get_uid());
			psd->set_gid(pwd.get_gid());
		} catch (...) {
			gsp_auth::util::auth_counters ac;
			psd->set_uid(ac.get_next_uid());
			psd->set_gid(gsp_auth::util::get_default_gid());
		}
	}
}

void gsp_auth::util::sess_update_helper(const gsp_auth::session::sid_info &sid,
					gsp_auth::session::session_table &t,
					const SHM_ID &shmid,
					gsp_auth::session::
					session_access &sess)
{
	using namespace gsp_auth::session;

	int new_shmid = sess.shm_update(shmid);
	if (new_shmid != shmid.val) {
		gsp_auth::util::shm_destroy(shmid);
		
		if (typeid(sess).name() == typeid(priv_session).name()) {
			t.update(sid, USER_SHMID(t.lookup_user_shmid(sid)),
				 PRIV_SHMID(new_shmid));
		} else if (typeid(sess).name() ==
			   typeid(user_session).name()) {
			t.update(sid, USER_SHMID(new_shmid),
				 PRIV_SHMID(t.lookup_priv_shmid(sid)));
		} else {
			throw app_error("Could not update session");
		}
	}
}

/* Public C API Implementation */

/* Interpret the internal SSH authmethod and return the flags
 * that should be set in the session accordingly */
int gsp_auth_util_ssh_get_flags(const char *authmethod)
{
	gsp_auth::util::ssh_authmethod s;

	return(s.get_flags(authmethod));
}

/* This function sets the authentication type to the original service
 * saved in the PAM handle */
int gsp_auth_util_set_authtype_from_pamh(pam_handle_t *pamh,
					 struct sid_data *sid)
{
	using namespace gsp_auth::session;

	gsp_auth::public_api::api_helper *apih = 0;
	const char * const ETC_PAMD_DIR = "/etc/pam.d";
	char at_buf[256];
	char srvc_fp[256];
	int atret;
	const char *auth_type = 0;
	const char *srvc = 0;
	int ret = 0;

	if ((pamh == 0) || (sid == 0)) return(ERROR);

	try {
		apih = new gsp_auth::public_api::api_helper;

		apih->lock();

		sid_info sinfo(sid);

		session_table t;
		int priv_shmid = t.lookup_priv_shmid(sinfo);

		// Grab session and session manager
		priv_session psess;
		psess.shm_restore(SHM_ID(priv_shmid));

		gsp_auth::pam::pam_helper ph(pamh);
		if (! ph.get_orig_service().empty()) {
			srvc = ph.get_orig_service().c_str();
		}

		snprintf(srvc_fp, sizeof(srvc_fp), "%s/%s",
			 ETC_PAMD_DIR, srvc);
		srvc_fp[sizeof(srvc_fp)-1] = '\0';
		
		memset(at_buf, '\0', sizeof(at_buf));
		atret = readlink(srvc_fp, at_buf, sizeof(at_buf)-1);
		if (atret == -1) {
			/* Not a symlink */
			auth_type = srvc;
		} else {
			/* Symlink; we only want filename */
			auth_type = basename(at_buf);
		}

		psess.get_session()->set_auth_type(auth_type);
		
		/* Update shm with new data */
		gsp_auth::util::sess_update_helper(sinfo, t,
						   PRIV_SHMID(priv_shmid),
						   psess);
	} catch (gsp_auth::pam::pam_error e) {
		avo::util::syslog_helper::log(gsp_auth::libinfo::get_name(),
					      LOG_ERR, e.get_str());
		ret = ERROR;
	} catch (app_error e) {
		avo::util::syslog_helper::log(gsp_auth::libinfo::get_name(),
					      LOG_ERR, e.get_str());
		ret = ERROR;
	} catch (...) {
		ret = ERROR;
	}

	try {
		if (apih) apih->unlock();
	} catch (app_error e) {
		avo::util::syslog_helper::log(gsp_auth::libinfo::get_name(),
					      LOG_ERR, e.get_str());
		ret = ERROR;
	} catch (...) {
		ret = ERROR;
	}

	delete apih;
	apih = 0;
	
	return(ret);
}

/* This function sets the current authentication type to the service
 * saved in the PAM handle */
int gsp_auth_util_set_curr_authtype_from_pamh(pam_handle_t *pamh,
					      struct sid_data *sid)
{
	using namespace gsp_auth::session;

	gsp_auth::public_api::api_helper *apih = 0;
	int ret = 0;

	if ((pamh == 0) || (sid == 0)) return(ERROR);

	try {
		apih = new gsp_auth::public_api::api_helper;

		apih->lock();

		sid_info sinfo(sid);

		session_table t;
		int priv_shmid = t.lookup_priv_shmid(sinfo);

		// Grab session and session manager
		priv_session psess;
		psess.shm_restore(SHM_ID(priv_shmid));

		gsp_auth::pam::pam_helper ph(pamh);

		if (! ph.get_service().empty()) {
			psess.get_session()->set_curr_auth_type(ph.get_service());
		}
		
		/* Update shm with new data */
		gsp_auth::util::sess_update_helper(sinfo, t,
						   PRIV_SHMID(priv_shmid),
						   psess);
	} catch (gsp_auth::pam::pam_error e) {
		avo::util::syslog_helper::log(gsp_auth::libinfo::get_name(),
					      LOG_ERR, e.get_str());
		ret = ERROR;
	} catch (app_error e) {
		avo::util::syslog_helper::log(gsp_auth::libinfo::get_name(),
					      LOG_ERR, e.get_str());
		ret = ERROR;
	} catch (...) {
		ret = ERROR;
	}

	try {
		if (apih) apih->unlock();
	} catch (app_error e) {
		avo::util::syslog_helper::log(gsp_auth::libinfo::get_name(),
					      LOG_ERR, e.get_str());
		ret = ERROR;
	} catch (...) {
		ret = ERROR;
	}

	delete apih;
	apih = 0;
	
	return(ret);
}
/* End Public C API Implementation */
