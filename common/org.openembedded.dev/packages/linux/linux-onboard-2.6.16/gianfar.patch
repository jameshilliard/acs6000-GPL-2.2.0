Index: linux-2.6.16/arch/ppc/platforms/85xx/mpc85xx_cds_common.c
===================================================================
--- linux-2.6.16.orig/arch/ppc/platforms/85xx/mpc85xx_cds_common.c	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/arch/ppc/platforms/85xx/mpc85xx_cds_common.c	2007-05-24 14:47:01.000000000 -0400
@@ -663,28 +663,22 @@
 
 	pdata = (struct gianfar_platform_data *) ppc_sys_get_pdata(MPC85xx_TSEC2);
 	if (pdata) {
-		pdata->board_flags = FSL_GIANFAR_BRD_HAS_PHY_INTR;
+		pdata->board_flags = ALTERPATH_TSEC2_BD_FLAGS;
 		pdata->bus_id = 0;
-		pdata->phy_id = 1;
-		memcpy(pdata->mac_addr, binfo->bi_enet1addr, 6);
-	}
-
-	pdata = (struct gianfar_platform_data *) ppc_sys_get_pdata(MPC85xx_eTSEC1);
-	if (pdata) {
-		pdata->board_flags = FSL_GIANFAR_BRD_HAS_PHY_INTR;
-		pdata->bus_id = 0;
-		pdata->phy_id = 0;
-		memcpy(pdata->mac_addr, binfo->bi_enetaddr, 6);
-	}
-
-	pdata = (struct gianfar_platform_data *) ppc_sys_get_pdata(MPC85xx_eTSEC2);
-	if (pdata) {
-		pdata->board_flags = FSL_GIANFAR_BRD_HAS_PHY_INTR;
-		pdata->bus_id = 0;
-		pdata->phy_id = 1;
-		memcpy(pdata->mac_addr, binfo->bi_enet1addr, 6);
+		pdata->phy_id = ALTERPATH_TSEC2_PHY_ID;
+#ifdef CONFIG_ALTERPATH_ONBOARD
+		/* DEBV1 use enet1addr for Failover eth,
+		 *           enet2addr for TSEC2
+		 *           enetaddr  for TSEC1
+		 */
+		memcpy(pdata->mac_addr, binfo->bi_enet2addr, 6);
+#else
+  		memcpy(pdata->mac_addr, binfo->bi_enet1addr, 6);
+#endif
 	}
 
+	ppc_sys_device_remove(MPC85xx_eTSEC1);
+	ppc_sys_device_remove(MPC85xx_eTSEC2);
 	ppc_sys_device_remove(MPC85xx_eTSEC3);
 	ppc_sys_device_remove(MPC85xx_eTSEC4);
 
Index: linux-2.6.16/arch/ppc/platforms/85xx/mpc85xx_cds_common.h
===================================================================
--- linux-2.6.16.orig/arch/ppc/platforms/85xx/mpc85xx_cds_common.h	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/arch/ppc/platforms/85xx/mpc85xx_cds_common.h	2007-05-24 14:47:01.000000000 -0400
@@ -184,18 +184,22 @@
 #define ALTERPATH_TSEC1_PHY_ID		0
 #define ALTERPATH_TSEC2_PHY_INTERRUPT	MPC85xx_IRQ_EXT1
 #define ALTERPATH_TSEC2_PHY_ID		7
+#define ALTERPATH_TSEC2_BD_FLAGS	FSL_GIANFAR_BRD_HAS_PHY_INTR
 #endif
 #ifdef CONFIG_Alterpath_KVMMAXV2
 #define ALTERPATH_TSEC1_PHY_INTERRUPT	SIU_INT_PC29
 #define ALTERPATH_TSEC1_PHY_ID		1
 #define ALTERPATH_TSEC2_PHY_INTERRUPT	SIU_INT_PC29
 #define ALTERPATH_TSEC2_PHY_ID		3
+#define ALTERPATH_TSEC2_BD_FLAGS	FSL_GIANFAR_BRD_HAS_PHY_INTR
 #endif
 #ifdef CONFIG_ALTERPATH_ONBOARD
 #define ALTERPATH_TSEC1_PHY_INTERRUPT	MPC85xx_IRQ_EXT0
 #define ALTERPATH_TSEC1_PHY_ID		0
 #define ALTERPATH_TSEC2_PHY_INTERRUPT	0
 #define ALTERPATH_TSEC2_PHY_ID		(GFAR_ALWAYS_LINK_UP | GFAR_1000MBPS | GFAR_FULL_DPLX)
+#define ALTERPATH_TSEC2_BD_FLAGS	FSL_GIANFAR_DEV_HAS_SMI_AGENT | FSL_GIANFAR_DEV_HAS_FAKE_PHY | \
+	FSL_GIANFAR_DEV_HAS_GIGABIT | FSL_GIANFAR_DEV_HAS_MULTI_INTR;
 #endif
 
 #endif
Index: linux-2.6.16/drivers/net/debmax_sw6095.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/debmax_sw6095.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1341 @@
+/*
+ * Cyclades:
+ *   Support for Marvell's 88E6095 11-port switch chips for DEB board.
+ *
+ * copied from Marvell's sample/MultiDevice/msApiInit.c
+ *
+ *
+ * Our block diagrams are like this:
+ * 
+ * -----------------------------------(DEB Version 1, ONBOARD_V1)------------------------------
+ *
+ *                                  -----------------------                                  
+ *                                  |MPC85xx TSEC2 Eth MAC|                                  
+ *                                  -----------------------                                  
+ *                                             |                              		 
+ *                                             |                              		 
+ *                                             |                              		 
+ *  8------10------9  8------10------9  8------10------9  8------10------9  8------10------9 
+ *  |  88E6095  #4 |--|  88E6095  #3 |--|  88E6095  #1 |--|  88E6095  #2 |--|  88E6095  #5 | 
+ *  ----------------  ----------------  ----------------  ----------------  ---------------- 
+ *    0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7    
+ *
+ *
+ * For 24-port model, there are no switch #4 or #3. ($4--#3)--#1--#2--#5
+ *
+ *             Ethernet port of CPU is connected to port 10 of Device #1,
+ *             port 9 of Device #1 is connected to port 8 of Device #2,
+ *             port 8 of Device #1 is connected to port 9 of Device #3,
+ *             and so on.
+ *
+ *             Device #1 uses Phy Address 0x01,
+ *             Device #2 uses Phy Address 0x02,
+ *             Device #3 uses Phy Address 0x03,
+ *             Device #4 uses Phy Address 0x04,
+ *             Device #5 uses Phy Address 0x05
+ *             Notes: Phy Address 0 cannot be used in a Multi Chip Address Mode.
+ *
+ *             Each Switch Device has to be configured to Multi Chip Address Mode.
+ *
+ * 
+ *
+ * NOTE: In later version, block diagram will probably change to:
+ * 
+ * ---------------------------(DEB Version 1 Revision 1, ONBOARD_V1_REV1)----------------------
+ *
+ *                                  -----------------------                                  
+ *                                  |MPC85xx TSEC2 Eth MAC|                                  
+ *                                  -----------------------                                  
+ *                                             |                              		 
+ *                                             |                              		 
+ *                                             |                              		 
+ *  8------10------9  8------10------9  8------10------9  8------10------9  8------10------9 
+ *  |  88E6095  #1 |--|  88E6095  #2 |--|  88E6095  #3 |--|  88E6095  #4 |--|  88E6095  #5 | 
+ *  ----------------  ----------------  ----------------  ----------------  ---------------- 
+ *    0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7    
+ *
+ *
+ *             The difference between ONBOARD_V1 and ONBOARD_V1_REV1 is the numbering of 88E6095 chips:
+ *             in ONBOARD_V1:
+ *                (#4--#3)--#1--#2--#5
+ *             in ONBOARD_V1_REV1:
+ *                #1--#2--#3--(#4--#5)
+ *
+ *             chip number in '( )' doesn't exist in 24-port model.
+ *
+ *
+ *             
+ * NOTE: Before we get ONBOARD_V1_REV1, we modify original ONBOARD_V1 boards to get ONBOARD_V1_REV1_PRE
+ *
+ * -----------------------(DEB Version 1 Revision 1 Pre, ONBOARD_V1_REV1_PRE)----------------------
+ *
+ *                                  -----------------------                                  
+ *                                  |MPC85xx TSEC2 Eth MAC|                                  
+ *                                  -----------------------                                  
+ *                                             |                              		 
+ *                                             |                              		 
+ *                                             |                              		 
+ *  8------10------9  8------10------9  8------10------9  8------10------9  8------10------9 
+ *  |  88E6095  #1 |--|  88E6095  #2 |--|  88E6095  #3 |--|  88E6095  #4 |--|  88E6095  #5 | 
+ *  ----------------  ----------------  ----------------  ----------------  ---------------- 
+ *    0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7    
+ *
+ * 
+ *       we have changed all original ONBOARD_V1 boards to ONBOARD_V1_REV1 SMI
+ *       addr numbering as follows:
+ *
+ *              ONBOARD_V1                ONBOARD_V1_REV1_PRE
+ *       ----------------        ----------------------
+ *               #4         ->             #1
+ *               #3         ->             #2
+ *               #1         ->             #3
+ *               #2         ->             #4
+ *               #5         ->             #5 (not change)
+ *
+ *       So there is no ONBOARD_V1 style numbering. However, for 24-port
+ *       model, ONBOARD_V1_REV1 boards have devices #1-#2-#3, while
+ *       ONBOARD_V1_REV1_PRE, which were originally ONBOARD_V1 boards with their
+ *       SMI addr renumbered, have devices #3-#4-#5. For 40-port
+ *       model, both ONBOARD_V1_REV1 and ONBOARD_V1_REV1_PRE boards are
+ *       identical. So:
+ *       
+ *       in ONBOARD_V1_REV1:
+ *       	#1--#2--#3--(#4--#5)
+ *       in ONBOARD_V1_REV1_PRE:
+ *       	(#1--#2)--#3--#4--#5
+ *       
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+
+#include <asm/semaphore.h>
+#include <linux/module.h>
+
+#ifdef CONFIG_MV88E6095
+
+#include <linux/debmax_sw6095.h>
+#include "gianfar_mii.h"
+#include <asm/mpc85xx.h>
+
+static int DEB_24P_DEVICE_FIRST;
+static int DEB_24P_DEVICE_SECOND;
+static int DEB_24P_DEVICE_THIRD;
+
+static int __DEB_24_PORT;
+
+#define is_24p() __DEB_24_PORT
+
+#define MULTI_ADDR_MODE
+
+#ifndef N_OF_QD_DEVICES
+#define N_OF_QD_DEVICES		MAX_NR_SWITCHES	/* number of 88E6095 devices connected */
+#endif
+
+#define DEVICE1_ID		1
+#define DEVICE2_ID		DEVICE1_ID + 1
+#define DEVICE3_ID		DEVICE1_ID + 2
+#define DEVICE4_ID		DEVICE1_ID + 3
+#define DEVICE5_ID		DEVICE1_ID + 4
+
+#define DEVICE1_PHY_ADDR	0x01
+#define DEVICE2_PHY_ADDR	DEVICE1_PHY_ADDR + 1
+#define DEVICE3_PHY_ADDR	DEVICE1_PHY_ADDR + 2
+#define DEVICE4_PHY_ADDR	DEVICE1_PHY_ADDR + 3
+#define DEVICE5_PHY_ADDR	DEVICE1_PHY_ADDR + 4
+
+typedef struct routing_tbl_entry_s {
+	GT_U32 devnum;
+	GT_LPORT portnum;
+} routing_tbl_entry_t;
+
+	
+/* cyclades: can have more than ONE cascade port? Yes! */
+#define DEVICE1_CPU_PORT		9
+#define DEVICE1_CASCADE_PORT	0xE 		/* 0xE means no CAS_PORT */
+#define DEVICE2_CPU_PORT		9
+#define DEVICE2_CASCADE_PORT	8
+#define DEVICE3_CPU_PORT		10
+#define DEVICE3_CASCADE_PORT	8
+#define DEVICE4_CPU_PORT		8
+#define DEVICE4_CASCADE_PORT	9
+#define DEVICE5_CPU_PORT		8
+#define DEVICE5_CASCADE_PORT	0xE
+#define ANOTHER_CPU_DEVICE_CASCADE_PORT 9
+#define S_CPU_DEVICE_ID		DEVICE3_ID
+#define S_CPU_DEVICE_PHY_ADDR	DEVICE3_PHY_ADDR
+#define S_CPU_DEVICE_CPU_PORT	DEVICE3_CPU_PORT
+#define S_CPU_DEVICE_CAS_PORT	0xF            /* use Routing Table in G2 Reg0x6. */
+#define S_CPU_DEVICE_ROUTING_TBL {{1,8}, {2,8}, {4,9}, {5,9}, {-1,-1}}
+#define VLANTABLE  {{0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x000, 0x0ff, 0x000}, \
+                    {0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x1ff, 0x000}, \
+                    {0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x3ff}, \
+                    {0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x2ff, 0x100, 0x000}, \
+		    {0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x0ff, 0x000, 0x000}}
+#define DEFAULTVID {{0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007, 0x008, 0x000, 0x000, 0x000}, \
+                    {0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f, 0x010, 0x000, 0x000, 0x000}, \
+		    {0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x017, 0x018, 0x000, 0x000, 0x000}, \
+                    {0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x01f, 0x020, 0x000, 0x000, 0x000}, \
+		    {0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x027, 0x028, 0x000, 0x000, 0x000}}
+#define UNM MEMBER_EGRESS_UNMODIFIED
+#define NOT NOT_A_MEMBER
+#define UNT MEMBER_EGRESS_UNTAGGED
+#define TAG MEMBER_EGRESS_TAGGED
+#define DEVICE1_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		            }
+#define DEVICE2_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:9, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:10, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:11, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:12, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:13, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:14, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:15, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:16, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+                            }
+#define DEVICE3_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:9, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:10, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:11, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:12, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:13, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:14, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:15, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:16, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:17, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:18, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:19, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:20, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:21, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:22, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:23, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:24, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:25, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:26, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:27, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:28, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:29, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:30, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:31, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:32, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:33, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:34, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:35, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:36, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:37, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:38, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:39, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:40, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+                            }
+#define DEVICE4_VTU_ENTRIES {{DBNum:0, vid:25, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:26, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:27, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:28, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:29, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:30, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:31, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:32, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:33, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:34, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:35, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:36, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:37, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:38, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:39, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:40, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			    }
+#define DEVICE5_VTU_ENTRIES {{DBNum:0, vid:33, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:34, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:35, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:36, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:37, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:38, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:39, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:40, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+}
+
+static routing_tbl_entry_t s_cpu_device_routing_tbl[N_OF_QD_DEVICES] __initdata = S_CPU_DEVICE_ROUTING_TBL;
+static int vlantable[N_OF_QD_DEVICES][MAX_PORTS_PER_SWITCH] __initdata = VLANTABLE;
+static int defaultvid[N_OF_QD_DEVICES][MAX_PORTS_PER_SWITCH] __initdata = DEFAULTVID;
+static GT_VTU_ENTRY device1_vtu_entries[] __initdata = DEVICE1_VTU_ENTRIES;
+static GT_VTU_ENTRY device2_vtu_entries[] __initdata = DEVICE2_VTU_ENTRIES;
+static GT_VTU_ENTRY device3_vtu_entries[] __initdata = DEVICE3_VTU_ENTRIES;
+static GT_VTU_ENTRY device4_vtu_entries[] __initdata = DEVICE4_VTU_ENTRIES;
+static GT_VTU_ENTRY device5_vtu_entries[] __initdata = DEVICE5_VTU_ENTRIES;
+
+GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES] = {0,};
+
+#undef debug
+//#define DEBUG
+
+#ifdef DEBUG
+int debug(const char * fmt, ...) {
+	return printk(fmt);
+}
+#else
+int debug(const char * fmt, ...) {
+	return 0;
+}
+#endif
+
+/*
+ * read mii register - see qdFFmii.c
+ */ 
+static GT_BOOL ffReadMii(GT_QD_DEV* dev, 
+			 unsigned int portNumber , 
+			 unsigned int MIIReg, unsigned int* value)
+{
+	int ret;
+	unsigned short data=0xffff;
+  
+	if(!dev || !value)
+		return GT_FALSE;
+	debug("%s, %s, %d, calling miiphy_read(%u, %u, 0x%x)\n", __FILE__, __FUNCTION__, __LINE__, (unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short*)value);
+	ret=miiphy_read((unsigned char)(dev->phyAddr), (unsigned char)MIIReg, &data);
+	debug("%s, %s, %d, got value = %04x\n", __FILE__, __FUNCTION__, __LINE__, data);
+	if(ret==0) {
+		*value=(unsigned int)data;
+		return GT_TRUE;
+	}
+	return GT_FALSE;
+}
+
+/*
+ * write mii register - see qdFFmii.c
+ */ 
+static GT_BOOL ffWriteMii(GT_QD_DEV* dev, 
+			  unsigned int portNumber , 
+			  unsigned int MIIReg, 
+			  unsigned int value)
+{
+	int ret;
+
+	if(!dev)
+		return GT_FALSE;
+	debug("%s, %s, %d, calling miiphy_write(%u, %u, %04x)\n", __FILE__, __FUNCTION__, __LINE__, (unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short)(value & 0x0000ffff));
+	ret=miiphy_write((unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short)(value & 0x0000ffff));
+	debug("%s, %s, %d, got ret = %d\n", __FILE__, __FUNCTION__, __LINE__, ret);
+	if(ret==0)
+		return GT_TRUE;
+	return GT_FALSE;
+}
+
+#if 0
+static GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state)
+{
+	struct semaphore * lxSem = NULL;
+
+	lxSem = kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+
+	if (!lxSem)
+		return NULL;
+	sema_init(lxSem, state);
+	return (GT_SEM)lxSem;
+}
+
+static GT_STATUS osSemDelete(GT_SEM smid)
+{
+	if (!smid)
+		return GT_FALSE;
+	kfree(smid);
+	return GT_OK;
+}
+
+static GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut)
+{
+	if (!smid)
+		return GT_FALSE;
+	
+}
+
+static GT_STATUS osSemSignal(GT_SEM smid)
+{
+}
+
+#endif
+
+/*
+ * setup some constants for board autodetection.
+ */
+static int sw6095_setup_const(bd_t *bis)
+{
+	if (bis->board_ver_rev == 0x01) {
+		DEB_24P_DEVICE_FIRST = 3;
+		DEB_24P_DEVICE_SECOND = 4;
+		DEB_24P_DEVICE_THIRD = 5;
+	} else {
+		DEB_24P_DEVICE_FIRST = 1;
+		DEB_24P_DEVICE_SECOND = 2;
+		DEB_24P_DEVICE_THIRD = 3;
+	}
+
+	__DEB_24_PORT = (bis->board_model & 0x80);
+	return 0;
+}
+
+/*
+ * Initialize each Switch Devices. This should be done in BSP driver init routine.
+ * Since BSP is not combined with QuarterDeck driver, we are doing here.
+ * This routine will setup Switch Devices according to the above description.
+ */
+static GT_STATUS qdMultiDevStart(void)
+{
+	GT_STATUS status = GT_FAIL;
+	GT_SYS_CONFIG   cfg;
+	int cpuPort;
+	int cascadePort;
+	int i,j;
+	int cpu_device_id = S_CPU_DEVICE_ID;
+	int another_cpu_cascadePort = ANOTHER_CPU_DEVICE_CASCADE_PORT;
+	routing_tbl_entry_t *rt_entry = s_cpu_device_routing_tbl;
+	int s_cpu_device_cas_port = S_CPU_DEVICE_CAS_PORT;
+
+	memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
+	
+	/* 
+	 * Create QD Device Structure for each device.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		qdMultiDev[i] = (GT_QD_DEV*)kmalloc(sizeof(GT_QD_DEV), GFP_KERNEL);
+
+		if(qdMultiDev[i] == NULL)
+		{
+			while(i--)
+				kfree(qdMultiDev[i]);
+			return GT_FAIL;
+		}
+
+		memset((char*)qdMultiDev[i],0,sizeof(GT_QD_DEV));
+	}
+	
+	/*
+	 * Register all the required functions to QuarterDeck Driver for each device.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		cfg.BSPFunctions.readMii   = ffReadMii;
+		cfg.BSPFunctions.writeMii  = ffWriteMii;
+#ifdef USE_SEMAPHORE
+		cfg.BSPFunctions.semCreate = osSemCreate;
+		cfg.BSPFunctions.semDelete = osSemDelete;
+		cfg.BSPFunctions.semTake   = osSemWait;
+		cfg.BSPFunctions.semGive   = osSemSignal;
+#else
+		cfg.BSPFunctions.semCreate = NULL;
+		cfg.BSPFunctions.semDelete = NULL;
+		cfg.BSPFunctions.semTake   = NULL;
+		cfg.BSPFunctions.semGive   = NULL;
+#endif
+
+		cfg.initPorts = GT_TRUE;	/* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
+		switch (i)
+		{
+		case 0: /* if we are registering device 1 */
+			cfg.cpuPortNum = DEVICE1_CPU_PORT;
+			break;
+		case 1: /* if we are registering device 2 */
+			cfg.cpuPortNum = DEVICE2_CPU_PORT;	
+			break;
+		case 2: /* if we are registering device 3 */
+			cfg.cpuPortNum = DEVICE3_CPU_PORT;	
+			break;
+		case 3: /* if we are registering device 4 */
+			cfg.cpuPortNum = DEVICE4_CPU_PORT;	
+			break;
+		case 4: /* if we are registering device 5 */
+			cfg.cpuPortNum = DEVICE5_CPU_PORT;	
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+#ifdef MANUAL_MODE	/* not defined. this is only for sample */
+		/* user may want to use this mode when there are two QD switchs on the same MII bus. */
+		cfg.mode.scanMode = SMI_MANUAL_MODE;	/* Use QD located at manually defined base addr */
+		cfg.mode.baseAddr = 0x10;	/* valid value in this case is either 0 or 0x10 */
+#else
+#ifdef MULTI_ADDR_MODE	/* It should have been defined for this sample code */
+		cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;	/* find a QD in indirect access mode */
+		cfg.mode.baseAddr = DEVICE1_PHY_ADDR + i; /* this is the phyAddr used by QD family device. Valid values are 1 ~ 31.*/
+#else
+		cfg.mode.scanMode = SMI_AUTO_SCAN_MODE;	/* Scan 0 or 0x10 base address to find the QD */
+		cfg.mode.baseAddr = 0;
+#endif
+#endif
+
+		if((status=qdLoadDriver(&cfg, qdMultiDev[i])) != GT_OK)
+		{
+			printk("qdLoadDriver return Failed on device [%d]\n", i+1);
+			goto errorExit;
+		}
+
+ 		printk("Opal #%d\n",i+1);
+		printk("Device ID     : 0x%x\n",qdMultiDev[i]->deviceId);
+		printk("Revision      : 0x%x\n",qdMultiDev[i]->revision);
+		printk("Base Reg Addr : 0x%x\n",qdMultiDev[i]->baseRegAddr);
+		printk("No of Ports   : %d\n",qdMultiDev[i]->numOfPorts);
+		printk("CPU Port      : %d\n",qdMultiDev[i]->cpuPortNum);
+
+		/*
+		 *  start the QuarterDeck
+		 */
+		if((status=sysEnable(qdMultiDev[i])) != GT_OK)
+		{
+			printk("sysEnable return Failed\n");
+			goto errorExit;
+		}
+	}
+
+	/* 
+	 *	Now, we need to configure Cascading information for each devices.
+	 *	1. Set Interswitch port mode for port 8 and 9 for device 1,2,3,4,5
+	 *	   so that switch device can expect Marvell Tag from frames 
+	 *         ingressing/egressing this port.
+	 *	2. Set CPU Port information (for To_CPU frame) for each port of device.
+	 *	3. Set Cascading Port information (for From_CPU frame) for each device.
+	 *      4. Set Device ID (if required)
+	 *	Note: DeviceID is hardware configurable.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		switch (i) {
+		case 0: /* if we are registering device 1 */
+			cpuPort = DEVICE1_CPU_PORT; 		
+			cascadePort = DEVICE1_CASCADE_PORT;	
+			break;
+		case 1: /* if we are registering device 2 */
+			cpuPort = DEVICE2_CPU_PORT; 		
+			cascadePort = DEVICE2_CASCADE_PORT;	
+			break;
+		case 2: /* if we are registering device 3 */
+			cpuPort = DEVICE3_CPU_PORT; 		
+			cascadePort = DEVICE3_CASCADE_PORT;	
+			break;
+		case 3: /* if we are registering device 4 */
+			cpuPort = DEVICE4_CPU_PORT; 		
+			cascadePort = DEVICE4_CASCADE_PORT;	
+			break;
+		case 4: /* if we are registering device 5 */
+			cpuPort = DEVICE5_CPU_PORT; 		
+			cascadePort = DEVICE5_CASCADE_PORT;	
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+
+		/*
+		 *	1. Set Interswitch port mode for port 8 and 9 for device 1,2,3,4,5
+		 *         so that switch device can expect Marvell Tag from frames 
+		 *         ingressing/egressing this port.
+		 *	2. Set CPU Port information (for To_CPU frame) for each port of device.
+		 */			
+		for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
+		{
+			if((j == cpuPort) || (j == cascadePort) || ((i==(cpu_device_id-1))&&(j==another_cpu_cascadePort)))
+			{
+				printk("Opal #%d Port %d is setting inter-switch port\n",i+1, j);
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_TRUE)) != GT_OK)
+				{
+					printk("gprtSetInterswitchPort returned %i (port %i, mode TRUE)\n",status,j);
+					goto errorExit;
+				}
+			}
+			else
+			{
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_FALSE)) != GT_OK)
+				{
+					printk("gprtSetInterswitchPort returned %i (port %i, mode FALSE)\n",status,j);
+					goto errorExit;
+				}
+			}
+
+			/* NOTE:
+			 * cyclades: should S_CPU_DEVICE_ID's cpuPort be set to interswitch (AKA. Marvell Tag port)?
+			 *           Finally we should if modified TSEC2 MAC driver supports MT, we can disable
+			 *           it temporarily for developing.
+			 */
+#if 0
+			if((i==(cpu_device_id-1)) && (j==cpuPort)) {
+				printk("Opal #%d is S_CPU_DEVICE_ID, its CPU_PORT %d is NOT set to Marvell Tag port because lack MAC driver support \n",i+1, j);
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_FALSE)) != GT_OK)
+				{
+					printk("gprtSetInterswitchPort returned %i (port %i, mode FALSE)\n",status,j);
+					goto errorExit;
+				}
+			}
+#endif
+
+			if((status=gprtSetCPUPort(qdMultiDev[i],j,cpuPort)) != GT_OK)
+			{
+				printk("gprtSetCPUPort returned %i\n",status);
+				goto errorExit;
+			}
+		}
+
+		/*
+		 *	3. Set Cascading Port information (for From_CPU fram) for each device.
+		 */	 	
+		if((status=gsysSetCascadePort(qdMultiDev[i],cascadePort)) != GT_OK)
+		{
+			printk("gsysSetCascadePort returned %i\n",status);
+			goto errorExit;
+		}
+
+		/*
+		 *  cyclades: Q? for S_CPU_DEVICE_ID, how to set another_cpu_cascadePort?
+		 *          seems only ONE CAS_PORT per DEVICE!
+		 *  solution: set S_CPU_DEVICE_ID's CAS_PORT to be 0xF, then use routing
+		 *          table to route From_CPU marvell-tagged frame to the specified
+		 *          6095 device.
+		 */
+		if(i==(cpu_device_id-1)) {
+			if((status=gsysSetCascadePort(qdMultiDev[i],s_cpu_device_cas_port)) != GT_OK)
+			{
+				printk("gsysSetCascadePort returned %i\n",status);
+				goto errorExit;
+			}
+			while(rt_entry && rt_entry->devnum !=-1) {
+				if((status=gsysSetDevRoutingTable(qdMultiDev[i],rt_entry->devnum, rt_entry->portnum)) != GT_OK)
+				{
+					printk("gsysSetDevRoutingTable returned %i\n",status);
+					goto errorExit;
+				}
+				rt_entry++;
+			}
+		}
+
+		/*
+		 * 	4. Set Device ID (if required)
+		 */	 	
+		if((status=gsysSetDeviceNumber(qdMultiDev[i],DEVICE1_ID+i)) != GT_OK)
+		{
+			printk("gsysSetDeviceNumber returned %i\n",status);
+			goto errorExit;
+		}
+	}
+
+	/* 
+	 *	For HW guy happy, we manually invert LED0 setting for all FE ports.
+	 *	set all PHY reg 0x19 bit-12 to be 1.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		switch (i) {
+		case 0: /* if we are registering device 1 */
+		case 1: /* if we are registering device 2 */
+		case 2: /* if we are registering device 3 */
+		case 3: /* if we are registering device 4 */
+		case 4: /* if we are registering device 5 */
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+
+		/*
+		 * set all PHY reg 0x19 bit-12 to be 1.
+		 */			
+		for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
+		{
+			GT_U16 data = 0;
+			GT_U32 regAddr = 0x19;
+
+			if(j>=NR_FE_PER_SWITCH)	/* GE ports */
+				continue;
+
+			if((status=gprtGetPhyReg(qdMultiDev[i],j,regAddr, &data)) != GT_OK)
+			{
+				debug("gprtGetPhyReg returned %i (port %i, reg 0x%02x, data 0x04)\n",status,j,regAddr,data);
+				goto errorExit;
+			}
+			data |= 0x1000;
+			if((status=gprtSetPhyReg(qdMultiDev[i],j,regAddr,data)) != GT_OK)
+			{
+				debug("gprtSetPhyReg returned %i (port %i, reg 0x%02x, data 0x04)\n",status,j,regAddr,data);
+				goto errorExit;
+			}
+		}
+	}
+
+	printk("QuarterDeck has been started.\n");
+
+	return GT_OK;
+
+errorExit:
+
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(qdMultiDev[i] != NULL)
+		{
+			qdUnloadDriver(qdMultiDev[i]);
+	  		kfree(qdMultiDev[i]);
+		}
+	}	
+
+	printk("QuarterDeck initialization failed.\n");
+
+	return status;
+}
+
+static GT_STATUS set_port_vlantable_helper(GT_QD_DEV *dev, GT_LPORT port, int vlantable)
+{
+	GT_LPORT mem_ports[MAX_SWITCH_PORTS];
+	GT_U8    mem_portslen =0;
+	int j;
+
+	for(j=0; j<MAX_SWITCH_PORTS; j++) {
+		if((vlantable>>j)&0x1) {
+			mem_ports[mem_portslen]=j;
+			mem_portslen++;
+		}
+	}
+	return gvlnSetPortVlanPorts(dev, port, mem_ports, mem_portslen);
+}
+
+static GT_STATUS set_vtu_helper(GT_QD_DEV *dev, int id)
+{
+	/* id is deviceID starting from 0 */
+	int j;
+	GT_STATUS status;
+	switch(id) {
+	case 0:			/* Opal 1 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printk("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device1_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device1_vtu_entries[j])) != GT_OK) {
+				printk("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 1:			/* Opal 2 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printk("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device2_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device2_vtu_entries[j])) != GT_OK) {
+				printk("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 2:			/* Opal 3 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printk("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device3_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device3_vtu_entries[j])) != GT_OK) {
+				printk("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 3:			/* Opal 4 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printk("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device4_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device4_vtu_entries[j])) != GT_OK) {
+				printk("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 4:			/* Opal 5 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printk("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device5_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device5_vtu_entries[j])) != GT_OK) {
+				printk("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	default:		/* No such device */
+		return GT_NO_SUCH;
+	}
+	return GT_OK;
+}
+
+/*
+ * set up Cross-chip Port-Based VLANs:
+ *   1) set all 11 ports of all 5 switches 802.1Q disabled except
+ *      for S_CPU_DEVICE_ID's S_CPU_DEVICE_CPU_PORT which set to Fallback
+ *   2) set all ports's VLANTABLE according to vlantable
+ *   3) set all ports's DEFAULTVID according to defaultvid
+ *   4) set VTU entries accordingly for 5 devices
+ * return 0 on success
+ */
+static int sw6095_setvlans(bd_t *bis)
+{
+	int i, j;
+	GT_STATUS status;
+
+	for(i=0; i<N_OF_QD_DEVICES; i++) {
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		for(j=0; j<MAX_PORTS_PER_SWITCH; j++) {
+			/* 1) set QMode disabled */
+			if((status=gvlnSetPortVlanDot1qMode(qdMultiDev[i], j, GT_DISABLE)) != GT_OK) {
+				printk("SW6095 #%d port %d setting QMode=disabled Failed\n", i+1, j);
+				return status;
+			}
+			/* 2) set VLANTABLE */
+			if((status=set_port_vlantable_helper(qdMultiDev[i], j, vlantable[i][j])) != GT_OK) {
+				printk("SW6095 #%d port %d setting VLANTABLE Failed\n", i+1, j);
+				return status;
+			}
+			/* 3) set DEFAULTVID */
+			if((status=gvlnSetPortVid(qdMultiDev[i], j, defaultvid[i][j])) != GT_OK) {
+				printk("SW6095 #%d port %d setting DEFAULTVID Failed\n", i+1, j);
+				return status;
+			}
+		}
+		if((status=set_vtu_helper(qdMultiDev[i], i)) != GT_OK) {
+			printk("SW6095 #%d setting VTU Failed\n", i+1);
+			return status;
+		}
+	}
+	/* set S_CPU_DEVICE_CPU_PORT's QMode fallback */
+	if((status=gvlnSetPortVlanDot1qMode(qdMultiDev[S_CPU_DEVICE_ID-1], S_CPU_DEVICE_CPU_PORT, GT_FALLBACK)) != GT_OK) {
+		printk("SW6095 #%d port %d setting QMode=fallback Failed\n", S_CPU_DEVICE_ID, S_CPU_DEVICE_CPU_PORT);
+		return status;
+	}
+	printk("Marvell 88E6095 switches set VLANs OK!\n");
+	return 0;
+}
+
+/* return 0 on success */
+static int sw6095_startup(bd_t *bis)
+{
+	int i, j;
+	GT_STATUS status;
+	int sp, ep;
+
+	for(i=0; i<N_OF_QD_DEVICES; i++) {
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		switch (i) {
+		case 0: 			/* OPAL 1 */
+			sp=9, ep=9;
+			break;
+		case 1: 			/* OPAL 2 */
+			sp=8, ep=9;
+			break;
+		case 2: 			/* OPAL 3 */
+			sp=8, ep=10;
+			break;
+		case 3: 			/* OPAL 4 */
+			sp=8, ep=9;
+			break;
+		case 4: 			/* OPAL 5 */
+			sp=8, ep=8;
+			break;
+		default:
+			sp=0, ep=-1;
+		}
+
+		for(j=sp; j<=ep; j++) {
+			status = GT_FAIL;
+			if((status=gpcsSetDpxValue(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+				if((status=gpcsSetForcedDpx(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+					debug("SW6095 #%d port %d setting Force Full Duplex OK\n", i+1, j);
+				}
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force Full Duplex Failed\n", i+1, j);
+				continue;
+			}
+
+			status = GT_FAIL;
+			if((status=gpcsSetForceSpeed(qdMultiDev[i], j, PORT_FORCE_SPEED_1000_MBPS)) == GT_OK) {
+				debug("SW6095 #%d port %d setting Force 1000Mbps Speed OK\n", i+1, j);
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force 1000Mbps Speed Failed\n", i+1, j);
+				continue;
+			}
+
+			status = GT_FAIL;
+			if((status=gpcsSetLinkValue(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+				if((status=gpcsSetForcedLink(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+					debug("SW6095 #%d port %d setting Force Link Up OK\n", i+1, j);
+				}
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force Link Up Failed\n", i+1, j);
+				continue;
+			}
+		}
+#if 0
+		{				/* dump port 3's PHY registers */
+			int j;
+			for(j=0; j<32; j++) {
+				GT_U16 data=0;
+      
+				if((status=gprtGetPhyReg(qdMultiDev[i], 3, j, &data)) == GT_OK) {
+					debug("----------port %d PHY reg 0x%02x is 0x%04x\n", 3, j, data);
+				}
+			}
+		}
+#endif
+	}
+	return 0;
+}
+
+static int __init debmax_sw6095_init(void)
+{
+	bd_t *bis = (bd_t *)__res;
+	struct sk_buff *skb = NULL;
+
+	printk("Marvell 88E6095 switches are starting up ...\n");
+	if (sizeof(mt_pair_t) > sizeof(skb->cb)) {
+		printk("Marvell 88E6095 switches Failed: Marvell Tag pair size is TOO BIG!!\n");
+		return -1;
+	}
+		
+	if(sw6095_setup_const(bis) != 0) {
+		printk("Marvell 88E6095 switches Failed: Setup board constants Failed!!\n");
+		return -1;
+	}
+	
+	if(qdMultiDevStart() != GT_OK) {
+		printk("Marvell 88E6095 switches Failed: Init switch driver Failed!!\n");
+		return -1;
+	}
+
+	if(sw6095_setvlans(bis)!=0) {
+		printk("Marvell 88E6095 switches Failed: Set VLANs Failed!!\n");
+		return -1;
+	}
+	if(sw6095_startup(bis)!=0) {
+		printk("Marvell 88E6095 switches Failed: startup switch chip Failed!!\n");
+		return -1;
+	}
+	printk("Marvell 88E6095 switches startup OK!!\n");
+	return 0;
+}
+
+static void __exit debmax_sw6095_exit(void)
+{
+	return;
+}
+
+module_init(debmax_sw6095_init);
+module_exit(debmax_sw6095_exit);
+
+#endif /* CONFIG_MV88E6095 */
Index: linux-2.6.16/drivers/net/gianfar.c
===================================================================
--- linux-2.6.16.orig/drivers/net/gianfar.c	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/drivers/net/gianfar.c	2007-05-24 14:47:01.000000000 -0400
@@ -109,6 +109,16 @@
 #define RECEIVE(x) netif_rx(x)
 #endif
 
+#undef TSEC2_ENABLE_MV_TAG
+#if defined(CONFIG_ALTERPATH_ONBOARD) && defined(CONFIG_MV88E6095)
+#define TSEC2_ENABLE_MV_TAG
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/mv_platform.h>
+#include <linux/marvell/mv_mvtag.h>
+#include <linux/debmax_sw6095.h>
+/* #define DEBUG_MV_TAG */
+#endif
+
 const char gfar_driver_name[] = "Gianfar Ethernet";
 const char gfar_driver_version[] = "1.3";
 
@@ -208,6 +218,7 @@
 
 	spin_lock_init(&priv->lock);
 
+	einfo->dev = dev;
 	platform_set_drvdata(pdev, dev);
 
 	/* Stop the DMA engine now, in case it was running before */
@@ -334,10 +345,23 @@
 	priv->rxcoalescing = DEFAULT_RX_COALESCE;
 	priv->rxcount = DEFAULT_RXCOUNT;
 	priv->rxtime = DEFAULT_RXTIME;
+	priv->index = priv->einfo->phy_id == ALTERPATH_TSEC1_PHY_ID ? 0 : 1;
 
 	/* Enable most messages by default */
 	priv->msg_enable = (NETIF_MSG_IFUP << 1 ) - 1;
 
+#ifdef CONFIG_ALTERPATH_ONBOARD
+	/* we want TSEC2 to have eth ifc name as "priv0" */
+	if (priv->index == 1) {
+		err = dev_alloc_name(dev, "priv%d");
+		if (err < 0) {
+			printk(KERN_ERR "%s: Cannot allocate device name.\n",
+			       dev->name);
+			goto register_fail;
+		}
+	}
+#endif
+	
 	err = register_netdev(dev);
 
 	if (err) {
@@ -381,6 +405,11 @@
 
 	platform_set_drvdata(pdev, NULL);
 
+	if (dev->ethtool_ops) {
+		kfree(dev->ethtool_ops);
+		dev->ethtool_ops = NULL;
+	}
+
 	iounmap(priv->regs);
 	free_netdev(dev);
 
@@ -400,6 +429,15 @@
 	struct phy_device *phydev;
 	char phy_id[BUS_ID_SIZE];
 
+	if (priv->einfo->device_flags & FSL_GIANFAR_DEV_HAS_FAKE_PHY) {
+		priv->oldlink = 1;
+		priv->oldspeed = 100;
+		priv->oldduplex = 1;
+		priv->phydev = NULL;
+		netif_schedule(dev);
+		return 0;
+	}
+
 	priv->oldlink = 0;
 	priv->oldspeed = 0;
 	priv->oldduplex = -1;
@@ -419,8 +457,60 @@
 
 	priv->phydev = phydev;
 
+	/* Fine tune the PHY immediately after config, default config
+	 * is ANEG enabled, in finetune() we can force
+	 * speed/duplexity */
+	//phy_run_commands(dev, priv->phyinfo->finetune);
+
+	return 0;
+}
+
+#if 0
+/* fine tune PHY setting after its default ANEG. */
+u16 mii_88E1011_finetune(u16 mii_reg, struct net_device * dev)
+{
+#ifdef CONFIG_ALTERPATH_ONBOARD
+	struct gfar_private *priv = (struct gfar_private *) dev->priv;
+	bd_t *bd = (bd_t *)__res;
+	unsigned char miiop;
+
+	if (priv->index == 0)
+		/* TSEC1, fecmode1 */
+		miiop = bd->mii_operation[0];
+	else if (priv->index == 1)
+		/* TSEC2, fecmode2 */
+		miiop = bd->mii_operation[1];
+	else
+		return 0;
+	
+	switch (miiop) {
+		case 0:		/* auto */
+		default:
+			break;
+		case 1:		/* 1000F */
+			write_phy_reg(dev, MIIM_CONTROL, MIIM_CONTROL_RESET|MIIM_CONTROL_1000F);
+			break;
+		case 2:		/* 1000H */
+			write_phy_reg(dev, MIIM_CONTROL, MIIM_CONTROL_RESET|MIIM_CONTROL_1000H);
+			break;
+		case 3:		/* 100F */
+			write_phy_reg(dev, MIIM_CONTROL, MIIM_CONTROL_RESET|MIIM_CONTROL_100F);
+			break;
+		case 4:		/* 100H */
+			write_phy_reg(dev, MIIM_CONTROL, MIIM_CONTROL_RESET|MIIM_CONTROL_100H);
+			break;
+		case 5:		/* 10F */
+			write_phy_reg(dev, MIIM_CONTROL, MIIM_CONTROL_RESET|MIIM_CONTROL_10F);
+			break;
+		case 6:		/* 10H */
+			write_phy_reg(dev, MIIM_CONTROL, MIIM_CONTROL_RESET|MIIM_CONTROL_10H);
+			break;
+	}
+#endif
+
 	return 0;
 }
+#endif
 
 static void init_registers(struct net_device *dev)
 {
@@ -508,7 +598,9 @@
 	struct gfar __iomem *regs = priv->regs;
 	unsigned long flags;
 
-	phy_stop(priv->phydev);
+	if (priv->phydev) {
+		phy_stop(priv->phydev);
+	}
 
 	/* Lock it down */
 	spin_lock_irqsave(&priv->lock, flags);
@@ -528,11 +620,15 @@
 
 	free_skb_resources(priv);
 
-	dma_free_coherent(NULL,
-			sizeof(struct txbd8)*priv->tx_ring_size
-			+ sizeof(struct rxbd8)*priv->rx_ring_size,
-			priv->tx_bd_base,
-			gfar_read(&regs->tbase0));
+	if (priv->tx_bd_base) {
+		dma_free_coherent(NULL,
+				sizeof(struct txbd8)*priv->tx_ring_size
+				+ sizeof(struct rxbd8)*priv->rx_ring_size,
+				priv->tx_bd_base,
+				gfar_read(&regs->tbase0));
+		priv->tx_bd_base = NULL;
+		priv->rx_bd_base = NULL;
+	}
 }
 
 /* If there are any tx skbs or rx skbs still around, free them.
@@ -546,15 +642,19 @@
 	/* Go through all the buffer descriptors and free their data buffers */
 	txbdp = priv->tx_bd_base;
 
-	for (i = 0; i < priv->tx_ring_size; i++) {
+	if (priv->tx_skbuff) {
+		for (i = 0; i < priv->tx_ring_size; i++) {
 
-		if (priv->tx_skbuff[i]) {
-			dma_unmap_single(NULL, txbdp->bufPtr,
-					txbdp->length,
-					DMA_TO_DEVICE);
-			dev_kfree_skb_any(priv->tx_skbuff[i]);
-			priv->tx_skbuff[i] = NULL;
+			if (priv->tx_skbuff[i]) {
+				dma_unmap_single(NULL, txbdp->bufPtr,
+						txbdp->length,
+						DMA_TO_DEVICE);
+				dev_kfree_skb_any(priv->tx_skbuff[i]);
+				priv->tx_skbuff[i] = NULL;
+			}
 		}
+		kfree(priv->tx_skbuff);
+		priv->tx_skbuff = NULL;
 	}
 
 	kfree(priv->tx_skbuff);
@@ -582,6 +682,7 @@
 		}
 
 		kfree(priv->rx_skbuff);
+		priv->rx_skbuff = NULL;
 	}
 }
 
@@ -767,7 +868,8 @@
 		}
 	}
 
-	phy_start(priv->phydev);
+	if (priv->phydev)
+		phy_start(priv->phydev);
 
 	/* Configure the coalescing support */
 	if (priv->txcoalescing)
@@ -847,6 +949,9 @@
 			priv->tx_bd_base,
 			gfar_read(&regs->tbase0));
 
+	priv->tx_bd_base = NULL;
+	priv->rx_bd_base = NULL;
+
 	return err;
 }
 
@@ -916,9 +1021,9 @@
 	fcb->vlctl = vlan_tx_tag_get(skb);
 }
 
-/* This is called by the kernel when a frame is ready for transmission. */
-/* It is pointed to by the dev->hard_start_xmit function pointer */
-static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
+/* called by gfar_start_xmit() after setting up skb and grabbing lock
+ * and disabled local irq. */
+static int __gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct gfar_private *priv = netdev_priv(dev);
 	struct txfcb *fcb = NULL;
@@ -928,9 +1033,6 @@
 	/* Update transmit stats */
 	priv->stats.tx_bytes += skb->len;
 
-	/* Lock priv now */
-	spin_lock_irq(&priv->lock);
-
 	/* Point at the first free tx descriptor */
 	txbdp = priv->cur_tx;
 
@@ -999,6 +1101,99 @@
 	/* Tell the DMA to go go go */
 	gfar_write(&priv->regs->tstat, TSTAT_CLEAR_THALT);
 
+	return 0;
+}
+
+static inline void dump_skb(struct sk_buff *skb, const char *name)
+{
+#ifdef DEBUG_MV_TAG
+	if(!skb)
+		return;
+	printk(KERN_DEBUG "--DUMPING %s:\n", name ? name : "skb");
+	printk(KERN_DEBUG "skb->next    [%08x]\n",skb->next    );
+	printk(KERN_DEBUG "skb->prev    [%08x]\n",skb->prev    );
+	printk(KERN_DEBUG "skb->list    [%08x]\n",skb->list    );
+	printk(KERN_DEBUG "skb->sk      [%08x]\n",skb->sk      );
+	printk(KERN_DEBUG "skb->dev     [%08x]\n",skb->dev     );
+	printk(KERN_DEBUG "skb->h.raw   [%08x]\n",skb->h.raw   );
+	printk(KERN_DEBUG "skb->nh.raw  [%08x]\n",skb->nh.raw  );
+	printk(KERN_DEBUG "skb->mac.raw [%08x]\n",skb->mac.raw );
+	printk(KERN_DEBUG "skb->dst     [%08x]\n",skb->dst     );
+	printk(KERN_DEBUG "skb->len     [%08x]\n",skb->len     );
+	printk(KERN_DEBUG "skb->data_len[%08x]\n",skb->data_len);
+	printk(KERN_DEBUG "skb->csum    [%08x]\n",skb->csum    );
+	printk(KERN_DEBUG "skb->cloned  [%08x]\n",skb->cloned  );
+	printk(KERN_DEBUG "skb->pkt_type[%08x]\n",skb->pkt_type);
+	printk(KERN_DEBUG "skb->users   [%08x]\n",atomic_read(&skb->users)   );
+	printk(KERN_DEBUG "skb->protocol[%08x]\n",skb->protocol);
+	printk(KERN_DEBUG "skb->truesize[%08x]\n",skb->truesize);
+	printk(KERN_DEBUG "skb->head    [%08x]\n",skb->head    );
+	printk(KERN_DEBUG "skb->data    [%08x]\n",skb->data    );
+	printk(KERN_DEBUG "skb->tail    [%08x]\n",skb->tail    );
+	printk(KERN_DEBUG "skb->end     [%08x]\n",skb->end     );
+#endif
+	return;
+}
+
+/* This is called by the kernel when a frame is ready for transmission. */
+/* It is pointed to by the dev->hard_start_xmit function pointer */
+static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct gfar_private *priv = (struct gfar_private *) dev->priv;
+
+	/* Lock priv now */
+	spin_lock_irq(&priv->lock);
+
+#ifdef TSEC2_ENABLE_MV_TAG
+	if (priv->index == 1) {
+		mvtag_t mt;
+#ifdef DEBUG_MV_TAG				
+		static unsigned int cnt = 0;
+		cnt++;
+#endif
+
+		if (skb_headroom(skb) < MV_TAG_LEN) {
+			struct sk_buff *skb_copy = NULL;
+
+#ifdef DEBUG_MV_TAG				
+			printk(KERN_DEBUG "%s SEND: skb lack %d bytes headroom for Marvell Tag, "
+			       "type (%04x), len (%u), (%u)\n", dev->name, MV_TAG_LEN - skb_headroom(skb),
+			       htons(*((unsigned short *)(skb->data+12))), skb->len, cnt);
+#endif
+
+			if((skb_copy = skb_realloc_headroom(skb, MV_TAG_LEN))==NULL) {
+#ifdef DEBUG_MV_TAG				
+				printk(KERN_WARNING "%s SEND: could not alloc new skbuff\n", dev->name);
+#endif
+				spin_unlock_irq(&priv->lock);
+				return -EBUSY;
+			}
+
+			dev_kfree_skb_any(skb);
+			skb=skb_copy;
+		}
+
+		skb_push(skb, MV_TAG_LEN);
+
+#ifdef DEBUG_MV_TAG				
+		printk(KERN_DEBUG "%s SEND, memmove(%08x, %08x, 12)\n", dev->name, skb->data, skb->data+MV_TAG_LEN);
+#endif
+		/* reserve Marvell Tag space after DA/SA */
+		memmove(skb->data, skb->data+MV_TAG_LEN, 12);
+
+		/*
+		 *	TODO: make a more suitable MT.
+		 */
+		mt = MT_DEFAULT_FWD_INGRESS;
+		
+		/* Insert Marvell Tag */
+		*((unsigned long *)(skb->data + 12)) = htonl(mt);
+
+		dump_skb(skb, "SEND skb");
+	}
+#endif
+	__gfar_start_xmit(skb, dev);
+	
 	/* Unlock priv */
 	spin_unlock_irq(&priv->lock);
 
@@ -1012,8 +1207,10 @@
 	stop_gfar(dev);
 
 	/* Disconnect from the PHY */
-	phy_disconnect(priv->phydev);
-	priv->phydev = NULL;
+	if (priv->phydev) {
+		phy_disconnect(priv->phydev);
+		priv->phydev = NULL;
+	}
 
 	netif_stop_queue(dev);
 
@@ -1321,8 +1518,8 @@
 	} else {
 		if (netif_msg_rx_err(priv))
 			printk(KERN_DEBUG "%s: receive called twice (%x)[%x]\n",
-				dev->name, gfar_read(&priv->regs->ievent),
-				gfar_read(&priv->regs->imask));
+			       dev->name, gfar_read(&priv->regs->ievent),
+			       gfar_read(&priv->regs->imask));
 	}
 #else
 
@@ -1391,6 +1588,34 @@
 	} else {
 		int ret;
 
+#ifdef TSEC2_ENABLE_MV_TAG
+		if (priv->index == 1) {
+			mvtag_t mt;
+			unsigned short proto;
+			
+			mt = ntohl(*((unsigned long *)(skb->data+12)));
+
+#ifdef DEBUG_MV_TAG				
+			printk(KERN_DEBUG "%s RCV: skb with MT(%08x)\n", dev->name, mt);
+#endif
+
+			/* remove MV_TAG */
+			memmove(skb->data+MV_TAG_LEN, skb->data, 12);
+
+			skb_reserve(skb, MV_TAG_LEN);
+			length -= MV_TAG_LEN;
+
+			proto = eth_type_trans(skb, dev);
+
+			/* only create MT pair for IP or ARP packets,
+			 * since we only handle MT in IP and ARP
+			 * receive routines. */
+			if (proto == htons(ETH_P_IP) || proto == htons(ETH_P_ARP))
+				mt_pair_create(MT_PAIR_SKB_CB(skb), mt);
+			
+			dump_skb(skb, "RCVed skb");
+		}
+#endif
 		/* Prep the skb for the packet */
 		skb_put(skb, length);
 
Index: linux-2.6.16/drivers/net/gianfar.h
===================================================================
--- linux-2.6.16.orig/drivers/net/gianfar.h	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/drivers/net/gianfar.h	2007-05-24 14:47:01.000000000 -0400
@@ -688,6 +688,7 @@
 	struct net_device_stats stats; /* linux network statistics */
 	struct gfar_extra_stats extra_stats;
 	spinlock_t lock;
+	spinlock_t phy_lock;
 	unsigned int rx_buffer_size;
 	unsigned int rx_stash_size;
 	unsigned int rx_stash_index;
@@ -713,9 +714,13 @@
 	struct mii_bus *mii_bus;
 	int oldspeed;
 	int oldduplex;
+	int link;
 	int oldlink;
 
 	uint32_t msg_enable;
+
+	int index;		/* equals ocpdev->def->index
+				 * 0 for TSEC1, 1 for TSEC2 */
 };
 
 static inline u32 gfar_read(volatile unsigned __iomem *addr)
Index: linux-2.6.16/drivers/net/gianfar_mii.c
===================================================================
--- linux-2.6.16.orig/drivers/net/gianfar_mii.c	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/drivers/net/gianfar_mii.c	2007-05-24 14:47:01.000000000 -0400
@@ -37,10 +37,12 @@
 #include <linux/crc32.h>
 #include <linux/mii.h>
 #include <linux/phy.h>
+#include <linux/fsl_devices.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/uaccess.h>
+#include <asm/ppc_sys.h>
 
 #include "gianfar.h"
 #include "gianfar_mii.h"
@@ -50,8 +52,12 @@
  * All PHY configuration is done through the TSEC1 MIIM regs */
 int gfar_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 value)
 {
-	struct gfar_mii __iomem *regs = (void __iomem *)bus->priv;
+	struct gfar_mii_priv *priv = (struct gfar_mii_priv *) (bus->priv);
+	struct gfar_mii __iomem *regs = (struct gfar_mii __iomem *)(priv->regs);
+	unsigned long irqflags;
 
+	spin_lock_irqsave(&bus->mdio_lock, irqflags);
+	
 	/* Set the PHY address and the register address we want to write */
 	gfar_write(&regs->miimadd, (mii_id << 8) | regnum);
 
@@ -62,6 +68,7 @@
 	while (gfar_read(&regs->miimind) & MIIMIND_BUSY)
 		cpu_relax();
 
+	spin_unlock_irqrestore(&bus->mdio_lock, irqflags);
 	return 0;
 }
 
@@ -70,9 +77,13 @@
  * configuration has to be done through the TSEC1 MIIM regs */
 int gfar_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 {
-	struct gfar_mii __iomem *regs = (void __iomem *)bus->priv;
+	struct gfar_mii_priv *priv = (struct gfar_mii_priv *) (bus->priv);
+	struct gfar_mii __iomem *regs = (struct gfar_mii __iomem *)(priv->regs);
+	unsigned long irqflags;
 	u16 value;
 
+	spin_lock_irqsave(&bus->mdio_lock, irqflags);
+	
 	/* Set the PHY address and the register address we want to read */
 	gfar_write(&regs->miimadd, (mii_id << 8) | regnum);
 
@@ -87,14 +98,67 @@
 	/* Grab the value of the register from miimstat */
 	value = gfar_read(&regs->miimstat);
 
+	spin_unlock_irqrestore(&bus->mdio_lock, irqflags);
+
 	return value;
 }
 
+/* returns which value to write to the control register. */
+/* For 10/100 the value is slightly different. */
+u16 mii_cr_init(u16 mii_reg, struct net_device * dev)
+{
+	struct gfar_private *priv = (struct gfar_private *) dev->priv;
+	struct gianfar_platform_data *einfo = priv->einfo;
+
+	if (einfo->board_flags & FSL_GIANFAR_DEV_HAS_GIGABIT)
+		return BMCR_SPEED1000 | BMCR_FULLDPLX | BMCR_ANENABLE;
+	else
+		return BMCR_ANENABLE;
+}
+
+#define BRIEF_GFAR_ERRORS
+/* Wait for auto-negotiation to complete */
+u16 mii_parse_sr(u16 mii_reg, struct net_device * dev)
+{
+	struct gfar_private *priv = (struct gfar_private *) dev->priv;
+
+	unsigned int timeout = GFAR_AN_TIMEOUT;
+
+	if (mii_reg & MIIM_88E1011_PHYSTAT_LINK)
+		priv->oldlink = priv->link = 1;
+	else
+		priv->oldlink = priv->link = 0;
+	
+	if(!(gfar_mdio_read(priv->mii_bus, priv->einfo->phy_id, MII_BMCR) & BMCR_ANENABLE)) {
+		/* Not ANEG, so no need to check AN_DONE */
+		printk(KERN_INFO "%s: Auto-negotiation disabled\n",
+		       dev->name);
+		return 0;
+	}
+
+	/* Only auto-negotiate if the link has just gone up */
+	if (priv->link && !priv->oldlink) {
+		while ((!(mii_reg & BMSR_ANEGCOMPLETE)) && timeout--)
+			mii_reg = gfar_mdio_read(priv->mii_bus, priv->einfo->phy_id, MII_BMSR);
+
+#if defined(BRIEF_GFAR_ERRORS)
+		if (mii_reg & BMSR_ANEGCOMPLETE)
+			printk(KERN_INFO "%s: Auto-negotiation done\n",
+			       dev->name);
+		else
+			printk(KERN_INFO "%s: Auto-negotiation timed out\n",
+			       dev->name);
+#endif
+	}
+
+	return 0;
+}
 
 /* Reset the MIIM registers, and wait for the bus to free */
 int gfar_mdio_reset(struct mii_bus *bus)
 {
-	struct gfar_mii __iomem *regs = (void __iomem *)bus->priv;
+	struct gfar_mii_priv *priv = (struct gfar_mii_priv *) (bus->priv);
+	struct gfar_mii __iomem *regs = (struct gfar_mii __iomem *)(priv->regs);
 	unsigned int timeout = PHY_INIT_TIMEOUT;
 
 	spin_lock_bh(&bus->mdio_lock);
@@ -121,12 +185,101 @@
 	return 0;
 }
 
+/* Take a list of struct phy_cmd, and, depending on the values, either */
+/* read or write, using a helper function if provided */
+/* It is assumed that all lists of struct phy_cmd will be terminated by */
+/* mii_end. */
+void phy_run_commands(struct net_device *dev, const struct phy_cmd *cmd)
+{
+	int i;
+	u16 result;
+	struct gfar_private *priv = (struct gfar_private *) dev->priv;
+
+	gfar_mdio_reset(priv->mii_bus);
+	
+	for (i = 0; cmd && cmd->mii_reg != miim_end; i++) {
+		/* The command is a read if mii_data is miim_read */
+		if (cmd->mii_data == miim_read) {
+			/* Read the value of the PHY reg */
+			result = gfar_mdio_read(priv->mii_bus, priv->einfo->phy_id, cmd->mii_reg);
+
+			/* If a function was supplied, we need to let it process */
+			/* the result. */
+			if (cmd->funct != NULL)
+				(*(cmd->funct)) (result, dev);
+		} else if (cmd->mii_data == miim_fake) {
+			result = 0;
+			if (cmd->funct != NULL)
+				(*(cmd->funct))(result, dev);
+		} else {	/* Otherwise, it's a write */
+			/* If a function was supplied, it will provide 
+			 * the value to write */
+			/* Otherwise, the value was supplied in cmd->mii_data */
+			if (cmd->funct != NULL)
+				result = (*(cmd->funct)) (0, dev);
+			else
+				result = cmd->mii_data;
+
+			/* Write the appropriate value to the PHY reg */
+			gfar_mdio_write(priv->mii_bus, priv->einfo->phy_id, cmd->mii_reg, result);
+		}
+		cmd++;
+	}
+}
+
+/*
+ * use TSECs to provide SMI_AGENT functions as long as accessed PHY devices
+ * share the same SMI bus as TSECs.
+ *
+ * we also allow TSECs to access their own PHY through these two functions if
+ * NOT HAS_FAKEPHY.
+ * 
+ */
+
+/*
+ * keep local cache, may have problem if TSEC removed later on,
+ * but that is very rare. We take this risk to enhance performance.
+ */
+static struct device *mdio_device = NULL;
+
+int gianfar_miiphy_read(unsigned char addr, unsigned char reg, unsigned short *value)
+{
+	struct mii_bus *miibus;
+
+	if (mdio_device == NULL) {
+		printk(KERN_WARNING "can't read PHY(0x%X) REG(0x%X)\n", addr, reg);
+		return -1;
+	}
+	miibus = dev_get_drvdata(mdio_device);
+
+	gfar_mdio_reset(miibus);
+	
+	*value = gfar_mdio_read(miibus, addr, (u16)reg);
+	return 0;
+}
+
+int gianfar_miiphy_write(unsigned char addr, unsigned char reg, unsigned short value)
+{
+	struct mii_bus *miibus;
+
+	if (mdio_device == NULL) {
+		printk(KERN_WARNING "can't write PHY(0x%X) REG(0x%X) VALUE(0x%X)\n", addr, reg, value);
+		return -1;
+	}
+	miibus = dev_get_drvdata(mdio_device);
+
+	gfar_mdio_reset(miibus);
+	
+	gfar_mdio_write(miibus, addr, (u16)reg, value);
+	return 0;
+}
 
 int gfar_mdio_probe(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct gianfar_mdio_data *pdata;
 	struct gfar_mii __iomem *regs;
+	struct gfar_mii_priv *priv;
 	struct mii_bus *new_bus;
 	struct resource *r;
 	int err = 0;
@@ -139,11 +292,19 @@
 	if (NULL == new_bus)
 		return -ENOMEM;
 
+	priv = kzalloc(sizeof(struct gfar_mii_priv), GFP_KERNEL);
+
+	if (!priv) {
+		kfree(new_bus);
+		return -ENOMEM;
+	}
+
 	new_bus->name = "Gianfar MII Bus",
 	new_bus->read = &gfar_mdio_read,
 	new_bus->write = &gfar_mdio_write,
 	new_bus->reset = &gfar_mdio_reset,
 	new_bus->id = pdev->id;
+	new_bus->priv = priv;
 
 	pdata = (struct gianfar_mdio_data *)pdev->dev.platform_data;
 
@@ -162,7 +323,8 @@
 		goto reg_map_fail;
 	}
 
-	new_bus->priv = (void __force *)regs;
+	new_bus->priv = (void __force *) priv;
+	priv->regs = regs;
 
 	new_bus->irq = pdata->irq;
 
@@ -177,11 +339,14 @@
 		goto bus_register_fail;
 	}
 
+	mdio_device = dev;
+
 	return 0;
 
 bus_register_fail:
 	iounmap(regs);
 reg_map_fail:
+	kfree(priv);
 	kfree(new_bus);
 
 	return err;
Index: linux-2.6.16/drivers/net/gianfar_mii.h
===================================================================
--- linux-2.6.16.orig/drivers/net/gianfar_mii.h	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/drivers/net/gianfar_mii.h	2007-05-24 14:47:01.000000000 -0400
@@ -18,11 +18,123 @@
 #ifndef __GIANFAR_MII_H
 #define __GIANFAR_MII_H
 
+#define miim_fake ((u32)-3)
+#define miim_end ((u32)-2)
+#define miim_read ((u32)-1)
+
+#define MIIM_CONTROL		0x00
+#define MIIM_CONTROL_RESET	0x00008000
+#define MIIM_CONTROL_INIT	0x00001140
+#define MIIM_ANEN		0x00001000
+#define MIIM_CONTROL_10H	0x00000000
+#define MIIM_CONTROL_10F	0x00000100
+#define MIIM_CONTROL_100H	0x00002000
+#define MIIM_CONTROL_100F	0x00002100
+#define MIIM_CONTROL_1000H	0x00000040
+#define MIIM_CONTROL_1000F	0x00000140
+
+#define MIIM_CR                 0x00
+#define MIIM_CR_RST		0x00008000
+#define MIIM_CR_INIT	        0x00001000
+
+#define MIIM_STATUS		0x1
+#define MIIM_STATUS_AN_DONE	0x00000020
+#define MIIM_STATUS_LINK	0x0004
+
+#define MIIM_PHYIR1		0x2
+#define MIIM_PHYIR2		0x3
+
+#define GFAR_AN_TIMEOUT         0x000fffff
+
+#define MIIM_ANLPBPA	0x5
+#define MIIM_ANLPBPA_HALF	0x00000040
+#define MIIM_ANLPBPA_FULL	0x00000020
+
+#define MIIM_ANEX		0x6
+#define MIIM_ANEX_NP    	0x00000004
+#define MIIM_ANEX_PRX   	0x00000002
+
+
 #define MIIMIND_BUSY            0x00000001
 #define MIIMIND_NOTVALID        0x00000004
 
 #define MII_READ_COMMAND       0x00000001
 
+/* Cicada Extended Control Register 1 */
+#define MIIM_CIS8201_EXT_CON1           0x17
+#define MIIM_CIS8201_EXTCON1_INIT       0x0000
+
+/* Cicada Interrupt Mask Register */
+#define MIIM_CIS8204_IMASK              0x19
+#define MIIM_CIS8204_IMASK_IEN          0x8000
+#define MIIM_CIS8204_IMASK_SPEED        0x4000
+#define MIIM_CIS8204_IMASK_LINK         0x2000
+#define MIIM_CIS8204_IMASK_DUPLEX       0x1000
+#define MIIM_CIS8204_IMASK_MASK         0xf000
+
+/* Cicada Interrupt Status Register */
+#define MIIM_CIS8204_ISTAT              0x1a
+#define MIIM_CIS8204_ISTAT_STATUS       0x8000
+#define MIIM_CIS8204_ISTAT_SPEED        0x4000
+#define MIIM_CIS8204_ISTAT_LINK         0x2000
+#define MIIM_CIS8204_ISTAT_DUPLEX       0x1000
+
+/* Cicada Auxiliary Control/Status Register */
+#define MIIM_CIS8201_AUX_CONSTAT        0x1c
+#define MIIM_CIS8201_AUXCONSTAT_INIT    0x0004
+#define MIIM_CIS8201_AUXCONSTAT_DUPLEX  0x0020
+#define MIIM_CIS8201_AUXCONSTAT_SPEED   0x0018
+#define MIIM_CIS8201_AUXCONSTAT_GBIT    0x0010
+#define MIIM_CIS8201_AUXCONSTAT_100     0x0008
+
+/* 88E1011 PHY Status Register */
+#define MIIM_88E1011_PHY_STATUS         0x11
+#define MIIM_88E1011_PHYSTAT_SPEED      0xc000
+#define MIIM_88E1011_PHYSTAT_GBIT       0x8000
+#define MIIM_88E1011_PHYSTAT_100        0x4000
+#define MIIM_88E1011_PHYSTAT_DUPLEX     0x2000
+#define MIIM_88E1011_PHYSTAT_LINK       0x0400
+
+#define MIIM_88E1011_IEVENT             0x13
+#define MIIM_88E1011_IEVENT_CLEAR       0x0000
+
+#define MIIM_88E1011_IMASK              0x12
+#define MIIM_88E1011_IMASK_INIT         0x6400
+#define MIIM_88E1011_IMASK_CLEAR        0x0000
+
+/* DM9161 Control register values */
+#define MIIM_DM9161_CR_STOP     0x0400
+#define MIIM_DM9161_CR_RSTAN    0x1200
+
+#define MIIM_DM9161_SCR         0x10
+#define MIIM_DM9161_SCR_INIT    0x0610
+
+/* DM9161 Specified Configuration and Status Register */
+#define MIIM_DM9161_SCSR        0x11
+#define MIIM_DM9161_SCSR_100F   0x8000
+#define MIIM_DM9161_SCSR_100H   0x4000
+#define MIIM_DM9161_SCSR_10F    0x2000
+#define MIIM_DM9161_SCSR_10H    0x1000
+
+/* DM9161 Interrupt Register */
+#define MIIM_DM9161_INTR        0x15
+#define MIIM_DM9161_INTR_PEND           0x8000
+#define MIIM_DM9161_INTR_DPLX_MASK      0x0800
+#define MIIM_DM9161_INTR_SPD_MASK       0x0400
+#define MIIM_DM9161_INTR_LINK_MASK      0x0200
+#define MIIM_DM9161_INTR_MASK           0x0100
+#define MIIM_DM9161_INTR_DPLX_CHANGE    0x0010
+#define MIIM_DM9161_INTR_SPD_CHANGE     0x0008
+#define MIIM_DM9161_INTR_LINK_CHANGE    0x0004
+#define MIIM_DM9161_INTR_INIT           0x0000
+#define MIIM_DM9161_INTR_STOP   \
+(MIIM_DM9161_INTR_DPLX_MASK | MIIM_DM9161_INTR_SPD_MASK \
+ | MIIM_DM9161_INTR_LINK_MASK | MIIM_DM9161_INTR_MASK)
+
+/* DM9161 10BT Configuration/Status */
+#define MIIM_DM9161_10BTCSR     0x12
+#define MIIM_DM9161_10BTCSR_INIT        0x7800
+
 #define GFAR_SUPPORTED (SUPPORTED_10baseT_Half \
 		| SUPPORTED_10baseT_Full \
 		| SUPPORTED_100baseT_Half \
@@ -30,6 +142,8 @@
 		| SUPPORTED_Autoneg \
 		| SUPPORTED_MII)
 
+#define GFAR_AN_TIMEOUT         0x000fffff
+
 struct gfar_mii {
 	u32	miimcfg;	/* 0x.520 - MII Management Config Register */
 	u32	miimcom;	/* 0x.524 - MII Management Command Register */
@@ -39,6 +153,80 @@
 	u32	miimind;	/* 0x.534 - MII Management Indicator Register */
 };
 
+struct gfar_mii_priv {
+	struct gfar_mii *regs;
+	uint flags;
+	uint phyid;
+	uint real_phyid;
+};
+
+/*
+ * struct phy_cmd:  A command for reading or writing a PHY register
+ *
+ * mii_reg:  The register to read or write
+ *
+ * mii_data:  For writes, the value to put in the register.
+ * 	A value of -1 indicates this is a read.
+ *
+ * funct: A function pointer which is invoked for each command.
+ * 	For reads, this function will be passed the value read
+ *	from the PHY, and process it.
+ *	For writes, the result of this function will be written
+ *	to the PHY register
+ */
+struct phy_cmd {
+    u32 mii_reg;
+    u32 mii_data;
+    u16 (*funct) (u16 mii_reg, struct net_device * dev);
+};
+
+/* struct phy_info: a structure which defines attributes for a PHY
+ *
+ * id will contain a number which represents the PHY.  During
+ * startup, the driver will poll the PHY to find out what its
+ * UID--as defined by registers 2 and 3--is.  The 32-bit result
+ * gotten from the PHY will be shifted right by "shift" bits to
+ * discard any bits which may change based on revision numbers
+ * unimportant to functionality
+ *
+ * The struct phy_cmd entries represent pointers to an arrays of
+ * commands which tell the driver what to do to the PHY.
+ */
+struct gianfar_phy_info {
+    u32 id;
+    char *name;
+    unsigned int shift;
+    /* Called to configure the PHY, and modify the controller
+     * based on the results */
+    const struct phy_cmd *config;
+
+    /* Called when starting up the controller.  Usually sets
+     * up the interrupt for state changes */
+    const struct phy_cmd *startup;
+
+    /* Called inside the interrupt handler to acknowledge
+     * the interrupt */
+    const struct phy_cmd *ack_int;
+
+    /* Called in the bottom half to handle the interrupt */
+    const struct phy_cmd *handle_int;
+
+    /* Called when bringing down the controller.  Usually stops
+     * the interrupts from being generated */
+    const struct phy_cmd *shutdown;
+
+    /* Called just after *config phy_cmd to fine tune PHY setting. In
+     * the *config phy_cmd ANEG is normally the default setting,
+     * while we can change to user specified mode in *finetune
+     * phy_cmd.
+     *
+     * This field could be left undefined. */
+    const struct phy_cmd *finetune;
+};
+
+struct gianfar_phy_info *get_phy_info(struct net_device *dev);
+void phy_run_commands(struct net_device *dev, const struct phy_cmd *cmd);
+
 int gfar_mdio_read(struct mii_bus *bus, int mii_id, int regnum);
 int gfar_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 value);
 int __init gfar_mdio_init(void);
Index: linux-2.6.16/drivers/net/Kconfig
===================================================================
--- linux-2.6.16.orig/drivers/net/Kconfig	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/drivers/net/Kconfig	2007-05-24 14:47:01.000000000 -0400
@@ -2221,6 +2221,13 @@
 	  This enables support for Port 2 of the Marvell MV643XX Gigabit
 	  Ethernet.
 
+config MV88E6095
+	bool 'OnBoard Marvell 88E6095 Switches Support'
+	depends on ALTERPATH_ONBOARD
+	help
+	  This option enables support for the Marvell switches as configured
+	  in the Cyclades Alterpath OnBoard.
+
 endmenu
 
 #
Index: linux-2.6.16/drivers/net/Makefile
===================================================================
--- linux-2.6.16.orig/drivers/net/Makefile	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/drivers/net/Makefile	2007-05-24 14:47:01.000000000 -0400
@@ -18,6 +18,7 @@
 		gianfar_mii.o \
 		gianfar_sysfs.o
 
+obj-$(CONFIG_MV88E6095) += marvell/ debmax_sw6095.o
 #
 # link order important here
 #
Index: linux-2.6.16/drivers/net/marvell/gtBrgFdb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtBrgFdb.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1733 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtBrgFdb.c
+ *
+ * DESCRIPTION:
+ *       API definitions for Multiple Forwarding Databases 
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtSem.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+
+/****************************************************************************/
+/* Forward function declaration.                                            */
+/****************************************************************************/
+static GT_STATUS atuOperationPerform
+(
+	IN      GT_QD_DEV           *dev,
+	IN      GT_ATU_OPERATION    atuOp,
+	INOUT	GT_EXTRA_OP_DATA	*opData,
+	INOUT 	GT_ATU_ENTRY    	*atuEntry
+	);
+
+/*******************************************************************************
+ * gfdbSetAtuSize
+ *
+ * DESCRIPTION:
+ *       Sets the Mac address table size.
+ *
+ * INPUTS:
+ *       size    - Mac address table size.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbSetAtuSize
+(
+	IN GT_QD_DEV    *dev,
+	IN ATU_SIZE     size
+	)
+{
+	GT_U16          data;
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gfdbSetAtuSize Called.\n"));
+
+	switch(size)
+	{
+	case ATU_SIZE_256:
+		if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
+			data = 0;
+		else
+			return GT_NOT_SUPPORTED;
+		break;
+    	case ATU_SIZE_512:
+    	case ATU_SIZE_1024:
+    	case ATU_SIZE_2048:
+		if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
+			data = (GT_U16)size;
+		else
+			data = (GT_U16)size - 1;
+		break;
+
+    	case ATU_SIZE_4096:
+		if ((IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))||(IS_IN_DEV_GROUP(dev,DEV_ATU_562_2048)))
+			return GT_NOT_SUPPORTED;
+		else
+			data = 3;
+		break;
+	default:
+		return GT_NOT_SUPPORTED;
+	}
+	
+	/* Gigabit Switch supports fixed 4096 mac addresses. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		if(size != ATU_SIZE_4096)
+			return GT_BAD_PARAM;
+		return GT_OK;
+	}
+	/* Set the Software reset bit.                  */
+	retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,2,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	/* Make sure the reset operation is completed.  */
+	data = 0;
+	while(data == 0)
+	{
+		retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,11,1,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbGetAgingTimeRange
+ *
+ * DESCRIPTION:
+ *       Gets the maximal and minimum age times that the hardware can support.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       maxTimeout - max aging time in secounds.
+ *       minTimeout - min aging time in secounds.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbGetAgingTimeRange
+(
+	IN GT_QD_DEV    *dev,
+	OUT GT_U32 *maxTimeout,
+	OUT GT_U32 *minTimeout
+	)
+{
+	DBG_INFO(("gfdbGetAgingTimeRange Called.\n"));
+	if((maxTimeout == NULL) || (minTimeout == NULL))
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		*minTimeout = 15;
+		*maxTimeout = 3825;
+	}
+	else
+	{
+		*minTimeout = 16;
+		*maxTimeout = 4080;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbSetAgingTimeout
+ *
+ * DESCRIPTION:
+ *       Sets the timeout period in seconds for aging out dynamically learned
+ *       forwarding information. The standard recommends 300 sec.
+ *
+ * INPUTS:
+ *       timeout - aging time in seconds.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbSetAgingTimeout
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_U32 timeout
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U16			timeBase;
+
+	DBG_INFO(("gfdbSetAgingTimeout Called.\n"));
+ 
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+		timeBase = 15;
+	else
+		timeBase = 16;
+
+	if((timeout < timeBase) && (timeout != 0))
+	{	
+		data = 1;
+	}
+	else
+	{
+		data = (GT_U16)(timeout/timeBase);
+		if (data & 0xFF00)
+			data = 0xFF;
+	}
+
+	/* Set the Time Out value.              */
+	retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,4,8,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbGetLearn2All
+ *
+ * DESCRIPTION:
+ *		When more than one Marvell device is used to form a single 'switch', it
+ *		may be desirable for all devices in the 'switch' to learn any address this 
+ *		device learns. When this bit is set to a one all other devices in the 
+ *		'switch' learn the same addresses this device learns. When this bit is 
+ *		cleared to a zero, only the devices that actually receive frames will learn
+ *		from those frames. This mode typically supports more active MAC addresses 
+ *		at one time as each device in the switch does not need to learn addresses 
+ *		it may nerver use.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbGetLearn2All
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetLearn2All Called.\n"));
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the Learn2All. */
+	retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gfdbSetLearn2All
+ *
+ * DESCRIPTION:
+ *		Enable or disable Learn2All mode.
+ *
+ * INPUTS:
+ *		mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbSetLearn2All
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gprtSetLearn2All Called.\n"));
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set Learn2All. */
+	retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gfdbGetAtuDynamicCount
+ *
+ * DESCRIPTION:
+ *       Gets the current number of dynamic unicast entries in this
+ *       Filtering Database.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       numDynEntries - number of dynamic entries.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *       GT_NO_SUCH - vlan does not exist.
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbGetAtuDynamicCount
+(
+	IN GT_QD_DEV    *dev,
+	OUT GT_U32 *numDynEntries
+	)
+{
+	GT_U32          dbNum, maxDbNum, numOfEntries;
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+
+	DBG_INFO(("gfdbGetAtuDynamicCount Called.\n"));
+
+	numOfEntries = 0;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL))
+		maxDbNum = 16;
+	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+		maxDbNum = 256;
+	else
+		maxDbNum = 1;
+		
+
+	for(dbNum=0; dbNum<maxDbNum; dbNum++)
+	{
+		entry.DBNum = (GT_U8)dbNum;
+
+		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+			gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+		else
+			gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+		while(1)
+		{
+			retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+			if(retVal != GT_OK)
+			{
+				DBG_INFO(("Failed.\n"));
+				return retVal;
+			}
+
+			if(IS_BROADCAST_MAC(entry.macAddr))
+				break;
+
+			if((IS_MULTICAST_MAC(entry.macAddr)) || (entry.entryState.ucEntryState == GT_UC_STATIC))
+			{
+				continue;
+			}
+
+			numOfEntries++;
+		}
+	}
+
+	*numDynEntries = numOfEntries;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbGetAtuEntryFirst
+ *
+ * DESCRIPTION:
+ *       Gets first lexicographic MAC address entry from the ATU.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       atuEntry - match Address translate unit entry.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *       GT_NO_SUCH - table is empty.
+ *
+ * COMMENTS:
+ *       Search starts from Mac[00:00:00:00:00:00]
+ *
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ *******************************************************************************/
+GT_STATUS gfdbGetAtuEntryFirst
+(
+	IN GT_QD_DEV    *dev,
+	OUT GT_ATU_ENTRY    *atuEntry
+	)
+{
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+
+	DBG_INFO(("gfdbGetAtuEntryFirst Called.\n"));
+
+	if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+		gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+	else
+		gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+	entry.DBNum = atuEntry->DBNum;
+
+	DBG_INFO(("DBNum : %i\n",entry.DBNum));
+
+	retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	if(IS_BROADCAST_MAC(entry.macAddr))
+	{
+		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+		{
+			DBG_INFO(("Failed (Invalid Mac).\n"));
+			return GT_NO_SUCH;
+		}
+		else if(entry.entryState.ucEntryState == 0)
+		{
+			DBG_INFO(("Failed (Invalid Mac).\n"));
+			return GT_NO_SUCH;
+		}
+	}
+
+	gtMemCpy(atuEntry->macAddr.arEther,entry.macAddr.arEther,6);
+	atuEntry->portVec   = entry.portVec;
+	atuEntry->prio      = entry.prio;
+	atuEntry->trunkMember = entry.trunkMember;
+
+	if(IS_MULTICAST_MAC(entry.macAddr))
+	{
+		if(dev->deviceId == GT_88E6051)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+
+		atuEntry->entryState.mcEntryState = entry.entryState.ucEntryState;
+	}
+	else
+	{
+		atuEntry->entryState.ucEntryState = entry.entryState.ucEntryState;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gfdbGetAtuEntryNext
+ *
+ * DESCRIPTION:
+ *       Gets next lexicographic MAC address from the specified Mac Addr.
+ *
+ * INPUTS:
+ *       atuEntry - the Mac Address to start the search.
+ *
+ * OUTPUTS:
+ *       atuEntry - match Address translate unit entry.
+ *
+ * RETURNS:
+ *       GT_OK      - on success.
+ *       GT_FAIL    - on error or entry does not exist.
+ *       GT_NO_SUCH - no more entries.
+ *
+ * COMMENTS:
+ *       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
+ *       user.
+ *
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ *******************************************************************************/
+GT_STATUS gfdbGetAtuEntryNext
+(
+	IN GT_QD_DEV    *dev,
+	INOUT GT_ATU_ENTRY  *atuEntry
+	)
+{
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+
+	DBG_INFO(("gfdbGetAtuEntryNext Called.\n"));
+	gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+
+	entry.DBNum = atuEntry->DBNum;
+	DBG_INFO(("DBNum : %i\n",entry.DBNum));
+
+	retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	if(IS_BROADCAST_MAC(entry.macAddr))
+	{
+		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+		{
+			DBG_INFO(("Failed (Invalid Mac).\n"));
+			return GT_NO_SUCH;
+		}
+		else if(entry.entryState.ucEntryState == 0)
+		{
+			DBG_INFO(("Failed (Invalid Mac).\n"));
+			return GT_NO_SUCH;
+		}
+	}
+
+	gtMemCpy(atuEntry->macAddr.arEther,entry.macAddr.arEther,6);
+	atuEntry->portVec   = entry.portVec;
+	atuEntry->prio      = entry.prio;
+	atuEntry->trunkMember = entry.trunkMember;
+
+	if(IS_MULTICAST_MAC(entry.macAddr))
+	{
+		if(dev->deviceId == GT_88E6051)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+
+		atuEntry->entryState.mcEntryState = entry.entryState.ucEntryState;
+	}
+	else
+	{
+		atuEntry->entryState.ucEntryState = entry.entryState.ucEntryState;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gfdbFindAtuMacEntry
+ *
+ * DESCRIPTION:
+ *       Find FDB entry for specific MAC address from the ATU.
+ *
+ * INPUTS:
+ *       atuEntry - the Mac address to search.
+ *
+ * OUTPUTS:
+ *       found    - GT_TRUE, if the appropriate entry exists.
+ *       atuEntry - the entry parameters.
+ *
+ * RETURNS:
+ *       GT_OK      - on success.
+ *       GT_FAIL    - on error or entry does not exist.
+ *       GT_NO_SUCH - no more entries.
+ *
+ * COMMENTS:
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ *******************************************************************************/
+GT_STATUS gfdbFindAtuMacEntry
+(
+	IN GT_QD_DEV    *dev,
+	INOUT GT_ATU_ENTRY  *atuEntry,
+	OUT GT_BOOL         *found
+	)
+{
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+	int           i;
+
+	DBG_INFO(("gfdbFindAtuMacEntry Called.\n"));
+	*found = GT_FALSE;
+	gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+	entry.DBNum = atuEntry->DBNum;
+
+	/* Decrement 1 from mac address.    */
+	for(i=5; i >= 0; i--)
+	{
+		if(entry.macAddr.arEther[i] != 0)
+		{
+			entry.macAddr.arEther[i] -= 1;
+			break;
+		}
+		else
+			entry.macAddr.arEther[i] = 0xFF;
+	}
+
+	/* Check if the given mac equals zero   */
+	if(i == -1)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_NO_SUCH;
+	}
+
+	retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	if(IS_BROADCAST_MAC(entry.macAddr))
+	{
+		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+		{
+			DBG_INFO(("Failed (Invalid Mac).\n"));
+			return GT_NO_SUCH;
+		}
+		else if(entry.entryState.ucEntryState == 0)
+		{
+			DBG_INFO(("Failed (Invalid Mac).\n"));
+			return GT_NO_SUCH;
+		}
+	}
+
+	if(gtMemCmp(atuEntry->macAddr.arEther,entry.macAddr.arEther,ETHERNET_HEADER_SIZE))
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_NO_SUCH;
+	}
+
+	atuEntry->portVec   = entry.portVec;
+	atuEntry->prio      = entry.prio;
+	atuEntry->trunkMember = entry.trunkMember;
+
+	if(IS_MULTICAST_MAC(entry.macAddr))
+	{
+		if(dev->deviceId == GT_88E6051)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+
+		atuEntry->entryState.mcEntryState = entry.entryState.ucEntryState;
+	}
+	else
+	{
+		atuEntry->entryState.ucEntryState = entry.entryState.ucEntryState;
+	}
+
+	*found = GT_TRUE;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gfdbFlush
+ *
+ * DESCRIPTION:
+ *       This routine flush all or unblocked addresses from the MAC Address
+ *       Table.
+ *
+ * INPUTS:
+ *       flushCmd - the flush operation type.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NO_RESOURCE  - failed to allocate a t2c struct
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbFlush
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_FLUSH_CMD flushCmd
+	)
+{
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+
+	DBG_INFO(("gfdbFlush Called.\n"));
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	entry.DBNum = 0;
+	entry.entryState.ucEntryState = 0;
+
+	if(flushCmd == GT_FLUSH_ALL)
+		retVal = atuOperationPerform(dev,FLUSH_ALL,NULL,&entry);
+	else
+		retVal = atuOperationPerform(dev,FLUSH_UNLOCKED,NULL,&entry);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbFlushInDB
+ *
+ * DESCRIPTION:
+ *       This routine flush all or unblocked addresses from the particular
+ *       ATU Database (DBNum). If multiple address databases are being used, this
+ *		API can be used to flush entries in a particular DBNum database.
+ *
+ * INPUTS:
+ *       flushCmd - the flush operation type.
+ *		DBNum	 - ATU MAC Address Database Number. 
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORTED- if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbFlushInDB
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_FLUSH_CMD flushCmd,
+	IN GT_U8 DBNum
+	)
+{
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+
+	DBG_INFO(("gfdbFlush Called.\n"));
+	DBG_INFO(("gfdbFush: dev=%x, dev->atuRegsSem=%d \n",dev, dev->atuRegsSem));
+
+	/* check if device supports this feature */
+	if ((!IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL)) && (!IS_IN_DEV_GROUP(dev,DEV_DBNUM_256)))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	entry.DBNum = DBNum;
+	entry.entryState.ucEntryState = 0;
+
+	if(flushCmd == GT_FLUSH_ALL)
+		retVal = atuOperationPerform(dev,FLUSH_ALL_IN_DB,NULL,&entry);
+	else
+		retVal = atuOperationPerform(dev,FLUSH_UNLOCKED_IN_DB,NULL,&entry);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbMove
+ *
+ * DESCRIPTION:
+ *       This routine moves all or unblocked addresses from a port to another.
+ *
+ * INPUTS:
+ * 		moveCmd  - the move operation type.
+ *		moveFrom - port where moving from
+ *		moveTo   - port where moving to
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbMove
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_MOVE_CMD  moveCmd,
+	IN GT_LPORT		moveFrom,
+	IN GT_LPORT		moveTo
+	)
+{
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+	GT_EXTRA_OP_DATA	opData;
+
+	DBG_INFO(("gfdbMove Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	entry.DBNum = 0;
+	entry.entryState.ucEntryState = 0xF;
+	opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
+	opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
+
+	if(moveCmd == GT_MOVE_ALL)
+		retVal = atuOperationPerform(dev,FLUSH_ALL,&opData,&entry);
+	else
+		retVal = atuOperationPerform(dev,FLUSH_UNLOCKED,&opData,&entry);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbMoveInDB
+ *
+ * DESCRIPTION:
+ *       This routine move all or unblocked addresses which are in the particular
+ *       ATU Database (DBNum) from a port to another.
+ *
+ * INPUTS:
+ *       moveCmd  - the move operation type.
+ *		DBNum	 - ATU MAC Address Database Number.
+ *		moveFrom - port where moving from
+ *		moveTo   - port where moving to
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORTED- if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbMoveInDB
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_MOVE_CMD 	moveCmd,
+	IN GT_U8 		DBNum,
+	IN GT_LPORT		moveFrom,
+	IN GT_LPORT		moveTo
+	)
+{
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+	GT_EXTRA_OP_DATA	opData;
+
+	DBG_INFO(("gfdbMoveInDB Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	entry.DBNum = DBNum;
+	entry.entryState.ucEntryState = 0xF;
+	opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
+	opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
+
+	if(moveCmd == GT_MOVE_ALL)
+		retVal = atuOperationPerform(dev,FLUSH_ALL_IN_DB,&opData,&entry);
+	else
+		retVal = atuOperationPerform(dev,FLUSH_UNLOCKED_IN_DB,&opData,&entry);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbRemovePort
+ *
+ * DESCRIPTION:
+ *       This routine deassociages all or unblocked addresses from a port.
+ *
+ * INPUTS:
+ *       moveCmd - the move operation type.
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbRemovePort
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_MOVE_CMD 	moveCmd,
+	IN GT_LPORT		port
+	)
+{
+	DBG_INFO(("gfdbRemovePort Called.\n"));
+
+	/* Only 88E6093 Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	return gfdbMove(dev,moveCmd,port,(GT_LPORT)0xF);
+}
+
+
+/*******************************************************************************
+ * gfdbRemovePortInDB
+ *
+ * DESCRIPTION:
+ *       This routine deassociages all or unblocked addresses from a port in the
+ *       particular ATU Database (DBNum).
+ *
+ * INPUTS:
+ *       moveCmd  - the move operation type.
+ *       port - the logical port number.
+ *		DBNum	 - ATU MAC Address Database Number.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORTED- if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbRemovePortInDB
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_MOVE_CMD 	moveCmd,
+	IN GT_LPORT		port,
+	IN GT_U8 		DBNum
+	)
+{
+	DBG_INFO(("gfdbRemovePortInDB Called.\n"));
+
+	/* Only 88E6093 Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+	return gfdbMoveInDB(dev,moveCmd,DBNum,port,(GT_LPORT)0xF);
+}
+
+
+/*******************************************************************************
+ * gfdbAddMacEntry
+ *
+ * DESCRIPTION:
+ *       Creates the new entry in MAC address table.
+ *
+ * INPUTS:
+ *       macEntry    - mac address entry to insert to the ATU.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK             - on success
+ *       GT_FAIL           - on error
+ *       GT_NO_RESOURCE    - failed to allocate a t2c struct
+ *       GT_OUT_OF_CPU_MEM - oaMalloc failed
+ *
+ * COMMENTS:
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbAddMacEntry
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_ATU_ENTRY *macEntry
+	)
+{
+	GT_STATUS       retVal;
+	GT_ATU_ENTRY    entry;
+
+	DBG_INFO(("gfdbAddMacEntry Called.\n"));
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	gtMemCpy(entry.macAddr.arEther,macEntry->macAddr.arEther,6);
+	entry.DBNum		= macEntry->DBNum;
+	entry.prio	    = macEntry->prio;
+	entry.portVec     = macEntry->portVec;
+	if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		entry.trunkMember = macEntry->trunkMember;
+	}
+	else
+	{
+		entry.trunkMember = GT_FALSE;
+	}
+
+	if(IS_MULTICAST_MAC(entry.macAddr))
+	{
+		entry.entryState.ucEntryState = macEntry->entryState.mcEntryState;
+	}
+	else
+		entry.entryState.ucEntryState = macEntry->entryState.ucEntryState;
+
+	if (entry.entryState.ucEntryState == 0)
+	{
+		DBG_INFO(("Entry State should not be ZERO.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gfdbDelMacEntry
+ *
+ * DESCRIPTION:
+ *       Deletes MAC address entry.
+ *
+ * INPUTS:
+ *       macAddress - mac address.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NO_RESOURCE  - failed to allocate a t2c struct
+ *       GT_NO_SUCH      - if specified address entry does not exist
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbDelMacEntry
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_ETHERADDR  *macAddress
+	)
+{
+	GT_STATUS retVal;
+	GT_ATU_ENTRY    entry;
+
+	DBG_INFO(("gfdbDelMacEntry Called.\n"));
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	gtMemCpy(entry.macAddr.arEther,macAddress->arEther,6);
+	entry.DBNum = 0;
+	entry.prio = 0;
+	entry.portVec = 0;
+	entry.entryState.ucEntryState = 0;
+	entry.trunkMember = GT_FALSE;
+
+	retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbDelAtuEntry
+ *
+ * DESCRIPTION:
+ *       Deletes ATU entry.
+ *
+ * INPUTS:
+ *       atuEntry - the ATU entry to be deleted.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NO_RESOURCE  - failed to allocate a t2c struct
+ *       GT_NO_SUCH      - if specified address entry does not exist
+ *
+ * COMMENTS:
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ *******************************************************************************/
+GT_STATUS gfdbDelAtuEntry
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_ATU_ENTRY  *atuEntry
+	)
+{
+	GT_ATU_ENTRY    entry;
+	GT_STATUS retVal;
+
+	DBG_INFO(("gfdbDelMacEntry Called.\n"));
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+	entry.DBNum = atuEntry->DBNum;
+	entry.prio = 0;
+	entry.portVec = 0;
+	entry.entryState.ucEntryState = 0;
+	entry.trunkMember = GT_FALSE;
+
+	retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gfdbLearnEnable
+ *
+ * DESCRIPTION:
+ *       Enable/disable automatic learning of new source MAC addresses on port
+ *       ingress.
+ *
+ * INPUTS:
+ *       en - GT_TRUE for enable  or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gfdbLearnEnable
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_BOOL  en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_LPORT	port;
+	GT_BOOL		mode;
+
+	DBG_INFO(("gfdbLearnEnable Called.\n"));
+	BOOL_2_BIT(en,data);
+	data = 1 - data;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		mode = (en)?GT_FALSE:GT_TRUE;
+
+		for (port=GT_LPORT_2_PORT(0); port<GT_LPORT_2_PORT(dev->numOfPorts); port++)
+		{
+			retVal = gprtSetLearnDisable(dev,port,mode);
+			if(retVal != GT_OK)
+			{
+				DBG_INFO(("Failed.\n"));
+				return retVal;
+			}
+		}
+	}
+	else
+	{
+		/* Set the Learn Enable bit.            */
+		retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,14,1,data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	}	
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+ * gatuGetViolation
+ *
+ * DESCRIPTION:
+ *       Get ATU Violation data
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       atuIntStatus - interrupt cause, source portID, and vid.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORT  - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This is an internal function. No user should call this function.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gatuGetViolation
+(
+	IN  GT_QD_DEV         *dev,
+	OUT GT_ATU_INT_STATUS *atuIntStatus
+	)
+{
+	GT_U16              intCause;
+	GT_STATUS       	retVal;
+	GT_ATU_ENTRY    	entry;
+	GT_EXTRA_OP_DATA	opData;
+
+	DBG_INFO(("gatuGetViolation Called.\n"));
+
+	/* check which Violation occurred */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,3,1,&intCause);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("ERROR to read ATU OPERATION Register.\n"));
+		return retVal;
+	}
+
+	if (!intCause)
+	{
+		/* No Violation occurred. */
+		atuIntStatus->atuIntCause = 0;
+		return GT_OK;
+	}
+
+	retVal = atuOperationPerform(dev,SERVICE_VIOLATIONS,&opData,&entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	atuIntStatus->atuIntCause = opData.intCause;
+	atuIntStatus->spid = entry.entryState.ucEntryState;
+	gtMemCpy(atuIntStatus->macAddr.arEther,entry.macAddr.arEther,6);
+	
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * atuOperationPerform
+ *
+ * DESCRIPTION:
+ *       This function is used by all ATU control functions, and is responsible
+ *       to write the required operation into the ATU registers.
+ *
+ * INPUTS:
+ *       atuOp       - The ATU operation bits to be written into the ATU
+ *                     operation register.
+ *       DBNum       - ATU Database Number for CPU accesses
+ *       entryPri    - The EntryPri field in the ATU Data register.
+ *       portVec     - The portVec field in the ATU Data register.
+ *       entryState  - The EntryState field in the ATU Data register.
+ *       atuMac      - The Mac address to be written to the ATU Mac registers.
+ *
+ * OUTPUTS:
+ *       entryPri    - The EntryPri field in case the atuOp is GetNext.
+ *       portVec     - The portVec field in case the atuOp is GetNext.
+ *       entryState  - The EntryState field in case the atuOp is GetNext.
+ *       atuMac      - The returned Mac address in case the atuOp is GetNext.
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  if atuMac == NULL, nothing needs to be written to ATU Mac registers.
+ *
+ *******************************************************************************/
+static GT_STATUS atuOperationPerform
+(
+	IN      GT_QD_DEV           *dev,
+	IN      GT_ATU_OPERATION    atuOp,
+	INOUT	GT_EXTRA_OP_DATA	*opData,
+	INOUT 	GT_ATU_ENTRY    	*entry
+	)
+/*
+  IN      GT_U8               DBNum,
+  INOUT   GT_U8               *entryPri,
+  INOUT   GT_U32              *portVec,
+  INOUT   GT_U8               *entryState,
+  INOUT   GT_ETHERADDR        *atuMac
+*/
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U16          opcodeData;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           i;
+	GT_U16			portMask;
+
+	gtSemTake(dev,dev->atuRegsSem,OS_WAIT_FOREVER);
+
+	portMask = (1 << dev->numOfPorts) - 1;
+
+	/* Wait until the ATU in ready. */
+	data = 1;
+	while(data == 1)
+	{
+		retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+	}
+
+	opcodeData = 0;
+
+	switch (atuOp)
+	{
+	case LOAD_PURGE_ENTRY:
+		if(!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+		{
+		        data = ( (((entry->prio) & 0x3) << 14) | (((entry->portVec) & portMask) << 4) |
+        		         (((entry->entryState.ucEntryState) & 0xF)) );
+		}
+		else
+		{
+			if (IS_IN_DEV_GROUP(dev,DEV_TRUNK) && entry->trunkMember)
+			{
+				/* portVec represents trunk ID */
+				data = ( 0x8000 | (((entry->portVec) & 0xF) << 4) |
+        			         (((entry->entryState.ucEntryState) & 0xF)) );
+			}
+			else
+			{
+				data = ( (((entry->portVec) & portMask) << 4) |
+        			         (((entry->entryState.ucEntryState) & 0xF)) );
+			}
+			opcodeData = (entry->prio & 0x7) << 8;
+		}
+		retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+		/* pass thru */
+
+	case GET_NEXT_ENTRY:
+		for(i = 0; i < 3; i++)
+		{
+			data=(entry->macAddr.arEther[2*i] << 8)|(entry->macAddr.arEther[1 + 2*i]);
+			retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),data);
+			if(retVal != GT_OK)
+			{
+		                gtSemGive(dev,dev->atuRegsSem);
+        		        return retVal;
+			}
+		}
+		break;
+
+	case FLUSH_ALL:
+	case FLUSH_UNLOCKED:
+	case FLUSH_ALL_IN_DB:
+	case FLUSH_UNLOCKED_IN_DB:
+		if (entry->entryState.ucEntryState == 0xF)
+		{
+			data = 0xF | ((opData->moveFrom & 0xF) << 4) | ((opData->moveTo & 0xF) << 8);
+		}
+		else
+		{
+			data = 0;
+		}
+		retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
+		if(retVal != GT_OK)
+		{
+       		    	gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+		break;
+
+	case SERVICE_VIOLATIONS:
+
+		break;
+
+	default :
+		return GT_FAIL;
+	}
+
+	/* Set the ATU Operation register   */
+	if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+	{
+		retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,4,(entry->DBNum & 0xF0) >> 4);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+	}
+
+	opcodeData |= ((1 << 15) | (atuOp << 12) | (entry->DBNum & 0xF));
+	retVal = hwWriteGlobalReg(dev,QD_REG_ATU_OPERATION,opcodeData);
+	if(retVal != GT_OK)
+	{
+		gtSemGive(dev,dev->atuRegsSem);
+		return retVal;
+	}
+
+	/* If the operation is to service violation operation wait for the response   */
+	if(atuOp == SERVICE_VIOLATIONS)
+	{
+		/* Wait until the VTU in ready. */
+		data = 1;
+		while(data == 1)
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->atuRegsSem);
+				return retVal;
+			}
+		}
+
+		/* get the Interrupt Cause */
+		retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,4,3,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+	
+		switch (data)
+		{
+		case 4:	/* Member Violation */
+			opData->intCause = GT_MEMBER_VIOLATION;
+			break;
+		case 2:	/* Miss Violation */
+			opData->intCause = GT_MISS_VIOLATION;
+			break;
+		case 1:	/* Full Violation */
+			opData->intCause = GT_FULL_VIOLATION;
+			break;
+		default:
+			opData->intCause = 0;
+			gtSemGive(dev,dev->atuRegsSem);
+			return GT_OK;
+		}
+
+		/* get the DBNum that was involved in the violation */
+		retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,0,4,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+
+		entry->DBNum = (GT_U8)(data & 0xF);
+
+		/* get the Source Port ID that was involved in the violation */
+
+		retVal = hwReadGlobalReg(dev,QD_REG_ATU_DATA_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+
+		entry->entryState.ucEntryState = data & 0xF;
+
+		/* Get the Mac address  */
+		for(i = 0; i < 3; i++)
+		{
+			retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->atuRegsSem);
+				return retVal;
+			}
+			entry->macAddr.arEther[2*i] = data >> 8;
+			entry->macAddr.arEther[1 + 2*i] = data & 0xFF;
+		}
+
+
+	} /* end of service violations */
+	/* If the operation is a gen next operation wait for the response   */
+	if(atuOp == GET_NEXT_ENTRY)
+	{
+		/* Wait until the ATU in ready. */
+		data = 1;
+		while(data == 1)
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->atuRegsSem);
+				return retVal;
+			}
+		}
+
+		/* Get the Mac address  */
+		for(i = 0; i < 3; i++)
+		{
+			retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->atuRegsSem);
+				return retVal;
+			}
+			entry->macAddr.arEther[2*i] = data >> 8;
+			entry->macAddr.arEther[1 + 2*i] = data & 0xFF;
+		}
+
+		retVal = hwReadGlobalReg(dev,QD_REG_ATU_DATA_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+
+		/* Get the Atu data register fields */
+		if(!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+		{
+			entry->prio = data >> 14;
+			entry->portVec = (data >> 4) & portMask;
+			entry->entryState.ucEntryState = data & 0xF;
+		}
+		else
+		{
+			if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+			{
+				entry->trunkMember = (data & 0x8000)?GT_TRUE:GT_FALSE;
+			}
+			else
+			{
+				entry->trunkMember = GT_FALSE;
+			}
+
+			entry->portVec = (data >> 4) & portMask;
+			entry->entryState.ucEntryState = data & 0xF;
+			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,8,3,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->atuRegsSem);
+				return retVal;
+			}
+			entry->prio = data;
+		}
+	}
+
+	gtSemGive(dev,dev->atuRegsSem);
+	return GT_OK;
+}
Index: linux-2.6.16/drivers/net/marvell/gtBrgStp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtBrgStp.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,308 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtBrgStp.c
+ *
+ * DESCRIPTION:
+ *       API definitions to handle port spanning tree state.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+static GT_STATUS enhancedBPDUSet(GT_QD_DEV *dev,GT_BOOL en)
+{
+	GT_STATUS       retVal = GT_OK; /* Functions return value.      */
+	GT_U16			enBits;
+
+	/* If disable, reset the BPDU bit(bit0) from Rsvd2CpuEnables register */
+   	if(en == GT_FALSE)
+	{
+		if((retVal = gsysGetRsvd2CpuEnables(dev,&enBits)) != GT_OK)
+		{
+			DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+			return retVal;
+		}
+		enBits &= ~0x1;
+
+		if((retVal = gsysSetRsvd2CpuEnables(dev,enBits)) != GT_OK)
+		{
+			DBG_INFO(("gsysSetRsvd2CpuEnables failed.\n"));
+			return retVal;
+		}
+
+		return retVal;
+	}
+
+	/* 
+	   If enable, 
+	   1) Set MGMT Pri bits, 
+	   2) Set BPDU bit(bit0) from Rsvd2CpuEnables register,
+	   3) Enable Rsvd2Cpu
+	*/
+	if((retVal = gsysSetMGMTPri(dev,7)) != GT_OK)
+	{
+		DBG_INFO(("gsysSetMGMTPri failed.\n"));
+		return retVal;
+	}
+
+	if((retVal = gsysGetRsvd2CpuEnables(dev,&enBits)) != GT_OK)
+	{
+		DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+		return retVal;
+	}
+	if((retVal = gsysSetRsvd2CpuEnables(dev,enBits|0x1)) != GT_OK)
+	{
+		DBG_INFO(("gsysSetRsvd2CpuEnables failed.\n"));
+		return retVal;
+	}
+
+	if((retVal = gsysSetRsvd2Cpu(dev,GT_TRUE)) != GT_OK)
+	{
+		DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+		return retVal;
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gstpSetMode
+ *
+ * DESCRIPTION:
+ *       This routine Enable the Spanning tree.
+ *
+ * INPUTS:
+ *       en - GT_TRUE for enable, GT_FALSE for disable.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       when enabled, this function sets all port to blocking state, and inserts
+ *       the BPDU MAC into the ATU to be captured to CPU, on disable all port are
+ *       being modified to be in forwarding state.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstpSetMode
+(
+	IN GT_QD_DEV *dev,
+	IN GT_BOOL  en
+	)
+{
+	GT_STATUS       retVal = GT_OK; /* Functions return value.      */
+	GT_ATU_ENTRY        atuEntry;   /* The ATU entry data to be set */
+	GT_U32          i, dbNum;
+
+	DBG_INFO(("gstpSetMode Called.\n"));
+	if(dev->deviceId == GT_88E6051)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	if((en == GT_TRUE) && (dev->stpMode == 1))
+	{
+		DBG_INFO(("OK.\n"));
+		return GT_OK;
+	}
+
+	switch(dev->deviceId)
+	{
+	case GT_88E6051:
+	case GT_88E6052:
+		dbNum = 1;
+		break;
+	case GT_FF_HG:
+	case GT_FF_EG:
+	case GT_88E6021:
+	case GT_88E6060:
+	case GT_88E6063:
+	case GT_FH_VPN:
+	case GT_88E6083:
+	case GT_88E6153:
+	case GT_88E6181:
+	case GT_88E6183:
+	case GT_88E6093:
+		dbNum = 16;
+		break;
+	case GT_88E6092:
+	case GT_88E6095:
+	case GT_88E6152:
+	case GT_88E6155:
+	case GT_88E6182:
+	case GT_88E6185:
+		/* 
+		   No need to add BPDU entry to the fdb table.
+		   Set or reset bit 0 of Rsvd2Cpu register.
+		*/
+		dbNum = 0;
+		retVal = enhancedBPDUSet(dev,en);
+		break;
+	default:
+		dbNum = 16;
+		break;
+	}
+
+	for (i=0; i<dbNum; i++)
+	{
+		/* Set the Atu entry parameters.    */
+		atuEntry.macAddr.arEther[0] = 0x01;
+		atuEntry.macAddr.arEther[1] = 0x80;
+		atuEntry.macAddr.arEther[2] = 0xC2;
+		atuEntry.macAddr.arEther[3] = 0x00;
+		atuEntry.macAddr.arEther[4] = 0x00;
+		atuEntry.macAddr.arEther[5] = 0x00;
+		atuEntry.portVec = ( 1 << dev->cpuPortNum);
+		atuEntry.prio    = 3;
+		atuEntry.DBNum = (GT_U8)i;
+		atuEntry.entryState.mcEntryState = GT_MC_PRIO_MGM_STATIC;
+
+		if(en == GT_TRUE)
+		{
+			retVal = gfdbAddMacEntry(dev,&atuEntry);
+		}
+		else
+		{
+			if(dev->stpMode == 0)
+				break;
+			retVal = gfdbDelAtuEntry(dev,&atuEntry);
+		}
+
+		if (retVal != GT_OK)
+			break;
+	}
+
+	if(retVal == GT_OK)
+	{
+		if(en == GT_TRUE)
+			dev->stpMode = 1;
+		else
+			dev->stpMode = 2;
+		DBG_INFO(("OK.\n"));
+	}
+	else
+	{
+		dev->stpMode = 0;
+		DBG_INFO(("Failed.\n"));
+	}
+
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gstpSetPortState
+ *
+ * DESCRIPTION:
+ *       This routine set the port state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *       state - the port state to set.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstpSetPortState
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT           port,
+	IN GT_PORT_STP_STATE  state
+	)
+{
+	GT_U8           phyPort;        /* Physical port                */
+	GT_U16          data;           /* Data to write to register.   */
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gstpSetPortState Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+	data    = state;
+
+	/* Set the port state bits.             */
+	retVal= hwSetPortRegField(dev,phyPort, QD_REG_PORT_CONTROL,0,2,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gstpGetPortState
+ *
+ * DESCRIPTION:
+ *       This routine returns the port state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - the current port state.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstpGetPortState
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT           port,
+	OUT GT_PORT_STP_STATE  *state
+	)
+{
+	GT_U8           phyPort;        /* Physical port                */
+	GT_U16          data;           /* Data read from register.     */
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gstpGetPortState Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* Get the port state bits.             */
+	retVal = hwGetPortRegField(dev,phyPort, QD_REG_PORT_CONTROL,0,2,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*state = data & 0x3;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
Index: linux-2.6.16/drivers/net/marvell/gtBrgVlan.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtBrgVlan.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1011 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtBrgVlan.c
+ *
+ * DESCRIPTION:
+ *       API definitions to handle port-based vlan configuration.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+ * gprtSetEgressMode
+ *
+ * DESCRIPTION:
+ *       This routine set the egress mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the egress mode.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetEgressMode
+(
+	IN GT_QD_DEV       *dev,
+	IN GT_LPORT        port,
+	IN GT_EGRESS_MODE  mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gprtSetEgressMode Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_TAGGING)) != GT_OK ) 
+		return retVal;
+	
+	switch (mode)
+	{
+        case (GT_UNMODIFY_EGRESS):
+		data = 0;
+		break;
+
+        case (GT_TAGGED_EGRESS):
+		data = 2;
+		break;
+
+        case (GT_UNTAGGED_EGRESS):
+		data = 1;
+		break;
+
+        case (GT_ADD_TAG):
+		if(!IS_IN_DEV_GROUP(dev,DEV_EGRESS_DOUBLE_TAGGING))
+		{
+		        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+			return GT_NOT_SUPPORTED;
+		}
+		data = 3;
+		break;
+        default:
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,12,2,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetEgressMode
+ *
+ * DESCRIPTION:
+ *       This routine get the egress mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - the egress mode.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetEgressMode
+(
+	IN GT_QD_DEV       *dev,
+	IN  GT_LPORT        port,
+	OUT GT_EGRESS_MODE  *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	if(mode == NULL)
+		return GT_BAD_PARAM;
+
+	DBG_INFO(("gprtGetEgressMode Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,12,2,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	switch (data)
+	{
+        case (0):
+		*mode = GT_UNMODIFY_EGRESS;
+		break;
+
+        case (2):
+		*mode = GT_TAGGED_EGRESS;
+		break;
+
+        case (1):
+		*mode = GT_UNTAGGED_EGRESS;
+		break;
+
+        case (3):
+		*mode = GT_ADD_TAG;
+		break;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gprtSetVlanTunnel
+ *
+ * DESCRIPTION:
+ *       This routine sets the vlan tunnel mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the vlan tunnel mode.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetVlanTunnel
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gprtSetVlanTunnel Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+	BOOL_2_BIT(mode,data);
+
+	retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,7,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetVlanTunnel
+ *
+ * DESCRIPTION:
+ *       This routine get the vlan tunnel mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - the vlan tunnel mode..
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetVlanTunnel
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_BOOL  *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gprtGetVlanTunnel Called.\n"));
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,7,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gvlnSetPortVlanPorts
+ *
+ * DESCRIPTION:
+ *       This routine sets the port VLAN group port membership list.
+ *
+ * INPUTS:
+ *       port        - logical port number to set.
+ *       memPorts    - array of logical ports in the same vlan.
+ *       memPortsLen - number of members in memPorts array
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnSetPortVlanPorts
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_LPORT  memPorts[],
+	IN GT_U8     memPortsLen
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U8           i;
+
+	DBG_INFO(("gvlnSetPortVlanPorts Called.\n"));
+	if(memPorts == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+	data = 0;
+
+	if(memPortsLen > dev->numOfPorts)
+	{
+		DBG_INFO(("Failed (PortsLen Too Big).\n"));
+		return GT_BAD_PARAM;
+	}
+
+	for(i = 0; i < memPortsLen; i++)
+		data |= (1 << GT_LPORT_2_PORT(memPorts[i]));
+
+	/* numOfPorts = 3 for fullsail, = 10 for octane, = 7 for others */
+	retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,0,dev->numOfPorts,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gvlnGetPortVlanPorts
+ *
+ * DESCRIPTION:
+ *       This routine gets the port VLAN group port membership list.
+ *
+ * INPUTS:
+ *       port        - logical port number to set.
+ *
+ * OUTPUTS:
+ *       memPorts    - array of logical ports in the same vlan.
+ *       memPortsLen - number of members in memPorts array
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnGetPortVlanPorts
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_LPORT memPorts[],
+	OUT GT_U8    *memPortsLen
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U8           i;
+
+	DBG_INFO(("gvlnGetPortVlanPorts Called.\n"));
+	if((memPorts == NULL) || (memPortsLen == NULL))
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* memPortsLen = 3 for fullsail, =7 for others */
+	retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,0,dev->numOfPorts,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	i = 0;
+	for(phyPort = 0; phyPort < dev->numOfPorts; phyPort++)
+	{
+		if(((1 << phyPort) & data) != 0)
+		{
+			memPorts[i] = GT_PORT_2_LPORT(phyPort);
+			i++;
+		}
+	}
+	*memPortsLen = i;
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gvlnSetPortUserPriLsb
+ *
+ * DESCRIPTION:
+ *       This routine Set the user priority (VPT) LSB bit, to be added to the
+ *       user priority on the egress.
+ *
+ * INPUTS:
+ *       port       - logical port number to set.
+ *       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnSetPortUserPriLsb
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   userPriLsb
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gvlnSetPortUserPriLsb Called.\n"));
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+	BOOL_2_BIT(userPriLsb,data);
+
+	retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,13,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gvlnGetPortUserPriLsb
+ *
+ * DESCRIPTION:
+ *       This routine gets the user priority (VPT) LSB bit.
+ *
+ * INPUTS:
+ *       port       - logical port number to set.
+ *
+ * OUTPUTS:
+ *       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnGetPortUserPriLsb
+(
+	IN GT_QD_DEV    *dev,
+	IN  GT_LPORT    port,
+	OUT GT_BOOL     *userPriLsb
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gvlnGetPortUserPriLsb Called.\n"));
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(userPriLsb == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,13,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*userPriLsb);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gvlnSetPortVid
+ *
+ * DESCRIPTION:
+ *       This routine Set the port default vlan id.
+ *
+ * INPUTS:
+ *       port - logical port number to set.
+ *       vid  - the port vlan id.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnSetPortVid
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_LPORT     port,
+	IN GT_U16       vid
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gvlnSetPortVid Called.\n"));
+	phyPort = GT_LPORT_2_PORT(port);
+
+	retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,0,12, vid);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gvlnGetPortVid
+ *
+ * DESCRIPTION:
+ *       This routine Get the port default vlan id.
+ *
+ * INPUTS:
+ *       port - logical port number to set.
+ *
+ * OUTPUTS:
+ *       vid  - the port vlan id.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnGetPortVid
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_U16   *vid
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gvlnGetPortVid Called.\n"));
+	if(vid == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,0,12, &data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*vid = data;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/* the following api's are added for fullsail and clippership */
+
+/*******************************************************************************
+ * gvlnSetPortVlanDBNum
+ *
+ * DESCRIPTION:
+ *       This routine sets the port's default VLAN database number (DBNum).
+ *
+ * INPUTS:
+ *       port	- logical port number to set.
+ *       DBNum 	- database number for this port 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:IN GT_INGRESS_MODE mode
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnSetPortVlanDBNum
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_U8     DBNum
+	)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gvlnSetPortVlanDBNum Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4,(GT_U16)((DBNum & 0xF0) >> 4));
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+	}
+	else
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+	}
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gvlnGetPortVlanDBNum
+ *
+ * DESCRIPTION:
+ *       This routine gets the port's default VLAN database number (DBNum).
+ *
+ * INPUTS:
+ *       port 	- logical port number to get.
+ *
+ * OUTPUTS:
+ *       DBNum 	- database number for this port 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnGetPortVlanDBNum
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_U8    *DBNum
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data,dataH;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gvlnGetPortVlanDBNum Called.\n"));
+
+	if(DBNum == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4, &dataH);
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+	}
+	else
+	{
+		dataH = 0;
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*DBNum = (GT_U8)(data | (dataH << 4));
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/********************************************************************
+ * gvlnSetPortVlanDot1qMode
+ *
+ * DESCRIPTION:
+ *       This routine sets the IEEE 802.1q mode for this port (11:10) 
+ *
+ * INPUTS:
+ *       port	- logical port number to set.
+ *       mode 	- 802.1q mode for this port 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:IN GT_INGRESS_MODE mode
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnSetPortVlanDot1qMode
+(
+	IN GT_QD_DEV        *dev,
+	IN GT_LPORT 	port,
+	IN GT_DOT1Q_MODE	mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gvlnSetPortVlanDot1qMode Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
+		return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2,(GT_U16)mode );
+	}
+	else
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2,(GT_U16)mode );
+	}
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gvlnGetPortVlanDot1qMode
+ *
+ * DESCRIPTION:
+ *       This routine gets the IEEE 802.1q mode for this (bit 11:10).
+ *
+ * INPUTS:
+ *       port 	- logical port number to get.
+ *
+ * OUTPUTS:
+ *       mode 	- 802.1q mode for this port 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnGetPortVlanDot1qMode
+(
+	IN GT_QD_DEV        *dev,
+	IN  GT_LPORT        port,
+	OUT GT_DOT1Q_MODE   *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gvlnGetPortVlanDot1qMode Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
+		return retVal;
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2, &data);
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2, &data);
+	}
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*mode = data;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/********************************************************************
+ * gvlnSetPortVlanForceDefaultVID
+ *
+ * DESCRIPTION:
+ *       This routine sets the mode for forcing to use default VID
+ *
+ * INPUTS:
+ *       port    - logical port number to set.
+ *       mode    - GT_TRUE, force to use default VID
+ *                 GT_FAULSE, otherwise 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnSetPortVlanForceDefaultVID
+(
+	IN GT_QD_DEV        *dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U16          data;           /* Data to be set into the      */
+
+	DBG_INFO(("gvlnSetPortForceDefaultVID Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
+		return retVal;
+
+	BOOL_2_BIT(mode,data);
+
+	retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,12,1,data );
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gvlnGetPortVlanForceDefaultVID
+ *
+ * DESCRIPTION:
+ *       This routine gets the port mode for ForceDefaultVID (bit 12).
+ *
+ * INPUTS:
+ *       port 	- logical port number to get.
+ *
+ * OUTPUTS:
+ *       mode 	- ForceDefaultVID mode for this port 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvlnGetPortVlanForceDefaultVID
+(
+	IN GT_QD_DEV        *dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL    	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+
+	DBG_INFO(("gvlnGetPortVlanDot1qMode Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
+		return retVal;
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,12,1, &data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
Index: linux-2.6.16/drivers/net/marvell/gtBrgVtu.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtBrgVtu.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1149 @@
+#include <linux/marvell/Copyright.h>
+
+/*******************************************************************************
+ * gtBrgVtu.c
+ *
+ * DESCRIPTION:
+ *       API definitions for Vlan Translation Unit for 802.1Q.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtSem.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* Forward function declaration.                                            */
+/****************************************************************************/
+#define MEMBER_TAG_CONV_FOR_APP(_dev,_tag)	memberTagConversionForApp(_dev,_tag)
+#define MEMBER_TAG_CONV_FOR_DEV(_dev,_tag)	memberTagConversionForDev(_dev,_tag)
+
+static GT_U8 memberTagConversionForApp
+(
+	IN	GT_QD_DEV           *dev,
+	IN	GT_U8               tag
+	)
+{
+	GT_U8 convTag;
+
+	/* check if memberTag needs to be converted */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+		return tag;
+
+	switch(tag)
+	{
+	case 0:
+		convTag = MEMBER_EGRESS_UNMODIFIED;
+		break;
+	case 1:
+		convTag = MEMBER_EGRESS_UNTAGGED;
+		break;
+	case 2:
+		convTag = MEMBER_EGRESS_TAGGED;
+		break;
+	case 3:
+		convTag = NOT_A_MEMBER;
+		break;
+	default:
+		DBG_INFO(("Unknown Tag (%#x) from Device !!!.\n",tag));
+		convTag = 0xFF;
+		break;
+			
+	}
+
+	return convTag;
+}
+
+static GT_U8 memberTagConversionForDev
+(
+	IN	GT_QD_DEV           *dev,
+	IN	GT_U8               tag
+	)
+{
+	GT_U8 convTag;
+
+	/* check if memberTag needs to be converted */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+		return tag;
+
+	switch(tag)
+	{
+	case MEMBER_EGRESS_UNMODIFIED:
+		convTag = 0;
+		break;
+	case NOT_A_MEMBER:
+		convTag = 3;
+		break;
+	case MEMBER_EGRESS_UNTAGGED:
+		convTag = 1;
+		break;
+	case MEMBER_EGRESS_TAGGED:
+		convTag = 2;
+		break;
+	default:
+		DBG_INFO(("Unknown Tag (%#x) from App. !!!.\n",tag));
+		convTag = 0xFF;
+		break;
+			
+	}
+
+	return convTag;
+}
+
+static GT_STATUS vtuOperationPerform
+(
+	IN	    GT_QD_DEV           *dev,
+	IN      GT_VTU_OPERATION    vtuOp,
+	INOUT   GT_U8               *valid,
+	INOUT 	GT_VTU_ENTRY    	*vtuEntry
+	);
+
+/*******************************************************************************
+ * gvtuGetEntryCount
+ *
+ * DESCRIPTION:
+ *       Gets the current number of valid entries in the VTU table
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       numEntries - number of VTU entries.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *       GT_NO_SUCH - vlan does not exist.
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuGetEntryCount
+(
+	IN  GT_QD_DEV *dev,
+	OUT GT_U32    *numEntries
+	)
+{
+	GT_U8               valid;
+	GT_U32		numOfEntries;
+	GT_STATUS       	retVal;
+	GT_VTU_ENTRY    	entry;
+
+	DBG_INFO(("gvtuGetEntryCount Called.\n"));
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+		return retVal;
+
+	entry.vid = 0xFFF;
+	entry.DBNum = 0;
+
+	numOfEntries = 0;
+	while(1)
+	{
+		retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid,&entry);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+			return retVal;
+		}
+
+		if( entry.vid==0xFFF )
+		{
+			if (valid==1) numOfEntries++;
+			break;
+		}
+
+		numOfEntries++;
+	}
+
+	*numEntries = numOfEntries;
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+ * gvtuGetEntryFirst
+ *
+ * DESCRIPTION:
+ *       Gets first lexicographic entry from the VTU.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       vtuEntry - match VTU entry.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *       GT_NO_SUCH - table is empty.
+ *
+ * COMMENTS:
+ *       Search starts from vid of all one's
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuGetEntryFirst
+(
+	IN  GT_QD_DEV       *dev,
+	OUT GT_VTU_ENTRY    *vtuEntry
+	)
+{
+	GT_U8               valid;
+	GT_STATUS       	retVal;
+	GT_U8       	i; 
+	GT_VTU_ENTRY    	entry;
+
+	DBG_INFO(("gvtuGetEntryFirst Called.\n"));
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+		return retVal;
+
+	entry.vid = 0xFFF;
+	entry.DBNum = 0;
+
+	retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	/* retrive the value from the operation */ 
+
+	if((entry.vid == 0xFFF) && (valid == 0))
+		return GT_NO_SUCH;
+
+	vtuEntry->DBNum = entry.DBNum;
+	vtuEntry->vid   = entry.vid;
+	vtuEntry->vidPriOverride = entry.vidPriOverride;
+	vtuEntry->vidPriority = entry.vidPriority;
+	for( i =0; i< dev->numOfPorts;i++)
+	{
+		vtuEntry->vtuData.memberTagP[i]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[i]);
+		vtuEntry->vtuData.portStateP[i]=entry.vtuData.portStateP[i];
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gvtuGetEntryNext
+ *
+ * DESCRIPTION:
+ *       Gets next lexicographic VTU entry from the specified VID.
+ *
+ * INPUTS:
+ *       vtuEntry - the VID to start the search.
+ *
+ * OUTPUTS:
+ *       vtuEntry - match VTU  entry.
+ *
+ * RETURNS:
+ *       GT_OK      - on success.
+ *       GT_FAIL    - on error or entry does not exist.
+ *       GT_NO_SUCH - no more entries.
+ *
+ * COMMENTS:
+ *       Search starts from the VID specified by the user.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuGetEntryNext
+(
+	IN  GT_QD_DEV       *dev,
+	INOUT GT_VTU_ENTRY  *vtuEntry
+	)
+{
+	GT_U8               valid;
+	GT_STATUS       	retVal;
+	GT_U8       	i; 
+	GT_VTU_ENTRY    	entry;
+
+	DBG_INFO(("gvtuGetEntryNext Called.\n"));
+    
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+		return retVal;
+
+	entry.DBNum = vtuEntry->DBNum;
+	entry.vid   = vtuEntry->vid;
+	valid = 0;
+
+	retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	/* retrive the value from the operation */ 
+
+	if((entry.vid == 0xFFF) && (valid == 0))
+		return GT_NO_SUCH;
+
+	vtuEntry->DBNum = entry.DBNum;
+	vtuEntry->vid   = entry.vid;
+	vtuEntry->vidPriOverride = entry.vidPriOverride;
+	vtuEntry->vidPriority = entry.vidPriority;
+	for( i =0; i< dev->numOfPorts;i++)
+	{
+		vtuEntry->vtuData.memberTagP[i]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[i]);
+		vtuEntry->vtuData.portStateP[i]=entry.vtuData.portStateP[i];
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gvtuFindVidEntry
+ *
+ * DESCRIPTION:
+ *       Find VTU entry for a specific VID, it will return the entry, if found, 
+ *       along with its associated data 
+ *
+ * INPUTS:
+ *       vtuEntry - contains the VID to searche for 
+ *
+ * OUTPUTS:
+ *       found    - GT_TRUE, if the appropriate entry exists.
+ *       vtuEntry - the entry parameters.
+ *
+ * RETURNS:
+ *       GT_OK      - on success.
+ *       GT_FAIL    - on error or entry does not exist.
+ *       GT_NO_SUCH - no more entries.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuFindVidEntry
+(
+	IN  GT_QD_DEV       *dev,
+	INOUT GT_VTU_ENTRY  *vtuEntry,
+	OUT GT_BOOL         *found
+	)
+{
+	GT_U8               valid;
+	GT_STATUS       	retVal;
+	GT_U8               i;
+	GT_VTU_ENTRY    	entry;
+
+	DBG_INFO(("gvtuFindVidEntry Called.\n"));
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+		return retVal;
+
+	*found = GT_FALSE;
+
+	/* Decrement 1 from vid    */
+	entry.vid   = vtuEntry->vid-1;
+	valid = 0; /* valid is not used as input in this operation */
+	entry.DBNum = vtuEntry->DBNum;
+
+	retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	/* retrive the value from the operation */ 
+
+	if( (entry.vid !=vtuEntry->vid) | (valid !=1) )
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_NO_SUCH;
+	}
+
+	vtuEntry->DBNum = entry.DBNum;
+	vtuEntry->vidPriOverride = entry.vidPriOverride;
+	vtuEntry->vidPriority = entry.vidPriority;
+
+	for( i =0; i< dev->numOfPorts;i++)
+	{
+		vtuEntry->vtuData.memberTagP[i]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[i]);
+		vtuEntry->vtuData.portStateP[i]=entry.vtuData.portStateP[i];
+	}
+
+	*found = GT_TRUE;
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gvtuFlush
+ *
+ * DESCRIPTION:
+ *       This routine removes all entries from VTU Table.
+ *
+ * INPUTS:
+ *       None
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuFlush
+(
+	IN  GT_QD_DEV       *dev
+	)
+{
+	GT_STATUS       retVal;
+
+	DBG_INFO(("gvtuFlush Called.\n"));
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+		return retVal;
+
+	retVal = vtuOperationPerform(dev,FLUSH_ALL,NULL,NULL);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gvtuAddEntry
+ *
+ * DESCRIPTION:
+ *       Creates the new entry in VTU table based on user input.
+ *
+ * INPUTS:
+ *       vtuEntry    - vtu entry to insert to the VTU.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK             - on success
+ *       GT_FAIL           - on error
+ *       GT_FULL			  - vtu table is full
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuAddEntry
+(
+	IN  GT_QD_DEV   *dev,
+	IN GT_VTU_ENTRY *vtuEntry
+	)
+{
+	GT_U8               valid;
+	GT_STATUS       	retVal;
+	GT_U8       	i; 
+	GT_VTU_ENTRY 	tmpVtuEntry;
+	GT_BOOL		 	found;
+	int				count = 50000;
+	GT_VTU_ENTRY    	entry;
+
+	DBG_INFO(("gvtuAddEntry Called.\n"));
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+		return retVal;
+
+	entry.DBNum = vtuEntry->DBNum;
+	entry.vid   = vtuEntry->vid;
+	entry.vidPriOverride = vtuEntry->vidPriOverride;
+	entry.vidPriority = vtuEntry->vidPriority;
+
+	valid = 1; /* for load operation */
+
+	for( i =0; i< dev->numOfPorts;i++)
+	{
+		entry.vtuData.memberTagP[i] = MEMBER_TAG_CONV_FOR_DEV(dev,vtuEntry->vtuData.memberTagP[i]);
+		if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+			entry.vtuData.portStateP[i] = vtuEntry->vtuData.portStateP[i];
+		else
+			entry.vtuData.portStateP[i] = 0;
+	}
+
+	retVal = vtuOperationPerform(dev,LOAD_PURGE_ENTRY,&valid, &entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	/* verify that the given entry has been added */
+	tmpVtuEntry.vid = vtuEntry->vid;
+	tmpVtuEntry.DBNum = vtuEntry->DBNum;
+
+	if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
+	{
+		while(count--);
+		if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
+		{
+			DBG_INFO(("Added entry cannot be found\n"));
+			return retVal;
+		}
+	}
+	if(found == GT_FALSE)
+	{
+		DBG_INFO(("Added entry cannot be found\n"));
+		return GT_FAIL;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gvtuDelEntry
+ *
+ * DESCRIPTION:
+ *       Deletes VTU entry specified by user.
+ *
+ * INPUTS:
+ *       vtuEntry - the VTU entry to be deleted 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NO_SUCH      - if specified address entry does not exist
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuDelEntry
+(
+	IN  GT_QD_DEV   *dev,
+	IN GT_VTU_ENTRY *vtuEntry
+	)
+{
+	GT_U8               valid;
+	GT_STATUS       	retVal;
+	GT_VTU_ENTRY    	entry;
+
+	DBG_INFO(("gvtuDelEntry Called.\n"));
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+		return retVal;
+    
+	entry.DBNum = vtuEntry->DBNum;
+	entry.vid   = vtuEntry->vid;
+	valid = 0; /* for delete operation */
+
+	retVal = vtuOperationPerform(dev,LOAD_PURGE_ENTRY,&valid, &entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+ * gvtuGetViolation
+ *
+ * DESCRIPTION:
+ *       Get VTU Violation data
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       vtuIntStatus - interrupt cause, source portID, and vid.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORT  - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This is an internal function. No user should call this function.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuGetViolation
+(
+	IN  GT_QD_DEV         *dev,
+	OUT GT_VTU_INT_STATUS *vtuIntStatus
+	)
+{
+	GT_U8               spid;
+	GT_U16               vid;
+	GT_U16               intCause;
+	GT_STATUS       	retVal;
+	GT_VTU_ENTRY    	entry;
+
+	DBG_INFO(("gvtuGetViolation Called.\n"));
+
+	/* check which Violation occurred */
+	retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,4,3,&intCause);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+		return retVal;
+	}
+
+	if (intCause == 0)
+	{
+		/* No Violation occurred. */
+		vtuIntStatus->vtuIntCause = 0;
+		return GT_OK;
+	}
+
+	entry.DBNum = 0;
+
+	retVal = vtuOperationPerform(dev,SERVICE_VIOLATIONS,NULL, &entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	spid = entry.DBNum & 0xF;
+	vid = entry.vid;
+
+	if(spid == 0xF)
+	{
+		vtuIntStatus->vtuIntCause = GT_VTU_FULL_VIOLATION;
+		vtuIntStatus->spid = spid;
+		vtuIntStatus->vid = 0;
+	}
+	else
+	{
+		vtuIntStatus->vtuIntCause = intCause & (GT_MEMBER_VIOLATION | GT_MISS_VIOLATION);
+		vtuIntStatus->spid = spid;
+		vtuIntStatus->vid = vid;
+	}
+	
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gvtuGetViolation2
+ *
+ * DESCRIPTION:
+ *       Get VTU Violation data (for Gigabit Device)
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       vtuIntStatus - interrupt cause, source portID, and vid.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORT  - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This is an internal function. No user should call this function.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gvtuGetViolation2
+(
+	IN  GT_QD_DEV         *dev,
+	OUT GT_VTU_INT_STATUS *vtuIntStatus
+	)
+{
+	GT_U16               intCause;
+	GT_STATUS       	retVal;
+	GT_VTU_ENTRY    	entry;
+
+	DBG_INFO(("gvtuGetViolation2 Called.\n"));
+
+	/* check if Violation occurred */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,5,1,&intCause);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+		return retVal;
+	}
+
+	if (intCause == 0)
+	{
+		/* No Violation occurred. */
+		vtuIntStatus->vtuIntCause = 0;
+		return GT_OK;
+	}
+
+	entry.DBNum = 0;
+
+	retVal = vtuOperationPerform(dev,SERVICE_VIOLATIONS,NULL, &entry);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	/* check which Violation occurred */
+	retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,5,2,&intCause);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+		return retVal;
+	}
+
+	switch (intCause)
+	{
+	case 0:
+		/* No Violation occurred. */
+		vtuIntStatus->vtuIntCause = 0;
+		return GT_OK;
+	case 1:
+		/* Miss Violation */
+		vtuIntStatus->vtuIntCause = GT_MISS_VIOLATION;
+		break;
+	case 2:
+		/* Member Violation */
+		vtuIntStatus->vtuIntCause = GT_MEMBER_VIOLATION;
+		break;
+	default :
+		return GT_FAIL;
+	}
+
+	vtuIntStatus->spid = entry.DBNum & 0xF;
+	vtuIntStatus->vid = entry.vid;
+	
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * vtuOperationPerform
+ *
+ * DESCRIPTION:
+ *       This function is used by all VTU control functions, and is responsible
+ *       to write the required operation into the VTU registers.
+ *
+ * INPUTS:
+ *       vtuOp       - The VTU operation bits to be written into the VTU
+ *                     operation register.
+ *       DBNum       - DBNum where the given vid belongs to
+ *       vid         - vlan id
+ *       valid       - valid bit
+ *       vtuData     - VTU Data with memberTag information
+ *
+ * OUTPUTS:
+ *       DBNum       - DBNum where the given vid belongs to
+ *       vid         - vlan id
+ *       valid       - valid bit
+ *       vtuData     - VTU Data with memberTag information
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+
+static GT_STATUS vtuOperationPerform
+(
+	IN	    GT_QD_DEV           *dev,
+	IN      GT_VTU_OPERATION    vtuOp,
+	INOUT   GT_U8               *valid,
+	INOUT	GT_VTU_ENTRY    	*entry
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+
+	gtSemTake(dev,dev->vtuRegsSem,OS_WAIT_FOREVER);
+
+	/* Wait until the VTU in ready. */
+	data = 1;
+	while(data == 1)
+	{
+		retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+	}
+
+	/* Set the VTU data register    */
+	/* There is no need to setup data reg. on flush, get next, or service violation */
+	if((vtuOp != FLUSH_ALL) && (vtuOp != GET_NEXT_ENTRY) && (vtuOp != SERVICE_VIOLATIONS))
+	{
+		/* get data from data register for ports 0 to 3 */
+
+		data =  (entry->vtuData.memberTagP[0] & 3)     |
+			((entry->vtuData.memberTagP[1] & 3))<<4 | 
+			((entry->vtuData.memberTagP[2] & 3))<<8 ;
+		data |= ((entry->vtuData.portStateP[0] & 3)<<2|
+			 ((entry->vtuData.portStateP[1] & 3))<<6 | 
+			 ((entry->vtuData.portStateP[2] & 3))<<10) ;
+			
+		/****************** if this is for CliperShip *******************/
+		if(dev->numOfPorts > 3)
+		{
+			/* fullsail has 3 ports(0,1,2), clippership has 7 prots(3 to 6)      */
+			/* port 3 is set on VTU_DATA1_REG, port 4-6 are set on VTU_DATA2_REG */
+			data |= ((entry->vtuData.memberTagP[3] & 3)<<12) ;
+			data |= ((entry->vtuData.portStateP[3] & 3)<<14) ;
+		}
+		/****************** end of  CliperShip **************************/
+
+		retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA1_REG,data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		/****************** if this is for CliperShip *******************/
+
+		if(dev->numOfPorts > 4)
+		{
+			/* also need to set data register  ports 4 to 6 */
+
+			data =  (entry->vtuData.memberTagP[4] & 3)   |
+				((entry->vtuData.memberTagP[5] & 3))<<4 |
+				((entry->vtuData.memberTagP[6] & 3))<<8 ;
+			data |= ((entry->vtuData.portStateP[4] & 3)<<2|
+				 ((entry->vtuData.portStateP[5] & 3))<<6 | 
+				 ((entry->vtuData.portStateP[6] & 3))<<10) ;
+
+			if(dev->numOfPorts > 7)
+			{
+				/* octane has 10 ports */
+				/* port 7 are set on VTU_DATA2_REG */
+				data |= ((entry->vtuData.memberTagP[7] & 3)<<12) ;
+				data |= ((entry->vtuData.portStateP[7] & 3)<<14) ;
+			}
+
+			retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA2_REG,data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+		}
+		/****************** end of  CliperShip *******************/
+
+		/****************** if this is for Octane *******************/
+
+		if(dev->numOfPorts > 7)
+		{
+			/* also need to set data register  ports 8 to 9 */
+
+			data =  (entry->vtuData.memberTagP[8] & 3)   |
+				((entry->vtuData.memberTagP[9] & 3))<<4;
+			data |= ((entry->vtuData.portStateP[8] & 3)<<2|
+				 ((entry->vtuData.portStateP[9] & 3))<<6);
+
+			if(dev->numOfPorts > 10)
+			{
+				data |= (((entry->vtuData.memberTagP[10] & 3)<<8) |
+					 ((entry->vtuData.portStateP[10] & 3)<<10));
+			}
+			
+			if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+			{
+				if(entry->vidPriOverride == GT_TRUE)
+					data |= ((1 << 15) | ((entry->vidPriority & 0x7) << 12));
+			}
+
+			retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+		}
+		/****************** end of Octane *******************/
+	}
+
+	/* Set the Vtu VID registers    */
+	/* There is no need to setup VID reg. on flush and service violation */
+	if((vtuOp != FLUSH_ALL) && (vtuOp != SERVICE_VIOLATIONS) )
+	{
+		data= ( (entry->vid) & 0xFFF ) | ( (*valid) << 12 );
+		retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_VID_REG),data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}		
+	}
+
+	/* Start the VTU Operation by defining the DBNum, vtuOp and VTUBusy    */
+	/* 
+	 * Flush operation will skip the above two setup (for data and vid), and 
+	 * come to here directly
+	 */
+
+	if ( entry == NULL )
+		data = (1 << 15) | (vtuOp << 12);
+	else
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+		{
+			/* Since DBNum is defined as GT_U8, it cannot be >= 256. */
+#if 0
+			if(entry->DBNum >= 256)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return GT_BAD_PARAM;
+			}	
+#endif
+			data = (1 << 15) | (vtuOp << 12) | ((entry->DBNum & 0xF0) << 4) | (entry->DBNum & 0x0F);
+		}
+		else
+		{
+			if(entry->DBNum >= 16)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return GT_BAD_PARAM;
+			}	
+			data = (1 << 15) | (vtuOp << 12) | entry->DBNum;
+		}
+	}
+
+	retVal = hwWriteGlobalReg(dev,QD_REG_VTU_OPERATION,data);
+	if(retVal != GT_OK)
+	{
+		gtSemGive(dev,dev->vtuRegsSem);
+		return retVal;
+	}
+
+	/* only two operations need to go through the mess below to get some data 
+	 * after the operations -  service violation and get next entry
+	 */
+
+	/* If the operation is to service violation operation wait for the response   */
+	if(vtuOp == SERVICE_VIOLATIONS)
+	{
+		/* Wait until the VTU in ready. */
+		data = 1;
+		while(data == 1)
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+		}
+
+		/* get the Source Port ID that was involved in the violation */
+		retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		entry->DBNum = (GT_U8)(data & 0xF);
+
+		/* get the VID that was involved in the violation */
+
+		retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		/* Get the vid - bits 0-11 */
+		entry->vid   = data & 0xFFF;
+
+
+	} /* end of service violations */
+
+	/* If the operation is a get next operation wait for the response   */
+	if(vtuOp == GET_NEXT_ENTRY)
+	{
+		/* Wait until the VTU in ready. */
+		data = 1;
+		while(data == 1)
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+		}
+
+		/****************** get the DBNum *******************/
+		retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		entry->DBNum = data & 0xF;
+
+		if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,8,4,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+
+			entry->DBNum |= ((data & 0xF) << 4);
+		}
+
+
+		/****************** get the vid *******************/
+
+		retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		/* the vid is bits 0-11 */
+		entry->vid   = data & 0xFFF;
+
+		/* the vid valid is bits 12 */
+		*valid   = (data >> 12) & 1;
+
+
+		/****************** get the MemberTagP *******************/
+		retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA1_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+		/* get data from data register for ports 0 to 3 */
+		entry->vtuData.memberTagP[0]  =  data & 3 ;
+		entry->vtuData.memberTagP[1]  = (data >> 4) & 3 ;
+		entry->vtuData.memberTagP[2]  = (data >> 8) & 3 ;
+		entry->vtuData.portStateP[0]  = (data >> 2) & 3 ;
+		entry->vtuData.portStateP[1]  = (data >> 6) & 3 ;
+		entry->vtuData.portStateP[2]  = (data >> 10) & 3 ;
+
+		/****************** for the switch more than 3 ports *****************/
+
+		if(dev->numOfPorts > 3)
+		{
+			/* fullsail has 3 ports, clippership has 7 prots */
+			entry->vtuData.memberTagP[3]  = (data >>12) & 3 ;
+			entry->vtuData.portStateP[3]  = (data >>14) & 3 ;
+
+			/* get data from data register for ports 4 to 6 */
+			retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA2_REG,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+			entry->vtuData.memberTagP[4]  = data & 3 ;
+			entry->vtuData.memberTagP[5]  = (data >> 4) & 3 ;
+			entry->vtuData.memberTagP[6]  = (data >> 8) & 3 ;
+			entry->vtuData.portStateP[4]  = (data >> 2) & 3 ;
+			entry->vtuData.portStateP[5]  = (data >> 6) & 3 ;
+			entry->vtuData.portStateP[6]  = (data >> 10) & 3 ;
+		}
+		/****************** upto 7 port switch *******************/
+
+		/****************** for the switch more than 7 ports *****************/
+
+		if(dev->numOfPorts > 7)
+		{
+			/* fullsail has 3 ports, clippership has 7 prots */
+			entry->vtuData.memberTagP[7]  = (data >>12) & 3 ;
+			entry->vtuData.portStateP[7]  = (data >>14) & 3 ;
+
+			/* get data from data register for ports 4 to 6 */
+			retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+			entry->vtuData.memberTagP[8]  = data & 3 ;
+			entry->vtuData.memberTagP[9]  = (data >> 4) & 3 ;
+			entry->vtuData.portStateP[8]  = (data >> 2) & 3 ;
+			entry->vtuData.portStateP[9]  = (data >> 6) & 3 ;
+
+			if(dev->numOfPorts > 10)
+			{
+				entry->vtuData.memberTagP[10]  = (data >> 8) & 3 ;
+				entry->vtuData.portStateP[10]  = (data >> 10) & 3 ;
+			}
+
+			if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+			{
+				if (data & 0x8000)
+				{
+					entry->vidPriOverride = GT_TRUE;
+					entry->vidPriority = (data >> 12) & 0x7;
+				}
+				else
+				{
+					entry->vidPriOverride = GT_FALSE;
+					entry->vidPriority = 0;
+				}
+			}
+
+		}
+		/****************** upto 11 ports switch *******************/
+
+	} /* end of get next entry */
+
+	gtSemGive(dev,dev->vtuRegsSem);
+	return GT_OK;
+}
Index: linux-2.6.16/drivers/net/marvell/gtDebug.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtDebug.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,53 @@
+#include <linux/marvell/Copyright.h>
+/********************************************************************************
+ * debug.c
+ *
+ * DESCRIPTION:
+ *       Debug message display routine
+ *
+ * DEPENDENCIES:
+ *       OS Dependent
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#ifdef DEBUG_QD
+/* #include "stdarg.h" */
+#include <linux/kernel.h>
+
+/*******************************************************************************
+ * gtDbgPrint
+ *
+ * DESCRIPTION:
+ *       .
+ *
+ * INPUTS:
+ *       None
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+void gtDbgPrint(char* format, ...)
+{
+	va_list argP;
+	char dbgStr[1000] = "";
+
+	va_start(argP, format);
+	vsprintf(dbgStr, format, argP);
+
+	printk(dbgStr);
+	return;
+}
+#else /* DEBUG_QD not defined */
+void gtDbgPrint(char* format, ...)
+{
+}
+#endif /* DEBUG_QD */
+
Index: linux-2.6.16/drivers/net/marvell/gtDrvConfig.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtDrvConfig.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,156 @@
+#include <linux/marvell/Copyright.h>
+/********************************************************************************
+ * gtDrvConfig.h
+ *
+ * DESCRIPTION:
+ *       Includes driver level configuration and initialization function.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#include <linux/marvell/gtDrvSwRegs.h>
+#include <linux/marvell/gtDrvConfig.h>
+#include <linux/marvell/gtMiiSmiIf.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/msApiDefs.h>
+
+/*******************************************************************************
+ * driverConfig
+ *
+ * DESCRIPTION:
+ *       This function initializes the driver level of the quarterDeck software.
+ *
+ * INPUTS:
+ *		None.
+ * OUTPUTS:
+ *		None.
+ * RETURNS:
+ *       GT_OK               - on success, or
+ *       GT_OUT_OF_CPU_MEM   - if failed to allocate CPU memory,
+ *       GT_FAIL             - otherwise.
+ *
+ * COMMENTS:
+ *       1.  This function should perform the following:
+ *           -   Initialize the global switch configuration structure.
+ *           -   Initialize Mii Interface
+ *           -   Set the CPU port into trailer mode (Ingress and Egress).
+ *
+ *******************************************************************************/
+GT_STATUS driverConfig
+(
+	IN GT_QD_DEV    *dev
+	)
+{
+	GT_U16          deviceId;
+	GT_BOOL         highSmiDevAddr;
+	GT_U32	    portsCount;
+
+	if(dev->accessMode == SMI_AUTO_SCAN_MODE)
+	{	
+		/* Initialize the MII / SMI interface, search for the device */
+		if((deviceId = miiSmiIfInit(dev,&highSmiDevAddr)) == 0)
+		{
+			return GT_FAIL;
+		}
+
+		dev->baseRegAddr = (highSmiDevAddr)?0x10:0;
+	}
+	else
+	{
+		if((deviceId = miiSmiManualIfInit(dev,(GT_U32)dev->baseRegAddr)) == 0)
+		{
+			return GT_FAIL;
+		}
+	}
+	
+	/* Init the device's config struct.             */
+	dev->deviceId       = deviceId >> 4;
+	dev->revision       = (GT_U8)deviceId & 0xF; 
+
+	/* Get the number of active ports               */
+
+	switch (dev->deviceId)
+	{
+	case GT_88E6051:
+		portsCount = 5;
+		break;
+	case GT_88E6021:
+		portsCount = 3; 
+		break;
+	case GT_FF_EG:
+	case GT_88E6060:
+		portsCount = 6; 
+		break;
+
+	case GT_88E6052:
+	case GT_88E6063:
+	case GT_FF_HG:
+	case GT_FH_VPN:
+		portsCount = 7; 
+		break;
+	case GT_88E6083:
+		portsCount = 10; 
+		break;
+	case GT_88E6152:
+	case GT_88E6155:
+	case GT_88E6153:
+		portsCount = 6;
+		break;
+	case GT_88E6181:
+		portsCount = 8;
+		break;
+	case GT_88E6182:
+	case GT_88E6183:
+	case GT_88E6185:
+		portsCount = 10;
+		break;
+	case GT_88E6092:
+	case GT_88E6093:
+	case GT_88E6095:
+		portsCount = 11;
+		break;
+	default:
+		portsCount = 7; 
+		break;
+	}
+
+	dev->numOfPorts = (GT_U8)portsCount;
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * driverEnable
+ *
+ * DESCRIPTION:
+ *       This function enables the switch for full operation, after the driver
+ *       Config function was called.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_FAIL othrwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS driverEnable
+(
+	IN GT_QD_DEV    *dev
+	)
+{
+	return GT_OK;
+}
+
Index: linux-2.6.16/drivers/net/marvell/gtDrvEvents.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtDrvEvents.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,92 @@
+#include <linux/marvell/Copyright.h>
+/********************************************************************************
+ * gtDrvEvents.c
+ *
+ * DESCRIPTION:
+ *       This file includes function declarations for QuarterDeck interrupts
+ *       configuration and handling.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#include <linux/marvell/gtDrvSwRegs.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvEvents.h>
+
+/*******************************************************************************
+ * drvEventsInit
+ *
+ * DESCRIPTION:
+ *       This function initializes the driver's interrupt handling mechanism.
+ *
+ * INPUTS:
+ *       intVecNum   - The interrupt vector the switch is connected to.
+ *       isrFunc     - A pointer to the Interrupt Service Routine to be
+ *                     connected to the given interrupt vector.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success,
+ *       GT_FAIL - otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS drvEventsInit
+(
+	IN  GT_QD_DEV       *dev,
+	IN GT_U32           intVecNum,
+	IN GT_VOIDFUNCPTR   isrFunc
+	)
+{
+#if 0
+	return osInterruptConnect(intVecNum,isrFunc,0);
+#endif
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * eventQdSr
+ *
+ * DESCRIPTION:
+ *       QuarterDeck interrupt service routine.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       None.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_BOOL eventQdSr
+(
+	IN  GT_QD_DEV* dev,
+	OUT GT_U16* intCause
+	)
+{
+	GT_STATUS       retVal;         /* Function calls return value.     */
+
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,0,4,intCause);
+
+	if(retVal != GT_OK)
+		return GT_FALSE;
+
+	return (*intCause)?GT_TRUE:GT_FALSE;
+}
+
Index: linux-2.6.16/drivers/net/marvell/gtEvents.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtEvents.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,239 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtEvents.c
+ *
+ * DESCRIPTION:
+ *       API definitions for system interrupt events handling.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+ * eventSetActive
+ *
+ * DESCRIPTION:
+ *       This routine enables/disables the receive of an hardware driven event.
+ *
+ * INPUTS:
+ *       eventType - the event type. any combination of the folowing: 
+ *       	GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+ *       	GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS eventSetActive
+(
+	IN GT_QD_DEV *dev,
+	IN GT_U32 	 eventType
+	)
+{
+	GT_STATUS   retVal;   
+	GT_U16 	data;
+	GT_U16	intMask;
+
+	DBG_INFO(("eventSetActive Called.\n"));
+
+	data = (GT_U16) eventType;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY_ONLY))
+	{
+		intMask = GT_NO_INTERNAL_PHY_INT_MASK;
+	}
+	else
+	{
+		intMask = GT_INT_MASK;
+	}
+	
+	if(data & ~intMask)
+	{
+		DBG_INFO(("Invalid event type.\n"));
+		return GT_FAIL;
+	}
+
+	/* Set the IntEn bit.               */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,0,7,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * eventGetIntStatus
+ *
+ * DESCRIPTION:
+ *       This routine reads an hardware driven event status.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       intCause -  It provides the source of interrupt of the following:
+ *       GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+ *       GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT. 
+ *		For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_PROB and 
+ *		if there is no internal phy, GT_PHY_INTERRUPT is not supported.
+ *
+ * RETURNS:
+ *       GT_TRUE - read success and there is a pending event.
+ *       GT_FAIL - otherwise
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS eventGetIntStatus
+(
+	IN GT_QD_DEV *dev,
+	OUT GT_U16   *intCause
+	)
+{
+	GT_STATUS       retVal;         /* Function calls return value.     */
+
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,0,7,intCause);
+
+	if(retVal != GT_OK)
+		return GT_FALSE;
+
+	return (*intCause)?GT_TRUE:GT_FALSE;
+}
+
+
+/*******************************************************************************
+ * gvtuGetIntStatus
+ *
+ * DESCRIPTION:
+ * Check to see if a specific type of VTU interrupt occured
+ *
+ * INPUTS:
+ *       	intType - the type of interrupt which causes an interrupt.
+ *			any combination of 
+ *			GT_MEMEBER_VIOLATION,
+ *			GT_MISS_VIOLATION,
+ *			GT_FULL_VIOLATION
+ *
+ * OUTPUTS:
+ * None.
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * FULL_VIOLATION is only for Fast Ethernet Switch (not for Gigabit Switch).
+ *
+ *******************************************************************************/
+
+GT_STATUS gvtuGetIntStatus
+(
+	IN GT_QD_DEV          *dev,
+	OUT GT_VTU_INT_STATUS *vtuIntStatus
+	)
+{
+	GT_STATUS       retVal;      
+
+	DBG_INFO(("gvtuGetIntStatus Called.\n"));
+   
+	/* check if device supports this feature */
+	if((IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK ) 
+		return GT_FAIL; 
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		retVal = gvtuGetViolation(dev,vtuIntStatus);
+	}
+	else
+	{
+		retVal = gvtuGetViolation2(dev,vtuIntStatus);
+	}
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+    
+	return retVal;
+}
+
+/*******************************************************************************
+ * gatuGetIntStatus
+ *
+ * DESCRIPTION:
+ * Check to see if a specific type of ATU interrupt occured
+ *
+ * INPUTS:
+ *       	intType - the type of interrupt which causes an interrupt.
+ *			any combination of 
+ *			GT_MEMEBER_VIOLATION,
+ *			GT_MISS_VIOLATION,
+ *			GT_FULL_VIOLATION 
+ *
+ * OUTPUTS:
+ * None.
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+
+GT_STATUS gatuGetIntStatus
+(
+	IN GT_QD_DEV          *dev,
+	OUT GT_ATU_INT_STATUS *atuIntStatus
+	)
+{
+	GT_STATUS       retVal;      
+
+	DBG_INFO(("gatuGetIntStatus Called.\n"));
+   
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = gatuGetViolation(dev,atuIntStatus);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+    
+	return retVal;
+}
Index: linux-2.6.16/drivers/net/marvell/gtHwCntl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtHwCntl.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1132 @@
+#include <linux/marvell/Copyright.h>
+/********************************************************************************
+ * gtHwCntl.c
+ *
+ * DESCRIPTION:
+ *       Functions declarations for Hw accessing quarterDeck phy, internal and
+ *       global registers.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtMiiSmiIf.h>
+
+/*******************************************************************************
+ * portToSmiMapping
+ *
+ * DESCRIPTION:
+ *       This function mapps port to smi address
+ *
+ * INPUTS:
+ *		dev - device context
+ *       portNum - Port number to read the register for.
+ *		accessType - type of register (Phy, Port, or Global)
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       smiAddr    - smi address.
+ *
+ *******************************************************************************/
+GT_U8 portToSmiMapping
+(
+	IN GT_QD_DEV *dev,
+	IN GT_U8	portNum,
+	IN GT_U32	accessType
+	)
+{
+	GT_U8 smiAddr;
+
+	if(IS_IN_DEV_GROUP(dev,DEV_8PORT_SWITCH))
+	{
+		switch(accessType)
+		{
+		case PHY_ACCESS:
+			if (dev->maxPhyNum <= portNum)
+				smiAddr = 0xFF;
+			else
+				smiAddr = PHY_REGS_START_ADDR_8PORT + portNum;
+			break;
+		case PORT_ACCESS:
+			if (dev->numOfPorts <= portNum)
+				smiAddr = 0xFF;
+			else
+				smiAddr = PORT_REGS_START_ADDR_8PORT + portNum;
+			break;
+		case GLOBAL_REG_ACCESS:
+			smiAddr = GLOBAL_REGS_START_ADDR_8PORT;
+			break;
+		default:
+			smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 1;
+			break;
+		}
+	}
+	else
+	{
+		smiAddr = dev->baseRegAddr;
+		switch(accessType)
+		{
+		case PHY_ACCESS:
+			if (dev->maxPhyNum <= portNum)
+				smiAddr = 0xFF;
+			else
+				smiAddr += PHY_REGS_START_ADDR + portNum;
+			break;
+		case PORT_ACCESS:
+			if (dev->numOfPorts <= portNum)
+				smiAddr = 0xFF;
+			else
+				smiAddr += PORT_REGS_START_ADDR + portNum;
+			break;
+		default:
+			smiAddr += GLOBAL_REGS_START_ADDR;
+			break;
+		}
+	}
+
+	return smiAddr;
+}
+
+
+/****************************************************************************/
+/* Phy registers related functions.                                         */
+/****************************************************************************/
+
+/*******************************************************************************
+ * hwReadPhyReg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch's port phy register.
+ *
+ * INPUTS:
+ *       portNum - Port number to read the register for.
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwReadPhyReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	OUT GT_U16   *data
+	)
+{
+	GT_U8       phyAddr;
+	GT_STATUS   retVal, retPPU;
+	GT_U16		orgPPU;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+	if (phyAddr == 0xFF)
+	{
+		return GT_BAD_PARAM;
+	}
+
+	if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+	{
+		if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+		{
+			return retPPU;
+		}
+
+		if(orgPPU)
+		{
+			/* Disable PPU so that External Phy can be accessible */
+			if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+			{
+				return retPPU;
+			}
+		}
+	}
+
+	retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+	DBG_INFO(("Read from phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+		  portNum,phyAddr,regAddr));
+
+	if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+	{
+		if(orgPPU)
+		{
+			if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+			{
+				return retPPU;
+			}
+		}
+	}
+
+	return retVal;
+
+}
+
+
+/*******************************************************************************
+ * hwWritePhyReg
+ *
+ * DESCRIPTION:
+ *       This function writes to a switch's port phy register.
+ *
+ * INPUTS:
+ *       portNum - Port number to write the register for.
+ *       regAddr - The register's address.
+ *       data    - The data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwWritePhyReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	IN  GT_U16   data
+	)
+{
+	GT_U8   		phyAddr;
+	GT_STATUS   retVal, retPPU;
+	GT_U16		orgPPU;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+	if (phyAddr == 0xFF)
+	{
+		return GT_BAD_PARAM;
+	}
+
+	if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+	{
+		if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+		{
+			return retPPU;
+		}
+
+		if(orgPPU)
+		{
+			/* Disable PPU so that External Phy can be accessible */
+			if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+			{
+				return retPPU;
+			}
+		}
+	}
+
+	DBG_INFO(("Write to phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+		  portNum,phyAddr,regAddr));
+	DBG_INFO(("data 0x%x.\n",data));
+
+	retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+	if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+	{
+		if(orgPPU)
+		{
+			if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+			{
+				return retPPU;
+			}
+		}
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * hwGetPhyRegField
+ *
+ * DESCRIPTION:
+ *       This function reads a specified field from a switch's port phy register.
+ *
+ * INPUTS:
+ *       portNum     - Port number to read the register for.
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to read.
+ *
+ * OUTPUTS:
+ *       data        - The read register field.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+GT_STATUS hwGetPhyRegField
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	IN  GT_U8    fieldOffset,
+	IN  GT_U8    fieldLength,
+	OUT GT_U16   *data
+	)
+{
+	GT_U16 mask;            /* Bits mask to be read */
+	GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+	if((retVal=hwReadPhyReg(dev,portNum,regAddr,&tmpData)) != GT_OK)
+		return retVal;
+
+	CALC_MASK(fieldOffset,fieldLength,mask);
+
+	tmpData = (tmpData & mask) >> fieldOffset;
+	*data = tmpData;
+
+	DBG_INFO(("Read from phy(%d) register: regAddr 0x%x, ",
+		  portNum,regAddr));
+	DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * hwSetPhyRegField
+ *
+ * DESCRIPTION:
+ *       This function writes to specified field in a switch's port phy register.
+ *
+ * INPUTS:
+ *       portNum     - Port number to write the register for.
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to write.
+ *       data        - Data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+GT_STATUS hwSetPhyRegField
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	IN  GT_U8    fieldOffset,
+	IN  GT_U8    fieldLength,
+	IN  GT_U16   data
+	)
+{
+	GT_U16 mask;
+	GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+	if((retVal=hwReadPhyReg(dev,portNum,regAddr,&tmpData)) != GT_OK)
+		return retVal;
+
+	CALC_MASK(fieldOffset,fieldLength,mask);
+
+	/* Set the desired bits to 0.                       */
+	tmpData &= ~mask;
+	/* Set the given data into the above reset bits.    */
+	tmpData |= ((data << fieldOffset) & mask);
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, ",
+		  portNum,regAddr));
+	DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+		  fieldLength,data));
+	return hwWritePhyReg(dev,portNum,regAddr,tmpData);
+}
+
+
+/****************************************************************************/
+/* Per port registers related functions.                                    */
+/****************************************************************************/
+
+/*******************************************************************************
+ * hwReadPortReg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch's port register.
+ *
+ * INPUTS:
+ *       portNum - Port number to read the register for.
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwReadPortReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	OUT GT_U16   *data
+	)
+{
+	GT_U8       phyAddr;
+	GT_STATUS   retVal;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+	if (phyAddr == 0xFF)
+	{
+		return GT_BAD_PARAM;
+	}
+
+	retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+	DBG_INFO(("Read from port(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+		  portNum,phyAddr,regAddr));
+	DBG_INFO(("data 0x%x.\n",*data));
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * hwWritePortReg
+ *
+ * DESCRIPTION:
+ *       This function writes to a switch's port register.
+ *
+ * INPUTS:
+ *       portNum - Port number to write the register for.
+ *       regAddr - The register's address.
+ *       data    - The data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwWritePortReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	IN  GT_U16   data
+	)
+{
+	GT_U8   phyAddr;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+	if (phyAddr == 0xFF)
+	{
+		return GT_BAD_PARAM;
+	}
+
+	DBG_INFO(("Write to port(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+		  portNum,phyAddr,regAddr));
+	DBG_INFO(("data 0x%x.\n",data));
+
+	return miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+}
+
+
+/*******************************************************************************
+ * hwGetPortRegField
+ *
+ * DESCRIPTION:
+ *       This function reads a specified field from a switch's port register.
+ *
+ * INPUTS:
+ *       portNum     - Port number to read the register for.
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to read.
+ *
+ * OUTPUTS:
+ *       data        - The read register field.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+GT_STATUS hwGetPortRegField
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	IN  GT_U8    fieldOffset,
+	IN  GT_U8    fieldLength,
+	OUT GT_U16   *data
+	)
+{
+	GT_U16 mask;            /* Bits mask to be read */
+	GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+	if((retVal=hwReadPortReg(dev,portNum,regAddr,&tmpData)) != GT_OK)
+		return retVal;
+
+	CALC_MASK(fieldOffset,fieldLength,mask);
+
+	tmpData = (tmpData & mask) >> fieldOffset;
+	*data = tmpData;
+	DBG_INFO(("Read from port(%d) register: regAddr 0x%x, ",
+		  portNum,regAddr));
+	DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * hwSetPortRegField
+ *
+ * DESCRIPTION:
+ *       This function writes to specified field in a switch's port register.
+ *
+ * INPUTS:
+ *       portNum     - Port number to write the register for.
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to write.
+ *       data        - Data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+GT_STATUS hwSetPortRegField
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	IN  GT_U8    fieldOffset,
+	IN  GT_U8    fieldLength,
+	IN  GT_U16   data
+	)
+{
+	GT_U16 mask;
+	GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+	if((retVal=hwReadPortReg(dev,portNum,regAddr,&tmpData)) != GT_OK)
+		return retVal;
+
+	CALC_MASK(fieldOffset,fieldLength,mask);
+
+	/* Set the desired bits to 0.                       */
+	tmpData &= ~mask;
+	/* Set the given data into the above reset bits.    */
+	tmpData |= ((data << fieldOffset) & mask);
+	DBG_INFO(("Write to port(%d) register: regAddr 0x%x, ",
+		  portNum,regAddr));
+	DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+		  fieldLength,data));
+
+	return hwWritePortReg(dev,portNum,regAddr,tmpData);
+}
+
+
+/****************************************************************************/
+/* Global registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+ * hwReadGlobalReg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch's global register.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwReadGlobalReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    regAddr,
+	OUT GT_U16   *data
+	)
+{
+	GT_U8       phyAddr;
+	GT_STATUS   retVal;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+
+	retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+	DBG_INFO(("read from global register: phyAddr 0x%x, regAddr 0x%x, ",
+		  phyAddr,regAddr));
+	DBG_INFO(("data 0x%x.\n",*data));
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * hwWriteGlobalReg
+ *
+ * DESCRIPTION:
+ *       This function writes to a switch's global register.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *       data    - The data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwWriteGlobalReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    regAddr,
+	IN  GT_U16   data
+	)
+{
+	GT_U8   phyAddr;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+
+	DBG_INFO(("Write to global register: phyAddr 0x%x, regAddr 0x%x, ",
+		  phyAddr,regAddr));
+	DBG_INFO(("data 0x%x.\n",data));
+
+	return miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+}
+
+
+/*******************************************************************************
+ * hwGetGlobalRegField
+ *
+ * DESCRIPTION:
+ *       This function reads a specified field from a switch's global register.
+ *
+ * INPUTS:
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to read.
+ *
+ * OUTPUTS:
+ *       data        - The read register field.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+GT_STATUS hwGetGlobalRegField
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    regAddr,
+	IN  GT_U8    fieldOffset,
+	IN  GT_U8    fieldLength,
+	OUT GT_U16   *data
+	)
+{
+	GT_U16 mask;            /* Bits mask to be read */
+	GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+	if((retVal=hwReadGlobalReg(dev,regAddr,&tmpData)) != GT_OK)
+		return retVal;
+
+	CALC_MASK(fieldOffset,fieldLength,mask);
+	tmpData = (tmpData & mask) >> fieldOffset;
+	*data = tmpData;
+	DBG_INFO(("Read from global register: regAddr 0x%x, ",
+		  regAddr));
+	DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * hwSetGlobalRegField
+ *
+ * DESCRIPTION:
+ *       This function writes to specified field in a switch's global register.
+ *
+ * INPUTS:
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to write.
+ *       data        - Data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+GT_STATUS hwSetGlobalRegField
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    regAddr,
+	IN  GT_U8    fieldOffset,
+	IN  GT_U8    fieldLength,
+	IN  GT_U16   data
+	)
+{
+	GT_U16 mask;
+	GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+	if((retVal=hwReadGlobalReg(dev,regAddr,&tmpData)) != GT_OK)
+		return retVal;
+
+	CALC_MASK(fieldOffset,fieldLength,mask);
+
+	/* Set the desired bits to 0.                       */
+	tmpData &= ~mask;
+	/* Set the given data into the above reset bits.    */
+	tmpData |= ((data << fieldOffset) & mask);
+
+	DBG_INFO(("Write to global register: regAddr 0x%x, ",
+		  regAddr));
+	DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+		  fieldLength,data));
+
+	return hwWriteGlobalReg(dev,regAddr,tmpData);
+}
+
+/*******************************************************************************
+ * hwReadGlobal2Reg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch's global 2 register.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwReadGlobal2Reg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    regAddr,
+	OUT GT_U16   *data
+	)
+{
+	GT_U8       phyAddr;
+	GT_STATUS   retVal;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+
+	retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+	DBG_INFO(("read from global 2 register: phyAddr 0x%x, regAddr 0x%x, ",
+		  phyAddr,regAddr));
+	DBG_INFO(("data 0x%x.\n",*data));
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * hwWriteGlobal2Reg
+ *
+ * DESCRIPTION:
+ *       This function writes to a switch's global 2 register.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *       data    - The data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwWriteGlobal2Reg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    regAddr,
+	IN  GT_U16   data
+	)
+{
+	GT_U8   phyAddr;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+
+	DBG_INFO(("Write to global 2 register: phyAddr 0x%x, regAddr 0x%x, ",
+		  phyAddr,regAddr));
+	DBG_INFO(("data 0x%x.\n",data));
+
+	return miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+}
+
+
+/*******************************************************************************
+ * hwGetGlobal2RegField
+ *
+ * DESCRIPTION:
+ *       This function reads a specified field from a switch's global 2 register.
+ *
+ * INPUTS:
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to read.
+ *
+ * OUTPUTS:
+ *       data        - The read register field.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+GT_STATUS hwGetGlobal2RegField
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    regAddr,
+	IN  GT_U8    fieldOffset,
+	IN  GT_U8    fieldLength,
+	OUT GT_U16   *data
+	)
+{
+	GT_U16 mask;            /* Bits mask to be read */
+	GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+	if((retVal=hwReadGlobal2Reg(dev,regAddr,&tmpData)) != GT_OK)
+		return retVal;
+
+	CALC_MASK(fieldOffset,fieldLength,mask);
+	tmpData = (tmpData & mask) >> fieldOffset;
+	*data = tmpData;
+	DBG_INFO(("Read from global 2 register: regAddr 0x%x, ",
+		  regAddr));
+	DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * hwSetGlobal2RegField
+ *
+ * DESCRIPTION:
+ *       This function writes to specified field in a switch's global 2 register.
+ *
+ * INPUTS:
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to write.
+ *       data        - Data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+GT_STATUS hwSetGlobal2RegField
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    regAddr,
+	IN  GT_U8    fieldOffset,
+	IN  GT_U8    fieldLength,
+	IN  GT_U16   data
+	)
+{
+	GT_U16 mask;
+	GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+	if((retVal=hwReadGlobal2Reg(dev,regAddr,&tmpData)) != GT_OK)
+		return retVal;
+
+	CALC_MASK(fieldOffset,fieldLength,mask);
+
+	/* Set the desired bits to 0.                       */
+	tmpData &= ~mask;
+	/* Set the given data into the above reset bits.    */
+	tmpData |= ((data << fieldOffset) & mask);
+
+	DBG_INFO(("Write to global 2 register: regAddr 0x%x, ",
+		  regAddr));
+	DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+		  fieldLength,data));
+
+	return hwWriteGlobal2Reg(dev,regAddr,tmpData);
+}
+
+/*******************************************************************************
+ * hwReadQDReg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch register.
+ *
+ * INPUTS:
+ *       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwReadMiiReg
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     phyAddr,
+	IN  GT_U8     regAddr,
+	OUT GT_U16    *data
+	)
+{
+	GT_STATUS   retVal;
+
+	retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+	DBG_INFO(("Read from phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
+		  phyAddr,regAddr,*data));
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * hwWriteMiiReg
+ *
+ * DESCRIPTION:
+ *       This function writes a switch register.
+ *
+ * INPUTS:
+ *       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS hwWriteMiiReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    phyAddr,
+	IN  GT_U8    regAddr,
+	IN  GT_U16   data
+	)
+{
+	GT_STATUS   retVal;
+
+	retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+	DBG_INFO(("Write to phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
+		  phyAddr,regAddr,data));
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * hwReadPPU
+ *
+ * DESCRIPTION:
+ *			This function reads PPU bit in Global Register
+ *
+ * INPUTS:
+ *			None.
+ *
+ * OUTPUTS:
+ *			data    - The read register's data.
+ *
+ * RETURNS:
+ *			GT_OK on success, or
+ *			GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *			This function can be used to access PHY register connected to Gigabit
+ *			Switch.
+ *
+ *******************************************************************************/
+GT_STATUS hwReadPPU
+(
+	IN  GT_QD_DEV *dev,
+	OUT GT_U16    *data
+	)
+{
+	GT_STATUS   retVal;
+
+	retVal = hwGetGlobalRegField(dev,4,14,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * hwWritePPU
+ *
+ * DESCRIPTION:
+ *			This function writes PPU bit in Global Register
+ *
+ * INPUTS:
+ *			data - The value to write into PPU bit
+ *
+ * OUTPUTS:
+ *			None.
+ *
+ * RETURNS:
+ *			GT_OK on success, or
+ *			GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *			This function can be used to access PHY register connected to Gigabit
+ *			Switch.
+ *
+ *******************************************************************************/
+GT_STATUS hwWritePPU
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U16    data
+	)
+{
+	GT_STATUS   retVal;
+	GT_U32      retryCount;
+	GT_U16      ppuState;
+
+	retVal = hwSetGlobalRegField(dev,4,14,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	/* busy wait - till PPU is actually disabled */
+	if (data == 0) /* disable PPU */
+	{
+		for (retryCount = 0x100; retryCount > 0; retryCount--)
+		{
+			retVal = hwGetGlobalRegField(dev,0,14,2, &ppuState);
+			if(retVal != GT_OK)
+			{
+				DBG_INFO(("Failed.\n"));
+				return retVal;
+			}
+			if (ppuState == 2)
+				break;
+		}
+
+		if (retryCount == 0)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
Index: linux-2.6.16/drivers/net/marvell/gtMiiSmiIf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtMiiSmiIf.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,482 @@
+#include <linux/marvell/Copyright.h>
+/********************************************************************************
+ * gtMiiSmiIf.c
+ *
+ * DESCRIPTION:
+ *       Includes functions prototypes for initializing and accessing the
+ *       MII / SMI interface.
+ *       This is the only file to be included from upper layers.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#include <linux/marvell/gtDrvSwRegs.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtMiiSmiIf.h>
+#include <linux/marvell/platformDeps.h>
+#include <linux/marvell/gtSem.h>
+
+#define QD_SMI_ACCESS_LOOP		1000
+#define QD_SMI_TIMEOUT			2
+
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MIIReg,
+			 unsigned int* value);
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MIIReg,
+			  unsigned int value);
+/*******************************************************************************
+ * miiSmiIfInit
+ *
+ * DESCRIPTION:
+ *       This function initializes the MII / SMI interface.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       highSmiDevAddr - Indicates whether to use the high device register
+ *                     addresses when accessing switch's registers (of all kinds)
+ *                     i.e, the devices registers range is 0x10 to 0x1F, or to
+ *                     use the low device register addresses (range 0x0 to 0xF).
+ *                       GT_TRUE     - use high addresses (0x10 to 0x1F).
+ *                       GT_FALSE    - use low addresses (0x0 to 0xF).
+ *
+ * RETURNS:
+ *       DEVICE_ID       - on success
+ *       0    - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_U16 miiSmiIfInit
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL * highSmiDevAddr
+	)
+{
+	GT_STATUS status;
+	GT_U16 data, data1;
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR,QD_REG_SWITCH_ID,&data)) != GT_OK)
+	{
+		return 0;
+	}
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+1,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+	{
+		return 0;
+	}
+
+	switch(data & 0xFF00)
+	{
+	case 0x0200:
+	case 0x0500:
+	case 0x0600:
+	case 0x1500:
+	case 0xF500:
+	case 0xF900:
+		if (data == data1)
+		{
+			*highSmiDevAddr = GT_FALSE;
+			return data;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x10,QD_REG_SWITCH_ID,&data)) != GT_OK)
+	{
+		return 0;
+	}
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x11,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+	{
+		return 0;
+	}
+
+	switch(data & 0xFF00)
+	{
+	case 0x0200:
+	case 0x0500:
+	case 0x0600:
+	case 0x1500:
+	case 0xF500:
+	case 0xF900:
+		if (data == data1)
+		{
+			*highSmiDevAddr = GT_TRUE;
+			return data;
+		}
+		break;
+	case 0x0800:
+	case 0x1A00:
+	case 0x0900:
+		if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0xF,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+		{
+			return 0;
+		}
+
+		if (data == data1)
+		{
+			*highSmiDevAddr = GT_FALSE;
+			return data;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+
+/*******************************************************************************
+ * miiSmiManualIfInit
+ *
+ * DESCRIPTION:
+ *       This function returns Device ID from the given base address
+ *
+ * INPUTS:
+ *       baseAddr - either 0x0 or 0x10. Indicates whether to use the low device 
+ *					register address or high device register address.
+ *					The device register range is from 0x0 to 0xF or from 0x10 
+ *					to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port 
+ *					switchs.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       DEVICE_ID       - on success
+ *       0    - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_U16 miiSmiManualIfInit
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_U32		baseAddr
+	)
+{
+	GT_STATUS status;
+	GT_U16 data;
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+baseAddr,QD_REG_SWITCH_ID,&data)) != GT_OK)
+	{
+		return 0;
+	}
+
+	switch(data & 0xFF00)
+	{
+	case 0x0200:
+	case 0x0500:
+	case 0x0600:
+	case 0x1500:
+	case 0xF500:
+	case 0xF900:
+		return data;
+	default:
+		break;
+	}
+	if(baseAddr != 0)
+		return 0;
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR_8PORT+baseAddr,QD_REG_SWITCH_ID,&data)) != GT_OK)
+	{
+		return 0;
+	}
+
+	switch(data & 0xFF00)
+	{
+	case 0x0800:
+	case 0x1A00:
+	case 0x0900:
+		return data;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+
+/*******************************************************************************
+ * miiSmiIfReadRegister
+ *
+ * DESCRIPTION:
+ *       This function reads a register throw the SMI / MII interface, to be used
+ *       by upper layers.
+ *
+ * INPUTS:
+ *       phyAddr     - The PHY address to be read.
+ *       regAddr     - The register address to read.
+ *
+ * OUTPUTS:
+ *       data        - The register's data.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS miiSmiIfReadRegister
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_U8        phyAddr,
+	IN  GT_U8        regAddr,
+	OUT GT_U16       *data
+	)
+{
+	unsigned int tmpData;
+
+	if(dev->accessMode == SMI_MULTI_ADDR_MODE)
+	{
+		if(dev->devEnabled)
+			gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+		if(qdMultiAddrRead(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
+		{
+			if(dev->devEnabled)
+				gtSemGive(dev,dev->multiAddrSem);
+			return GT_FAIL;
+		}
+		if(dev->devEnabled)
+			gtSemGive(dev,dev->multiAddrSem);
+	}
+	else
+	{
+		if(dev->fgtReadMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
+		{
+			return GT_FAIL;
+		}
+	}
+	*data = (GT_U16)tmpData;
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * miiSmiIfWriteRegister
+ *
+ * DESCRIPTION:
+ *       This function writes to a register throw the SMI / MII interface, to be
+ *       used by upper layers.
+ *
+ * INPUTS:
+ *       phyAddr     - The PHY address to be read.
+ *       regAddr     - The register address to read.
+ *       data        - The data to be written to the register.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS miiSmiIfWriteRegister
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_U8        phyAddr,
+	IN  GT_U8        regAddr,
+	IN  GT_U16       data
+	)
+{
+	if(dev->accessMode == SMI_MULTI_ADDR_MODE)
+	{
+		if(dev->devEnabled)
+			gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+		if(qdMultiAddrWrite(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
+		{
+			if(dev->devEnabled)
+				gtSemGive(dev,dev->multiAddrSem);
+			return GT_FAIL;
+		}
+
+		if(dev->devEnabled)
+			gtSemGive(dev,dev->multiAddrSem);
+	}
+	else
+	{
+		if(dev->fgtWriteMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
+		{
+			return GT_FAIL;
+		}
+	}
+	return GT_OK;
+}
+
+
+/*****************************************************************************
+ * qdMultiAddrRead
+ *
+ * DESCRIPTION:
+ *       This function reads data from a device in the secondary MII bus.
+ *
+ * INPUTS:
+ *       phyAddr     - The PHY address to be read.
+ *       regAddr     - The register address to read.
+ *       value       - The storage where register date to be saved.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_TRUE   - on success
+ *       GT_FALSE  - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
+			 unsigned int* value)
+{
+	unsigned int smiReg;
+	volatile unsigned int timeOut; /* in 100MS units */
+	volatile int i;
+
+	/* first check that it is not busy */
+	if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+	{
+		return GT_FALSE;
+	}
+	timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+
+	if(smiReg & QD_SMI_BUSY) 
+	{
+		for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+		do 
+		{
+			if(timeOut-- < 1 ) 
+			{
+				return GT_FALSE;
+			}
+			if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+			{
+				return GT_FALSE;
+			}
+		} while (smiReg & QD_SMI_BUSY);
+	}
+
+	smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) | 
+    		(regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+	if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
+	{
+		return GT_FALSE;
+	}
+	timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+	if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+	{
+		return GT_FALSE;
+	}
+
+	if(smiReg & QD_SMI_BUSY) 
+	{
+		for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+		do 
+		{
+			if(timeOut-- < 1 ) 
+			{
+				return GT_FALSE;
+			}
+			if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+			{
+				return GT_FALSE;
+			}
+		} while (smiReg & QD_SMI_BUSY);
+	}
+	if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, &smiReg) != GT_TRUE)
+	{
+		return GT_FALSE;
+	}
+	*value = smiReg;
+    
+	return GT_TRUE;
+}
+
+/*****************************************************************************
+ * qdMultiAddrWrite
+ *
+ * DESCRIPTION:
+ *       This function writes data to the device in the secondary MII bus.
+ *
+ * INPUTS:
+ *       phyAddr     - The PHY address to be read.
+ *       regAddr     - The register address to read.
+ *       value       - The data to be written into the register.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_TRUE   - on success
+ *       GT_FALSE  - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
+			  unsigned int value)
+{
+	unsigned int smiReg;
+	volatile unsigned int timeOut; /* in 100MS units */
+	volatile int i;
+
+	/* first check that it is not busy */
+	if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+	{
+		return GT_FALSE;
+	}
+	timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+
+	if(smiReg & QD_SMI_BUSY) 
+	{
+		for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+		do 
+		{
+			if(timeOut-- < 1 ) 
+			{
+				return GT_FALSE;
+			}
+			if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+			{
+				return GT_FALSE;
+			}
+		} while (smiReg & QD_SMI_BUSY);
+	}
+
+	if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, value) != GT_TRUE)
+	{
+		return GT_FALSE;
+	}
+	smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) | 
+		(regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+	if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
+	{
+		return GT_FALSE;
+	}
+
+	return GT_TRUE;
+}
+
Index: linux-2.6.16/drivers/net/marvell/gtPCSCtrl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPCSCtrl.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1700 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtPCSCtrl.c
+ *
+ * DESCRIPTION:
+ *       API implementation for 1000BASE-X PCS block register access.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+ * gpcsGetCommaDet
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Comma Detection status in PCS
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetCommaDet
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetCommaDet Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_PCS_LINK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the CommaDet bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,15,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetPCSLink
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Link up status in PCS
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetPCSLink
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetPCSLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_PCS_LINK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the PCS Link bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,15,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetSyncOK
+ *
+ * DESCRIPTION:
+ *		This routine retrieves SynOK bit. It is set to a one when the PCS has
+ *		detected a few comma patterns and is synchronized with its peer PCS 
+ *		layer.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if synchronized or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetSyncOK
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetSyncOK Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the SyncOK bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,14,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gpcsGetSyncFail
+ *
+ * DESCRIPTION:
+ *		This routine retrieves SynFail bit.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetSyncFail
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetSyncFail Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the SyncFail bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,13,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gpcsGetAnBypassed
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Inband Auto-Negotiation bypass status.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetAnBypassed
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetAnBypassed Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the AnBypassed bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,12,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetAnBypassMode
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetAnBypassMode
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetAnBypassMode Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the AnBypass bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,11,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gpcsSetAnBypassMode
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetAnBypassMode
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetAnBypassMode Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the AnBypass bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,11,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetPCSAnEn
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetPCSAnEn
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetPCSAnEn Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the PCSAnEn bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,10,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gpcsSetPCSAnEn
+ *
+ * DESCRIPTION:
+ *		This routine sets Enable mode of PCS Inband Auto-Negotiation.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetPCSAnEn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetPCSAnEn Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the PCSAnEn bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,10,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gpcsSetRestartPCSAn
+ *
+ * DESCRIPTION:
+ *		This routine restarts PCS Inband Auto-Negotiation.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetRestartPCSAn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetRestartPCSAn Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	data = 1;	/* to set RestartPCSAn bit */
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the RestartPCSAn bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,9,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetPCSAnDone
+ *
+ * DESCRIPTION:
+ *		This routine retrieves completion information of PCS Auto-Negotiation.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE if PCS AN is done or never done
+ *			    GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetPCSAnDone
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetPCSAnDone Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the PCSAnDone bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,8,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsSetFCValue
+ *
+ * DESCRIPTION:
+ *		This routine sets Flow Control's force value
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetFCValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetFCValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(state, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Set the FCValue bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,7,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetFCValue
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Flow Control Value which will be used for Forcing 
+ *		Flow Control enabled or disabled.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if FC Force value is one (flow control enabled)
+ *			     GT_FALSE otherwise (flow control disabled)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetFCValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetFCValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the FCValue bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,7,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsSetForcedFC
+ *
+ * DESCRIPTION:
+ *		This routine forces Flow Control. If FCValue is set to one, calling this 
+ *		routine with GT_TRUE will force Flow Control to be enabled.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetForcedFC
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetForcedFC Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(state, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the ForcedFC bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetForcedFC
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Forced Flow Control bit
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if ForcedFC bit is one,
+ *			     GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetForcedFC
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the ForcedLink bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gpcsSetLinkValue
+ *
+ * DESCRIPTION:
+ *		This routine sets Link's force value
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force link up, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetLinkValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetLinkValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(state, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the LinkValue bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,5,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetLinkValue
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Link Value which will be used for Forcing Link 
+ *		up or down.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if Link Force value is one (link up)
+ *			     GT_FALSE otherwise (link down)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetLinkValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetLinkValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the LinkValue bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,5,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsSetForcedLink
+ *
+ * DESCRIPTION:
+ *		This routine forces Link. If LinkValue is set to one, calling this 
+ *		routine with GT_TRUE will force Link to be up.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force link (up or down), GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetForcedLink
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetForcedLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(state, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the ForcedLink bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,4,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetForcedLink
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Forced Link bit
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if ForcedLink bit is one,
+ *			     GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetForcedLink
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the ForcedLink bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,4,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsSetDpxValue
+ *
+ * DESCRIPTION:
+ *		This routine sets Duplex's Forced value. This function needs to be
+ *		called prior to gpcsSetForcedDpx.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force full duplex, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetDpxValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetDpxValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(state, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the DpxValue bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,3,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetDpxValue
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Duplex's Forced value
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if Duplex's Forced value is set to Full duplex,
+ *			     GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetDpxValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the DpxValue bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,3,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsSetForcedDpx
+ *
+ * DESCRIPTION:
+ *		This routine forces duplex mode. If DpxValue is set to one, calling this 
+ *		routine with GT_TRUE will force duplex mode to be full duplex.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force duplex mode, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetForcedDpx
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetForcedDpx Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(state, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the ForcedDpx bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,2,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetForcedDpx
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Forced Duplex.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if ForcedDpx bit is one,
+ *			     GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetForcedDpx
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetForcedDpx Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the ForcedDpx bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,2,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsSetForceSpeed
+ *
+ * DESCRIPTION:
+ *		This routine forces Speed.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsSetForceSpeed
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_PORT_FORCED_SPEED_MODE  mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsSetForceSpeed Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Set the Force Speed bits.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,0,2,mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gpcsGetForceSpeed
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Force Speed value
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpcsGetForceSpeed
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_PORT_FORCED_SPEED_MODE   *mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gpcsGetForceSpeed Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the ForceSpeed bits.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,0,2,&data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	
+	*mode = data;
+
+	/* return */
+	return retVal;
+}
Index: linux-2.6.16/drivers/net/marvell/gtPhyCtrl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPhyCtrl.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,2202 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtPhyCtrl.h
+ * 
+ * DESCRIPTION:
+ * API definitions for PHY control facility.
+ *
+ * DEPENDENCIES:
+ * None.
+ *
+ * FILE REVISION NUMBER:
+ * $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+#include <linux/marvell/gtVct.h>
+
+/*******************************************************************************
+ * phySetAutoMode
+ *
+ * DESCRIPTION:
+ *       This routine will write the given mode to Autonegotiation Advertisement
+ *		Register. Supported mode is as follows:
+ *		- Auto for both speed and duplex.
+ *		- Auto for speed only and Full duplex.
+ *		- Auto for speed only and Half duplex.
+ *		- Auto for duplex only and speed 100Mbps.
+ *		- Auto for duplex only and speed 10Mbps.
+ *		
+ *
+ * INPUTS:
+ * port - The logical port number
+ * mode - Auto Mode to be written
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ * COMMENTS:
+ * data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement Register
+ *******************************************************************************/
+
+static
+GT_STATUS phyIsGigabitCapable
+(
+	IN  GT_QD_DEV 	*dev,
+	IN  GT_U8 		hwPort,
+	OUT GT_U32		*capability
+	)
+{
+	GT_U16 u16Data;
+
+	if(hwGetPhyRegField(dev,hwPort,15,12,4,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,15));
+		return GT_FAIL;
+	}
+
+	*capability = (GT_U32)u16Data;
+	return GT_OK;
+}
+
+#if 0
+static
+GT_BOOL phyIsValidMode
+(
+	IN GT_U32 			capability,
+	IN GT_PHY_AUTO_MODE mode
+	)
+{
+	GT_BOOL isValid = GT_TRUE;
+
+	switch(mode)
+	{
+	case SPEED_AUTO_DUPLEX_AUTO:
+		isValid = GT_TRUE				
+			break;
+	case SPEED_1000_DUPLEX_AUTO:
+		if(capability == 0)
+		{
+			isValid = GT_FALSE;
+		}
+		break;
+	case SPEED_100_DUPLEX_AUTO:
+		if(capability & QD_GIGPHY_1000X_CAP)
+		{
+			isValid = GT_FALSE;
+		}
+		break;
+	case SPEED_10_DUPLEX_AUTO:
+		break;
+	case SPEED_AUTO_DUPLEX_FULL:
+		break;
+	case SPEED_AUTO_DUPLEX_HALF:
+		break;
+	case SPEED_1000_DUPLEX_FULL:
+		break;
+	case SPEED_100_DUPLEX_FULL:
+		break;
+	case SPEED_100_DUPLEX_HALF:
+		break;
+	case SPEED_10_DUPLEX_FULL:
+		break;
+	case SPEED_10_DUPLEX_HALF:
+		break;
+	default:
+		DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+		return GT_FAIL;
+
+	}
+}
+}
+#endif
+
+static 
+GT_STATUS gigCopperSetAutoMode
+(
+IN GT_QD_DEV *dev,
+	IN GT_U8 hwPort,
+	IN GT_PHY_AUTO_MODE mode,
+	IN GT_U32 capability
+	)
+{
+GT_U16 			u16Data;
+GT_U8			regOffset;
+GT_U8			fieldOffset;
+
+DBG_INFO(("gigCopperSetAutoMode Called.\n"));
+
+fieldOffset = 8;
+regOffset = 9;
+
+switch(mode)
+{
+case SPEED_AUTO_DUPLEX_AUTO:
+case SPEED_1000_DUPLEX_AUTO:
+	u16Data = 2;	/* 1000 Half Duplex is not supported. */
+	break;
+case SPEED_AUTO_DUPLEX_FULL:
+	if(capability & QD_GIGPHY_1000T_FULL_CAP)
+		u16Data = 2;
+	else
+		u16Data = 0;
+	break;
+case SPEED_1000_DUPLEX_FULL:
+	if(capability & QD_GIGPHY_1000T_FULL_CAP)
+		u16Data = 2;
+	else
+		return GT_FAIL;
+	break;
+case SPEED_AUTO_DUPLEX_HALF:
+	u16Data = 0;	/* 1000 Half Duplex is not supported. */
+	break;
+case SPEED_100_DUPLEX_AUTO:
+case SPEED_10_DUPLEX_AUTO:
+case SPEED_100_DUPLEX_FULL:
+case SPEED_100_DUPLEX_HALF:
+case SPEED_10_DUPLEX_FULL:
+case SPEED_10_DUPLEX_HALF:
+	u16Data = 0;
+	break;
+default:
+	DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+	return GT_FAIL;
+}
+
+/* Write to Phy AutoNegotiation Advertisement Register.  */
+if(hwSetPhyRegField(dev,hwPort,regOffset,fieldOffset,2,u16Data) != GT_OK)
+{
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,regOffset,u16Data));
+	return GT_FAIL;
+}
+
+return GT_OK;
+}
+
+static 
+GT_STATUS gigFiberSetAutoMode
+(
+	IN GT_QD_DEV *dev,
+	IN GT_U8 hwPort,
+	IN GT_PHY_AUTO_MODE mode,
+	IN GT_U32 capability
+	)
+{
+	GT_U16 			u16Data;
+	GT_U8			regOffset;
+	GT_U8			fieldOffset;
+
+	DBG_INFO(("gigPhySetAutoMode Called.\n"));
+
+	fieldOffset = 5;
+	regOffset = 4;
+
+#if 0
+	fieldOffset = 8;
+	regOffset = 9;
+#endif
+
+	switch(mode)
+	{
+	case SPEED_AUTO_DUPLEX_AUTO:
+	case SPEED_1000_DUPLEX_AUTO:
+		u16Data = 3;
+		break;
+	case SPEED_AUTO_DUPLEX_FULL:
+	case SPEED_1000_DUPLEX_FULL:
+		if(capability & QD_GIGPHY_1000X_FULL_CAP)
+			u16Data = 1;
+		else
+			return GT_FAIL;
+		break;
+	case SPEED_AUTO_DUPLEX_HALF:
+	case SPEED_1000_DUPLEX_HALF:
+		return GT_FAIL;	/* 1000 Half Duplex is not supported. */
+	case SPEED_100_DUPLEX_AUTO:
+	case SPEED_10_DUPLEX_AUTO:
+	case SPEED_100_DUPLEX_FULL:
+	case SPEED_100_DUPLEX_HALF:
+	case SPEED_10_DUPLEX_FULL:
+	case SPEED_10_DUPLEX_HALF:
+	default:
+		DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+		return GT_FAIL;
+	}
+
+	/* Write to Phy AutoNegotiation Advertisement Register.  */
+	if(hwSetPhyRegField(dev,hwPort,regOffset,fieldOffset,2,u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,regOffset,u16Data));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+static 
+GT_STATUS phySetAutoMode
+(
+	IN GT_QD_DEV *dev,
+	IN GT_U8 hwPort,
+	IN GT_PHY_AUTO_MODE mode
+	)
+{
+	GT_U16 			u16Data;
+	GT_U32			capability;
+
+	DBG_INFO(("phySetAutoMode Called.\n"));
+
+	if(phyIsGigabitCapable(dev, hwPort, &capability) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+		return GT_FAIL;
+	}
+
+	if(hwReadPhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+		return GT_FAIL;
+	}
+
+	/* Mask out all auto mode related bits. */
+	u16Data &= ~QD_PHY_MODE_AUTO_AUTO;
+
+	switch(mode)
+	{
+	case SPEED_AUTO_DUPLEX_AUTO:
+		u16Data |= QD_PHY_MODE_AUTO_AUTO;
+		break;
+	case SPEED_1000_DUPLEX_AUTO:
+		u16Data |= 0;
+		break;
+	case SPEED_100_DUPLEX_AUTO:
+		u16Data |= QD_PHY_MODE_100_AUTO;
+		break;
+	case SPEED_10_DUPLEX_AUTO:
+		u16Data |= QD_PHY_MODE_10_AUTO;
+		break;
+	case SPEED_AUTO_DUPLEX_FULL:
+		u16Data |= QD_PHY_MODE_AUTO_FULL;
+		break;
+	case SPEED_AUTO_DUPLEX_HALF:
+		u16Data |= QD_PHY_MODE_AUTO_HALF;
+		break;
+	case SPEED_1000_DUPLEX_FULL:
+		u16Data |= 0;
+		break;
+	case SPEED_100_DUPLEX_FULL:
+		u16Data |= QD_PHY_100_FULL;
+		break;
+	case SPEED_100_DUPLEX_HALF:
+		u16Data |= QD_PHY_100_HALF;
+		break;
+	case SPEED_10_DUPLEX_FULL:
+		u16Data |= QD_PHY_10_FULL;
+		break;
+	case SPEED_10_DUPLEX_HALF:
+		u16Data |= QD_PHY_10_HALF;
+		break;
+	default:
+		DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+		return GT_FAIL;
+	}
+
+	if(capability & QD_GIGPHY_1000X_CAP)
+	{
+		if(gigFiberSetAutoMode(dev, hwPort, mode, capability) != GT_OK)
+		{
+			return GT_FAIL;
+		}
+	}
+	else if(capability & QD_GIGPHY_1000T_CAP)
+	{
+		if(gigCopperSetAutoMode(dev, hwPort, mode, capability) != GT_OK)
+		{
+			return GT_FAIL;
+		}
+	}
+
+	/* Write to Phy AutoNegotiation Advertisement Register.  */
+	if(hwWritePhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gprtPhyReset
+ *
+ * DESCRIPTION:
+ *       This routine preforms PHY reset.
+ *		After reset, phy will be in Autonegotiation mode.
+ *
+ * INPUTS:
+ * port - The logical port number
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ * COMMENTS:
+ * data sheet register 0.15 - Reset
+ * data sheet register 0.13 - Speed
+ * data sheet register 0.12 - Autonegotiation
+ * data sheet register 0.8  - Duplex Mode
+ *******************************************************************************/
+
+GT_STATUS gprtPhyReset
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port
+	)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtPhyReset Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(phySetAutoMode(dev,hwPort,SPEED_AUTO_DUPLEX_AUTO) != GT_OK)
+	{
+		DBG_INFO(("Setting AutoMode Failed.\n"));
+		return GT_FAIL;
+	}
+
+	u16Data = QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+		  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetPortLoopback
+ *
+ * DESCRIPTION:
+ * Enable/Disable Internal Port Loopback. Enabling Loopback will disable the 
+ * Autonegotiation and set the phy mode to 10 Half duplex.
+ * To test Loopback on a different mode, such as 100 Full duplex, 
+ * user may need to call gprtSetPortSpeed and gprtSetPortDuplexMode.
+ * Disabling Loopback does not enable the Autonegotiation, so user may need to call
+ * gprtPortAutoNegEnable in order to enable Autonegotiation.
+ *
+ * INPUTS:
+ * port - logical port number
+ * enable - If GT_TRUE, enable loopback mode
+ * If GT_FALSE, disable loopback mode
+ *
+ * OUTPUTS:
+ * None.
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * data sheet register 0.14 - Loop_back
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtSetPortLoopback
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   enable
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtSetPortLoopback Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+		return GT_FAIL;
+	}
+
+	if(enable)
+	{
+		u16Data = QD_PHY_LOOPBACK | QD_PHY_RESET;
+	}
+	else
+	{
+		u16Data &= ~QD_PHY_LOOPBACK;
+	}
+
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+		  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetPortSpeed
+ *
+ * DESCRIPTION:
+ * 		Sets speed for a specific logical port. This function will keep the duplex 
+ *		mode and loopback mode to the previous value, but disable others, such as 
+ *		Autonegotiation.
+ *
+ * INPUTS:
+ * 		port  - logical port number
+ * 		speed - port speed. 	GT_TRUE=100Mb/s, GT_FALSE=10Mb/s
+ *
+ * OUTPUTS:
+ * None.
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * data sheet register 0.13 - Speed Selection (LSB)
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtSetPortSpeed
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   speed
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtSetPortSpeed Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+		return GT_FAIL;
+	}
+
+	if(speed)
+	{
+		u16Data = QD_PHY_RESET | (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX)) | QD_PHY_SPEED;
+	}
+	else
+	{
+		u16Data = QD_PHY_RESET | (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX));
+	}
+
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+		  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtPortAutoNegEnable
+ *
+ * DESCRIPTION:
+ * 		Enable/disable an Auto-Negotiation for duplex mode on specific
+ * 		logical port. When Autonegotiation is disabled, phy will be in 10Mbps Half 
+ *		Duplex mode. Enabling Autonegotiation will set 100BASE-TX Full Duplex, 
+ *		100BASE-TX Full Duplex, 100BASE-TX Full Duplex, and 100BASE-TX Full Duplex
+ *		in AutoNegotiation Advertisement register.
+ *
+ * INPUTS:
+ * 		port - logical port number
+ * 		state - GT_TRUE for enable Auto-Negotiation for duplex mode,
+ * 					GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.12 - Auto-Negotiation Enable
+ * 		data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtPortAutoNegEnable
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   state
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtPortAutoNegEnable Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(state)
+	{
+		if(phySetAutoMode(dev,hwPort,SPEED_AUTO_DUPLEX_AUTO) != GT_OK)
+		{
+			DBG_INFO(("Setting AutoMode Failed.\n"));
+			return GT_FAIL;
+		}
+
+		u16Data = QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+	}
+	else
+	{
+		u16Data = QD_PHY_RESET;
+	}
+
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+		  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtPortPowerDown
+ *
+ * DESCRIPTION:
+ * 		Enable/disable (power down) on specific logical port. When this function 
+ *		is called with normal operation request, phy will set to Autonegotiation 
+ *		mode.
+ *
+ * INPUTS:
+ * 		port	- logical port number
+ * 		state	-  GT_TRUE: power down
+ * 					GT_FALSE: normal operation
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.11 - Power Down
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtPortPowerDown
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   state
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtPortPowerDown Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(state)
+	{
+		if(phySetAutoMode(dev, hwPort,SPEED_AUTO_DUPLEX_AUTO) != GT_OK)
+		{
+			DBG_INFO(("Setting AutoMode Failed.\n"));
+			return GT_FAIL;
+		}
+
+		u16Data = QD_PHY_POWER;
+	}
+	else
+	{
+		u16Data = QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+	}
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+		  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtPortRestartAutoNeg
+ *
+ * DESCRIPTION:
+ * 		Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
+ *		it. Loopback and Power Down will be disabled by this routine.
+ *
+ * INPUTS:
+ * 		port - logical port number
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.9 - Restart Auto-Negotiation
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtPortRestartAutoNeg
+( 
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port
+	)
+{
+	GT_STATUS       retVal;      
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtPortRestartAutoNeg Called.\n"));
+  
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+		return GT_FAIL;
+	}
+
+	u16Data &= (QD_PHY_DUPLEX | QD_PHY_SPEED);
+	u16Data |= (QD_PHY_RESTART_AUTONEGO | QD_PHY_AUTONEGO);
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+		  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetPortDuplexMode
+ *
+ * DESCRIPTION:
+ * 		Sets duplex mode for a specific logical port. This function will keep 
+ *		the speed and loopback mode to the previous value, but disable others,
+ *		such as Autonegotiation.
+ *
+ * INPUTS:
+ * 		port 	- logical port number
+ * 		dMode	- dulpex mode
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.8 - Duplex Mode
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetPortDuplexMode
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   dMode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtSetPortDuplexMode Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+		return GT_FAIL;
+	}
+
+	if(dMode)
+	{
+		u16Data = QD_PHY_RESET | (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED)) | QD_PHY_DUPLEX;
+	}
+	else
+	{
+		u16Data = QD_PHY_RESET | (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED));
+	}
+
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+		  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetPortAutoMode
+ *
+ * DESCRIPTION:
+ * 		This routine sets up the port with given Auto Mode.
+ *		Supported mode is as follows:
+ *		- Auto for both speed and duplex.
+ *		- Auto for speed only and Full duplex.
+ *		- Auto for speed only and Half duplex.
+ *		- Auto for duplex only and speed 1000Mbps.
+ *		- Auto for duplex only and speed 100Mbps.
+ *		- Auto for duplex only and speed 10Mbps.
+ *		- Speed 1000Mbps and Full duplex.
+ *		- Speed 1000Mbps and Half duplex.
+ *		- Speed 100Mbps and Full duplex.
+ *		- Speed 100Mbps and Half duplex.
+ *		- Speed 10Mbps and Full duplex.
+ *		- Speed 10Mbps and Half duplex.
+ *		
+ *
+ * INPUTS:
+ * 		port - The logical port number
+ * 		mode - Auto Mode to be written
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ * COMMENTS:
+ * 		data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+ * 		data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+ * 		data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+ *******************************************************************************/
+
+GT_STATUS gprtSetPortAutoMode
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_PHY_AUTO_MODE mode
+	)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtSetPortAutoMode Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(phySetAutoMode(dev,hwPort,mode) != GT_OK)
+	{
+		DBG_INFO(("Setting AutoMode Failed.\n"));
+		return GT_FAIL;
+	}
+
+	u16Data = QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+		  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetPause
+ *
+ * DESCRIPTION:
+ *       This routine will set the pause bit in Autonegotiation Advertisement
+ *		Register. And restart the autonegotiation.
+ *
+ * INPUTS:
+ * port - The logical port number
+ * state - either GT_TRUE(for enable) or GT_FALSE(for disable)
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ * COMMENTS:
+ * data sheet register 4.10 Autonegotiation Advertisement Register
+ *******************************************************************************/
+
+GT_STATUS gprtSetPause
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   state
+	)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+
+	DBG_INFO(("phySetPause Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(hwReadPhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+		return GT_FAIL;
+	}
+
+	if(state == GT_TRUE)
+	{
+		/* Set the Pause bit. */
+		u16Data |= QD_PHY_PAUSE;
+	}
+	else
+	{
+		/* Reset the Pause bit. */
+		u16Data &= ~QD_PHY_PAUSE;
+	}
+
+	/* Write to Phy AutoNegotiation Advertisement Register.  */
+	if(hwWritePhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+		return GT_FAIL;
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * doesDeviceSupportDTE
+ *
+ * DESCRIPTION:
+ *       This routine check if the given device supports DTE.
+ *
+ * INPUTS:
+ *       hwPort - port number to be checked.
+ *
+ * OUTPUTS:
+ *		phyType - PHY_1000M, PHY_1000M_MP, or PHY_100M
+ *
+ * RETURNS:
+ *       GT_OK   			- if the device supports VCT
+ *       GT_NOT_SUPPORTED 	- otherwise
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+static 
+GT_STATUS doesDeviceSupportDTE
+(
+	IN  GT_QD_DEV *dev,
+	IN	GT_U8 hwPort,
+	OUT GT_U16* phyType
+	)
+{
+	GT_STATUS status = GT_OK;
+	GT_U16 ouiMsb, ouiLsb;
+
+	DBG_INFO(("doesDeviceSupportVCT Called.\n"));
+
+	if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if(ouiMsb != MARVELL_OUI_MSb)
+		return GT_NOT_SUPPORTED;
+
+	*phyType = PHY_1000M;
+
+	switch(ouiLsb & PHY_MODEL_MASK)
+	{
+	case DEV_E3082:
+		*phyType = PHY_100M;
+		DBG_INFO(("Phy is E3082.\n"));
+		break;
+	case DEV_E1111:
+		if((ouiLsb & PHY_REV_MASK) < 2)
+		{
+			*phyType = PHY_1000M_B;
+		}
+		break;
+	case DEV_E114X:
+		if((ouiLsb & PHY_REV_MASK) < 4)
+		{
+			*phyType = PHY_1000M_B;
+		}
+		break;
+	case DEV_E1180:
+	case DEV_EC010:
+		*phyType = PHY_1000M_B;
+		DBG_INFO(("Gigabit Phy.\n"));
+		break;
+	case DEV_E1149:
+	case DEV_E1112:
+		*phyType = PHY_1000M_MP;
+		DBG_INFO(("Gigabit Phy with Multi Page mode.\n"));
+		break;
+	default:
+		status = GT_NOT_SUPPORTED;
+		DBG_INFO(("Unknown Device.\n"));
+		break;
+	}
+
+	return status;
+}
+
+static
+GT_STATUS dteWorkAround_Phy100M
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8            hwPort
+	)
+{
+	GT_STATUS status = GT_OK;
+	GT_U32 threshold[] = {0x000B,0x0000,0x8780,0x0000,0x8F80,0x0000,
+			      0x9780,0x0000,0x9F80,0x0000,0xA780,0x0000,
+			      0xAF80,0x0000,0xB780,0x0000,0xBF80,0x0000,
+			      0xC780,0x0000,0xCF80,0x0000,0xD780,0x0000,
+			      0xDF80,0x0000,0xE780,0x0000,0xEF80,0x0000,
+			      0xF780,0x0000,0xFF80,0x0000};
+	int i, thresholdSize;
+
+	/* force r125 clock */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x807f)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* write thresholds */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000B)) != GT_OK)
+	{
+		return status;
+	}
+
+	thresholdSize = sizeof(threshold)/sizeof(GT_U32);
+
+	for(i=0; i<thresholdSize; i++)
+	{
+		if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	/* setting adc Masking */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0001)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4000)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* setting noise level */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0005)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xA000)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* 
+	   offseting cable length measurement by 6.72m(2*4*0.84m)
+	   set 30_10.14:11 to 0x1001 for cable length measure.
+	*/ 
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000a)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4840)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* release force r125 clock */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x0000)) != GT_OK)
+	{
+		return status;
+	}
+
+
+	return status;
+}
+
+static
+GT_STATUS dteWorkAround_Phy1000M
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8            hwPort
+	)
+{
+	GT_STATUS status = GT_OK;
+	GT_U32 threshold[] = {0x0000,0x8780,0x0000,0x8F80,0x0000,0x9780,
+			      0x0000,0x9F80,0x0000,0xA780,0x0000,0xAF80,
+			      0x0000,0xB780,0x0000,0xBF80,0x0000,0xC780,
+			      0x0000,0xCF80,0x0000,0xD780,0x0000,0xDF80,
+			      0x0000,0xE780,0x0000,0xEF80,0x0000,0xF780,
+			      0x0000,0xFF80,0x0000};
+	int i, thresholdSize;
+
+	/*  */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001B)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x43FF)) != GT_OK)
+	{
+		return status;
+	}
+
+	/*  */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001C)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x9999)) != GT_OK)
+	{
+		return status;
+	}
+
+	/*  */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001F)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xE00C)) != GT_OK)
+	{
+		return status;
+	}
+
+	/*  */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0018)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xFFA1)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* write thresholds */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0010)) != GT_OK)
+	{
+		return status;
+	}
+
+	thresholdSize = sizeof(threshold)/sizeof(GT_U32);
+
+	for(i=0; i<thresholdSize; i++)
+	{
+		if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	return status;
+}
+
+static
+GT_STATUS feSetDTE
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     hwPort,
+	IN  GT_BOOL   state
+	)
+{
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+
+	if((retVal = hwReadPhyReg(dev,hwPort,0x10,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	u16Data = state?(u16Data|0x8000):(u16Data&(~0x8000));
+
+	if((retVal = hwWritePhyReg(dev,hwPort,0x10,u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	if((retVal = hwReadPhyReg(dev,hwPort,0x0,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+	if((retVal = hwWritePhyReg(dev,hwPort,0x0,u16Data|0x8000)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	return retVal;
+}
+
+static
+GT_STATUS gigSetDTE
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     hwPort,
+	IN  GT_BOOL   state
+	)
+{
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+
+	if((retVal = hwReadPhyReg(dev,hwPort,20,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	u16Data = state?(u16Data|0x4):(u16Data&(~0x4));
+
+	if((retVal = hwWritePhyReg(dev,hwPort,20,u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	if((retVal = hwReadPhyReg(dev,hwPort,0x0,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+	if((retVal = hwWritePhyReg(dev,hwPort,0x0,u16Data|0x8000)) != GT_OK)
+	{
+		return retVal;
+	}
+	return retVal;
+}
+
+static
+GT_STATUS gigMPSetDTE
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     hwPort,
+	IN  GT_BOOL   state
+	)
+{
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+
+	if((retVal = gprtGetPagedPhyReg(dev,hwPort,26,0,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	u16Data = state?(u16Data|0x100):(u16Data&(~0x100));
+
+	if((retVal = gprtSetPagedPhyReg(dev,hwPort,26,0,u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	if((retVal = gprtGetPagedPhyReg(dev,hwPort,0x0,0,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+	if((retVal = gprtSetPagedPhyReg(dev,hwPort,0x0,0,u16Data|0x8000)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetDTEDetect
+ *
+ * DESCRIPTION:
+ *       This routine enables/disables DTE.
+ *
+ * INPUTS:
+ * 		port - The logical port number
+ * 		mode - either GT_TRUE(for enable) or GT_FALSE(for disable)
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtSetDTEDetect
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   state
+	)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_STATUS		retVal = GT_OK;
+	GT_U16 			phyType;
+
+	DBG_INFO(("phySetDTE Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port supports DTE */
+	if(doesDeviceSupportDTE(dev,hwPort,&phyType) != GT_OK)
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch(phyType)
+	{
+	case PHY_100M:
+		/* FE Phy needs work-around */
+		if((retVal = feSetDTE(dev,hwPort,state)) != GT_OK)
+		{
+			return retVal;
+		}
+
+		if(state == GT_FALSE)
+			break;
+
+		if((retVal = dteWorkAround_Phy100M(dev,hwPort)) != GT_OK)
+		{
+			return retVal;
+		}
+		break;
+	case PHY_1000M_B:
+		/* Gigabit Phy with work-around required */
+		if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
+		{
+			return retVal;
+		}
+
+		if(state == GT_FALSE)
+			break;
+
+		if((retVal = dteWorkAround_Phy1000M(dev,hwPort)) != GT_OK)
+		{
+			return retVal;
+		}
+		break;
+
+	case PHY_1000M:
+		/* no workaround required */
+		if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
+		{
+			return retVal;
+		}
+
+		break;
+	case PHY_1000M_MP:
+		/* no workaround required */
+		if((retVal = gigMPSetDTE(dev,hwPort,state)) != GT_OK)
+		{
+			return retVal;
+		}
+		break;
+	default:
+		return GT_NOT_SUPPORTED;
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetDTEDetectStatus
+ *
+ * DESCRIPTION:
+ *       This routine gets DTE status.
+ *
+ * INPUTS:
+ * 		port - The logical port number
+ *
+ * OUTPUTS:
+ *       status - GT_TRUE, if link partner needs DTE power.
+ *				 GT_FALSE, otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectStatus
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *state
+	)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+	GT_U16 			phyType;
+
+	DBG_INFO(("gprtGetDTEStatus Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port supports DTE */
+	if(doesDeviceSupportDTE(dev,hwPort,&phyType) != GT_OK)
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch(phyType)
+	{
+	case PHY_100M:
+		/* FE Phy needs work-around */
+		if((retVal = hwReadPhyReg(dev,hwPort,17,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		*state = (u16Data & 0x8000)?GT_TRUE:GT_FALSE;
+
+		break;
+	case PHY_1000M_B:
+	case PHY_1000M:
+		if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		*state = (u16Data & 0x10)?GT_TRUE:GT_FALSE;
+			
+		break;
+	case PHY_1000M_MP:
+		/* no workaround required */
+		if((retVal = gprtGetPagedPhyReg(dev,hwPort,17,0,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		*state = (u16Data & 0x4)?GT_TRUE:GT_FALSE;
+		break;
+	default:
+		return GT_NOT_SUPPORTED;
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetDTEDetectDropWait
+ *
+ * DESCRIPTION:
+ *       Once the PHY no longer detects that the link partner filter, the PHY
+ *		will wait a period of time before clearing the power over Ethernet 
+ *		detection status bit. The wait time is 5 seconds multiplied by the 
+ *		given value.
+ *
+ * INPUTS:
+ * 		port - The logical port number
+ *       waitTime - 0 ~ 15 (unit of 4 sec.)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtSetDTEDetectDropWait
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	IN  GT_U16    waitTime
+	)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+	GT_U16 			phyType;
+
+	DBG_INFO(("gprtSetDTEDropWait Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port supports DTE */
+	if(doesDeviceSupportDTE(dev,hwPort,&phyType) != GT_OK)
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch(phyType)
+	{
+	case PHY_100M:
+		if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		u16Data = (u16Data & ~(0xF<<12)) | ((waitTime & 0xF) << 12);
+
+		if((retVal = hwWritePhyReg(dev,hwPort,22,u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		break;
+	case PHY_1000M_B:
+	case PHY_1000M:
+		if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		u16Data = (u16Data & ~(0xF<<5)) | ((waitTime & 0xF) << 5);
+
+		if((retVal = hwWritePhyReg(dev,hwPort,27,u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+			
+		break;
+	case PHY_1000M_MP:
+		/* no workaround required */
+		if((retVal = gprtGetPagedPhyReg(dev,hwPort,26,0,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		u16Data = (u16Data & ~(0xF<<4)) | ((waitTime & 0xF) << 4);
+		if((retVal = gprtSetPagedPhyReg(dev,hwPort,26,0,u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		break;
+	default:
+		return GT_NOT_SUPPORTED;
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetDTEDetectDropWait
+ *
+ * DESCRIPTION:
+ *       Once the PHY no longer detects that the link partner filter, the PHY
+ *		will wait a period of time before clearing the power over Ethernet 
+ *		detection status bit. The wait time is 5 seconds multiplied by the 
+ *		returned value.
+ *
+ * INPUTS:
+ * 		port - The logical port number
+ *
+ * OUTPUTS:
+ *       waitTime - 0 ~ 15 (unit of 4 sec.)
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectDropWait
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_U16    *waitTime
+	)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+	GT_U16 			phyType;
+
+	DBG_INFO(("gprtSetDTEDropWait Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port supports DTE */
+	if(doesDeviceSupportDTE(dev,hwPort,&phyType) != GT_OK)
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch(phyType)
+	{
+	case PHY_100M:
+		if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		u16Data = (u16Data >> 12) & 0xF;
+
+		break;
+	case PHY_1000M_B:
+	case PHY_1000M:
+		if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		u16Data = (u16Data >> 5) & 0xF;
+
+		break;
+	case PHY_1000M_MP:
+		/* no workaround required */
+		if((retVal = gprtGetPagedPhyReg(dev,hwPort,26,0,&u16Data)) != GT_OK)
+		{
+			return retVal;
+		}
+		u16Data = (u16Data >> 4) & 0xF;
+
+		break;
+	default:
+		return GT_NOT_SUPPORTED;
+	}
+
+	*waitTime = u16Data;
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSet1000TMasterMode
+ *
+ * DESCRIPTION:
+ *       This routine set the port multicast rate limit.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - GT_1000T_MASTER_SLAVE structure
+ *				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+ *				masterPrefer - GT_TRUE if Master configuration is preferred.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_LPORT     port,
+	IN  GT_1000T_MASTER_SLAVE   *mode
+	)
+{
+	GT_STATUS	retVal;         /* Functions return value.      */
+	GT_U8			hwPort;         /* the physical port number     */
+	GT_U16		data;
+	GT_U32		capability;
+
+	DBG_INFO(("gprtSet1000TMasterMode Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(phyIsGigabitCapable(dev, hwPort, &capability) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+		return GT_FAIL;
+	}
+
+	if(!(capability & QD_GIGPHY_1000T_CAP))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(mode->autoConfig == GT_TRUE)
+	{
+		if(mode->masterPrefer == GT_TRUE)
+		{
+			data = 0x1;
+		}
+		else
+		{
+			data = 0x0;
+		}
+	}
+	else
+	{
+		if(mode->masterPrefer == GT_TRUE)
+		{
+			data = 0x6;
+		}
+		else
+		{
+			data = 0x4;
+		}
+	}
+
+	/* Set the Master Mode.    */
+	retVal = hwSetPhyRegField(dev,hwPort, 9,10,3,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGet1000TMasterMode
+ *
+ * DESCRIPTION:
+ *       This routine set the port multicast rate limit.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_1000T_MASTER_SLAVE structure
+ *				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+ *				masterPrefer - GT_TRUE if Master configuration is preferred.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_LPORT     port,
+	OUT GT_1000T_MASTER_SLAVE   *mode
+	)
+{
+	GT_STATUS	retVal;         /* Functions return value.      */
+	GT_U8			hwPort;         /* the physical port number     */
+	GT_U16		data;
+	GT_U32		capability;
+
+	DBG_INFO(("gprtGet1000TMasterMode Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(phyIsGigabitCapable(dev, hwPort, &capability) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+		return GT_FAIL;
+	}
+
+	if(!(capability & QD_GIGPHY_1000T_CAP))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set the Master Mode.    */
+	retVal = hwGetPhyRegField(dev,hwPort, 9,10,3,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	if(data & 0x4)	/* Manual Mode */
+	{
+		mode->autoConfig = GT_FALSE;
+
+		if(data & 0x2)
+		{
+			mode->masterPrefer = GT_TRUE;
+		}
+		else
+		{
+			mode->masterPrefer = GT_FALSE;
+		}
+	}
+	else	/* Auto Mode */
+	{
+		mode->autoConfig = GT_TRUE;
+
+		if(data & 0x1)
+		{
+			mode->masterPrefer = GT_TRUE;
+		}
+		else
+		{
+			mode->masterPrefer = GT_FALSE;
+		}
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine reads Phy Registers.
+ *
+ * INPUTS:
+ *       port    - logical port number
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPhyReg
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_LPORT     port,
+	IN  GT_U32	     regAddr,
+	OUT GT_U16	     *data
+	)
+{
+	GT_U16          u16Data;           /* The register's read data.    */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetPhyReg Called.\n"));
+
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get Phy Register. */
+	if(hwReadPhyReg(dev,hwPort,(GT_U8)regAddr,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	*data = u16Data;
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gprtSetPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine writes Phy Registers.
+ *
+ * INPUTS:
+ *       port    - logical port number
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetPhyReg
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_U32			regAddr,
+	IN  GT_U16			data
+	)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+    
+	DBG_INFO(("gprtSetPhyReg Called.\n"));
+
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the Scheduling bit.              */
+	if(hwWritePhyReg(dev,hwPort,(GT_U8)regAddr,data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetPagedPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine reads phy register of the given page
+ *
+ * INPUTS:
+ *		port 	- port to be read
+ *		regAddr	- register offset to be read
+ *		page	- page number to be read
+ *
+ * OUTPUTS:
+ *		data	- value of the read register
+ *
+ * RETURNS:
+ *       GT_OK   			- if read successed
+ *       GT_FAIL   			- if read failed
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPagedPhyReg
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U32  port,
+	IN	GT_U32  regAddr,
+	IN	GT_U32  page,
+	OUT GT_U16* data
+	)
+{
+	GT_U32 pageReg;
+	GT_U16 orgReg, u16Data;
+
+	if (regAddr < 29)
+	{
+		pageReg = 22;
+		page &= 0xFF;
+	}
+	else
+	{
+		pageReg = 29;
+		page &= 0x3F;
+	}
+
+	if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&orgReg) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	do
+	{
+		if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,(GT_U16)page) != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+
+		if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&u16Data) != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+	} while (u16Data != page);
+
+	if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)regAddr, &u16Data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	*data = u16Data;
+
+	if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,orgReg) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gprtSetPagedPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine writes a value to phy register of the given page
+ *
+ * INPUTS:
+ *		port 	- port to be read
+ *		regAddr	- register offset to be read
+ *		page	- page number to be read
+ *		data	- value of the read register
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *       GT_OK   			- if read successed
+ *       GT_FAIL   			- if read failed
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetPagedPhyReg
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U32 port,
+	IN	GT_U32 regAddr,
+	IN	GT_U32 page,
+	IN  GT_U16 data
+	)
+{
+	GT_U32 pageReg;
+	GT_U16 orgReg,u16Data;
+
+	if (regAddr < 29)
+	{
+		pageReg = 22;
+		page &= 0xFF;
+	}
+	else
+	{
+		pageReg = 29;
+		page &= 0x3F;
+	}
+
+	if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&orgReg) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	do
+	{
+		if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,(GT_U16)page) != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+
+		if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&u16Data) != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+	} while (u16Data != page);
+
+	if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)regAddr, data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,orgReg) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+
+
Index: linux-2.6.16/drivers/net/marvell/gtPhyInt.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPhyInt.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,222 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtPhyInt.h
+ * 
+ * DESCRIPTION:
+ * API definitions for PHY interrupt handling 
+ *
+ * DEPENDENCIES:
+ * None.
+ *
+ * FILE REVISION NUMBER:
+ * $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+ * gprtPhyIntEnable
+ *
+ * DESCRIPTION:
+ * Enable/Disable one PHY Interrupt
+ * This register determines whether the INT# pin is asserted when an interrupt 
+ * event occurs. When an interrupt occurs, the corresponding bit is set and
+ * remains set until register 19 is read via the SMI. When interrupt enable
+ * bits are not set in register 18, interrupt status bits in register 19 are 
+ * still set when the corresponding interrupt events occur. However, the INT# 
+ * is not asserted.
+ *
+ * INPUTS:
+ * port    - logical port number
+ * intType - the type of interrupt to enable/disable. any combination of 
+ *			GT_SPEED_CHANGED,
+ *			GT_DUPLEX_CHANGED,
+ *			GT_PAGE_RECEIVED,
+ *			GT_AUTO_NEG_COMPLETED,
+ *			GT_LINK_STATUS_CHANGED,
+ *			GT_SYMBOL_ERROR,
+ *			GT_FALSE_CARRIER,
+ *			GT_FIFO_FLOW,
+ *			GT_CROSSOVER_CHANGED,
+ *			GT_POLARITY_CHANGED, and
+ *			GT_JABBER
+ *
+ *
+ * OUTPUTS:
+ * None.
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * 88E3081 data sheet register 18
+ *
+ *******************************************************************************/
+
+
+GT_STATUS gprtPhyIntEnable
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_LPORT	port,
+	IN GT_U16	intType
+	)
+{
+	GT_STATUS       retVal;      
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtPhyIntEnable Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = hwWritePhyReg(dev,hwPort, QD_PHY_INT_ENABLE_REG, intType);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+    
+	return retVal;
+
+}
+
+/*******************************************************************************
+ * gprtGetPhyIntStatus
+ *
+ * DESCRIPTION:
+ * Check to see if a specific type of interrupt occured
+ *
+ * INPUTS:
+ * port - logical port number
+ * intType - the type of interrupt which causes an interrupt.
+ *			any combination of 
+ *			GT_SPEED_CHANGED,
+ *			GT_DUPLEX_CHANGED,
+ *			GT_PAGE_RECEIVED,
+ *			GT_AUTO_NEG_COMPLETED,
+ *			GT_LINK_STATUS_CHANGED,
+ *			GT_SYMBOL_ERROR,
+ *			GT_FALSE_CARRIER,
+ *			GT_FIFO_FLOW,
+ *			GT_CROSSOVER_CHANGED,
+ *			GT_POLARITY_CHANGED, and
+ *			GT_JABBER
+ *
+ * OUTPUTS:
+ * None.
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * 88E3081 data sheet register 19
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtGetPhyIntStatus
+(
+	IN   GT_QD_DEV  *dev,
+	IN   GT_LPORT   port,
+	OUT  GT_U16*    intType
+	)
+{
+	GT_STATUS       retVal;      
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetPhyIntStatus Called.\n"));
+   
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+    
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_STATUS_REG, intType);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+    
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetPhyIntPortSummary
+ *
+ * DESCRIPTION:
+ * Lists the ports that have active interrupts. It provides a quick way to 
+ * isolate the interrupt so that the MAC or switch does not have to poll the
+ * interrupt status register (19) for all ports. Reading this register does not
+ * de-assert the INT# pin
+ *
+ * INPUTS:
+ * none
+ *
+ * OUTPUTS:
+ * GT_U8 *intPortMask - bit Mask with the bits set for the corresponding 
+ * phys with active interrupt. E.g., the bit number 0 and 2 are set when 
+ * port number 0 and 2 have active interrupt
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * 88E3081 data sheet register 20
+ *
+ *******************************************************************************/
+
+GT_STATUS gprtGetPhyIntPortSummary
+(
+	IN  GT_QD_DEV  *dev,
+	OUT GT_U16     *intPortMask
+	)
+{
+	GT_STATUS       retVal;      
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetPhyIntPortSummary Called.\n"));
+   
+	/* translate LPORT 0 to hardware port */
+	hwPort = GT_LPORT_2_PORT(0);
+
+	*intPortMask=0;
+
+	/* get the interrupt port summary from port 0 */
+	retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_PORT_SUMMARY_REG, intPortMask);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+
+}
+
Index: linux-2.6.16/drivers/net/marvell/gtPortCtrl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPortCtrl.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,4125 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtPortCtrl.c
+ *
+ * DESCRIPTION:
+ *       API implementation for switch port control.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+ * gprtSetForceFc
+ *
+ * DESCRIPTION:
+ *       This routine set the force flow control state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetForceFc
+(
+	IN GT_QD_DEV  *dev,
+	IN GT_LPORT   port,
+	IN GT_BOOL    force
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_PORT_STP_STATE  state;
+
+	DBG_INFO(("gprtSetForceFc Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device allows to force a flowcontrol disabled */
+	if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+	{
+		if(force)
+			data = 3;
+		else
+			data = 0;
+			
+		retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+		}
+		else
+		{
+			DBG_INFO(("OK.\n"));
+		}
+		return retVal;		
+	}
+
+	/* Port should be disabled before Set Force Flow Control bit */
+	retVal = gstpGetPortState(dev,port, &state);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("gstpGetPortState failed.\n"));
+		return retVal;
+	}
+
+	retVal = gstpSetPortState(dev,port, GT_PORT_DISABLE);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("gstpSetPortState failed.\n"));
+		return retVal;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(force, data);
+
+	/* Set the force flow control bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* Restore original stp state. */
+	if(gstpSetPortState(dev,port, state) != GT_OK)
+	{
+		DBG_INFO(("gstpSetPortState failed.\n"));
+		return GT_FAIL;
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetForceFc
+ *
+ * DESCRIPTION:
+ *       This routine get the force flow control state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetForceFc
+(
+	IN  GT_QD_DEV  *dev,
+	IN  GT_LPORT   port,
+	OUT GT_BOOL    *force
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetForceFc Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device allows to force a flowcontrol disabled */
+	if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+	{
+		retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+		}
+		else
+		{
+			DBG_INFO(("OK.\n"));
+		}
+
+		if(data & 0x1)
+			*force = GT_TRUE;
+		else
+			*force = GT_FALSE;
+			
+		return retVal;		
+	}
+
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *force);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetUseCoreTag
+ *
+ * DESCRIPTION:
+ *		This routine set the UseCoreTag bit in Port Control Register.
+ *		When this bit is cleared to a zero, ingressing frames are considered
+ *		Tagged if the 16-bits following the frame's Source Address is 0x8100.
+ *		When this bit is set to a one, ingressing frames are considered Tagged
+ *		if the 16-bits following the frame's Source Address is equal to the 
+ *		CoreTag register value.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetUseCoreTag
+(
+	IN GT_QD_DEV  *dev,
+	IN GT_LPORT   port,
+	IN GT_BOOL    force
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetUseCoreTag Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device allows to force a flowcontrol disabled */
+	if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(force, data);
+
+	/* Set the UseCoreTag bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetUseCoreTag
+ *
+ * DESCRIPTION:
+ *       This routine get the Use Core Tag state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetUseCoreTag
+(
+	IN  GT_QD_DEV  *dev,
+	IN  GT_LPORT   port,
+	OUT GT_BOOL    *force
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetUseCoreTag Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the UseCoreTag bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *force);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetTrailerMode
+ *
+ * DESCRIPTION:
+ *       This routine set the egress trailer mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetTrailerMode
+(
+	IN GT_QD_DEV  *dev,
+	IN GT_LPORT   port,
+	IN GT_BOOL    mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetTrailerMode Called.\n"));
+
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if(hwPort < 4)
+	{
+		/* check if device supports this feature for this port */
+		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5|DEV_TRAILER_P4P5))
+		{
+			DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+			return GT_NOT_SUPPORTED;
+		}
+	}
+	else if(hwPort == 4)
+	{
+		/* check if device supports this feature for this port*/
+		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
+		{
+			DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+			return GT_NOT_SUPPORTED;
+		}
+	}
+
+	/* Set the trailer mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetTrailerMode
+ *
+ * DESCRIPTION:
+ *       This routine get the egress trailer mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetTrailerMode
+(
+	IN  GT_QD_DEV  *dev,
+	IN  GT_LPORT   port,
+	OUT GT_BOOL    *mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetTrailerMode Called.\n"));
+
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if(hwPort < 4)
+	{
+		/* check if device supports this feature for this port */
+		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5|DEV_TRAILER_P4P5))
+		{
+			DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+			return GT_NOT_SUPPORTED;
+		}
+	}
+	else if(hwPort == 4)
+	{
+		/* check if device supports this feature for this port */
+		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
+		{
+			DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+			return GT_NOT_SUPPORTED;
+		}
+	}
+
+	/* Get the Trailer mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+
+/*******************************************************************************
+ * gprtSetIngressMode
+ *
+ * DESCRIPTION:
+ *       This routine set the ingress mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the ingress mode.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetIngressMode
+(
+	IN  GT_QD_DEV      *dev,
+	IN GT_LPORT        port,
+	IN GT_INGRESS_MODE mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetIngressMode Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* check if device supports this feature */
+	switch (mode)
+	{
+        case (GT_UNMODIFY_INGRESS):
+		break;
+
+        case (GT_TRAILER_INGRESS):
+		if(!(IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5)))
+		{
+			DBG_INFO(("Given ingress mode is not supported by this device\n"));
+			return GT_NOT_SUPPORTED;
+		}
+		break;
+
+        case (GT_UNTAGGED_INGRESS):
+		if(!(IS_IN_DEV_GROUP(dev,DEV_TAGGING)))
+		{
+			DBG_INFO(("Given ingress mode is not supported by this device\n"));
+			return GT_NOT_SUPPORTED;
+		}
+		break;
+
+        case (GT_CPUPORT_INGRESS):
+		if(!(IS_IN_DEV_GROUP(dev,DEV_IGMP_SNOOPING)))
+		{
+			DBG_INFO(("Given ingress mode is not supported by this device\n"));
+			return GT_NOT_SUPPORTED;
+		}
+
+		if(hwPort != dev->cpuPortNum)
+		{
+			DBG_INFO(("Given ingress mode is supported by CPU port only\n"));
+			return GT_NOT_SUPPORTED;
+		}
+
+		break;
+
+        default:
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	/* Set the Ingress Mode.        */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,2,(GT_U16)mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetIngressMode
+ *
+ * DESCRIPTION:
+ *       This routine get the ingress mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - the ingress mode.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetIngressMode
+(
+	IN  GT_QD_DEV      *dev,
+	IN  GT_LPORT        port,
+	OUT GT_INGRESS_MODE *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetIngressMode Called.\n"));
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+	/* Get the Ingress Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 2,&data);
+	*mode = data;
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetMcRateLimit
+ *
+ * DESCRIPTION:
+ *       This routine set the port multicast rate limit.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetMcRateLimit
+(
+	IN  GT_QD_DEV   *dev,
+	IN GT_LPORT     port,
+	IN GT_MC_RATE   rate
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetMcRateLimit Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* this feature only exits in 6051, 6052, and 6012. It is replace with
+	 * Rate Cotrol Register in the future products, starting from clippership
+	 */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MC_RATE_PERCENT)) != GT_OK)
+		return retVal;
+
+	/* Set the multicast rate limit.    */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,2,(GT_U16)rate);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetMcRateLimit
+ *
+ * DESCRIPTION:
+ *       This routine Get the port multicast rate limit.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetMcRateLimit
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_LPORT    port,
+	OUT GT_MC_RATE  *rate
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read data        */
+
+	DBG_INFO(("gprtGetMcRateLimit Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* this feature only exits in 6051, 6052, and 6012. It is replace with
+	 * Rate Cotrol Register in the future products, starting from clippership
+	 */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MC_RATE_PERCENT)) != GT_OK)
+		return retVal;
+
+	/* Get the multicast rate limit.    */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 2, 2,&data);
+	*rate = data;
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/* the following two APIs are added to support fullsail and clippership */
+
+/*******************************************************************************
+ * gprtSetIGMPSnoop
+ *
+ * DESCRIPTION:
+ * 		This routine set the IGMP Snoop. When set to one and this port receives
+ *		IGMP frame, the frame is switched to the CPU port, overriding all other 
+ *		switching decisions, with exception for CPU's Trailer.
+ *		CPU port is determined by the Ingress Mode bits. A port is considered 
+ *		the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or 
+ *		GT_CPUPORT_INGRESS.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetIGMPSnoop
+(
+	IN  GT_QD_DEV   *dev,
+	IN GT_LPORT     port,
+	IN GT_BOOL      mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetIGMPSnoop Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_IGMP_SNOOPING)) != GT_OK)
+		return retVal;
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the IGMP Snooping mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,10,1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetIGMPSnoop
+ *
+ * DESCRIPTION:
+ *       This routine get the IGMP Snoop mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: IGMP Snoop enabled
+ *	       GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetIGMPSnoop
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_LPORT    port,
+	OUT GT_BOOL     *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetIGMPSnoop Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_IGMP_SNOOPING)) != GT_OK)
+		return retVal;
+
+	/* Get the Ingress Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 10, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/* the following two APIs are added to support clippership */
+
+/*******************************************************************************
+ * gprtSetHeaderMode
+ *
+ * DESCRIPTION:
+ *       This routine set ingress and egress header mode of a switch port. 
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - GT_TRUE for header mode  or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetHeaderMode
+(
+	IN  GT_QD_DEV   *dev,
+	IN GT_LPORT     port,
+	IN GT_BOOL      mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetHeaderMode Called.\n"));
+
+	/* only devices beyond quarterdeck (6052) has this feature */
+	/* Fullsail (DEV_QD_88E6502) is an exception, and does not support this feature */
+	if(IS_VALID_API_CALL(dev,port, DEV_HEADER|DEV_HEADER_P5|DEV_HEADER_P4P5) != GT_OK)
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if(hwPort < 4)
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5|DEV_HEADER_P4P5))
+		{
+			DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+			return GT_NOT_SUPPORTED;
+		}
+	}
+	else if(hwPort == 4)
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
+		{
+			DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+			return GT_NOT_SUPPORTED;
+		}
+	}
+
+	/* Set the header mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,11,1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetHeaderMode
+ *
+ * DESCRIPTION:
+ *       This routine gets ingress and egress header mode of a switch port. 
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: header mode enabled
+ *	       GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetHeaderMode
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_LPORT    port,
+	OUT GT_BOOL     *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetHeaderMode Called.\n"));
+
+	/* only devices beyond quarterdeck (6052) has this feature */
+	/* Fullsail (DEV_QD_88E602) is an exception, and does not support this feature */
+	if(IS_VALID_API_CALL(dev,port, DEV_HEADER|DEV_HEADER_P5|DEV_HEADER_P4P5) != GT_OK)
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if(hwPort < 4)
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5|DEV_HEADER_P4P5))
+		{
+			DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+			return GT_NOT_SUPPORTED;
+		}
+	}
+	else if(hwPort == 4)
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
+		{
+			DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+			return GT_NOT_SUPPORTED;
+		}
+	}
+
+	/* Get the Header Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 11, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/* the following four APIs are added to support Octane */
+
+/*******************************************************************************
+ * gprtSetProtectedMode
+ *
+ * DESCRIPTION:
+ *       This routine set protected mode of a switch port. 
+ *		When this mode is set to GT_TRUE, frames are allowed to egress port
+ *		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+ *		by the port's VLANTable if 802.1Q is enabled on the port. Both must
+ *		allow the frame to Egress.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - GT_TRUE for protected mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetProtectedMode
+(
+	IN  GT_QD_DEV   *dev,
+	IN GT_LPORT     port,
+	IN GT_BOOL      mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetProtectedMode Called.\n"));
+
+	/* Check if this feature is supported */
+	if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Set the protected mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,3,1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetProtectedMode
+ *
+ * DESCRIPTION:
+ *       This routine gets protected mode of a switch port. 
+ *		When this mode is set to GT_TRUE, frames are allowed to egress port
+ *		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+ *		by the port's VLANTable if 802.1Q is enabled on the port. Both must
+ *		allow the frame to Egress.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: header mode enabled
+ *	       GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetProtectedMode
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_LPORT    port,
+	OUT GT_BOOL     *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetProtectedMode Called.\n"));
+
+	if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the protected Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetForwardUnknown
+ *
+ * DESCRIPTION:
+ *       This routine set Forward Unknown mode of a switch port. 
+ *		When this mode is set to GT_TRUE, normal switch operation occurs.
+ *		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+ *		will not egress out this port.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - GT_TRUE for protected mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetForwardUnknown
+(
+	IN  GT_QD_DEV   *dev,
+	IN GT_LPORT     port,
+	IN GT_BOOL      mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetForwardUnknown Called.\n"));
+
+	if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Set the forward unknown mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetForwardUnknown
+ *
+ * DESCRIPTION:
+ *       This routine gets Forward Unknown mode of a switch port. 
+ *		When this mode is set to GT_TRUE, normal switch operation occurs.
+ *		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+ *		will not egress out this port.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: header mode enabled
+ *	       GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetForwardUnknown
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_LPORT    port,
+	OUT GT_BOOL     *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetForwardUnknown Called.\n"));
+
+	if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the forward unknown Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 2, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetDropOnLock
+ *
+ * DESCRIPTION:
+ *		This routine set the Drop on Lock. When set to one, Ingress frames will
+ *		be discarded if their SA field is not in the ATU's address database.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetDropOnLock
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDropOnLock Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the DropOnLock mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetDropOnLock
+ *
+ * DESCRIPTION:
+ *		This routine gets DropOnLock mode.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: DropOnLock enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetDropOnLock
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetDropOnLock Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the DropOnLock Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 14, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetDoubleTag
+ *
+ * DESCRIPTION:
+ *		This routine set the Ingress Double Tag Mode. When set to one, 
+ *		ingressing frames are examined to see if they contain an 802.3ac tag.
+ *		If they do, the tag is removed and then the frame is processed from
+ *		there (i.e., removed tag is ignored). Essentially, untagged frames
+ *		remain untagged, single tagged frames become untagged and double tagged
+ *		frames become single tagged.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetDoubleTag
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDoubleTag Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the DoubleTag mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,9,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetDoubleTag
+ *
+ * DESCRIPTION:
+ *		This routine gets DoubleTag mode.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: DoubleTag enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetDoubleTag
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetDoubleTag Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the DoubleTag Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 9, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetInterswitchPort
+ *
+ * DESCRIPTION:
+ *		This routine set Interswitch Port. When set to one, 
+ *		it indicates this port is a interswitch port used to communicated with
+ *		CPU or to cascade with another switch device.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetInterswitchPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetInterswitchPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the InterswitchPort.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetInterswithPort
+ *
+ * DESCRIPTION:
+ *		This routine gets InterswitchPort.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: This port is interswitch port,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetInterswitchPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetInterswitchPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the InterswitchPort Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetLearnDisable
+ *
+ * DESCRIPTION:
+ *		This routine enables/disables automatic learning of new source MAC
+ *		addresses on the given port ingress
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for disable or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetLearnDisable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetLearnDisable Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the LearnDisable mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,11,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetLearnDisable
+ *
+ * DESCRIPTION:
+ *		This routine gets LearnDisable setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: Learning disabled on the given port ingress frames,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetLearnDisable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetLearnDisable Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the LearnDisable Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 11, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetIgnoreFCS
+ *
+ * DESCRIPTION:
+ *		This routine sets FCS Ignore mode. When this bit is set to a one,
+ *		the last four bytes of frames received on this port are overwritten with
+ *		a good CRC and the frames will be accepted by the switch.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetIgnoreFCS
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL 		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetIgnoreFCS Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the IgnoreFCS mode.            */
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,data );
+	}
+	else
+	{
+		retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,10,1,data);
+	}
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetIgnoreFCS
+ *
+ * DESCRIPTION:
+ *		This routine gets Ignore FCS setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetIgnoreFCS
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetIgnoreFCS Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the IgnoreFCS Mode.            */
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,&data );
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 1, &data);
+	}
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetVTUPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine sets VTU Priority Override. When this bit is set to a one,
+ *		VTU priority overrides can occur on this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for VTU Priority Override or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetVTUPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetVTUPriOverride Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the IgnoreFCS mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetVTUPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine gets VTU Priority Override setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: VTU Priority Override enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetVTUPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetVTUPriOverride Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the VTUPriOverride Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 14, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetSAPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine sets SA Priority Override. When this bit is set to a one,
+ *		SA priority overrides can occur on this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for SA Priority Override or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetSAPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetSAPriOverride Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the SAPriOverride mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetSAPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine gets SA Priority Override setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: SA Priority Override enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetSAPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetSAPriOverride Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the SAPriOverride Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 13, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetDAPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine sets DA Priority Override. When this bit is set to a one,
+ *		DA priority overrides can occur on this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for DA Priority Override or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetDAPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDAPriOverride Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the DAPriOverride mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetDAPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine gets DA Priority Override setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: DA Priority Override enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetDAPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetDAPriOverride Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the DAPriOverride Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 12, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetCPUPort
+ *
+ * DESCRIPTION:
+ *		This routine sets CPU Port number. When Snooping is enabled on this port
+ *		or when this port is configured as an Interswitch Port and it receives a 
+ *		To_CPU frame, the switch needs to know what port on this device the frame 
+ *		should egress.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		cpuPort - CPU Port number or interswitch port where CPU Port is connected
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetCPUPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_LPORT 	cpuPort
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetCPUPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+	data = (GT_U16)GT_LPORT_2_PORT(cpuPort);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set the CPU Port.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,0,4,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetCPUPort
+ *
+ * DESCRIPTION:
+ *		This routine gets CPU Logical Port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		cpuPort - CPU Port's logical number
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetCPUPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_LPORT 	*cpuLPort
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetCPUPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the CPUPort.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 0, 4, &data);
+
+	*cpuLPort = GT_PORT_2_LPORT((GT_LPORT)data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetLockedPort
+ *
+ * DESCRIPTION:
+ *		This routine sets LockedPort. When it's set to one, CPU directed 
+ *		learning for 802.1x MAC authentication is enabled on this port. In this
+ *		mode, an ATU Miss Violation interrupt will occur when a new SA address
+ *		is received in a frame on this port. Automatically SA learning and 
+ *		refreshing is disabled in this mode.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetLockedPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetLockedPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set Locked Port.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 13, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetLockedPort
+ *
+ * DESCRIPTION:
+ *		This routine gets Locked Port mode for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetLockedPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL  	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetLockedPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the LockedPort. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 13, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetIgnoreWrongData
+ *
+ * DESCRIPTION:
+ *		This routine sets Ignore Wrong Data. If the frame's SA address is found 
+ *		in the database and if the entry is 'static' or if the port is 'locked'
+ *		the source port's bit is checked to insure the SA has been assigned to 
+ *		this port. If the SA is NOT assigned to this port, it is considered an 
+ *		ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+ *		Member Violation interrupt will be generated. If it's set to GT_TRUE,
+ *		the ATU Member Violation error will be masked and ignored.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetIgnoreWrongData
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetIgnoreWrongData Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set IgnoreWrongData.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 12, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetIgnoreWrongData
+ *
+ * DESCRIPTION:
+ *		This routine gets Ignore Wrong Data mode for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetIgnoreWrongData
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetIgnoreWrongData Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the IgnoreWrongData. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 12, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetDiscardTagged
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one, all non-MGMT frames that are processed as 
+ *		Tagged will be discarded as they enter this switch port. Priority only 
+ *		tagged frames (with a VID of 0x000) are considered tagged.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetDiscardTagged
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDiscardTagged Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set DiscardTagged. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 9, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetDiscardTagged
+ *
+ * DESCRIPTION:
+ *		This routine gets DiscardTagged bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetDiscardTagged
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetDiscardTagged Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the DiscardTagged. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 9, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetDiscardUntagged
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one, all non-MGMT frames that are processed as 
+ *		Untagged will be discarded as they enter this switch port. Priority only 
+ *		tagged frames (with a VID of 0x000) are considered tagged.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetDiscardUntagged
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDiscardUntagged Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set DiscardUnTagged. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 8, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetDiscardUntagged
+ *
+ * DESCRIPTION:
+ *		This routine gets DiscardUntagged bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetDiscardUntagged
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetDiscardUnTagged Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the DiscardUnTagged. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 8, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetMapDA
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one, normal switch operation will occur where a 
+ *		frame's DA address is used to direct the frame out the correct port.
+ *		When this be is cleared to a zero, the frame will be sent out the port(s) 
+ *		defined by ForwardUnknown bits or the DefaultForward bits even if the DA 
+ *		is ound in the address database.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetMapDA
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetMapDA Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set MapDA. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 7, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetMapDA
+ *
+ * DESCRIPTION:
+ *		This routine gets MapDA bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetMapDA
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetMapDA Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the MapDA. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 7, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetDefaultForward
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one, normal switch operation will occurs and 
+ *		multicast frames with unknown DA addresses are allowed to egress out this 
+ *		port (assuming the VLAN settings allow the frame to egress this port too).
+ *		When this be is cleared to a zero, multicast frames with unknown DA 
+ *		addresses will not egress out this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetDefaultForward
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDefaultForward Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set DefaultForward. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetDefaultForward
+ *
+ * DESCRIPTION:
+ *		This routine gets DefaultForward bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetDefaultForward
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetDefaultForward Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the DefaultForward. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetEgressMonitorSource
+ *
+ * DESCRIPTION:
+ *		When this be is cleared to a zero, normal network switching occurs.
+ *		When this bit is set to a one, any frame that egresses out this port will
+ *		also be sent to the EgressMonitorDest Port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetEgressMonitorSource
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetEgressMonitorSource Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set EgressMonitorSource. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 5, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetEgressMonitorSource
+ *
+ * DESCRIPTION:
+ *		This routine gets EgressMonitorSource bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetEgressMonitorSource
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetEgressMonitorSource Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the EgressMonitorSource. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 5, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetIngressMonitorSource
+ *
+ * DESCRIPTION:
+ *		When this be is cleared to a zero, normal network switching occurs.
+ *		When this bit is set to a one, any frame that egresses out this port will
+ *		also be sent to the EgressMonitorDest Port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetIngressMonitorSource
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetIngressMonitorSource Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set IngressMonitorSource. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 4, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetIngressMonitorSource
+ *
+ * DESCRIPTION:
+ *		This routine gets IngressMonitorSource bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetIngressMonitorSource
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetIngressMonitorSource Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the IngressMonitorSource. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 4, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetMessagePort
+ *
+ * DESCRIPTION:
+ *		When the Learn2All bit is set to one, learning message frames are 
+ *		generated. These frames will be sent out all ports whose Message Port is 
+ *		set to one.
+ * 		If this feature is used, it is recommended that all Marvell Tag ports, 
+ *		except for the CPU's port, have their MessagePort bit set to one. 
+ *		Ports that are not Marvell Tag ports should not have their Message Port
+ *		bit set to one.
+ *		
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetMessagePort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetMessagePort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set IngressMonitorSource. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 15, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetMessagePort
+ *
+ * DESCRIPTION:
+ *		When the Learn2All bit is set to one, learning message frames are 
+ *		generated. These frames will be sent out all ports whose Message Port is 
+ *		set to one.
+ * 		If this feature is used, it is recommended that all Marvell Tag ports, 
+ *		except for the CPU's port, have their MessagePort bit set to one. 
+ *		Ports that are not Marvell Tag ports should not have their Message Port
+ *		bit set to one.
+ *
+ *		
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetMessagePort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetMessagePort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the IngressMonitorSource. */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 15, 1, &data);
+
+	BIT_2_BOOL(data, *mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetTrunkPort
+ *
+ * DESCRIPTION:
+ *		This function enables/disables and sets the trunk ID.
+ *		
+ * INPUTS:
+ *		port - the logical port number.
+ *		en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+ *			 GT_FALSE, otherwise.
+ *		trunkId - valid ID is 0 ~ 15.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetTrunkPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL 		en,
+	IN GT_U32		trunkId
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetTrunkPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(en, data);
+
+	if(en == GT_TRUE)
+	{
+		/* need to enable trunk. so check the trunkId */
+		if (!IS_TRUNK_ID_VALID(dev, trunkId))
+		{
+			DBG_INFO(("GT_BAD_PARAM\n"));
+			return GT_BAD_PARAM;
+		}
+
+	}
+	else
+	{
+		/* 
+		   Need to reset trunkId for 88E6095 rev0 and it gives no harm to
+		   any other device. So just apply to every device.
+		*/
+		trunkId = 0;
+	}
+
+	/* Set TrunkId. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, (GT_U16)trunkId);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;	
+	}
+
+	/* Set TrunkPort bit. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 14, 1, data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetTrunkPort
+ *
+ * DESCRIPTION:
+ *		This function returns trunk state of the port.
+ *		When trunk is disabled, trunkId field won't have valid value.
+ *		
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE, if the port is a member of a trunk,
+ *			 GT_FALSE, otherwise.
+ *		trunkId - 0 ~ 15, valid only if en is GT_TRUE
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetTrunkPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	OUT GT_BOOL 	*en,
+	OUT GT_U32		*trunkId
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetTrunkPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	data = 0;
+
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 14, 1, &data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data, *en);
+
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, &data);
+	*trunkId = (GT_U32)data;
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+
+/*******************************************************************************
+ * gprtGetSwitchReg
+ *
+ * DESCRIPTION:
+ *       This routine reads Switch Port Registers.
+ *
+ * INPUTS:
+ *       port    - logical port number
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetSwitchReg
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_LPORT     port,
+	IN  GT_U32	     regAddr,
+	OUT GT_U16	     *data
+	)
+{
+	GT_U16          u16Data;           /* The register's read data.    */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetSwitchReg Called.\n"));
+
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get Phy Register. */
+	if(hwReadPortReg(dev,hwPort,(GT_U8)regAddr,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	*data = u16Data;
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gprtSetSwitchReg
+ *
+ * DESCRIPTION:
+ *       This routine writes Switch Port Registers.
+ *
+ * INPUTS:
+ *       port    - logical port number
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetSwitchReg
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_U32			regAddr,
+	IN  GT_U16			data
+	)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+    
+	DBG_INFO(("gprtSetSwitchReg Called.\n"));
+
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the Scheduling bit.              */
+	if(hwWritePortReg(dev,hwPort,(GT_U8)regAddr,data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gprtGetGlobalReg
+ *
+ * DESCRIPTION:
+ *       This routine reads Switch Global Registers.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetGlobalReg
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_U32	     regAddr,
+	OUT GT_U16	     *data
+	)
+{
+	GT_U16          u16Data;           /* The register's read data.    */
+
+	DBG_INFO(("gprtGetGlobalReg Called.\n"));
+
+	/* Get Phy Register. */
+	if(hwReadGlobalReg(dev,(GT_U8)regAddr,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	*data = u16Data;
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gprtSetGlobalReg
+ *
+ * DESCRIPTION:
+ *       This routine writes Switch Global Registers.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetGlobalReg
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_U32			regAddr,
+	IN  GT_U16			data
+	)
+{
+	DBG_INFO(("gprtSetGlobalReg Called.\n"));
+
+	/* Get the Scheduling bit.              */
+	if(hwWriteGlobalReg(dev,(GT_U8)regAddr,data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gprtGetGlobal2Reg
+ *
+ * DESCRIPTION:
+ *       This routine reads Switch Global 2 Registers.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetGlobal2Reg
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_U32	     regAddr,
+	OUT GT_U16	     *data
+	)
+{
+	GT_U16          u16Data;           /* The register's read data.    */
+
+	DBG_INFO(("gprtGetGlobal2Reg Called.\n"));
+
+	/* Get Phy Register. */
+	if(hwReadGlobal2Reg(dev,(GT_U8)regAddr,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	*data = u16Data;
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gprtSetGlobal2Reg
+ *
+ * DESCRIPTION:
+ *       This routine writes Switch Global2 Registers.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetGlobal2Reg
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_U32			regAddr,
+	IN  GT_U16			data
+	)
+{
+	DBG_INFO(("gprtSetGlobal2Reg Called.\n"));
+
+	/* Get the Scheduling bit.              */
+	if(hwWriteGlobal2Reg(dev,(GT_U8)regAddr,data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
Index: linux-2.6.16/drivers/net/marvell/gtPortPav.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPortPav.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,294 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtPortPav.c
+ *
+ * DESCRIPTION:
+ *       API definitions to handle Port Association Vector (0xB).
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+ * gpavSetPAV
+ *
+ * DESCRIPTION:
+ *       This routine sets the Port Association Vector 
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *       pav 	- Port Association Vector 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpavSetPAV
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT	 port,
+	IN GT_U16	 pav
+	)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U16	    hwPav,portNum, hwPortNum;
+
+	DBG_INFO(("gpavSetPAV Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+    
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK ) 
+		return retVal;
+	
+	/*
+	 * translate Logical Port Vector to Physical Port Vector.
+	 */
+	hwPav = 0;
+
+	for(portNum=0; portNum<dev->numOfPorts; portNum++)
+	{
+		if (pav & 0x1)
+		{
+			hwPortNum = GT_LPORT_2_PORT(portNum);
+			hwPav |= (1 << hwPortNum);
+		}
+		pav >>= 1;
+	}
+		
+	/* there are 7 ports in the switch */
+	retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,0,dev->numOfPorts,hwPav);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gpavGetPAV
+ *
+ * DESCRIPTION:
+ *       This routine gets the Port Association Vector 
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *
+ * OUTPUTS:
+ *       pav 	- Port Association Vector 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpavGetPAV
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_U16   *pav
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort, swPort;        /* Physical port.               */
+	GT_U16			lPav,portNum, lPortNum;
+
+	DBG_INFO(("gpavGetPAV Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK ) 
+		return retVal;
+	
+	if(pav == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	swPort = dev->numOfPorts;
+
+	retVal = hwGetPortRegField(dev,phyPort,(GT_U8)QD_REG_PORT_ASSOCIATION,0,swPort,&data );
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	/*
+	 * translate Physical Port Vector to Logical Port Vector.
+	 */
+	lPav = 0;
+	for(portNum=0; portNum<swPort; portNum++)
+	{
+		if (data & 0x1)
+		{
+			lPortNum = (GT_U16)GT_PORT_2_LPORT(portNum);
+			lPav |= (1 << lPortNum);
+		}
+		data >>= 1;
+	}
+		
+	*pav = lPav;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gpavSetIngressMonitor
+ *
+ * DESCRIPTION:
+ *       This routine sets the Ingress Monitor bit in the PAV.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the ingress monitor bit in the PAV
+ *              GT_FALSE: Ingress Monitor enabled 
+ *              GT_TRUE:  Ingress Monitor disabled 
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpavSetIngressMonitor
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("gpavSetIngressMonitorCalled.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+	BOOL_2_BIT(mode,data);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK ) 
+		return retVal;
+	
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENABLE_MONITORING))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,15,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gpavGetIngressMonitor
+ *
+ * DESCRIPTION:
+ *       This routine gets the Ingress Monitor bit in the PAV.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       
+ * OUTPUTS:
+ *       mode - the ingress monitor bit in the PAV
+ *              GT_FALSE: Ingress Monitor enabled 
+ *              GT_TRUE:  Ingress Monitor disabled 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gpavGetIngressMonitor
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_BOOL  *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcGetIngressMonitor Called.\n"));
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK ) 
+		return retVal;
+	
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENABLE_MONITORING))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,15,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
Index: linux-2.6.16/drivers/net/marvell/gtPortRateCtrl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPortRateCtrl.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1251 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtPortRateCtrl.c
+ *
+ * DESCRIPTION:
+ *       API definitions to handle port rate control registers (0xA).
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/*
+  Convert given hw Rate Limit to sw defined Rate Limit.
+  This routine is only for Gigabit Managed Switch Device.
+  If the given device is not an accepted device, it'll simply copy the hw limit 
+  to sw limit.
+*/
+static GT_STATUS cRateLimit(GT_QD_DEV *dev, GT_U32 hwLimit, GT_U32* swLimit)
+{
+	GT_U32 sLimit, hLimit, startLimit, endLimit, i;
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		*swLimit = hwLimit;
+		return GT_OK;
+	}
+
+	if(hwLimit == 0)
+	{
+		*swLimit = GT_NO_LIMIT;
+		return GT_OK;
+	}
+		
+	sLimit = 1000;
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+		hLimit = GT_GET_RATE_LIMIT2(sLimit);
+	else
+		hLimit = GT_GET_RATE_LIMIT(sLimit);
+	if(hLimit == hwLimit)
+	{
+		*swLimit = GT_1M;
+		return GT_OK;
+	}
+	
+	if(hLimit > hwLimit)
+	{
+		startLimit = 2000;
+		endLimit = 256000;
+		*swLimit = GT_2M;
+	}
+	else
+	{
+		startLimit = 128;
+		endLimit = 512;
+		*swLimit = GT_128K;
+	}
+	
+	i = 0;
+	for(sLimit=startLimit;sLimit<=endLimit;sLimit *= 2, i++)
+	{
+		if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+			hLimit = GT_GET_RATE_LIMIT2(sLimit);
+		else
+			hLimit = GT_GET_RATE_LIMIT(sLimit);
+
+		if(hLimit == 0)
+			hLimit = 1;
+
+		if(hLimit == hwLimit)
+		{
+			*swLimit += i;
+			return GT_OK;
+		}
+
+		if(hLimit < hwLimit)
+			break;
+	}
+
+	*swLimit = hwLimit;
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * grcSetLimitMode
+ *
+ * DESCRIPTION:
+ *       This routine sets the port's rate control ingress limit mode.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *       mode 	- rate control ingress limit mode. 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcSetLimitMode
+(
+	IN GT_QD_DEV             *dev,
+	IN GT_LPORT 	     port,
+	IN GT_RATE_LIMIT_MODE    mode
+	)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcSetLimitMode Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+		return retVal;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,(GT_U16)mode );
+	}
+	else
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,(GT_U16)mode );
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * grcGetLimitMode
+ *
+ * DESCRIPTION:
+ *       This routine gets the port's rate control ingress limit mode.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *
+ * OUTPUTS:
+ *       mode 	- rate control ingress limit mode. 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcGetLimitMode
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_RATE_LIMIT_MODE    *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcGetLimitMode Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+		return retVal;
+	
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,&data );
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,&data );
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*mode = data;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * grcSetPri3Rate
+ *
+ * DESCRIPTION:
+ *       This routine sets the ingress data rate limit for priority 3 frames.
+ *       Priority 3 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the priority 3 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri2Rate
+ *              GT_TRUE:  use twice the rate as Pri2Rate
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcSetPri3Rate
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT port,
+	IN GT_BOOL  mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcSetPri3Rate Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+		return retVal;
+	
+	BOOL_2_BIT(mode,data);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,data );
+	}
+	else
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,data);
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * grcGetPri3Rate
+ *
+ * DESCRIPTION:
+ *       This routine gets the ingress data rate limit for priority 3 frames.
+ *       Priority 3 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       
+ * OUTPUTS:
+ *       mode - the priority 3 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri2Rate
+ *              GT_TRUE:  use twice the rate as Pri2Rate
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcGetPri3Rate
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_BOOL  *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcGetPri3Rate Called.\n"));
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+		return retVal;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,&data );
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,&data);
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * grcSetPri2Rate
+ *
+ * DESCRIPTION:
+ *       This routine sets the ingress data rate limit for priority 2 frames.
+ *       Priority 2 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the priority 2 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri1Rate
+ *              GT_TRUE:  use twice the rate as Pri1Rate
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcSetPri2Rate
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT port,
+	IN GT_BOOL  mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcSetPri2Rate Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+		return retVal;
+	
+	BOOL_2_BIT(mode,data);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,data );
+	}
+	else
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,data);
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * grcGetPri2Rate
+ *
+ * DESCRIPTION:
+ *       This routine gets the ingress data rate limit for priority 2 frames.
+ *       Priority 2 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       
+ * OUTPUTS:
+ *       mode - the priority 2 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri1Rate
+ *              GT_TRUE:  use twice the rate as Pri1Rate
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcGetPri2Rate
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_BOOL  *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcGetPri2Rate Called.\n"));
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+		return retVal;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,&data );
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,&data);
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * grcSetPri1Rate
+ *
+ * DESCRIPTION:
+ *       This routine sets the ingress data rate limit for priority 1 frames.
+ *       Priority 1 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the priority 1 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri0Rate
+ *              GT_TRUE:  use twice the rate as Pri0Rate
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcSetPri1Rate
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcSetPri1Rate Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+		return retVal;
+	
+	BOOL_2_BIT(mode,data);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,data );
+	}
+	else
+	{
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,data);
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * grcGetPri1Rate
+ *
+ * DESCRIPTION:
+ *       This routine gets the ingress data rate limit for priority 1 frames.
+ *       Priority 1 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       
+ * OUTPUTS:
+ *       mode - the priority 1 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri0Rate
+ *              GT_TRUE:  use twice the rate as Pri0Rate
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcGetPri1Rate
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_BOOL  *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcGetPri1Rate Called.\n"));
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+		return retVal;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,&data );
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,&data);
+	}
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * grcSetPri0Rate
+ *
+ * DESCRIPTION:
+ *       This routine sets the port's ingress data limit for priority 0 frames.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *       rate    - ingress data rate limit for priority 0 frames. These frames
+ *       	  will be discarded after the ingress rate selected is reached 
+ *       	  or exceeded. 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
+ *			are supported only by Gigabit Ethernet Switch.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcSetPri0Rate
+(
+	IN GT_QD_DEV       *dev,
+	IN GT_LPORT        port,
+	IN GT_PRI0_RATE    rate
+	)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U32			rateLimit, tmpLimit;
+
+	DBG_INFO(("grcSetPri0Rate Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+		return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		switch(rate)
+		{
+		case GT_NO_LIMIT :
+			rateLimit = 0; /* MAX_RATE_LIMIT; */
+			break;
+		case GT_128K :
+			rateLimit = 128;
+			break;
+		case GT_256K :
+			rateLimit = 256;
+			break;
+		case GT_512K :
+			rateLimit = 512;
+			break;
+		case GT_1M :
+			rateLimit = 1000;
+			break;
+		case GT_2M :
+			rateLimit = 2000;
+			break;
+		case GT_4M :
+			rateLimit = 4000;
+			break;
+		case GT_8M :
+			rateLimit = 8000;
+			break;
+		case GT_16M :
+			rateLimit = 16000;
+			break;
+		case GT_32M :
+			rateLimit = 32000;
+			break;
+		case GT_64M :
+			rateLimit = 64000;
+			break;
+		case GT_128M :
+			rateLimit = 128000;
+			break;
+		case GT_256M :
+			rateLimit = 256000;
+			break;
+		default :
+			return GT_BAD_PARAM;
+/*
+  rateLimit = (GT_U32)rate;
+  break;					
+*/
+		}
+
+		if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+			tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
+		else
+			tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
+
+		if((tmpLimit == 0) && (rateLimit != 0))
+			rateLimit = 1;
+		else
+			rateLimit = tmpLimit;
+
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	}
+	else
+	{
+		switch(rate)
+		{
+		case GT_NO_LIMIT :
+		case GT_128K :
+		case GT_256K :
+		case GT_512K :
+		case GT_1M :
+		case GT_2M :
+		case GT_4M :
+		case GT_8M :
+			break;
+		default :
+			return GT_BAD_PARAM;
+		}
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,(GT_U16)rate );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * grcGetPri0Rate
+ *
+ * DESCRIPTION:
+ *       This routine gets the port's ingress data limit for priority 0 frames.
+ *
+ * INPUTS:
+ *       port	- logical port number to set.
+ *
+ * OUTPUTS:
+ *       rate    - ingress data rate limit for priority 0 frames. These frames
+ *       	  will be discarded after the ingress rate selected is reached 
+ *       	  or exceeded. 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
+ *			are supported only by Gigabit Ethernet Switch.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcGetPri0Rate
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_PRI0_RATE    *rate
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U32			tmpLimit;
+
+	DBG_INFO(("grcGetPri0Rate Called.\n"));
+
+	if(rate == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+		return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		tmpLimit = 0;
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,(GT_U16*)&tmpLimit );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+
+		cRateLimit(dev, tmpLimit, (GT_U32*)rate);
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,&data );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+		*rate = data;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * grcSetBytesCount
+ *
+ * DESCRIPTION:
+ *       This routine sets the byets to count for limiting needs to be determined
+ *
+ * INPUTS:
+ *       port	  - logical port number to set.
+ *    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+ *    		    GT_FALSE: otherwise
+ *    	countIFG  - GT_TRUE: To count IFG bytes
+ *    		    GT_FALSE: otherwise
+ *    	countPre  - GT_TRUE: To count Preamble bytes
+ *    		    GT_FALSE: otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcSetBytesCount
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL 	 limitMGMT,
+	IN GT_BOOL 	 countIFG,
+	IN GT_BOOL 	 countPre
+	)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U16          data;           /* data for bytes count         */
+
+	DBG_INFO(("grcSetBytesCount Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+		return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		BOOL_2_BIT(limitMGMT,data);
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,data );
+		if (retVal != GT_OK)
+			return retVal;
+
+		data = 0;
+		if( countIFG == GT_TRUE ) data |= 2;
+		if( countPre == GT_TRUE ) data |= 1;
+
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,data );
+	}
+	else
+	{
+		data = 0;
+		if(	limitMGMT == GT_TRUE ) data |=4;
+		if(	 countIFG == GT_TRUE ) data |=2;
+		if(	 countPre == GT_TRUE ) data |=1;
+
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,data );
+	}
+
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * grcGetBytesCount
+ *
+ * DESCRIPTION:
+ *       This routine gets the byets to count for limiting needs to be determined
+ *
+ * INPUTS:
+ *       port	- logical port number 
+ *
+ * OUTPUTS:
+ *    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+ *    		    GT_FALSE: otherwise
+ *    	countIFG  - GT_TRUE: To count IFG bytes
+ *    		    GT_FALSE: otherwise
+ *    	countPre  - GT_TRUE: To count Preamble bytes
+ *    		    GT_FALSE: otherwise
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcGetBytesCount
+(	
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL 	 *limitMGMT,
+	IN GT_BOOL 	 *countIFG,
+	IN GT_BOOL 	 *countPre
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+
+	DBG_INFO(("grcGetBytesCount Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+		return retVal;
+
+	if (limitMGMT == NULL || countIFG == NULL || countPre == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+   	*limitMGMT = *countIFG = *countPre = GT_FALSE;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,&data );
+		if (retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+
+		BIT_2_BOOL(data,*limitMGMT);
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,&data );
+		if (retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+
+		if( data & 0x2 ) *countIFG = GT_TRUE;
+		if( data & 0x1 ) *countPre = GT_TRUE;
+
+	}
+	else
+	{
+
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,&data );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+
+		if ( data & 4 ) *limitMGMT = GT_TRUE;
+		if ( data & 2 ) *countIFG  = GT_TRUE;
+		if ( data & 1 ) *countPre  = GT_TRUE;
+	
+	}
+	    
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * grcSetEgressRate
+ *
+ * DESCRIPTION:
+ *       This routine sets the port's egress data limit.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *       rate    - egress data rate limit.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+ *			are supported only by Gigabit Ethernet Switch.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS grcSetEgressRate
+(
+	IN GT_QD_DEV       *dev,
+	IN GT_LPORT        port,
+	IN GT_EGRESS_RATE  rate
+	)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U32			rateLimit, tmpLimit;
+
+	DBG_INFO(("grcSetEgressRate Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_EGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+		return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		switch(rate)
+		{
+		case GT_NO_LIMIT :
+			rateLimit = 0; /* MAX_RATE_LIMIT; */
+			break;
+		case GT_128K :
+			rateLimit = 128;
+			break;
+		case GT_256K :
+			rateLimit = 256;
+			break;
+		case GT_512K :
+			rateLimit = 512;
+			break;
+		case GT_1M :
+			rateLimit = 1000;
+			break;
+		case GT_2M :
+			rateLimit = 2000;
+			break;
+		case GT_4M :
+			rateLimit = 4000;
+			break;
+		case GT_8M :
+			rateLimit = 8000;
+			break;
+		case GT_16M :
+			rateLimit = 16000;
+			break;
+		case GT_32M :
+			rateLimit = 32000;
+			break;
+		case GT_64M :
+			rateLimit = 64000;
+			break;
+		case GT_128M :
+			rateLimit = 128000;
+			break;
+		case GT_256M :
+			rateLimit = 256000;
+			break;
+		default :
+			return GT_BAD_PARAM;
+/*
+  rateLimit = (GT_U32)rate;
+  break;					
+*/
+		}
+
+		if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+			tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
+		else
+			tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
+
+		if((tmpLimit == 0) && (rateLimit != 0))
+			rateLimit = 1;
+		else
+			rateLimit = tmpLimit;
+
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	}
+	else
+	{
+		switch(rate)
+		{
+		case GT_NO_LIMIT :
+		case GT_128K :
+		case GT_256K :
+		case GT_512K :
+		case GT_1M :
+		case GT_2M :
+		case GT_4M :
+		case GT_8M :
+			break;
+		default :
+			return GT_BAD_PARAM;
+		}
+		retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,(GT_U16)rate );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * grcGetEgressRate
+ *
+ * DESCRIPTION:
+ *       This routine gets the port's egress data limit.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *
+ * OUTPUTS:
+ *       rate    - egress data rate limit.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+ *			are supported only by Gigabit Ethernet Switch.
+ *
+ *******************************************************************************/
+GT_STATUS grcGetEgressRate
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_LPORT port,
+	OUT GT_EGRESS_RATE  *rate
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U32			tmpLimit;
+
+	DBG_INFO(("grcGetEgressRate Called.\n"));
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_EGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+		return retVal;
+	
+	if(rate == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		tmpLimit = 0;
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16*)&tmpLimit );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+
+		cRateLimit(dev, tmpLimit, (GT_U32*)rate);
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,&data );
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+		
+		*rate = data;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
Index: linux-2.6.16/drivers/net/marvell/gtPortRmon.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPortRmon.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,943 @@
+#include <linux/marvell/Copyright.h>
+
+/*******************************************************************************
+ * gtPortCounter.c
+ *
+ * DESCRIPTION:
+ *       API definitions for RMON counters
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtSem.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* STATS operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS statsOperationPerform
+(
+	IN   GT_QD_DEV            *dev,
+	IN   GT_STATS_OPERATION   statsOp,
+	IN   GT_U8                port,
+	IN   GT_STATS_COUNTERS    counter,
+	OUT  GT_VOID              *statsData
+	);
+
+static GT_STATUS statsCapture
+(
+	IN GT_QD_DEV  *dev,
+	IN GT_U8      port
+	);
+
+static GT_STATUS statsReadCounter
+(
+	IN   GT_QD_DEV		*dev,
+	IN   GT_U32			counter,
+	OUT  GT_U32			*statsData
+	);
+
+
+/*******************************************************************************
+ * gstatsFlushAll
+ *
+ * DESCRIPTION:
+ *       Flush All counters for all ports.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsFlushAll
+(
+        IN GT_QD_DEV  *dev
+	)
+{
+	GT_STATUS       	retVal;
+
+	DBG_INFO(("gstatsFlushAll Called.\n"));
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_FLUSH_ALL,0,0,NULL);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+ * gstatsFlushPort
+ *
+ * DESCRIPTION:
+ *       Flush All counters for a given port.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsFlushPort
+(
+	IN GT_QD_DEV  *dev,
+	IN GT_LPORT	  port
+	)
+{
+	GT_STATUS	retVal;
+	GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsFlushPort Called.\n"));
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_FLUSH_PORT,hwPort,0,NULL);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+ * gstatsGetPortCounter
+ *
+ * DESCRIPTION:
+ *		This routine gets a specific counter of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		counter - the counter which will be read
+ *
+ * OUTPUTS:
+ *		statsData - points to 32bit data storage for the MIB counter
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsGetPortCounter
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS	counter,
+	OUT GT_U32			*statsData
+	)
+{
+	GT_STATUS	retVal;
+	GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsFlushPort Called.\n"));
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Gigabit Switch does not support this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+ * gstatsGetPortAllCounters
+ *
+ * DESCRIPTION:
+ *       This routine gets all counters of the given port
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters
+(
+	IN  GT_QD_DEV               *dev,
+	IN  GT_LPORT		port,
+	OUT GT_STATS_COUNTER_SET	*statsCounterSet
+	)
+{
+	GT_STATUS	retVal;
+	GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsFlushPort Called.\n"));
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Gigabit Switch does not support this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+ * gstatsGetPortCounter2
+ *
+ * DESCRIPTION:
+ *		This routine gets a specific counter of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		counter - the counter which will be read
+ *
+ * OUTPUTS:
+ *		statsData - points to 32bit data storage for the MIB counter
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsGetPortCounter2
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS2	counter,
+	OUT GT_U32			*statsData
+	)
+{
+	GT_STATUS	retVal;
+	GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsGetPortCounters2 Called.\n"));
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+ * gstatsGetPortAllCounters2
+ *
+ * DESCRIPTION:
+ *		This routine gets all counters of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters2
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	OUT GT_STATS_COUNTER_SET2	*statsCounterSet
+	)
+{
+	GT_STATUS	retVal;
+	GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsGetPortAllCounters2 Called.\n"));
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+ * gstatsGetPortCounter3
+ *
+ * DESCRIPTION:
+ *		This routine gets a specific counter of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		counter - the counter which will be read
+ *
+ * OUTPUTS:
+ *		statsData - points to 32bit data storage for the MIB counter
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsGetPortCounter3
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS3	counter,
+	OUT GT_U32			*statsData
+	)
+{
+	GT_STATUS	retVal;
+	GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsGetPortCounters3 Called.\n"));
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Only 88E6093 Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+ * gstatsGetPortAllCounters3
+ *
+ * DESCRIPTION:
+ *		This routine gets all counters of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters3
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	OUT GT_STATS_COUNTER_SET3	*statsCounterSet
+	)
+{
+	GT_STATUS	retVal;
+	GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsGetPortAllCounters3 Called.\n"));
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+ * gstatsGetHistogramMode
+ *
+ * DESCRIPTION:
+ *		This routine gets the Histogram Counters Mode.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+ *					and GT_COUNT_RX_TX)
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_BAD_PARAM    - on bad parameter
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsGetHistogramMode
+(
+	IN  GT_QD_DEV				*dev,
+	OUT GT_HISTOGRAM_MODE	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gstatsGetHistogramMode Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Get the Histogram mode bit.                */
+	retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,10,2,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*mode = data - 1; /* Software definition starts from 0 ~ 2, 
+			     while hardware supports the values from 1 to 3 */
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gstatsSetHistogramMode
+ *
+ * DESCRIPTION:
+ *		This routine sets the Histogram Counters Mode.
+ *
+ * INPUTS:
+ *		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+ *					and GT_COUNT_RX_TX)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_BAD_PARAM    - on bad parameter
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gstatsSetHistogramMode
+(
+	IN GT_QD_DEV 				*dev,
+	IN GT_HISTOGRAM_MODE		mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gstatsSetHistogramMode Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch (mode)
+	{
+	case GT_COUNT_RX_ONLY:
+	case GT_COUNT_TX_ONLY:
+	case GT_COUNT_RX_TX:
+		break;
+	default:
+	        DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = (GT_U16)mode + 1;
+
+	/* Set the Histogram mode bit.                */
+	retVal = hwSetGlobalRegField(dev,QD_REG_STATS_OPERATION,10,2,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+ * statsOperationPerform
+ *
+ * DESCRIPTION:
+ *       This function is used by all stats control functions, and is responsible
+ *       to write the required operation into the stats registers.
+ *
+ * INPUTS:
+ *       statsOp       - The stats operation bits to be written into the stats
+ *                     operation register.
+ *       port        - port number
+ *       counter     - counter to be read if it's read operation
+ *
+ * OUTPUTS:
+ *       statsData   - points to the data storage where the MIB counter will be saved.
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+
+static GT_STATUS statsOperationPerform
+(
+	IN   GT_QD_DEV            *dev,
+	IN   GT_STATS_OPERATION   statsOp,
+	IN   GT_U8                port,
+	IN   GT_STATS_COUNTERS    counter,
+	OUT  GT_VOID              *statsData
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data,histoData; /* Data to be set into the      */
+	/* register.                    */
+	GT_U32 statsCounter;
+	GT_U32 lastCounter;
+
+	gtSemTake(dev,dev->statsRegsSem,OS_WAIT_FOREVER);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		lastCounter = (GT_U32)STATS_OutDiscards;
+	}
+	else
+	{
+		lastCounter = (GT_U32)STATS2_Late;
+	}
+
+	/* Wait until the stats in ready. */
+	data = 1;
+	while(data == 1)
+	{
+		retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->statsRegsSem);
+			return retVal;
+		}
+	}
+
+	/* Get the Histogram mode bit.                */
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+	if(retVal != GT_OK)
+	{
+		gtSemGive(dev,dev->statsRegsSem);
+		return retVal;
+	}
+	
+	histoData &= 0xC00;
+
+	/* Set the STAT Operation register */
+	switch (statsOp)
+	{
+	case STATS_FLUSH_ALL:
+		data = (1 << 15) | (GT_STATS_FLUSH_ALL << 12) | histoData;
+		retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+		gtSemGive(dev,dev->statsRegsSem);
+		return retVal;
+
+	case STATS_FLUSH_PORT:
+		data = (1 << 15) | (GT_STATS_FLUSH_PORT << 12) | port | histoData;
+		retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+		gtSemGive(dev,dev->statsRegsSem);
+		return retVal;
+
+	case STATS_READ_COUNTER:
+		retVal = statsCapture(dev,port);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->statsRegsSem);
+			return retVal;
+		}
+
+		retVal = statsReadCounter(dev,counter,(GT_U32*)statsData);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->statsRegsSem);
+			return retVal;
+		}
+		break;
+
+	case STATS_READ_ALL:
+		retVal = statsCapture(dev,port);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->statsRegsSem);
+			return retVal;
+		}
+
+		for(statsCounter=0; statsCounter<=lastCounter; statsCounter++)
+		{
+			retVal = statsReadCounter(dev,statsCounter,((GT_U32*)statsData + statsCounter));
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->statsRegsSem);
+				return retVal;
+			}
+		}
+		break;
+
+	default:
+			
+		gtSemGive(dev,dev->statsRegsSem);
+		return GT_FAIL;
+	}
+
+	gtSemGive(dev,dev->statsRegsSem);
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * statsCapture
+ *
+ * DESCRIPTION:
+ *       This function is used to capture all counters of a port.
+ *
+ * INPUTS:
+ *       port        - port number
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *		If Semaphore is used, Semaphore should be acquired before this function call.
+ *******************************************************************************/
+static GT_STATUS statsCapture
+(
+	IN GT_QD_DEV            *dev,
+	IN GT_U8 		    port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data, histoData;/* Data to be set into the      */
+	/* register.                    */
+
+	/* Get the Histogram mode bit.                */
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+	if(retVal != GT_OK)
+	{
+		gtSemGive(dev,dev->statsRegsSem);
+		return retVal;
+	}
+	
+	histoData &= 0xC00;
+
+	data = 1;
+   	while(data == 1)
+	{
+		retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+		if(retVal != GT_OK)
+		{
+			return retVal;
+		}
+   	}
+
+	data = (1 << 15) | (GT_STATS_CAPTURE_PORT << 12) | port | histoData;
+	retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+	if(retVal != GT_OK)
+	{
+		return retVal;
+	}
+
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+ * statsReadCounter
+ *
+ * DESCRIPTION:
+ *       This function is used to read a captured counter.
+ *
+ * INPUTS:
+ *       counter     - counter to be read if it's read operation
+ *
+ * OUTPUTS:
+ *       statsData   - points to the data storage where the MIB counter will be saved.
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *		If Semaphore is used, Semaphore should be acquired before this function call.
+ *******************************************************************************/
+static GT_STATUS statsReadCounter
+(
+	IN   GT_QD_DEV      *dev,
+	IN   GT_U32			counter,
+	OUT  GT_U32		    *statsData
+	)
+{
+	GT_STATUS   retVal;         /* Functions return value.            */
+	GT_U16      data, histoData;/* Data to be set into the  register. */ 
+	GT_U16	counter3_2;     /* Counter Register Bytes 3 & 2       */
+	GT_U16	counter1_0;     /* Counter Register Bytes 1 & 0       */
+
+	/* Get the Histogram mode bit.                */
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+	if(retVal != GT_OK)
+	{
+		gtSemGive(dev,dev->statsRegsSem);
+		return retVal;
+	}
+	
+	histoData &= 0xC00;
+
+	data = 1;
+   	while(data == 1)
+	{
+		retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+		if(retVal != GT_OK)
+		{
+			return retVal;
+		}
+   	}
+
+	data = (1 << 15) | (GT_STATS_READ_COUNTER << 12) | counter | histoData;
+	retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+	if(retVal != GT_OK)
+	{
+		return retVal;
+	}
+
+	data = 1;
+   	while(data == 1)
+	{
+		retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+		if(retVal != GT_OK)
+		{
+			return retVal;
+		}
+   	}
+
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
+	if(retVal != GT_OK)
+	{
+		return retVal;
+	}
+
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
+	if(retVal != GT_OK)
+	{
+		return retVal;
+	}
+
+	*statsData = (counter3_2 << 16) | counter1_0;
+
+	return GT_OK;
+
+}
Index: linux-2.6.16/drivers/net/marvell/gtPortStat.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPortStat.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,342 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtPortStat.c
+ *
+ * DESCRIPTION:
+ *       API implementation for switch port rx/tx counters.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+ * gprtSetCtrMode
+ *
+ * DESCRIPTION:
+ *       This routine sets the port rx/tx counters mode of operation.
+ *
+ * INPUTS:
+ *       mode  - the counter mode.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetCtrMode
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_CTR_MODE  mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gprtSetCtrMode Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,(GT_U16)mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("gprtSetCtrMode Failed .\n"));
+		return GT_FAIL;
+	}
+
+	DBG_INFO(("gprtSetCtrMode OK .\n"));
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtClearAllCtr
+ *
+ * DESCRIPTION:
+ *       This routine clears all port rx/tx counters.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtClearAllCtr
+(
+	IN GT_QD_DEV    *dev
+	)
+{
+	IN GT_STATUS     retVal;         /* Functions return value.      */
+	IN GT_U16        mode;           /* hold counters current mode   */
+
+	DBG_INFO(("gprtClearAllCtr Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* get counter current mode  */
+	if(hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,&mode) != GT_OK)
+	{
+		DBG_INFO(("Failed (Get field).\n"));
+		return GT_FAIL;
+	}
+	/* write opposite value to reset counter */
+	if(hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,(GT_U16)(1 - mode)) != GT_OK)
+	{
+		DBG_INFO(("Failed (Get field).\n"));
+		return GT_FAIL;
+	}
+	/* restore counters mode */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,mode);
+
+	DBG_INFO(("OK.\n"));
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetPortCtr
+ *
+ * DESCRIPTION:
+ *       This routine gets the port rx/tx counters.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       ctr - the counters value.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPortCtr
+(
+	IN  GT_QD_DEV       *dev,
+	IN  GT_LPORT        port,
+	OUT GT_PORT_STAT    *ctr
+	)
+{
+	GT_U16          count;          /* counters current value       */
+	GT_U8           hwPort;         /* physical port number         */
+
+	DBG_INFO(("gprtGetPortCtr Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(ctr  == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* get rx counter value  */
+	if(hwReadPortReg(dev,hwPort, QD_REG_RX_COUNTER, &count) != GT_OK)
+	{
+		DBG_INFO(("Failed (Read Rx).\n"));
+		return GT_FAIL;
+	}
+	ctr->rxCtr = count;
+	/* get tx counter value  */
+	if(hwReadPortReg(dev,hwPort, QD_REG_TX_COUNTER, &count) != GT_OK)
+	{
+		DBG_INFO(("Failed (Read Tx).\n"));
+		return GT_FAIL;
+	}
+	ctr->txCtr = count;
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gprtGetPortCtr2
+ *
+ * DESCRIPTION:
+ *       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       ctr - the counters value.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPortCtr2
+(
+	IN  GT_QD_DEV       *dev,
+	IN  GT_LPORT        port,
+	OUT GT_PORT_STAT2   *ctr
+	)
+{
+	GT_U16          count;          /* counters current value       */
+	GT_U8           hwPort;         /* physical port number         */
+
+	DBG_INFO(("gprtGetPortCtr2 Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(ctr  == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* get InDiscard Low counter value  */
+	if(hwReadPortReg(dev,hwPort, QD_REG_INDISCARD_LO_COUNTER, &count) != GT_OK)
+	{
+		DBG_INFO(("Failed (Read inDiscardLo).\n"));
+		return GT_FAIL;
+	}
+	ctr->inDiscardLo = count;
+	/* get InDiscard High counter value  */
+	if(hwReadPortReg(dev,hwPort, QD_REG_INDISCARD_HI_COUNTER, &count) != GT_OK)
+	{
+		DBG_INFO(("Failed (Read inDiscardHi).\n"));
+		return GT_FAIL;
+	}
+	ctr->inDiscardHi = count;
+
+	/* get InFiltered counter value  */
+	if(hwReadPortReg(dev,hwPort, QD_REG_INFILTERED_COUNTER, &count) != GT_OK)
+	{
+		DBG_INFO(("Failed (Read inFiltered).\n"));
+		return GT_FAIL;
+	}
+	ctr->inFiltered = count;
+
+	/* get OutFiltered counter value  */
+	if(hwReadPortReg(dev,hwPort, QD_REG_OUTFILTERED_COUNTER, &count) != GT_OK)
+	{
+		DBG_INFO(("Failed (Read outFiltered).\n"));
+		return GT_FAIL;
+	}
+	ctr->outFiltered = count;
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+#ifdef DEBUG_FEATURE /* this is a debug feature*/
+/*******************************************************************************
+ * gprtGetPortQueueCtr
+ *
+ * DESCRIPTION:
+ *       This routine gets the port queue counters.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       ctr - the counters value.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPortQueueCtr
+(
+	IN  GT_QD_DEV       *dev,
+	IN  GT_LPORT        port,
+	OUT GT_PORT_Q_STAT  *ctr
+	)
+{
+	GT_U16          count;          /* counters current value       */
+	GT_U8           hwPort;         /* physical port number         */
+
+	DBG_INFO(("gprtGetPortQueueCtr Called.\n"));
+
+	if(ctr  == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* translate logical port to physical port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* get queue counter value  */
+	if(hwReadPortReg(dev,hwPort, QD_REG_Q_COUNTER, &count) != GT_OK)
+	{
+		DBG_INFO(("Failed (Read Rx).\n"));
+		return GT_FAIL;
+	}
+
+	/* the fist 5 bits(4:0) are OutQ_Size */
+	ctr->OutQ_Size = count & 0x1F;
+
+	/* the Rsv_Size are bits 15:8 */
+	ctr->Rsv_Size  = count >> 8;
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+#endif 
Index: linux-2.6.16/drivers/net/marvell/gtPortStatus.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtPortStatus.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1385 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtPortCtrl.c
+ *
+ * DESCRIPTION:
+ *       API implementation for switch port status.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+ * gprtGetPartnerLinkPause
+ *
+ * DESCRIPTION:
+ *       This routine retrives the link partner pause state.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - GT_TRUE for enable  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPartnerLinkPause
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetPartnerLinkPause Called.\n"));
+
+	/* Gigabit Switch does not support this status. gprtGetPauseEn is supported instead. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,15,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetPauseEn
+ *
+ * DESCRIPTION:
+ *		This routine retrives the link pause state.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE for enable or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		If set MAC Pause (for Full Duplex flow control) is implemented in the
+ *		link partner and in MyPause
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPauseEn
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetPauseEn Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,15,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetSelfLinkPause
+ *
+ * DESCRIPTION:
+ *       This routine retrives the link pause state.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - GT_TRUE for enable  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetSelfLinkPause
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetSelfLinkPause Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,14,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetResolve
+ *
+ * DESCRIPTION:
+ *       This routine retrives the resolve state.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - GT_TRUE for Done  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetResolve
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetResolve Called.\n"));
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,13,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetHdFlow
+ *
+ * DESCRIPTION:
+ *		This routine retrives the half duplex flow control value.
+ *		If set, Half Duplex back pressure will be used on this port if this port
+ *		is in a half duplex mode.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE for enable or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetHdFlow
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetHdFlow Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,13,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetPHYDetect
+ *
+ * DESCRIPTION:
+ *		This routine retrives the information regarding PHY detection.
+ *		If set, An 802.3 PHY is attached to this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if connected or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPHYDetect
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetPHYDetect Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,12,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtSetPHYDetect
+ *
+ * DESCRIPTION:
+ *		This routine sets PHYDetect bit which make PPU change its polling.
+ *		PPU's pool routine uses these bits to determine which port's to poll
+ *		PHYs on for Link, Duplex, Speed, and Flow Control.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE or GT_FALSE
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This function should not be called if gsysGetPPUState returns 
+ *		PPU_STATE_ACTIVE.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetPHYDetect
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_BOOL  	state
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetPHYDetect Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Set the PHY Detect bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,12,1,(GT_U16)state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetLinkState
+ *
+ * DESCRIPTION:
+ *       This routine retrives the link state.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - GT_TRUE for Up  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetLinkState
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U8			bitNumber;
+
+	DBG_INFO(("gprtGetLinkState Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		bitNumber = 11;
+	}
+	else
+	{
+		bitNumber = 12;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,bitNumber,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetPortMode
+ *
+ * DESCRIPTION:
+ *       This routine retrives the port mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for MII  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPortMode
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetPortMode Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,11,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetPhyMode
+ *
+ * DESCRIPTION:
+ *       This routine retrives the PHY mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for MII PHY  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetPhyMode
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetPhyMode Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,10,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetDuplex
+ *
+ * DESCRIPTION:
+ *       This routine retrives the port duplex mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for Full  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetDuplex
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U8			bitNumber;
+
+	DBG_INFO(("gprtGetDuplex Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		bitNumber = 10;
+	}
+	else
+	{
+		bitNumber = 9;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,bitNumber,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetSpeed
+ *
+ * DESCRIPTION:
+ *       This routine retrives the port speed.
+ *
+ * INPUTS:
+ *       speed - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for 100Mb/s  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetSpeed
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *speed
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetSpeed Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+	/* Get the force flow control bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,1,&data);
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *speed);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetSpeedMode
+ *
+ * DESCRIPTION:
+ *       This routine retrives the port speed.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_PORT_SPEED_MODE type.
+ *					(PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, or PORT_SPEED_10_MBPS)
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetSpeedMode
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_PORT_SPEED_MODE   *speed
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetSpeed Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		/* Get the force flow control bit.  */
+		retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,2,&data);
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,1,&data);
+	}
+
+	*speed = (GT_PORT_SPEED_MODE)data;
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtSetDuplex
+ *
+ * DESCRIPTION:
+ *       This routine sets the duplex mode of MII/SNI/RMII ports.
+ *
+ * INPUTS:
+ *       port - 	the logical port number.
+ *				(for FullSail, it will be port 2, and for ClipperShip, 
+ *				it could be either port 5 or port 6.)
+ *       mode -  GT_TRUE for Full Duplex,
+ *				GT_FALSE for Half Duplex.
+ *
+ * OUTPUTS: None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetDuplex
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	IN  GT_BOOL   mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDuplex Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MII_DUPLEX_CONFIG)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* check if phy is not configurable. */
+	if(IS_CONFIGURABLE_PHY(dev, hwPort))
+	{
+		/* 
+		 * phy is configurable. this function is not for the port where phy 
+		 * can be configured.
+		 */
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set the duplex mode. */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,9,1,(GT_U16)mode);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtGetHighErrorRate
+ *
+ * DESCRIPTION:
+ *		This routine retrives the PCS High Error Rate.
+ *		This routine returns GT_TRUE if the rate of invalid code groups seen by
+ *		PCS has exceeded 10 to the power of -11.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE or GT_FALSE
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetHighErrorRate
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetHighErrorRate Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the high error rate bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetMGMII
+ *
+ * DESCRIPTION:
+ *		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+ *		detected connected to this port, the SERDES interface between this port
+ *		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+ *		detected connected to this port, the SERDES interface between this port 
+ *		and the PHY will be MGMII. When no PHY is detected on this port and the 
+ *		SERDES interface is being used, it will be configured in 1000Base-X mode.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE or GT_FALSE
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetMGMII
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetMGMII Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the high error rate bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gprtSetMGMII
+ *
+ * DESCRIPTION:
+ *		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+ *		detected connected to this port, the SERDES interface between this port
+ *		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+ *		detected connected to this port, the SERDES interface between this port 
+ *		and the PHY will be MGMII. When no PHY is detected on this port and the 
+ *		SERDES interface is being used, it will be configured in 1000Base-X mode.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE or GT_FALSE
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtSetMGMII
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_BOOL  	state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetMGMII Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	BOOL_2_BIT(state,data);
+
+	/* Get the high error rate bit.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gprtGetTxPaused
+ *
+ * DESCRIPTION:
+ *		This routine retrives Transmit Pause state.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
+ *				  GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetTxPaused
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetTxPaused Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the TxPaused bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,5,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetFlowCtrl
+ *
+ * DESCRIPTION:
+ *		This routine retrives Flow control state.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if Rx MAC determines that no more data should be 
+ *					entering this port.
+ *				  GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetFlowCtrl
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetFlowCtrl Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the FlowCtrl bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,4,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetC_Duplex
+ *
+ * DESCRIPTION:
+ *		This routine retrives Port 9's duplex configuration mode determined
+ *		at reset.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if configured as Full duplex operation
+ *				  GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		Return value is valid only if the given port is 9.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetC_Duplex
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetC_Duplex Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the C_Duplex bit.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,3,1,&data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *state);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+/*******************************************************************************
+ * gprtGetC_Mode
+ *
+ * DESCRIPTION:
+ *		This routine retrives port's interface type configuration mode 
+ *		determined at reset.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - one of value in GT_PORT_CONFIG_MODE enum type
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		Return value is valid only if the given port is 9.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gprtGetC_Mode
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_PORT_CONFIG_MODE   *state
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtGetC_Mode Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Get the C_Mode bits.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,0,3,&data);
+
+	/* translate binary to BOOL  */
+	*state = (GT_PORT_CONFIG_MODE)data;
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	/* return */
+	return retVal;
+}
+
+
+
Index: linux-2.6.16/drivers/net/marvell/gtQosMap.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtQosMap.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,910 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtQosMap.c
+ *
+ * DESCRIPTION:
+ *       API implementation for qos mapping.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+ * gcosSetPortDefaultTc
+ *
+ * DESCRIPTION:
+ *       Sets the default traffic class for a specific port.
+ *
+ * INPUTS:
+ *       port      - logical port number
+ *       trafClass - default traffic class of a port.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
+ *		family supports 3 bits (0 ~ 7)
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gcosSetPortDefaultTc
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_LPORT   port,
+	IN GT_U8      trafClass
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gcosSetPortDefaultTc Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+		return retVal;
+	
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		/* Set the default port pri.  */
+		retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,13,3,trafClass);
+	}
+	else
+	{
+		/* Set the default port pri.  */
+		retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,14,2,trafClass);
+	}
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gcosGetPortDefaultTc
+ *
+ * DESCRIPTION:
+ *       Gets the default traffic class for a specific port.
+ *
+ * INPUTS:
+ *       port      - logical port number
+ *
+ * OUTPUTS:
+ *       trafClass - default traffic class of a port.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
+ *		family supports 3 bits (0 ~ 7)
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gcosGetPortDefaultTc
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_LPORT   port,
+	OUT GT_U8     *trafClass
+	)
+{
+	GT_U16			data;
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gcosSetPortDefaultTc Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+		return retVal;
+	
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		/* Get the default port pri.  */
+		retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,13,3,&data);
+	}
+	else
+	{
+		/* Get the default port pri.  */
+		retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,14,2,&data);
+	}
+
+	*trafClass = (GT_U8)data;
+	
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gqosSetPrioMapRule
+ *
+ * DESCRIPTION:
+ *       This routine sets priority mapping rule.
+ *		If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6, 
+ *		and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are 
+ *		enabled, then priority selection is made based on this setup.
+ *		If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
+ *		If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gqosSetPrioMapRule
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_LPORT   port,
+	IN GT_BOOL    mode
+	)
+{
+	GT_U16          data;           /* temporary data buffer */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gqosSetPrioMapRule Called.\n"));
+	/* translate bool to binary */
+	BOOL_2_BIT(mode, data);
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+		return retVal;
+	
+	/* Set the TagIfBoth.  */
+	retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,6,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gqosGetPrioMapRule
+ *
+ * DESCRIPTION:
+ *       This routine gets priority mapping rule.
+ *		If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6, 
+ *		and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are 
+ *		enabled, then priority selection is made based on this setup.
+ *		If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
+ *		If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gqosGetPrioMapRule
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *mode
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gqosGetPrioMapRule Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+		return retVal;
+	
+	/* get the TagIfBoth.  */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,6,1,&data);
+	/* translate bool to binary */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gqosIpPrioMapEn
+ *
+ * DESCRIPTION:
+ *       This routine enables the IP priority mapping.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gqosIpPrioMapEn
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_LPORT   port,
+	IN GT_BOOL    en
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gqosIpPrioMapEn Called.\n"));
+	/* translate bool to binary */
+	BOOL_2_BIT(en, data);
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+		return retVal;
+	
+	/* Set the useIp.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,5,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+
+/*******************************************************************************
+ * gqosGetIpPrioMapEn
+ *
+ * DESCRIPTION:
+ *       This routine return the IP priority mapping state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gqosGetIpPrioMapEn
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *en
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gqosGetIpPrioMapEn Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+		return retVal;
+	
+	/* Get the UseIp.  */
+	retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,5,1,&data);
+	/* translate bool to binary */
+	BIT_2_BOOL(data, *en);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+
+/*******************************************************************************
+ * gqosUserPrioMapEn
+ *
+ * DESCRIPTION:
+ *       This routine enables the user priority mapping.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gqosUserPrioMapEn
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_LPORT   port,
+	IN GT_BOOL    en
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gqosUserPrioMapEn Called.\n"));
+	/* translate bool to binary */
+	BOOL_2_BIT(en, data);
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+		return retVal;
+	
+	/* Set the useTag.  */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,4,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+
+/*******************************************************************************
+ * gqosGetUserPrioMapEn
+ *
+ * DESCRIPTION:
+ *       This routine return the user priority mapping state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gqosGetUserPrioMapEn
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *en
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gqosGetUserPrioMapEn Called.\n"));
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+		return retVal;
+	
+	/* Get the UseTag.  */
+	retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,4,1,&data);
+	/* translate bool to binary */
+	BIT_2_BOOL(data, *en);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+
+/*******************************************************************************
+ * gcosGetUserPrio2Tc
+ *
+ * DESCRIPTION:
+ *       Gets the traffic class number for a specific 802.1p user priority.
+ *
+ * INPUTS:
+ *       userPrior - user priority
+ *
+ * OUTPUTS:
+ *       trClass - The Traffic Class the received frame is assigned.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gcosGetUserPrio2Tc
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     userPrior,
+	OUT GT_U8     *trClass
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           bitOffset;      /* the bit offset in the reg    */
+	GT_U16          data;           /* store the read data          */
+
+	DBG_INFO(("gcosGetUserPrio2Tc Called.\n"));
+
+	/* check if device supports this feature */
+	if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+		return GT_NOT_SUPPORTED;
+	
+	/* calc the bit offset */
+	bitOffset = ((userPrior & 0x7) * 2);
+	/* Get the traffic class for the VPT.  */
+	retVal = hwGetGlobalRegField(dev,QD_REG_IEEE_PRI,bitOffset,2,&data);
+	*trClass = (GT_U8)data;
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gcosSetUserPrio2Tc
+ *
+ * DESCRIPTION:
+ *       Sets the traffic class number for a specific 802.1p user priority.
+ *
+ * INPUTS:
+ *       userPrior - user priority of a port.
+ *       trClass   - the Traffic Class the received frame is assigned.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gcosSetUserPrio2Tc
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_U8      userPrior,
+	IN GT_U8      trClass
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           bitOffset;      /* the bit offset in the reg    */
+
+	DBG_INFO(("gcosSetUserPrio2Tc Called.\n"));
+	/* check if device supports this feature */
+	if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+		return GT_NOT_SUPPORTED;
+	
+	/* calc the bit offset */
+	bitOffset = ((userPrior & 0x7) * 2);
+	/* Set the traffic class for the VPT.  */
+	retVal = hwSetGlobalRegField(dev,QD_REG_IEEE_PRI, bitOffset,2,trClass);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gcosGetDscp2Tc
+ *
+ * DESCRIPTION:
+ *       This routine retrieves the traffic class assigned for a specific
+ *       IPv4 Dscp.
+ *
+ * INPUTS:
+ *       dscp    - the IPv4 frame dscp to query.
+ *
+ * OUTPUTS:
+ *       trClass - The Traffic Class the received frame is assigned.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gcosGetDscp2Tc
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     dscp,
+	OUT GT_U8     *trClass
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           bitOffset;      /* the bit offset in the reg    */
+	GT_U8           regOffset;      /* the reg offset in the IP tbl */
+	GT_U16          data;           /* store the read data          */
+
+	DBG_INFO(("gcosGetDscp2Tc Called.\n"));
+	/* check if device supports this feature */
+	if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+		return GT_NOT_SUPPORTED;
+	
+	/* calc the bit offset */
+	bitOffset = (((dscp & 0x3f) % 8) * 2);
+	regOffset = ((dscp & 0x3f) / 8);
+	/* Get the traffic class for the IP dscp.  */
+	retVal = hwGetGlobalRegField(dev,(GT_U8)(QD_REG_IP_PRI_BASE+regOffset),
+				     bitOffset, 2, &data);
+	*trClass = (GT_U8)data;
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gcosSetDscp2Tc
+ *
+ * DESCRIPTION:
+ *       This routine sets the traffic class assigned for a specific
+ *       IPv4 Dscp.
+ *
+ * INPUTS:
+ *       dscp    - the IPv4 frame dscp to map.
+ *       trClass - the Traffic Class the received frame is assigned.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gcosSetDscp2Tc
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_U8      dscp,
+	IN GT_U8      trClass
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           bitOffset;      /* the bit offset in the reg    */
+	GT_U8           regOffset;      /* the reg offset in the IP tbl */
+
+	DBG_INFO(("gcosSetDscp2Tc Called.\n"));
+	/* check if device supports this feature */
+	if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+		return GT_NOT_SUPPORTED;
+	
+	/* calc the bit offset */
+	bitOffset = (((dscp & 0x3f) % 8) * 2);
+	regOffset = ((dscp & 0x3f) / 8);
+	/* Set the traffic class for the IP dscp.  */
+	retVal = hwSetGlobalRegField(dev,(GT_U8)(QD_REG_IP_PRI_BASE+regOffset),
+				     bitOffset, 2, trClass);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+ * gqosGetTagRemap
+ *
+ * DESCRIPTION:
+ *		Gets the remapped priority value for a specific 802.1p priority on a
+ *		given port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *		pri   - 802.1p priority
+ *
+ * OUTPUTS:
+ *		remappedPri - remapped Priority
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gqosGetTagRemap
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_U8    	pri,
+	OUT GT_U8   	*remappedPri
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* store the read data          */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U8           regAddr;        /* register address.            */
+	GT_U8           bitOffset;      /* the bit offset in the reg    */
+	
+	DBG_INFO(("gqosGetTagRemap Called.\n"));
+
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	if (pri <= 3)
+	{
+		regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
+	}
+	else
+	{
+		regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
+	}
+
+	/* calc the bit offset */
+	bitOffset = 4 * (pri % 4);
+	
+	retVal = hwGetPortRegField(dev,phyPort,regAddr,bitOffset,3,&data );
+
+	*remappedPri = (GT_U8)data;
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+ * gqosSetTagRemap
+ *
+ * DESCRIPTION:
+ *		Sets the remapped priority value for a specific 802.1p priority on a
+ *		given port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *		pri   - 802.1p priority
+ *		remappedPri - remapped Priority
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gqosSetTagRemap
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_U8    	pri,
+	IN GT_U8    	remappedPri
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           phyPort;        /* Physical port.               */
+	GT_U8           regAddr;        /* register address.            */
+	GT_U8           bitOffset;      /* the bit offset in the reg    */
+	
+	DBG_INFO(("gqosSetTagRemap Called.\n"));
+
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	phyPort = GT_LPORT_2_PORT(port);
+
+	if (pri <= 3)
+	{
+		regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
+	}
+	else
+	{
+		regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
+	}
+
+	/* calc the bit offset */
+	bitOffset = 4 * (pri % 4);
+	
+	retVal = hwSetPortRegField(dev,phyPort,regAddr,bitOffset,3,remappedPri);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
Index: linux-2.6.16/drivers/net/marvell/gtSem.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtSem.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,149 @@
+#include <linux/marvell/Copyright.h>
+/********************************************************************************
+ * gtOs.c
+ *
+ * DESCRIPTION:
+ *       Semaphore related routines
+ *
+ * DEPENDENCIES:
+ *       OS Dependent.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtSem.h>
+
+
+/*******************************************************************************
+ * gtSemCreate
+ *
+ * DESCRIPTION:
+ *       Create semaphore.
+ *
+ * INPUTS:
+ *		state - beginning state of the semaphore, either GT_SEM_EMPTY or GT_SEM_FULL
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_SEM if success. Otherwise, NULL
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+GT_SEM gtSemCreate
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM_BEGIN_STATE state
+	)
+{
+	if(dev->semCreate)
+		return dev->semCreate(state);
+
+	return 1; /* should return any value other than 0 to let it keep going */
+}
+
+/*******************************************************************************
+ * gtSemDelete
+ *
+ * DESCRIPTION:
+ *       Delete semaphore.
+ *
+ * INPUTS:
+ *       smid - semaphore Id
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+GT_STATUS gtSemDelete
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM smid
+	)
+{
+	if((dev->semDelete) && (smid))
+		return dev->semDelete(smid);
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gtSemTake
+ *
+ * DESCRIPTION:
+ *       Wait for semaphore.
+ *
+ * INPUTS:
+ *       smid    - semaphore Id
+ *       timeOut - time out in miliseconds or 0 to wait forever
+ *
+ * OUTPUTS:
+ *       None
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       OS_TIMEOUT - on time out
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+GT_STATUS gtSemTake
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM smid, 
+	IN GT_U32 timeOut
+	)
+{
+	if(dev->semTake)
+		return dev->semTake(smid, timeOut);
+
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+ * gtSemGive
+ *
+ * DESCRIPTION:
+ *       release the semaphore which was taken previously.
+ *
+ * INPUTS:
+ *       smid    - semaphore Id
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+GT_STATUS gtSemGive
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM       smid
+	)
+{
+	if(dev->semGive)
+		return dev->semGive(smid);
+
+	return GT_OK;
+}
+
Index: linux-2.6.16/drivers/net/marvell/gtSysConfig.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtSysConfig.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,426 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtSysConfig.c
+ *
+ * DESCRIPTION:
+ *       API definitions for system configuration, and enabling.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtDrvConfig.h>
+#include <linux/marvell/gtSem.h>
+#include <linux/marvell/platformDeps.h>
+
+static GT_BOOL gtRegister(GT_QD_DEV *dev, BSP_FUNCTIONS* pBSPFunctions);
+
+/*******************************************************************************
+ * qdLoadDriver
+ *
+ * DESCRIPTION:
+ *       QuarterDeck Driver Initialization Routine. 
+ *       This is the first routine that needs be called by system software. 
+ *       It takes *cfg from system software, and retures a pointer (*dev) 
+ *       to a data structure which includes infomation related to this QuarterDeck
+ *       device. This pointer (*dev) is then used for all the API functions. 
+ *
+ * INPUTS:
+ *       cfg  - Holds device configuration parameters provided by system software.
+ *
+ * OUTPUTS:
+ *       dev  - Holds device information to be used for each API call.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_ALREADY_EXIST    - if device already started
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ * 	qdUnloadDriver is also provided to do driver cleanup.
+ *
+ *******************************************************************************/
+GT_STATUS qdLoadDriver
+(
+	IN  GT_SYS_CONFIG   *cfg,
+	OUT GT_QD_DEV	*dev
+	)
+{
+	GT_STATUS   retVal;
+	GT_LPORT	port;
+
+	DBG_INFO(("qdLoadDriver Called.\n"));
+
+	/* Check for parameters validity        */
+	if(dev == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Check for parameters validity        */
+	if(cfg == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* The initialization was already done. */
+	if(dev->devEnabled)
+	{
+		DBG_INFO(("QuarterDeck already started.\n"));
+		return GT_ALREADY_EXIST;
+	}
+
+	if(gtRegister(dev,&(cfg->BSPFunctions)) != GT_TRUE)
+	{
+		DBG_INFO(("gtRegister Failed.\n"));
+		return GT_FAIL;
+	}
+	dev->accessMode = cfg->mode.scanMode;
+	if (dev->accessMode == SMI_MULTI_ADDR_MODE)
+	{
+		dev->baseRegAddr = 0;
+		dev->phyAddr = cfg->mode.baseAddr;
+	}
+	else
+	{
+		dev->baseRegAddr = cfg->mode.baseAddr;
+		dev->phyAddr = 0;
+	}
+
+	/* Initialize the driver    */
+	retVal = driverConfig(dev);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("driverConfig Failed.\n"));
+		return retVal;
+	}
+
+	/* Initialize dev fields.         */
+	dev->cpuPortNum = cfg->cpuPortNum;
+	dev->maxPhyNum = 5;
+	dev->devGroup = 0;
+
+	/* Assign Device Name */
+	switch(dev->deviceId)
+	{
+	case GT_88E6021:
+		dev->maxPhyNum = 2;
+		dev->devName = DEV_88E6021;
+		break;
+
+	case GT_88E6051:
+		dev->devName = DEV_88E6051;
+		break;
+
+	case GT_88E6052:
+		dev->devName = DEV_88E6052;
+		break;
+
+	case GT_88E6060:
+		if((dev->cpuPortNum != 4)&&(dev->cpuPortNum != 5))
+		{
+			dev = NULL;
+        		return GT_FAIL;
+		}
+		dev->devName = DEV_88E6060;
+		break;
+
+	case GT_88E6063:
+		dev->devName = DEV_88E6063;
+		break;
+
+	case GT_FH_VPN:
+		dev->devName = DEV_FH_VPN;
+		break;
+
+	case GT_FF_EG:
+		if(dev->cpuPortNum != 5)
+		{
+			dev = NULL;
+        		return GT_FAIL;
+		}
+		dev->devName = DEV_FF_EG;
+		break;
+
+	case GT_FF_HG:
+		dev->devName = DEV_FF_HG;
+		break;
+
+	case GT_88E6083:
+		dev->maxPhyNum = 8;
+		dev->devName = DEV_88E6083;
+		break;
+	case GT_88E6153:
+                dev->maxPhyNum = 6;
+		dev->devName = DEV_88E6183;
+		break;
+	case GT_88E6181:
+                dev->maxPhyNum = 8;
+		dev->devName = DEV_88E6181;
+		break;
+	case GT_88E6183:
+                dev->maxPhyNum = 10;
+		dev->devName = DEV_88E6183;
+		break;
+	case GT_88E6093:
+                dev->maxPhyNum = 11;
+		dev->devName = DEV_88E6093;
+		break;
+	case GT_88E6092:
+                dev->maxPhyNum = 11;
+		dev->devName = DEV_88E6092;
+		break;
+	case GT_88E6095:
+                dev->maxPhyNum = 11;
+		dev->devName = DEV_88E6095;
+		break;
+	case GT_88E6152:
+                dev->maxPhyNum = 6;
+		dev->devName = DEV_88E6182;
+		break;
+	case GT_88E6155:
+                dev->maxPhyNum = 6;
+		dev->devName = DEV_88E6185;
+		break;
+	case GT_88E6182:
+                dev->maxPhyNum = 10;
+		dev->devName = DEV_88E6182;
+		break;
+	case GT_88E6185:
+                dev->maxPhyNum = 10;
+		dev->devName = DEV_88E6185;
+		break;
+	default:
+		DBG_INFO(("Unknown Device. Initialization failed\n"));
+		dev = NULL;
+		return GT_FAIL;
+	}
+
+	/* Initialize the MultiAddress Register Access semaphore.    */
+	if((dev->multiAddrSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+	{
+		DBG_INFO(("semCreate Failed.\n"));
+		qdUnloadDriver(dev);
+		return GT_FAIL;
+	}
+
+	/* Initialize the ATU semaphore.    */
+	if((dev->atuRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+	{
+		DBG_INFO(("semCreate Failed.\n"));
+		qdUnloadDriver(dev);
+		return GT_FAIL;
+	}
+
+	/* Initialize the VTU semaphore.    */
+	if((dev->vtuRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+	{
+		DBG_INFO(("semCreate Failed.\n"));
+		qdUnloadDriver(dev);
+		return GT_FAIL;
+	}
+
+	/* Initialize the STATS semaphore.    */
+	if((dev->statsRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+	{
+		DBG_INFO(("semCreate Failed.\n"));
+		qdUnloadDriver(dev);
+		return GT_FAIL;
+	}
+
+	/* Initialize the ports states to forwarding mode. */
+	if(cfg->initPorts == GT_TRUE)
+	{
+		for (port=GT_LPORT_2_PORT(0); port<GT_LPORT_2_PORT(dev->numOfPorts); port++)
+		{
+			if((retVal = gstpSetPortState(dev,port,GT_PORT_FORWARDING)) != GT_OK)
+			{
+				DBG_INFO(("Failed.\n"));
+				qdUnloadDriver(dev);
+				return retVal;
+			}
+		}
+	}
+
+	if(IS_IN_DEV_GROUP(dev,DEV_ENHANCED_CPU_PORT))
+	{
+		if((retVal = gsysSetRsvd2CpuEnables(dev,0)) != GT_OK)
+		{
+			DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+			qdUnloadDriver(dev);
+			return retVal;
+		}
+
+		if((retVal = gsysSetRsvd2Cpu(dev,GT_FALSE)) != GT_OK)
+		{
+			DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+			qdUnloadDriver(dev);
+			return retVal;
+		}
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		for (port=GT_LPORT_2_PORT(0); port<GT_LPORT_2_PORT(dev->numOfPorts); port++)
+		{
+			retVal = gprtSetCPUPort(dev,port,GT_LPORT_2_PORT(dev->cpuPortNum));
+			if((retVal != GT_OK) && (retVal != GT_NOT_SUPPORTED))
+			{
+				DBG_INFO(("Failed.\n"));
+				qdUnloadDriver(dev);
+				return retVal;
+			}
+		}
+	}
+
+	dev->devEnabled = 1;
+	dev->devNum = cfg->devNum;
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * sysEnable
+ *
+ * DESCRIPTION:
+ *       This function enables the system for full operation.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       1.  This function should be called only after successful execution of
+ *           qdLoadDriver().
+ *
+ *******************************************************************************/
+GT_STATUS sysEnable( GT_QD_DEV *dev)
+{
+	DBG_INFO(("sysEnable Called.\n"));
+	DBG_INFO(("OK.\n"));
+	return driverEnable(dev);
+}
+
+
+/*******************************************************************************
+ * qdUnloadDriver
+ *
+ * DESCRIPTION:
+ *       This function unloads the QuaterDeck Driver.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       1.  This function should be called only after successful execution of
+ *           qdLoadDriver().
+ *
+ *******************************************************************************/
+GT_STATUS qdUnloadDriver
+(
+	IN GT_QD_DEV* dev
+	)
+{
+	DBG_INFO(("qdUnloadDriver Called.\n"));
+
+	/* Delete the MultiAddress mode reagister access semaphore.    */
+	if(gtSemDelete(dev,dev->multiAddrSem) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+ 
+	/* Delete the ATU semaphore.    */
+	if(gtSemDelete(dev,dev->atuRegsSem) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	/* Delete the VTU semaphore.    */
+	if(gtSemDelete(dev,dev->vtuRegsSem) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	/* Delete the STATS semaphore.    */
+	if(gtSemDelete(dev,dev->statsRegsSem) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	gtMemSet(dev,0,sizeof(GT_QD_DEV));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gtRegister
+ *
+ * DESCRIPTION:
+ *       BSP should register the following functions:
+ *		1) MII Read - (Input, must provide)
+ *			allows QuarterDeck driver to read QuarterDeck device registers.
+ *		2) MII Write - (Input, must provice)
+ *			allows QuarterDeck driver to write QuarterDeck device registers.
+ *		3) Semaphore Create - (Input, optional)
+ *			OS specific Semaphore Creat function.
+ *		4) Semaphore Delete - (Input, optional)
+ *			OS specific Semaphore Delete function.
+ *		5) Semaphore Take - (Input, optional)
+ *			OS specific Semaphore Take function.
+ *		6) Semaphore Give - (Input, optional)
+ *			OS specific Semaphore Give function.
+ *		Notes: 3) ~ 6) should be provided all or should not be provided at all.
+ *
+ * INPUTS:
+ *		pBSPFunctions - pointer to the structure for above functions.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *       GT_TRUE, if input is valid. GT_FALSE, otherwise.
+ *
+ * COMMENTS:
+ *       This function should be called only once.
+ *
+ *******************************************************************************/
+static GT_BOOL gtRegister(GT_QD_DEV *dev, BSP_FUNCTIONS* pBSPFunctions)
+{
+	dev->fgtReadMii =  pBSPFunctions->readMii;
+	dev->fgtWriteMii = pBSPFunctions->writeMii;
+	
+	dev->semCreate = pBSPFunctions->semCreate;
+	dev->semDelete = pBSPFunctions->semDelete;
+	dev->semTake   = pBSPFunctions->semTake  ;
+	dev->semGive   = pBSPFunctions->semGive  ;
+	
+	return GT_TRUE;
+}
+
Index: linux-2.6.16/drivers/net/marvell/gtSysCtrl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtSysCtrl.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,3775 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtSysCtrl.c
+ *
+ * DESCRIPTION:
+ *       API definitions for system global control.
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+ * gsysSwReset
+ *
+ * DESCRIPTION:
+ *       This routine preforms switch software reset.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSwReset
+(
+	IN  GT_QD_DEV *dev
+	)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8			regOffset;
+
+	DBG_INFO(("gsysSwReset Called.\n"));
+
+	/* Set the Software reset bit.                  */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		regOffset = QD_REG_GLOBAL_CONTROL;
+	}
+	else
+	{
+		regOffset = QD_REG_ATU_CONTROL;
+	}
+
+	retVal = hwSetGlobalRegField(dev,regOffset,15,1,1);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	/* Make sure the reset operation is completed.  */
+	data = 1;
+	while(data != 0)
+	{
+		retVal = hwGetGlobalRegField(dev,regOffset,15,1,&data);
+
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	}
+	
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetPPUEn
+ *
+ * DESCRIPTION:
+ *		This routine enables/disables Phy Polling Unit.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetPPUEn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL 		en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetPPUEn Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(en,data);
+
+	/* Set the PPUEn bit.                */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetPPUEn
+ *
+ * DESCRIPTION:
+ *		This routine get the PPU state.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_BAD_PARAM    - on bad parameter
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetPPUEn
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetPPUEn Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(en == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Get the GetPPUEn bit.                */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetDiscardExcessive
+ *
+ * DESCRIPTION:
+ *       This routine set the Discard Excessive state.
+ *
+ * INPUTS:
+ *       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetDiscardExcessive
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_BOOL en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetDiscardExcessive Called.\n"));
+	BOOL_2_BIT(en,data);
+
+	/* Set the Discard Exissive bit.                */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,13,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysGetDiscardExcessive
+ *
+ * DESCRIPTION:
+ *       This routine get the Discard Excessive state.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetDiscardExcessive
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_BOOL    *en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetDiscardExcessive Called.\n"));
+	if(en == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Get the Discard Exissive bit.                */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,13,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysSetSchedulingMode
+ *
+ * DESCRIPTION:
+ *       This routine set the Scheduling Mode.
+ *
+ * INPUTS:
+ *       mode - GT_TRUE wrr, GT_FALSE strict.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetSchedulingMode
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_BOOL    mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetSchedulingMode Called.\n"));
+	BOOL_2_BIT(mode,data);
+	data = 1 - data;
+
+	/* Set the Schecduling bit.             */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,11,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysGetSchedulingMode
+ *
+ * DESCRIPTION:
+ *       This routine get the Scheduling Mode.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE wrr, GT_FALSE strict.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetSchedulingMode
+(
+	IN  GT_QD_DEV *dev,
+	OUT GT_BOOL   *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetSchedulingMode Called.\n"));
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+	/* Get the Scheduling bit.              */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,11,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(1 - data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysSetMaxFrameSize
+ *
+ * DESCRIPTION:
+ *       This routine Set the max frame size allowed.
+ *
+ * INPUTS:
+ *       mode - GT_TRUE max size 1522, 
+ *			   GT_FALSE max size 1535 or 1632.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *		Please refer to the device spec. to get the max frame size.
+ *       88E6095 device supports upto 1632.
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetMaxFrameSize
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_BOOL   mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetMaxFrameSize Called.\n"));
+	BOOL_2_BIT(mode,data);
+	data = 1 - data;
+
+	/* Set the Max Fram Size bit.               */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,10,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysGetMaxFrameSize
+ *
+ * DESCRIPTION:
+ *       This routine Get the max frame size allowed.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE max size 1522, 
+ *			   GT_FALSE max size 1535,or 1632.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *		Please refer to the device spec. to get the max frame size.
+ *       88E6095 device supports upto 1632.
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetMaxFrameSize
+(
+	IN  GT_QD_DEV *dev,
+	OUT GT_BOOL   *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetMaxFrameSize Called.\n"));
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+	/* Get the Max Frame Size bit.          */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,10,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(1 - data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysReLoad
+ *
+ * DESCRIPTION:
+ *       This routine cause to the switch to reload the EEPROM.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysReLoad
+(
+	IN  GT_QD_DEV *dev
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gsysReLoad Called.\n"));
+	/* Set the Reload bit.                  */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,9,1,1);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	/* Should a check for reload completion. */
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysSetWatchDog
+ *
+ * DESCRIPTION:
+ *       This routine Set the the watch dog mode.
+ *
+ * INPUTS:
+ *       en - GT_TRUE enables, GT_FALSE disable.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetWatchDog
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_BOOL   en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetWatchDog Called.\n"));
+	BOOL_2_BIT(en,data);
+
+	/* Set the WatchDog bit.            */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,7,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysGetWatchDog
+ *
+ * DESCRIPTION:
+ *       This routine Get the the watch dog mode.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE enables, GT_FALSE disable.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetWatchDog
+(
+	IN  GT_QD_DEV *dev,
+	OUT GT_BOOL   *en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetWatchDog Called.\n"));
+	if(en == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Get the WatchDog bit.            */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,7,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetDuplexPauseMac
+ *
+ * DESCRIPTION:
+ *       This routine sets the full duplex pause src Mac Address.
+ *
+ * INPUTS:
+ *       mac - The Mac address to be set.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetDuplexPauseMac
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_ETHERADDR *mac
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetDuplexPauseMac Called.\n"));
+	if(mac == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Set the first Mac register with diffAddr bit reset.  */
+	data = (((*mac).arEther[0] & 0xFE) << 8) | (*mac).arEther[1];
+	retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_01,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	/* Set the Mac23 address register.   */
+	data = ((*mac).arEther[2] << 8) | (*mac).arEther[3];
+	retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_23,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	/* Set the Mac45 address register.   */
+	data = ((*mac).arEther[4] << 8) | (*mac).arEther[5];
+	retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_45,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysGetDuplexPauseMac
+ *
+ * DESCRIPTION:
+ *       This routine Gets the full duplex pause src Mac Address.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mac - the Mac address.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetDuplexPauseMac
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_ETHERADDR *mac
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to read from register.  */
+
+	DBG_INFO(("gsysGetDuplexPauseMac Called.\n"));
+	if(mac == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Get the Mac01 register.      */
+	retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_01,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+#if 0	/* This should be always a unicast. */
+	/* The mac is allwasy a multicast mac   */
+	(*mac).arEther[0] = (data >> 8) | 0x01;
+	(*mac).arEther[1] = data & 0xFF;
+#else
+	(*mac).arEther[0] = (data >> 8) & ~0x01;
+	(*mac).arEther[1] = data & 0xFF;
+#endif
+	/* Get the Mac23 register.      */
+	retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_23,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	(*mac).arEther[2] = data >> 8;
+	(*mac).arEther[3] = data & 0xFF;
+
+	/* Get the Mac45 register.      */
+	retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_45,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	(*mac).arEther[4] = data >> 8;
+	(*mac).arEther[5] = data & 0xFF;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysSetPerPortDuplexPauseMac
+ *
+ * DESCRIPTION:
+ *       This routine sets whether the full duplex pause src Mac Address is per
+ *       port or per device.
+ *
+ * INPUTS:
+ *       en - GT_TURE per port mac, GT_FALSE global mac.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetPerPortDuplexPauseMac
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_BOOL      en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetPerPortDuplexPauseMac Called.\n"));
+	BOOL_2_BIT(en,data);
+
+	/* Set the WatchDog bit.            */
+	retVal = hwSetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysGetPerPortDuplexPauseMac
+ *
+ * DESCRIPTION:
+ *       This routine Gets whether the full duplex pause src Mac Address is per
+ *       port or per device.
+ *
+ * INPUTS:
+ *       en - GT_TURE per port mac, GT_FALSE global mac.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetPerPortDuplexPauseMac
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL      *en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetPerPortDuplexPauseMac Called.\n"));
+	if(en == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Get the Scheduling bit.              */
+	retVal = hwGetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysReadMiiReg
+ *
+ * DESCRIPTION:
+ *       This routine reads QuarterDeck Registers. Since this routine is only for
+ *		Diagnostic Purpose, no error checking will be performed.
+ *		User has to know which phy address(0 ~ 0x1F) will be read.		
+ *
+ * INPUTS:
+ *       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysReadMiiReg
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_U32	     phyAddr,
+	IN  GT_U32	     regAddr,
+	OUT GT_U32	     *data
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          u16Data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysReadMiiRegister Called.\n"));
+
+	/* Get the Scheduling bit.              */
+	retVal = hwReadMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,&u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*data = (GT_U32)u16Data;
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysWriteMiiReg
+ *
+ * DESCRIPTION:
+ *       This routine writes QuarterDeck Registers. Since this routine is only for
+ *		Diagnostic Purpose, no error checking will be performed.
+ *		User has to know which phy address(0 ~ 0x1F) will be read.		
+ *
+ * INPUTS:
+ *       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysWriteMiiReg
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_U32	     phyAddr,
+	IN  GT_U32	     regAddr,
+	IN  GT_U16	     data
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+    
+	DBG_INFO(("gsysWriteMiiRegister Called.\n"));
+
+	/* Get the Scheduling bit.              */
+	retVal = hwWriteMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetRetransmitMode
+ *
+ * DESCRIPTION:
+ *       This routine set the Retransmit Mode.
+ *
+ * INPUTS:
+ *       en - GT_TRUE Retransimt Mode is enabled, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetRetransmitMode
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_BOOL      en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetRetransmitMode Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+	BOOL_2_BIT(en,data);
+
+	/* Set the Retransmit Mode bit.                */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysGetRetransmitMode
+ *
+ * DESCRIPTION:
+ *       This routine get the Retransmit Mode.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE Retransmit Mode is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetRetransmitMode
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL      *en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetRetransmitMode Called.\n"));
+	if(en == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+	/* Get the bit.                */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetLimitBackoff
+ *
+ * DESCRIPTION:
+ *       This routine set the Limit Backoff bit.
+ *
+ * INPUTS:
+ *       en - GT_TRUE:  uses QoS half duplex backoff operation  
+ *            GT_FALSE: uses normal half duplex backoff operation
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetLimitBackoff
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_BOOL      en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetLimitBackoff Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+	BOOL_2_BIT(en,data);
+
+	/* Set the bit.                */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysGetLimitBackoff
+ *
+ * DESCRIPTION:
+ *       This routine set the Limit Backoff bit.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE:  uses QoS half duplex backoff operation  
+ *            GT_FALSE: uses normal half duplex backoff operation
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetLimitBackoff
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL      *en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetLimitBackoff Called.\n"));
+	if(en == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the bit.                */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetRsvRegPri
+ *
+ * DESCRIPTION:
+ *       This routine set the Reserved Queue's Requesting Priority 
+ *
+ * INPUTS:
+ *       en - GT_TRUE: use the last received frome's priority
+ *            GT_FALSE:use the last switched frame's priority 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetRsvReqPri
+(
+	IN  GT_QD_DEV    *dev,
+	IN  GT_BOOL      en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+	/* register.                    */
+	DBG_INFO(("gsysSetRsvReqPri Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+	BOOL_2_BIT(en,data);
+
+	/* Set the bit.                */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gsysGetRsvReqPri
+ *
+ * DESCRIPTION:
+ *       This routine get the Reserved Queue's Requesting Priority 
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE: use the last received frome's priority
+ *            GT_FALSE:use the last switched frame's priority 
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetRsvReqPri
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL      *en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetRsvReqPri Called.\n"));
+	if(en == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the bit.                */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetCascadePort
+ *
+ * DESCRIPTION:
+ *		This routine sets Cascade Port number.
+ *		In multichip systems frames coming from a CPU need to know when they
+ *		have reached their destination chip.
+ *
+ * INPUTS:
+ *		port - Cascade Port
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetCascadePort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysSetCascadePort Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate LPORT to hardware port */
+	data = (GT_U16)(GT_LPORT_2_PORT(port));
+
+	/* Set the Cascade port.                */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetCascadePort
+ *
+ * DESCRIPTION:
+ *		This routine gets Cascade Port number.
+ *		In multichip systems frames coming from a CPU need to know when they
+ *		have reached their destination chip.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		port - Cascade Port
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetCascadePort
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT 	*port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysSetCascadePort Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the Cascade port.                */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*port = GT_PORT_2_LPORT(data);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetDeviceNumber
+ *
+ * DESCRIPTION:
+ *		This routine sets Device Number.
+ *		In multichip systems frames coming from a CPU need to know when they
+ *		have reached their destination chip. From CPU frames whose Dev_Num
+ *		fieldmatches these bits have reachedtheir destination chip and are sent
+ *		out this chip using the port number indicated in the frame's Trg_Port 
+ *		field.
+ *
+ * INPUTS:
+ *		devNum - Device Number (0 ~ 31)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetDeviceNumber
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		devNum
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysSetDeviceNumber Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	data = ((GT_U16)devNum) & 0x1F; /* only 5 bits are valid */
+
+	/* Set the Device Number.                */
+	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetDeviceNumber
+ *
+ * DESCRIPTION:
+ *		This routine gets Device Number.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		devNum - Device Number (0 ~ 31)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetDeviceNumber
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U32  	*devNum
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetDeviceNumber Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the Device Number.                */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*devNum = (GT_U32)data;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetCoreTagType
+ *
+ * DESCRIPTION:
+ *		This routine sets Ether Core Tag Type.
+ *		This Ether Type is added to frames that egress the switch as Double Tagged 
+ *		frames. It is also the Ether Type expected during Ingress to determine if 
+ *		a frame is Tagged or not on ports configured as UseCoreTag mode.
+ *
+ * INPUTS:
+ *		etherType - Core Tag Type (2 bytes)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetCoreTagType
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16  		etherType
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gsysSetCoreTagType Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set the Ether Type */
+	retVal = hwWriteGlobalReg(dev,QD_REG_CORETAG_TYPE,etherType);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetCoreTagType
+ *
+ * DESCRIPTION:
+ *		This routine gets CoreTagType
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		etherType - Core Tag Type (2 bytes)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetCoreTagType
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*etherType
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetCoreTagType Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the Device Number.                */
+	retVal = hwReadGlobalReg(dev,QD_REG_CORETAG_TYPE,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*etherType = data;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetIngressMonitorDest
+ *
+ * DESCRIPTION:
+ *		This routine sets Ingress Monitor Destination Port. Frames that are 
+ *		targeted toward an Ingress Monitor Destination go out the port number 
+ *		indicated in these bits. This includes frames received on a Marvell Tag port
+ *		with the Ingress Monitor type, and frames received on a Network port that 
+ *		is enabled to be the Ingress Monitor Source Port.
+ *		If the Ingress Monitor Destination Port resides in this device these bits 
+ *		should point to the Network port where these frames are to egress. If the 
+ *		Ingress Monitor Destination Port resides in another device these bits 
+ *		should point to the Marvell Tag port in this device that is used to get 
+ *		to the device that contains the Ingress Monitor Destination Port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetIngressMonitorDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gsysSetIngressMonitorDest Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set the Ether Type */
+	retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, (GT_U16)hwPort);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetIngressMonitorDest
+ *
+ * DESCRIPTION:
+ *		This routine gets Ingress Monitor Destination Port.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		port  - the logical port number.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetIngressMonitorDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetIngressMonitorDest Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the IngressMonitorDest. */
+	retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, &data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*port = GT_PORT_2_LPORT(data);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetEgressMonitorDest
+ *
+ * DESCRIPTION:
+ *		This routine sets Egress Monitor Destination Port. Frames that are 
+ *		targeted toward an Egress Monitor Destination go out the port number 
+ *		indicated in these bits. This includes frames received on a Marvell Tag port
+ *		with the Egress Monitor type, and frames transmitted on a Network port that 
+ *		is enabled to be the Egress Monitor Source Port.
+ *		If the Egress Monitor Destination Port resides in this device these bits 
+ *		should point to the Network port where these frames are to egress. If the 
+ *		Egress Monitor Destination Port resides in another device these bits 
+ *		should point to the Marvell Tag port in this device that is used to get 
+ *		to the device that contains the Egress Monitor Destination Port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetEgressMonitorDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gsysSetEgressMonitorDest Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set EgressMonitorDest */
+	retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, (GT_U16)hwPort);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetEgressMonitorDest
+ *
+ * DESCRIPTION:
+ *		This routine gets Egress Monitor Destination Port.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		port  - the logical port number.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetEgressMonitorDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetEgressMonitorDest Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the EgressMonitorDest. */
+	retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, &data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*port = GT_PORT_2_LPORT(data);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetARPDest
+ *
+ * DESCRIPTION:
+ *		This routine sets ARP Monitor Destination Port. Tagged or untagged 
+ *		frames ingress Network ports that have the Broadcast Destination Address 
+ *		with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+ *		should point to the port that directs these frames to the switch's CPU 
+ *		that will process ARPs. This target port should be a Marvell Tag port so 
+ *		that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
+ *		To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+ *		Tag port will be sent to the port number defineded in ARPDest.
+ *
+ *		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP 
+ *		frames will be discarded.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetARPDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gsysSetARPDest Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_SUPPORT))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set related bit */
+	retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, (GT_U16)hwPort);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetARPDest
+ *
+ * DESCRIPTION:
+ *		This routine gets ARP Monitor Destination Port. Tagged or untagged 
+ *		frames ingress Network ports that have the Broadcast Destination Address 
+ *		with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+ *		should point to the port that directs these frames to the switch's CPU 
+ *		that will process ARPs. This target port should be a Marvell Tag port so 
+ *		that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
+ *		To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+ *		Tag port will be sent to the port number defineded in ARPDest.
+ *
+ *		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP 
+ *		frames will be discarded.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		port  - the logical port number.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetARPDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetARPDest Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_SUPPORT))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, &data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*port = GT_PORT_2_LPORT(data);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetRsvd2CpuEnables
+ *
+ * DESCRIPTION:
+ *		Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, 
+ *		the 16 reserved multicast DA addresses, whose bit in this register are 
+ *		also set to a one, are treadted as MGMT frames. All the reserved DA's 
+ *		take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is 
+ *		tested. When x = 0x2, bit 2 of this field is tested and so on.
+ *		If the tested bit in this register is cleared to a zero, the frame will 
+ *		be treated as a normal (non-MGMT) frame.
+ *
+ * INPUTS:
+ *		enBits - bit vector of enabled Reserved Multicast.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetRsvd2CpuEnables
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		enBits
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gsysSetRsvd2CpuEnables Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set related register */
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_MGMT_ENABLE, (GT_U16)enBits);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetRsvd2CpuEnables
+ *
+ * DESCRIPTION:
+ *		Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, 
+ *		the 16 reserved multicast DA addresses, whose bit in this register are 
+ *		also set to a one, are treadted as MGMT frames. All the reserved DA's 
+ *		take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is 
+ *		tested. When x = 0x2, bit 2 of this field is tested and so on.
+ *		If the tested bit in this register is cleared to a zero, the frame will 
+ *		be treated as a normal (non-MGMT) frame.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		enBits - bit vector of enabled Reserved Multicast.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetRsvd2CpuEnables
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*enBits
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gsysGetRsvd2CpuEnables Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related register */
+	retVal = hwReadGlobal2Reg(dev, QD_REG_MGMT_ENABLE, enBits);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetRsvd2Cpu
+ *
+ * DESCRIPTION:
+ *		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+ *		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+ *		membership, will be considered MGMT frames and sent to the port's CPU 
+ *		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+ *		function) for the frames's DA is also set to a one.
+ *
+ * INPUTS:
+ *		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetRsvd2Cpu
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+	DBG_INFO(("gsysSetRsvd2Cpu Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(en,data);
+
+	/* Set related bit */
+	retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 3, 1, data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetRsvd2Cpu
+ *
+ * DESCRIPTION:
+ *		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+ *		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+ *		membership, will be considered MGMT frames and sent to the port's CPU 
+ *		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+ *		function) for the frames's DA is also set to a one.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetRsvd2Cpu
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetRsvd2Cpu Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,3,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetMGMTPri
+ *
+ * DESCRIPTION:
+ *		These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
+ *
+ * INPUTS:
+ *		pri - PRI[2:0] bits (should be less than 8)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - If pri is not less than 8.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetMGMTPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		pri
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gsysSetMGMTPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if (pri > 0x7)
+	{
+		DBG_INFO(("GT_BAD_PARAM\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Set related bit */
+	retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 0, 3, pri);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetMGMTPri
+ *
+ * DESCRIPTION:
+ *		These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		pri - PRI[2:0] bits (should be less than 8)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetMGMTPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*pri
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	DBG_INFO(("gsysGetMGMTPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,0,3,pri);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetUseDoubleTagData
+ *
+ * DESCRIPTION:
+ *		This bit is used to determine if Double Tag data that is removed from a 
+ *		Double Tag frame is used or ignored when making switching decisions on 
+ *		the frame.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetUseDoubleTagData
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+	DBG_INFO(("gsysSetUseDoubleTagData Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(en,data);
+
+	/* Set related bit */
+	retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 15, 1, data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetUseDoubleTagData
+ *
+ * DESCRIPTION:
+ *		This bit is used to determine if Double Tag data that is removed from a 
+ *		Double Tag frame is used or ignored when making switching decisions on 
+ *		the frame.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetUseDoubleTagData
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetUseDoubleTagData Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,15,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetPreventLoops
+ *
+ * DESCRIPTION:
+ *		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+ *		field equals this device's Device Number, the following action will be 
+ *		taken depending upon the value of this bit.
+ *		GT_TRUE (1) - The frame will be discarded.
+ *		GT_FALSE(0) - The frame will be prevented from going out its original 
+ *						source port as defined by the frame's Src_Port field.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetPreventLoops
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+	DBG_INFO(("gsysSetPreventLoops Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(en,data);
+
+	/* Set related bit */
+	retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 14, 1, data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetPreventLoops
+ *
+ * DESCRIPTION:
+ *		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+ *		field equals this device's Device Number, the following action will be 
+ *		taken depending upon the value of this bit.
+ *		GT_TRUE (1) - The frame will be discarded.
+ *		GT_FALSE(0) - The frame will be prevented from going out its original 
+ *						source port as defined by the frame's Src_Port field.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetPreventLoops
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetPreventLoops Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,14,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetFlowControlMessage
+ *
+ * DESCRIPTION:
+ *		When this bit is set to one, Marvell Tag Flow Control messages will be 
+ *		generated when an output queue becomes congested and received Marvell Tag 
+ *		Flow Control messages will pause MACs inside this device. When this bit 
+ *		is cleared to a zero Marvell Tag Flow Control messages will not be 
+ *		generated and any received will be ignored at the target MAC.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetFlowControlMessage
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+	DBG_INFO(("gsysSetFlowControlMessage Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(en,data);
+
+	/* Set related bit */
+	retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 13, 1, data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetFlowControlMessage
+ *
+ * DESCRIPTION:
+ *		When this bit is set to one, Marvell Tag Flow Control messages will be 
+ *		generated when an output queue becomes congested and received Marvell Tag 
+ *		Flow Control messages will pause MACs inside this device. When this bit 
+ *		is cleared to a zero Marvell Tag Flow Control messages will not be 
+ *		generated and any received will be ignored at the target MAC.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetFlowControlMessage
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetFlowControlMessage Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,13,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetForceFlowControlPri
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+ *		Flow Control frames will be set to the value of the FC Pri bits (set by 
+ *		gsysSetFCPri function call). When this bit is cleared to a zero generated 
+ *		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+ *		frames that caused the congestion. This bit will have no effect if the 
+ *		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+ *		cleared to a zero.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetForceFlowControlPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+	DBG_INFO(("gsysSetForceFlowControlPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(en,data);
+
+	/* Set related bit */
+	retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 7, 1, data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetForceFlowControlPri
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+ *		Flow Control frames will be set to the value of the FC Pri bits (set by 
+ *		gsysSetFCPri function call). When this bit is cleared to a zero generated 
+ *		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+ *		frames that caused the congestion. This bit will have no effect if the 
+ *		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+ *		cleared to a zero.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetForceFlowControlPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetForceFlowControlPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,7,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetFCPri
+ *
+ * DESCRIPTION:
+ *		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+ *		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+ *		is set to a one.
+ *
+ * INPUTS:
+ *		pri - PRI[2:0] bits (should be less than 8)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - If pri is not less than 8.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetFCPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		pri
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+
+	DBG_INFO(("gsysSetFCPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if (pri > 0x7)
+	{
+		DBG_INFO(("GT_BAD_PARAM\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* Set related bit */
+	retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 4, 3, pri);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetFCPri
+ *
+ * DESCRIPTION:
+ *		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+ *		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+ *		is set to a one.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		pri - PRI[2:0] bits (should be less than 8)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetFCPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*pri
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	DBG_INFO(("gsysGetFCPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,4,3,pri);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetFlowCtrlDelay
+ *
+ * DESCRIPTION:
+ *		This function sets Flow control delay time for 10Mbps, 100Mbps, and 
+ *		1000Mbps. 
+ *
+ * INPUTS:
+ *		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+ *		delayTime - actual delay time will be (this value x 2.048uS).
+ *					the value cannot exceed 0x1FFF (or 8191 in decimal).
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetFlowCtrlDelay
+(
+	IN GT_QD_DEV			*dev,
+	IN GT_PORT_SPEED_MODE	sp,
+	IN GT_U32				delayTime
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+	DBG_INFO(("gsysSetFlowCtrlDelay Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Check if the register can be accessed. */
+	do
+	{
+		retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	} while (data & 0x8000);
+
+	switch(sp)
+	{
+	case PORT_SPEED_10_MBPS:
+		data = 0;
+		break;
+	case PORT_SPEED_100_MBPS:
+		data = 1 << 13;
+		break;
+	case PORT_SPEED_1000_MBPS:
+		data = 2 << 13;
+		break;
+	default:
+		DBG_INFO(("GT_BAD_PARAM (sp)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	if (delayTime > 0x1FFF)
+	{
+		DBG_INFO(("GT_BAD_PARAM (delayTime)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data |= (GT_U16)(0x8000 | delayTime);
+
+	/* Set related register */
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetFlowCtrlDelay
+ *
+ * DESCRIPTION:
+ *		This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+ *		1000Mbps. 
+ *
+ * INPUTS:
+ *		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+ *
+ * OUTPUTS:
+ *		delayTime - actual delay time will be (this value x 2.048uS).
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetFlowCtrlDelay
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_PORT_SPEED_MODE	sp,
+	OUT GT_U32		*delayTime
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetFlowCtrlDelay Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Check if the register can be accessed. */
+	do
+	{
+		retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	} while (data & 0x8000);
+
+	switch(sp)
+	{
+	case PORT_SPEED_10_MBPS:
+		data = 0;
+		break;
+	case PORT_SPEED_100_MBPS:
+		data = 1 << 13;
+		break;
+	case PORT_SPEED_1000_MBPS:
+		data = 2 << 13;
+		break;
+	default:
+		DBG_INFO(("GT_BAD_PARAM (sp)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*delayTime = (GT_U32)(data & 0x1FFF);
+		
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysSetDevRoutingTable
+ *
+ * DESCRIPTION:
+ *		This function sets Device to Port mapping (which device is connected to 
+ *		which port of this device). 
+ *
+ * INPUTS:
+ *		devNum - target device number.
+ *		portNum - the logical port number.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetDevRoutingTable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		devNum,
+	IN GT_LPORT 	port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysSetDevRoutingTable Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Check if the register can be accessed. */
+	do
+	{
+		retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	} while (data & 0x8000);
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if(devNum > 0x1F)
+	{
+		DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	if(hwPort >= dev->numOfPorts)
+	{
+		DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+		hwPort = 0xF;
+	}
+
+	data = 0x8000 | (devNum << 8) | hwPort;
+
+	/* Set related register */
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetDevRoutingTable
+ *
+ * DESCRIPTION:
+ *		This function gets Device to Port mapping (which device is connected to 
+ *		which port of this device). 
+ *
+ * INPUTS:
+ *		devNum - target device number.
+ *
+ * OUTPUTS:
+ *		portNum - the logical port number.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetDevRoutingTable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		devNum,
+	OUT GT_LPORT 	*port
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetDevRoutingTable Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Check if the register can be accessed. */
+	do
+	{
+		retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	} while (data & 0x8000);
+
+	if(devNum > 0x1F)
+	{
+		DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = devNum << 8;
+
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*port = GT_PORT_2_LPORT(data & 0xF);
+		
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetTrunkMaskTable
+ *
+ * DESCRIPTION:
+ *		This function sets routing information for the given Trunk ID.
+ *
+ * INPUTS:
+ *		trunkNum - Trunk Number.
+ *		trunkMask - Trunk route bits. Bit 0 controls trunk routing for port 0,
+ *					bit 1 for port 1 , etc.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkId > 0xF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetTrunkMaskTable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		trunkNum,
+	IN GT_U32		trunkMask
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U32			mask;
+
+	DBG_INFO(("gsysSetTrunkMaskTable Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Check if the register can be accessed. */
+	do
+	{
+		retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	} while (data & 0x8000);
+
+	if(trunkNum > 0x7)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	mask = (1 << dev->numOfPorts) - 1;
+
+	if(trunkMask > mask)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkMask)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = 0x8000 | (trunkNum << 12) | trunkMask;
+
+	/* Set related register */
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetTrunkMaskTable
+ *
+ * DESCRIPTION:
+ *		This function retrieves routing information for the given Trunk ID.
+ *
+ * INPUTS:
+ *		trunkNum - Trunk Number.
+ *
+ * OUTPUTS:
+ *		trunkMask - Trunk route bits. Bit 0 controls trunk routing for port 0,
+ *					bit 1 for port 1 , etc.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkId > 0xF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetTrunkMaskTable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		trunkNum,
+	OUT GT_U32		*trunkMask
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U32			mask;
+
+	DBG_INFO(("gsysGetTrunkMaskTable Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Check if the register can be accessed. */
+	do
+	{
+		retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	} while (data & 0x8000);
+
+	if(trunkNum > 0x7)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = trunkNum << 12;
+
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	mask = (1 << dev->numOfPorts) - 1;
+
+	*trunkMask = (GT_U32)(data & mask);
+			
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetHashTrunk
+ *
+ * DESCRIPTION:
+ *		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+ *		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+ *		When this bit is set to a one the hashed computed for address table 
+ *		lookups is used for the TrunkMask selection. When this bit is cleared to 
+ *		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+ *		select the TrunkMask to use.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetHashTrunk
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+	DBG_INFO(("gsysSetHashTrunk Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	BOOL_2_BIT(en,data);
+
+	/* Set related bit */
+	retVal = hwSetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL, 11, 1, data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetHashTrunk
+ *
+ * DESCRIPTION:
+ *		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+ *		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+ *		When this bit is set to a one the hashed computed for address table 
+ *		lookups is used for the TrunkMask selection. When this bit is cleared to 
+ *		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+ *		select the TrunkMask to use.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetHashTrunk
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	DBG_INFO(("gsysGetHashTrunk Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get related bit */
+	retVal = hwGetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL,11,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*en);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysSetTrunkRouting
+ *
+ * DESCRIPTION:
+ *		This function sets routing information for the given Trunk ID.
+ *
+ * INPUTS:
+ *		trunkId - Trunk ID.
+ *		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+ *					bit 1 for port 1 , etc.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkId > 0xF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysSetTrunkRouting
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		trunkId,
+	IN GT_U32		trunkRoute
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U32			mask;
+	GT_U32			maxTrunk;
+
+	DBG_INFO(("gsysSetTrunkRouting Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Check if the register can be accessed. */
+	do
+	{
+		retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	} while (data & 0x8000);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
+		maxTrunk = 8;
+	else
+		maxTrunk = 16;
+
+	if(trunkId >= maxTrunk)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	mask = (1 << dev->numOfPorts) - 1;
+
+	if(trunkRoute > mask)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkRoute)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = 0x8000 | (trunkId << 11) | trunkRoute;
+
+	/* Set related register */
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetTrunkRouting
+ *
+ * DESCRIPTION:
+ *		This function retrieves routing information for the given Trunk ID.
+ *
+ * INPUTS:
+ *		trunkId - Trunk ID.
+ *
+ * OUTPUTS:
+ *		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+ *					bit 1 for port 1 , etc.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkId > 0xF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetTrunkRouting
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		trunkId,
+	OUT GT_U32		*trunkRoute
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+	GT_U32			mask;
+	GT_U32			maxTrunk;
+
+	DBG_INFO(("gsysGetTrunkRouting Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Check if the register can be accessed. */
+	do
+	{
+		retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+	} while (data & 0x8000);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
+		maxTrunk = 8;
+	else
+		maxTrunk = 16;
+
+	if(trunkId >= maxTrunk)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = trunkId << 11;
+
+	retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+   	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	mask = (1 << dev->numOfPorts) - 1;
+
+	*trunkRoute = (GT_U32)(data & mask);
+			
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
Index: linux-2.6.16/drivers/net/marvell/gtSysStatus.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtSysStatus.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,385 @@
+#include <linux/marvell/Copyright.h>
+
+/*******************************************************************************
+ * gtSysStatus.c
+ *
+ * DESCRIPTION:
+ *       API definitions for system global status.
+ * 	Added for fullsail
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+ * gsysGetPPUState
+ *
+ * DESCRIPTION:
+ *		This routine get the PPU State. These two bits return 
+ *		the current value of the PPU.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		mode - GT_PPU_STATE
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_BAD_PARAM    - on bad parameter
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetPPUState
+(
+	IN  GT_QD_DEV   	*dev,
+	OUT GT_PPU_STATE	*mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetPPUState Called.\n"));
+
+	/* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("Not Supported.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* get the bits from hardware */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,14,2,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*mode = data;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gsysGetSW_Mode
+ *
+ * DESCRIPTION:
+ *       This routine get the Switch mode. These two bits returen 
+ *       the current value of the SW_MODE[1:0] pins.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetSW_Mode
+(
+	IN GT_QD_DEV  *dev,
+	IN GT_SW_MODE *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetSW_Mode Called.\n"));
+
+	/* only devices beyond quarterdeck (6052) has this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+		return retVal;
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* get the bits from hardware */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,12,2,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	*mode = data;
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetInitReady
+ *
+ * DESCRIPTION:
+ *       This routine get the InitReady bit. This bit is set to a one when the ATU,
+ *       the Queue Controller and the Statistics Controller are done with their 
+ *       initialization and are ready to accept frames.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetInitReady
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_BOOL    *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetInitReady Called.\n"));
+
+	/* only devices beyond quarterdeck (6052) has this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+		return retVal;
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* get the bits from hardware */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,11,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+#ifdef DEBUG_FEATURE
+/*******************************************************************************
+ * gsysGetPtrCollision
+ *
+ * DESCRIPTION:
+ *       This routine get the QC Pointer Collision.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetPtrCollision
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_BOOL    *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetPtrCollision Called.\n"));
+
+	/* only devices beyond quarterdeck (6052) has this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+		return retVal;
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* get the bits from hardware */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,15,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+
+/* the following are for clippership only - not for fullsail */
+
+/*******************************************************************************
+ * gsysGetDpvCorrupt
+ *
+ * DESCRIPTION:
+ *       This routine get the DpvCorrupt bit. This bit is set to a one when the 
+ *       QC detects a destination vector error
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: destination vector corrupt, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ * 	This feature is on clippership, but not on fullsail
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetDpvCorrupt
+(
+	IN  GT_QD_DEV *dev,
+	IN GT_BOOL    *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetDpvCorrupt Called.\n"));
+
+	/* only devices beyond quarterdeck (6052) has this feature */
+	/* Fullsail (DEV_QD_88E6502) is an exception, and does not support this feature */
+
+	if((IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+		return GT_NOT_SUPPORTED; /* this is quarterdeck */
+	if(  IS_VALID_API_CALL(dev,1, DEV_88E6021 ) == GT_OK )
+		return GT_NOT_SUPPORTED; /* this is fullsail */
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* get the bits from hardware */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,8,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * gsysGetMissingPointers
+ *
+ * DESCRIPTION:
+ *       This routine get the Missing Pointer bit. This bit is set to a one when  
+ *       the Register File detects less than 64 pointers in the Link List. 
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: Missing Pointers error, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ * 	This feature is on clippership, but not on fullsail
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+GT_STATUS gsysGetMissingPointers
+(
+	IN GT_QD_DEV *dev,
+	IN GT_BOOL   *mode
+	)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* The register's read data.    */
+
+	DBG_INFO(("gsysGetMissingPointers Called.\n"));
+
+	/* only devices beyond quarterdeck (6052) has this feature */
+	/* Fullsail (DEV_QD_88E6502) is an exception, and does not support this feature */
+
+	if((IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+		return GT_NOT_SUPPORTED; /* this is quarterdeck */
+	if(  IS_VALID_API_CALL(dev,1, DEV_88E6021 ) == GT_OK )
+		return GT_NOT_SUPPORTED; /* this is fullsail */
+
+	if(mode == NULL)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_BAD_PARAM;
+	}
+
+	/* get the bits from hardware */
+	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,7,1,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	BIT_2_BOOL(data,*mode);
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+#endif /* DEBUG_FEATURE */
Index: linux-2.6.16/drivers/net/marvell/gtUtils.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtUtils.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,179 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtUtils.c
+ *
+ * DESCRIPTION:
+ *       Collection of Utility functions
+ *
+ * DEPENDENCIES:
+ *       None
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+
+/*******************************************************************************
+ * gtMemSet
+ *
+ * DESCRIPTION:
+ *       Set a block of memory
+ *
+ * INPUTS:
+ *       start  - start address of memory block for setting
+ *       simbol - character to store, converted to an unsigned char
+ *       size   - size of block to be set
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       Pointer to set memory block
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+void * gtMemSet
+(
+	IN void * start,
+	IN int    symbol,
+	IN GT_U32 size
+	)
+{
+	GT_U32 i;
+	char* buf;
+	
+	buf = (char*)start;
+		
+	for(i=0; i<size; i++)
+	{
+		*buf++ = (char)symbol;
+	}
+
+	return start;
+}
+
+/*******************************************************************************
+ * gtMemCpy
+ *
+ * DESCRIPTION:
+ *       Copies 'size' characters from the object pointed to by 'source' into
+ *       the object pointed to by 'destination'. If copying takes place between
+ *       objects that overlap, the behavior is undefined.
+ *
+ * INPUTS:
+ *       destination - destination of copy
+ *       source      - source of copy
+ *       size        - size of memory to copy
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       Pointer to destination
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+void * gtMemCpy
+(
+	IN void *       destination,
+	IN const void * source,
+	IN GT_U32       size
+	)
+{
+	GT_U32 i;
+	char* buf;
+	char* src;
+	
+	buf = (char*)destination;
+	src = (char*)source;
+		
+	for(i=0; i<size; i++)
+	{
+		*buf++ = *src++;
+	}
+
+	return destination;
+}
+
+/*******************************************************************************
+ * gtMemCmp
+ *
+ * DESCRIPTION:
+ *       Compares given memories.
+ *
+ * INPUTS:
+ *       src1 - source 1
+ *       src2 - source 2
+ *       size - size of memory to copy
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       0, if equal.
+ *		negative number, if src1 < src2.
+ *		positive number, if src1 > src2.
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+int gtMemCmp
+(
+	IN char src1[],
+	IN char src2[],
+	IN GT_U32 size
+	)
+{
+	GT_U32 i;
+	int value;
+
+	for(i=0; i<size; i++)
+	{
+		if((value = (int)(src1[i] - src2[i])) != 0)
+			return value; 
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+ * gtStrlen
+ *
+ * DESCRIPTION:
+ *       Determine the length of a string
+ * INPUTS:
+ *       source  - string
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       size    - number of characters in string, not including EOS.
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+GT_U32 gtStrlen
+(
+	IN const void * source
+	)
+{
+	GT_U32 i = 0;
+	char* src;
+	
+	src = (char*)source;
+		
+	while(*src++) i++;
+
+	return i;
+}
+
+
Index: linux-2.6.16/drivers/net/marvell/gtVct.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtVct.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1541 @@
+#include <linux/marvell/Copyright.h>
+/*******************************************************************************
+ * gtVct.c
+ *
+ * DESCRIPTION:
+ *       API for Marvell Virtual Cable Tester.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtVct.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+#include <linux/marvell/gtHwCntl.h>
+
+
+/*******************************************************************************
+ * getPagedPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine reads phy register of the given page
+ *
+ * INPUTS:
+ *		port 	- port to be read
+ *		regAddr	- register offset to be read
+ *		page	- page number to be read
+ *
+ * OUTPUTS:
+ *		data	- value of the read register
+ *
+ * RETURNS:
+ *       GT_OK   			- if read successed
+ *       GT_FAIL   			- if read failed
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+static 
+GT_STATUS getPagedPhyReg
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U32  port,
+	IN	GT_U32  regAddr,
+	IN	GT_U32  page,
+	OUT GT_U16* data
+	)
+{
+	GT_U32 pageReg;
+	GT_U16 orgReg, u16Data;
+
+	if (regAddr < 29)
+	{
+		pageReg = 22;
+		page &= 0xFF;
+	}
+	else
+	{
+		pageReg = 29;
+		page &= 0x3F;
+	}
+
+	if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&orgReg) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	do
+	{
+		if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,(GT_U16)page) != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+
+		if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&u16Data) != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+	} while (u16Data != page);
+
+	if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)regAddr, &u16Data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	*data = u16Data;
+
+	if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,orgReg) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * setPagedPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine writes a value to phy register of the given page
+ *
+ * INPUTS:
+ *		port 	- port to be read
+ *		regAddr	- register offset to be read
+ *		page	- page number to be read
+ *		data	- value of the read register
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *       GT_OK   			- if read successed
+ *       GT_FAIL   			- if read failed
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+static 
+GT_STATUS setPagedPhyReg
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U32 port,
+	IN	GT_U32 regAddr,
+	IN	GT_U32 page,
+	IN  GT_U16 data
+	)
+{
+	GT_U32 pageReg;
+	GT_U16 orgReg,u16Data;
+
+	if (regAddr < 29)
+	{
+		pageReg = 22;
+		page &= 0xFF;
+	}
+	else
+	{
+		pageReg = 29;
+		page &= 0x3F;
+	}
+
+	if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&orgReg) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	do
+	{
+		if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,(GT_U16)page) != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+
+		if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&u16Data) != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+	} while (u16Data != page);
+
+	if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)regAddr, data) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,orgReg) != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * doesDeviceSupportVCT
+ *
+ * DESCRIPTION:
+ *       This routine check if the given device supports VCT.
+ *
+ * INPUTS:
+ *       ouiMsb - Organizationally Unique Id bits 3:18
+ *       ouiLsb - Organizationally Unique Id bits 19:24
+ *
+ * OUTPUTS:
+ *		phyType - PHY_1000M, or PHY_100M
+ *
+ * RETURNS:
+ *       GT_OK   			- if the device supports VCT
+ *       GT_NOT_SUPPORTED 	- otherwise
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+static 
+GT_STATUS doesDeviceSupportVCT
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U16 ouiMsb,
+	IN  GT_U16 ouiLsb,
+	OUT GT_U16* phyType
+	)
+{
+	GT_STATUS status = GT_OK;
+
+	DBG_INFO(("isDeviceSupportVCT Called.\n"));
+
+	if(ouiMsb != MARVELL_OUI_MSb)
+		return GT_NOT_SUPPORTED;
+
+	*phyType = PHY_1000M;
+
+	switch(ouiLsb & PHY_MODEL_MASK)
+	{
+	case DEV_E3082:
+		*phyType = PHY_100M;
+		DBG_INFO(("Phy is E3082.\n"));
+		break;
+	case DEV_E104X:
+		if ((ouiLsb & PHY_REV_MASK) < 0x3)
+			status = GT_NOT_SUPPORTED;
+		if ((ouiLsb & PHY_REV_MASK) == 0x3)
+			*phyType = PHY_1000M_B;
+		DBG_INFO(("Phy is E104X.\n"));
+		break;
+	case DEV_E1111:
+	case DEV_E114X:
+	case DEV_E1180:
+	case DEV_EC010:
+		DBG_INFO(("Gigabit Phy.\n"));
+		break;
+	case DEV_E1149:
+	case DEV_E1112:
+		*phyType = PHY_1000M_MP;
+		DBG_INFO(("Gigabit Phy with Multi Page mode.\n"));
+		break;
+	default:
+		status = GT_NOT_SUPPORTED;
+		DBG_INFO(("Unknown Device.\n"));
+		break;
+	}
+
+	return status;
+}
+
+
+/*******************************************************************************
+ * analizePhy100MVCTResult
+ *
+ * DESCRIPTION:
+ *       This routine analize the virtual cable test result for 10/100M Phy
+ *
+ * INPUTS:
+ *       regValue - test result
+ *
+ * OUTPUTS:
+ *       cableStatus - analized test result.
+ *       cableLen    - cable length or the distance where problem occurs.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+static
+GT_STATUS analizePhy100MVCTResult
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U16 regValue, 
+	OUT GT_TEST_STATUS *cableStatus,
+	OUT GT_CABLE_LEN *cableLen
+	)
+{
+	int len;
+
+	switch((regValue & 0x6000) >> 13)
+	{
+	case 0:
+		/* test passed. No problem found. */
+		/* check if there is impedance mismatch */
+		if ((regValue & 0xFF) == 0xFF)
+		{
+			*cableStatus = GT_NORMAL_CABLE;
+			cableLen->normCableLen = GT_UNKNOWN_LEN;
+		}
+		else
+		{
+			*cableStatus = GT_IMPEDANCE_MISMATCH;
+			len = (int)FORMULA_PHY100M(regValue & 0xFF);
+			if(len <= 0)
+				cableLen->errCableLen = 0;
+			else
+				cableLen->errCableLen = (GT_U8)len;
+		}
+				
+		break;
+	case 1:
+		/* test passed. Cable is short. */
+		*cableStatus = GT_SHORT_CABLE;
+		len = (int)FORMULA_PHY100M(regValue & 0xFF);
+		if(len <= 0)
+			cableLen->errCableLen = 0;
+		else
+			cableLen->errCableLen = (GT_U8)len;
+		break;
+	case 2:
+		/* test passed. Cable is open. */
+		*cableStatus = GT_OPEN_CABLE;
+		len = (int)FORMULA_PHY100M(regValue & 0xFF);
+		if(len <= 0)
+			cableLen->errCableLen = 0;
+		else
+			cableLen->errCableLen = (GT_U8)len;
+		break;
+	case 3:
+	default:
+		/* test failed. No result is valid. */
+		*cableStatus = GT_TEST_FAIL;
+		break;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * getCableStatus_Phy100M
+ *
+ * DESCRIPTION:
+ *       This routine perform the virtual cable test for the 10/100Mbps phy,
+ *       and returns the the status per Rx/Tx pair.
+ *
+ * INPUTS:
+ *       port - logical port number.
+ *
+ * OUTPUTS:
+ *       cableStatus - the port copper cable status.
+ *       cableLen    - the port copper cable length.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+static 
+GT_STATUS getCableStatus_Phy100M
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8            hwPort,
+	OUT GT_CABLE_STATUS *cableStatus
+	)
+{
+	GT_STATUS status;
+	GT_U16 reg26, reg27;
+
+	DBG_INFO(("getCableStatus_100Phy Called.\n"));
+
+	/* 
+	 * 	phy should be in 100 Full Duplex.
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,0,QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* 
+	 * start Virtual Cable Tester
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,26,0x8000)) != GT_OK)
+	{
+		return status;
+	}
+
+	do
+	{
+		if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
+		{
+			return status;
+		}
+		
+	} while(reg26 & 0x8000);
+
+	/*
+	 * read the test result for RX Pair
+	 */
+	if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
+	{
+		return status;
+	}
+		
+	/*
+	 * read the test result for TX Pair
+	 */
+	if((status= hwReadPhyReg(dev,hwPort,27,&reg27)) != GT_OK)
+	{
+		return status;
+	}
+		
+	cableStatus->phyType = PHY_100M;
+
+	/*
+	 * analyze the test result for RX Pair
+	 */
+	analizePhy100MVCTResult(dev, reg26, &cableStatus->cableStatus[MDI_RX_PAIR], 
+				&cableStatus->cableLen[MDI_RX_PAIR]);
+
+	/*
+	 * analyze the test result for TX Pair
+	 */
+	analizePhy100MVCTResult(dev, reg27, &cableStatus->cableStatus[MDI_TX_PAIR], 
+				&cableStatus->cableLen[MDI_TX_PAIR]);
+
+	return status;
+}
+
+static
+GT_STATUS  enable1stWorkAround_Phy100M
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     hwPort
+	)
+{
+	GT_U16      value;
+	GT_STATUS   status;
+
+	/* enable 1st work-around */
+	if ((status = hwWritePhyReg(dev, hwPort, 29, 3)) != GT_OK)
+		return status;
+
+	value = 0x6440;
+	if ((status = hwWritePhyReg(dev, hwPort, 30, value)) != GT_OK)
+		return status;
+
+	return GT_OK;
+}
+
+static
+GT_STATUS  disable1stWorkAround_Phy100M
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     hwPort
+	)
+{
+	GT_STATUS status;
+
+	/* disable 1st work-around */
+	if ((status = hwWritePhyReg(dev, hwPort, 29, 3)) != GT_OK)
+		return status;
+
+	if ((status = hwWritePhyReg(dev, hwPort, 30, 0)) != GT_OK)
+		return status;
+
+	return GT_OK;
+}
+
+static
+GT_STATUS workAround_Phy100M
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8            hwPort,
+	OUT GT_CABLE_STATUS *cableStatus
+	)
+{
+	GT_STATUS status = GT_OK;
+
+	/* 
+	 * If Cable Status is OPEN and the length is less than 15m,
+	 * then apply Work Around.
+	 */
+
+	if((cableStatus->cableStatus[MDI_RX_PAIR] == GT_OPEN_CABLE) ||
+	   (cableStatus->cableStatus[MDI_TX_PAIR] == GT_OPEN_CABLE))
+	{
+		/* must be disabled first and then enable again */
+		disable1stWorkAround_Phy100M(dev,hwPort);
+
+		enable1stWorkAround_Phy100M(dev,hwPort);
+
+		if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
+		{
+			return status;
+		}
+		if((status= hwWritePhyReg(dev,hwPort,30,0x0002)) != GT_OK)
+		{
+			return status;
+		}
+
+		if((status = getCableStatus_Phy100M(dev,hwPort,cableStatus)) != GT_OK)
+		{
+			return status;
+		}
+		
+		if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
+		{
+			return status;
+		}
+		if((status= hwWritePhyReg(dev,hwPort,30,0x0000)) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	return status;
+}
+
+
+static
+GT_STATUS  enable1stWorkAround_Phy1000M
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     hwPort
+	)
+{
+	GT_STATUS   status;
+
+	/* enable 1st work-around */
+	if ((status = hwWritePhyReg(dev, hwPort, 29, 0x0018)) != GT_OK)
+		return status;
+
+	if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
+		return status;
+
+	if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00ca)) != GT_OK)
+		return status;
+
+	if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
+		return status;
+
+	return GT_OK;
+}
+
+static
+GT_STATUS  disable1stWorkAround_Phy1000M
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8     hwPort
+	)
+{
+	GT_STATUS status;
+
+	/* disable 1st work-around */
+	if ((status = hwWritePhyReg(dev, hwPort, 29, 0x0018)) != GT_OK)
+		return status;
+
+	if ((status = hwWritePhyReg(dev, hwPort, 30, 0x0042)) != GT_OK)
+		return status;
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * analizePhy1000MVCTResult
+ *
+ * DESCRIPTION:
+ *       This routine analize the virtual cable test result for a Gigabit Phy
+ *
+ * INPUTS:
+ *       reg17 - original value of register 17
+ *       regValue - test result
+ *
+ * OUTPUTS:
+ *       cableStatus - analized test result.
+ *       cableLen    - cable length or the distance where problem occurs.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+static
+GT_STATUS analizePhy1000MVCTResult
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U16 reg17,
+	IN  GT_U16 regValue, 
+	OUT GT_TEST_STATUS *cableStatus,
+	OUT GT_CABLE_LEN *cableLen
+	)
+{
+	GT_U16 u16Data;
+	int len;
+
+	switch((regValue & 0x6000) >> 13)
+	{
+	case 0:
+
+		/* Check Impedance Mismatch */
+		if ((regValue & 0xFF) < 0xFF)
+		{
+			/*  if the reflected amplitude is low it is good cable too.
+			    for this registers values it is a good cable:
+			    0xE23, 0xE24, 0xE25, 0xE26, 0xE27 */
+			if ((regValue < 0xE23) || (regValue > 0xE27))
+			{
+				*cableStatus = GT_IMPEDANCE_MISMATCH;
+				len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+				if(len <= 0)
+					cableLen->errCableLen = 0;
+				else
+					cableLen->errCableLen = (GT_U8)len;
+				break;
+			}
+		}
+
+		/* test passed. No problem found. */
+		*cableStatus = GT_NORMAL_CABLE;
+
+		u16Data = reg17;
+
+		/* To get Cable Length, Link should be on and Speed should be 100M or 1000M */
+		if(!(u16Data & 0x0400))
+		{
+			cableLen->normCableLen = GT_UNKNOWN_LEN;
+			break;
+		}
+
+		if((u16Data & 0xC000) != 0x8000)
+		{
+			cableLen->normCableLen = GT_UNKNOWN_LEN;
+			break;
+		}
+
+		/*
+		 * read the test result for the selected MDI Pair
+		 */
+
+		u16Data = ((u16Data >> 7) & 0x7);
+
+		switch(u16Data)
+		{
+		case 0:
+			cableLen->normCableLen = GT_LESS_THAN_50M;
+			break;
+		case 1:
+			cableLen->normCableLen = GT_50M_80M;
+			break;
+		case 2:
+			cableLen->normCableLen = GT_80M_110M;
+			break;
+		case 3:
+			cableLen->normCableLen = GT_110M_140M;
+			break;
+		case 4:
+			cableLen->normCableLen = GT_MORE_THAN_140;
+			break;
+		default:
+			cableLen->normCableLen = GT_UNKNOWN_LEN;
+			break;
+		}
+		break;
+	case 1:
+		/* test passed. Cable is short. */
+		*cableStatus = GT_SHORT_CABLE;
+		len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+		if(len <= 0)
+			cableLen->errCableLen = 0;
+		else
+			cableLen->errCableLen = (GT_U8)len;
+		break;
+	case 2:
+		/* test passed. Cable is open. */
+		*cableStatus = GT_OPEN_CABLE;
+		len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+		if(len <= 0)
+			cableLen->errCableLen = 0;
+		else
+			cableLen->errCableLen = (GT_U8)len;
+		break;
+	case 3:
+	default:
+		/* test failed. No result is valid. */
+		*cableStatus = GT_TEST_FAIL;
+		break;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * getCableStatus_Phy1000M
+ *
+ * DESCRIPTION:
+ *       This routine perform the virtual cable test for the 10/100Mbps phy,
+ *       and returns the the status per Rx/Tx pair.
+ *
+ * INPUTS:
+ *       port - logical port number.
+ *		reg17 - original value of reg17.
+ *
+ * OUTPUTS:
+ *       cableStatus - the port copper cable status.
+ *       cableLen    - the port copper cable length.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+static 
+GT_STATUS getCableStatus_Phy1000M
+(	
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8			hwPort,
+	IN  GT_U16 			reg17,
+	OUT GT_CABLE_STATUS *cableStatus
+	)
+{
+	GT_STATUS status;
+	GT_U16 reg28, u16Data;
+	int i;
+
+	DBG_INFO(("getCableStatus_Phy1000M Called.\n"));
+
+	do
+	{
+		if((status = hwWritePhyReg(dev,hwPort,22,0)) != GT_OK)
+		{
+			return status;
+		}
+		if((status = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+		{
+			return status;
+		}
+	} while ((u16Data&0x3) != 0);
+
+	/* 
+	 * start Virtual Cable Tester
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,28,0x8000)) != GT_OK)
+	{
+		return status;
+	}
+
+	do
+	{
+		if((status= hwReadPhyReg(dev,hwPort,28,&reg28)) != GT_OK)
+		{
+			return status;
+		}
+		
+	} while(reg28 & 0x8000);
+
+	cableStatus->phyType = PHY_1000M;
+
+	DBG_INFO(("Reg28 after test : %0#x.\n", reg28));
+
+	for (i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		/*
+		 * Select a MDI Pair to be read
+		 */
+		do
+		{
+			if((status = hwWritePhyReg(dev,hwPort,22,(GT_U16)i)) != GT_OK)
+			{
+				return status;
+			}
+			if((status = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+			{
+				return status;
+			}
+		} while ((GT_U16)i != (u16Data&0x3));
+			
+		/*
+		 * read the test result for the selected MDI Pair
+		 */
+		if((status = hwReadPhyReg(dev,hwPort,28,&reg28)) != GT_OK)
+		{
+			return status;
+		}
+		
+		/*
+		 * analyze the test result for RX Pair
+		 */
+		if((status = analizePhy1000MVCTResult(dev, reg17, reg28, 
+						      &cableStatus->cableStatus[i], 
+						      &cableStatus->cableLen[i])) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	return GT_OK;
+}
+
+static
+GT_STATUS workAround_Phy1000M
+(
+	GT_QD_DEV *dev,
+	GT_U8 hwPort
+	)
+{
+	GT_STATUS status;
+
+	DBG_INFO(("workAround for Gigabit Phy Called.\n"));
+
+	if((status = hwWritePhyReg(dev,hwPort,29,0x1e)) != GT_OK)
+	{
+		return status;
+	}
+		
+	if((status = hwWritePhyReg(dev,hwPort,30,0xcc00)) != GT_OK)
+	{
+		return status;
+	}
+
+	if((status = hwWritePhyReg(dev,hwPort,30,0xc800)) != GT_OK)
+	{
+		return status;
+	}
+	if((status = hwWritePhyReg(dev,hwPort,30,0xc400)) != GT_OK)
+	{
+		return status;
+	}
+	if((status = hwWritePhyReg(dev,hwPort,30,0xc000)) != GT_OK)
+	{
+		return status;
+	}
+	if((status = hwWritePhyReg(dev,hwPort,30,0xc100)) != GT_OK)
+	{
+		return status;
+	}
+
+	DBG_INFO(("workAround for Gigabit Phy completed.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * getCableStatus_Phy1000MPage
+ *
+ * DESCRIPTION:
+ *       This routine perform the virtual cable test for the 10/100Mbps phy with
+ *       multiple page mode and returns the the status per MDIP/N.
+ *
+ * INPUTS:
+ *       port - logical port number.
+ *
+ * OUTPUTS:
+ *       cableStatus - the port copper cable status.
+ *       cableLen    - the port copper cable length.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+static 
+GT_STATUS getCableStatus_Phy1000MPage
+(	
+	IN  GT_QD_DEV *dev,
+	IN  GT_U8			hwPort,
+	OUT GT_CABLE_STATUS *cableStatus
+	)
+{
+	GT_STATUS status;
+	GT_U16 u16Data;
+	GT_U16 reg17 = 0;
+	int i;
+
+	DBG_INFO(("getCableStatus_Phy1000M Called.\n"));
+
+	/*
+	 * If Fiber is used, simply return with test fail.
+	 */
+	if((status= getPagedPhyReg(dev,(GT_U32)hwPort,17,1,&u16Data)) != GT_OK)
+	{
+		return status;
+	}
+
+	if(u16Data & 0x400)
+	{
+		for (i=0; i<GT_MDI_PAIR_NUM; i++)
+		{
+			cableStatus->cableStatus[i] = GT_TEST_FAIL;
+		}
+		return GT_OK;
+	}
+
+	/*
+	 * If Copper is used and Link is on, get DSP Distance and put it in the
+	 * old reg17 format.(bit9:7 with DSP Distance)
+	 */
+	if((status= getPagedPhyReg(dev,(GT_U32)hwPort,17,0,&u16Data)) != GT_OK)
+	{
+		return status;
+	}
+
+	if(u16Data & 0x400)
+	{
+		reg17 = (u16Data & 0xC000) | 0x400;
+
+		if((status= getPagedPhyReg(dev,(GT_U32)hwPort,26,5,&u16Data)) != GT_OK)
+		{
+			return status;
+		}
+		reg17 |= ((u16Data & 0x7) << 7);
+	}
+
+	/* 
+	 * start Virtual Cable Tester
+	 */
+	if((status= setPagedPhyReg(dev,(GT_U32)hwPort,16,5,0x8000)) != GT_OK)
+	{
+		return status;
+	}
+
+	do
+	{
+		if((status= getPagedPhyReg(dev,(GT_U32)hwPort,16,5,&u16Data)) != GT_OK)
+		{
+			return status;
+		}
+		
+	} while(u16Data & 0x8000);
+
+	cableStatus->phyType = PHY_1000M;
+
+	DBG_INFO(("Page 5 of Reg16 after test : %0#x.\n", u16Data));
+
+	for (i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		/*
+		 * read the test result for the selected MDI Pair
+		 */
+		if((status= getPagedPhyReg(dev,(GT_U32)hwPort,16+i,5,&u16Data)) != GT_OK)
+		{
+			return status;
+		}
+		
+		/*
+		 * analyze the test result for RX Pair
+		 */
+		if((status = analizePhy1000MVCTResult(dev, reg17, u16Data, 
+						      &cableStatus->cableStatus[i], 
+						      &cableStatus->cableLen[i])) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+ * gvctGetCableStatus
+ *
+ * DESCRIPTION:
+ *       This routine perform the virtual cable test for the requested port,
+ *       and returns the the status per MDI pair.
+ *
+ * INPUTS:
+ *       port - logical port number.
+ *
+ * OUTPUTS:
+ *       cableStatus - the port copper cable status.
+ *       cableLen    - the port copper cable length.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *       Command - vctGetCableDiag
+ *
+ *******************************************************************************/
+GT_STATUS gvctGetCableDiag
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT        port,
+	OUT GT_CABLE_STATUS *cableStatus
+	)
+{
+	GT_STATUS status;
+	GT_U8 hwPort;
+	GT_U16 ouiMsb, ouiLsb, phyType;
+	GT_U16 u16Data, orgReg0, orgReg17;
+	GT_BOOL ppuEn;
+	GT_PPU_STATE ppuSt;
+
+	DBG_INFO(("gvctGetCableDiag Called.\n"));
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status = doesDeviceSupportVCT(dev,ouiMsb,ouiLsb,&phyType)) != GT_OK)
+	{
+		DBG_INFO(("Device is not supporting VCT.\n"));
+		return status;
+	}
+
+	/* Need to disable PPUEn for safe. */
+	if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+	{
+		ppuEn = GT_FALSE;
+	}
+
+	if(ppuEn != GT_FALSE)
+	{
+		if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+		{
+			DBG_INFO(("Not able to disable PPUEn.\n"));
+			return status;
+		}
+		do
+		{
+			if((status= gsysGetPPUState(dev,&ppuSt)) != GT_OK)
+			{
+				DBG_INFO(("Not able to read PPUEn.\n"));
+				return status;
+			}
+		} while(ppuSt != PPU_STATE_DISABLED_AFTER_RESET);
+	}
+		
+	/*
+	 * save original register 17 value, which will be used later depending on
+	 * test result.
+	 */
+	if((status= hwReadPhyReg(dev,hwPort,17,&orgReg17)) != GT_OK)
+	{
+		DBG_INFO(("Not able to reset the Phy.\n"));
+		goto cableDiagCleanup;
+	}
+
+	/*
+	 * reset the phy
+	 */
+	if((status= hwReadPhyReg(dev,hwPort,0,&orgReg0)) != GT_OK)
+	{
+		DBG_INFO(("Not able to reset the Phy.\n"));
+		goto cableDiagCleanup;
+	}
+
+	if((status= hwWritePhyReg(dev,hwPort,0,(GT_U16)(0x8000|orgReg0))) != GT_OK)
+	{
+		DBG_INFO(("Not able to reset the Phy.\n"));
+		goto cableDiagCleanup;
+	}
+
+	do
+	{
+		if((status= hwReadPhyReg(dev,hwPort,0,&u16Data)) != GT_OK)
+		{
+			DBG_INFO(("Not able to read Phy Register.\n"));
+			goto cableDiagCleanup;
+		}
+	} while (u16Data & 0x8000);
+
+	switch(phyType)
+	{
+	case PHY_100M:
+		enable1stWorkAround_Phy100M(dev,hwPort);
+		status = getCableStatus_Phy100M(dev,hwPort,cableStatus);
+		/* every fast ethernet phy requires this work-around */
+		workAround_Phy100M(dev,hwPort,cableStatus);
+		disable1stWorkAround_Phy100M(dev,hwPort);
+		break;
+	case PHY_1000M:
+		enable1stWorkAround_Phy1000M(dev,hwPort);
+		status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
+		disable1stWorkAround_Phy1000M(dev,hwPort);
+		break;
+	case PHY_1000M_B:
+		enable1stWorkAround_Phy1000M(dev,hwPort);
+		workAround_Phy1000M(dev,hwPort);
+		status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
+		disable1stWorkAround_Phy1000M(dev,hwPort);
+		break;
+	case PHY_1000M_MP:
+		status = getCableStatus_Phy1000MPage(dev,hwPort,cableStatus);
+		break;
+	default:
+		status = GT_FAIL;
+		break;
+	}
+	
+	/*
+	 * reset the phy
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,0,(GT_U16)(0x8000|orgReg0))) != GT_OK)
+	{
+		DBG_INFO(("Not able to reset the Phy.\n"));
+		goto cableDiagCleanup;
+	}
+
+	do
+	{
+		if((status= hwReadPhyReg(dev,hwPort,0,&u16Data)) != GT_OK)
+		{
+			DBG_INFO(("Not able to read Phy Register.\n"));
+			goto cableDiagCleanup;
+		}
+	} while (u16Data & 0x8000);
+
+cableDiagCleanup:
+
+	if(ppuEn != GT_FALSE)
+	{
+		if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+		{
+			DBG_INFO(("Not able to enable PPUEn.\n"));
+			status = GT_FAIL;
+		}
+	}
+
+	return status;	
+}
+
+
+/*******************************************************************************
+ * doesDeviceSupportExtStatus
+ *
+ * DESCRIPTION:
+ *       This routine check if the given device supports Extended Status.
+ *
+ * INPUTS:
+ *       ouiMsb - Organizationally Unique Id bits 3:18
+ *       ouiLsb - Organizationally Unique Id bits 19:24
+ *
+ * OUTPUTS:
+ *		phyType - PHY_1000M, or PHY_1000M_MP (multi page mode)
+ *
+ * RETURNS:
+ *       GT_OK   			- if the device supports Extended Status
+ *       GT_NOT_SUPPORTED 	- otherwise
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+static 
+GT_STATUS doesDeviceSupportExtStatus
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U16 ouiMsb,
+	IN  GT_U16 ouiLsb,
+	OUT GT_U16* phyType
+	)
+{
+	GT_STATUS status = GT_OK;
+
+	DBG_INFO(("isDeviceSupportExtStatus Called.\n"));
+
+	if(ouiMsb != MARVELL_OUI_MSb)
+		return GT_NOT_SUPPORTED;
+
+	*phyType = PHY_1000M;
+
+	switch(ouiLsb & PHY_MODEL_MASK)
+	{
+	case DEV_E114X:
+	case DEV_EC010:
+		DBG_INFO(("Gigabit Phy.\n"));
+		break;
+	case DEV_E1149:
+	case DEV_E1112:
+		*phyType = PHY_1000M_MP;
+		DBG_INFO(("Gigabit Phy with Multi Page mode.\n"));
+		break;
+	default:
+		status = GT_NOT_SUPPORTED;
+		DBG_INFO(("Unknown Device.\n"));
+		break;
+	}
+
+	return status;
+}
+
+
+/*******************************************************************************
+ * getExStatus1000M
+ *
+ * DESCRIPTION:
+ *       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+ *		for 1000M phy
+ *
+ * INPUTS:
+ *       dev - device context.
+ *       port - logical port number.
+ *
+ * OUTPUTS:
+ *       extendedStatus - extended cable status.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+static GT_STATUS getExStatus1000M
+(
+	IN  GT_QD_DEV 		*dev,
+	IN  GT_U8           hwPort,
+	OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+	)
+{
+	GT_STATUS status;
+	GT_U16 u16Data, i;
+
+	/*
+	 * get data from 28_5 register
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,22,5)) != GT_OK)
+	{
+		DBG_INFO(("Not able to write to the Phy register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,28,&u16Data)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read a Phy register.\n"));
+		return status;
+	}
+
+	/* if bit 6 is not set, it's not valid. */
+	if (!(u16Data & 0x0040))
+	{
+		DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+		extendedStatus->isValid = GT_FALSE;
+		return GT_OK;
+	}
+
+	extendedStatus->isValid = GT_TRUE;
+	
+	/* get Pair Polarity */
+	for(i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		switch((u16Data >> i) & 0x1)
+		{
+		case 0:
+			extendedStatus->pairPolarity[i] = GT_POSITIVE;
+			break;
+		default:
+			extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+			break;
+		}
+	}
+
+	/* get Pair Swap */
+	for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
+	{
+		switch((u16Data >> (i+4)) & 0x1)
+		{
+		case 0:
+			extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
+			break;
+		default:
+			extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
+			break;
+		}
+	}
+
+	/*
+	 * get data from 28_4 register
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,22,4)) != GT_OK)
+	{
+		DBG_INFO(("Not able to write to the Phy register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,28,&u16Data)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read a Phy register.\n"));
+		return status;
+	}
+
+	/* get Pair Skew */
+	for(i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * getExStatus1000MPage
+ *
+ * DESCRIPTION:
+ *       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+ *		for 1000M phy with multiple page mode
+ *
+ * INPUTS:
+ *       dev - device context.
+ *       port - logical port number.
+ *
+ * OUTPUTS:
+ *       extendedStatus - extended cable status.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+static GT_STATUS getExStatus1000MPage
+(
+	IN  GT_QD_DEV 		*dev,
+	IN  GT_U8	        hwPort,
+	OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+	)
+{
+	GT_STATUS status;
+	GT_U16 u16Data, i;
+
+	/*
+	 * get data from 21_5 register for pair swap
+	 */
+	if((status= getPagedPhyReg(dev,(GT_U32)hwPort,21,5,&u16Data)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read a paged Phy register.\n"));
+		return status;
+	}
+
+	/* if bit 6 is not set, it's not valid. */
+	if (!(u16Data & 0x0040))
+	{
+		DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+		extendedStatus->isValid = GT_FALSE;
+		return GT_OK;
+	}
+
+	extendedStatus->isValid = GT_TRUE;
+	
+	/* get Pair Polarity */
+	for(i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		switch((u16Data >> i) & 0x1)
+		{
+		case 0:
+			extendedStatus->pairPolarity[i] = GT_POSITIVE;
+			break;
+		default:
+			extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+			break;
+		}
+	}
+
+	/* get Pair Swap */
+	for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
+	{
+		switch((u16Data >> (i+4)) & 0x1)
+		{
+		case 0:
+			extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
+			break;
+		default:
+			extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
+			break;
+		}
+	}
+
+	/*
+	 * get data from 20_5 register for pair skew
+	 */
+	if((status= getPagedPhyReg(dev,(GT_U32)hwPort,20,5,&u16Data)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read a paged Phy register.\n"));
+		return status;
+	}
+
+	/* get Pair Skew */
+	for(i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * gvctGet1000BTExtendedStatus
+ *
+ * DESCRIPTION:
+ *       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+ *
+ * INPUTS:
+ *       dev - device context.
+ *       port - logical port number.
+ *
+ * OUTPUTS:
+ *       extendedStatus - extended cable status.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_STATUS gvctGet1000BTExtendedStatus
+(
+	IN  GT_QD_DEV 		*dev,
+	IN  GT_LPORT        port,
+	OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+	)
+{
+	GT_STATUS status;
+	GT_U8 hwPort;
+	GT_U16 ouiMsb, ouiLsb, phyType;
+	GT_BOOL ppuEn;
+	GT_PPU_STATE ppuSt;
+
+	DBG_INFO(("gvctGetCableDiag Called.\n"));
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status = doesDeviceSupportExtStatus(dev,ouiMsb,ouiLsb,&phyType)) != GT_OK)
+	{
+		DBG_INFO(("Device is not supporting Extended Status.\n"));
+		return status;
+	}
+	
+	/* Need to disable PPUEn for safe. */
+	if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+	{
+		ppuEn = GT_FALSE;
+	}
+
+	if(ppuEn != GT_FALSE)
+	{
+		if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+		{
+			DBG_INFO(("Not able to disable PPUEn.\n"));
+			return status;
+		}
+		do
+		{
+			if((status= gsysGetPPUState(dev,&ppuSt)) != GT_OK)
+			{
+				DBG_INFO(("Not able to read PPUEn.\n"));
+				return status;
+			}
+		} while(ppuSt != PPU_STATE_DISABLED_AFTER_RESET);
+	}
+
+	switch(phyType)
+	{
+	case PHY_1000M:
+		status = getExStatus1000M(dev,hwPort,extendedStatus);
+		break;
+	case PHY_1000M_MP:
+		status = getExStatus1000MPage(dev,hwPort,extendedStatus);
+		break;
+	default:
+		DBG_INFO(("Device is not supporting Extended Cable Status.\n"));
+		status = GT_NOT_SUPPORTED;
+	}
+
+	if(ppuEn != GT_FALSE)
+	{
+		if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+		{
+			DBG_INFO(("Not able to enable PPUEn.\n"));
+			status = GT_FAIL;
+		}
+	}
+
+	return status;
+}
+
+
Index: linux-2.6.16/drivers/net/marvell/gtVersion.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/gtVersion.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,60 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtVersion.h
+ *
+ * DESCRIPTION:
+ *       Includes software version information for the QuarterDeck software
+ *       suite.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+
+char msApiCopyright[] = MSAPI_COPYRIGHT;
+char msApiVersion[] = MSAPI_VERSION;
+
+/*******************************************************************************
+ * gtVersion
+ *
+ * DESCRIPTION:
+ *       This function returns the version of the QuarterDeck SW suite.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       version     - QuarterDeck software version.
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_BAD_PARAM on bad parameters,
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+GT_STATUS gtVersion
+(
+	OUT GT_VERSION   *version
+	)
+{
+	if(version == NULL)
+		return GT_BAD_PARAM;
+
+	if(gtStrlen(msApiVersion) > VERSION_MAX_LEN)
+	{
+		return GT_FAIL;
+	}
+
+	gtMemCpy(version->version,msApiVersion,gtStrlen(msApiVersion));
+	version->version[gtStrlen(msApiVersion)] = '\0';
+	return GT_OK;
+}
+
Index: linux-2.6.16/drivers/net/marvell/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/Makefile	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,21 @@
+# makefile - build main object file
+#
+# modification history
+# --------------------
+# 04-15-02,mj	created
+#
+#######################################################################
+
+
+# TODO obj-$(CONFIG_MV88E6095) = qdDrv.o
+
+obj-y += 	gtBrgFdb.o     gtEvents.o    gtPortPav.o       gtSysConfig.o \
+		gtBrgStp.o     gtHwCntl.o    gtPortRateCtrl.o  gtSysCtrl.o \
+		gtBrgVlan.o    gtMiiSmiIf.o  gtPortRmon.o      gtSysStatus.o  platformDeps.o \
+		gtBrgVtu.o     gtPCSCtrl.o   gtPortStat.o      gtUtils.o \
+		gtDebug.o      gtPhyCtrl.o   gtPortStatus.o    gtVct.o \
+		gtDrvConfig.o  gtPhyInt.o    gtQosMap.o        gtVersion.o \
+		gtDrvEvents.o  gtPortCtrl.o  gtSem.o
+# 		qdFFmii.o      qdInit.o      qdIoctl.o         qdModule.o \
+#                 mv_eth.o       mv_eth_addrtbl.o  mv_unm.o      mv_unm_netconf.o
+
Index: linux-2.6.16/drivers/net/marvell/mv_eth_addrtbl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/mv_eth_addrtbl.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,348 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ ********************************************************************************
+ * 
+ * FILENAME:    $Workfile: mv_eth_addrtbl.c $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $ 
+ * 
+ * mvFF_addrtbl.c
+ *
+ * DESCRIPTION:
+ *	        Address Table driver for the Marvell ethernet unit.
+ *
+ * DEPENDENCIES:   
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+/* #include <asm/88E6318/mv88E6318.h> */
+/* #include <asm/88E6318/mv88E6318int.h> */
+/* #include <asm/88E6318/mv88E6318regs.h> */
+#include <asm/mpc85xx.h>
+
+#include <linux/marvell/mv_unimac.h>
+#include <linux/marvell/mv_eth_addrtbl.h>
+#include <linux/marvell/mv_eth.h>
+
+/*
+ * We have only one MAC port in FF 
+ */
+#define MAX_NUMBER_OF_ETHERNET_PORTS            1
+
+/*
+ * An address table entry 64bit representation 
+ */
+typedef struct addressTableEntryStruct {
+	u32 hi;
+	u32 lo;
+} addrTblEntry;
+
+/*
+ * Per port hash mode
+ */
+static u32 addressTableHashMode[MAX_NUMBER_OF_ETHERNET_PORTS];
+
+/*
+ * Per port hash size
+ */
+static u32 addressTableHashSize[MAX_NUMBER_OF_ETHERNET_PORTS];
+
+/*
+ * Per port address table base
+ */
+static addrTblEntry *addressTableBase[MAX_NUMBER_OF_ETHERNET_PORTS];
+
+/*
+ * Hash length size options
+ */
+static u32 hashLength[2] = {
+	(0x8000),		/* 32K entries */
+	(0x8000 / 16),/*  2K entries */
+};
+
+/*
+ * A hash function that acts exactly as the HW hash 
+ */
+static u32 hashTableFunction(u32 macH, u32 macL, u32 HashSize, u32 hash_mode);
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function will add an entry to the address table.
+ * depends on the hash mode and hash size that was initialized.
+ * Inputs
+ * port - ETHERNET port number.
+ * macH - the 2 most significant bytes of the MAC address.
+ * macL - the 4 least significant bytes of the MAC address.
+ * skip - if 1, skip this address.
+ * rd   - the RD field in the address table.
+ * Outputs
+ * address table entry is added.
+ * 1 if success.
+ * 0 if table full
+ */
+static int
+addAddressTableEntry(u32 port, u32 macH, u32 macL, u32 rd, u32 skip);
+
+
+/*
+ * ----------------------------------------------------------------------------
+ *  Create an addressTable entry from MAC address info
+ *  found in the specifed net_device struct
+ *
+ *  Input : pointer to ethernet interface network device structure
+ *  Output : N/A
+ */
+void
+mv_eth_update_mac_address(u8 *byte, u8 port)
+{
+	u32 macH;
+	u32 macL;
+
+	macH = byte[0];
+	macH = (macH << 8) | byte[1];
+	macL = byte[2];
+	macL = (macL << 8) | byte[3];
+	macL = (macL << 8) | byte[4];
+	macL = (macL << 8) | byte[5];
+
+	/*
+	 * addAddressTableEntry() will flush Dcache and sync
+	 */
+	addAddressTableEntry(port, macH, macL, 1, 0);
+}
+
+
+/*
+ * clear the address table
+ * port - ETHERNET port number.
+ */
+void
+addressTableClear(u32 port)
+{
+	u32 addr, size;
+	memset((void *) addressTableBase[port],
+	       0, (hashLength[addressTableHashSize[port]] * MAC_ENTRY_SIZE));
+
+	addr = ((u32)(addressTableBase[port]));
+	size = (hashLength[addressTableHashSize[port]] * MAC_ENTRY_SIZE);
+	dma_cache_wback_inv(addr, size);
+}
+
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function will initialize the address table and will enableFiltering.
+ * Inputs
+ * hashMode         - hash mode 0 or hash mode 1.
+ * hashSizeSelector - indicates number of hash table entries (0=0x8000,1=0x800)
+ * hashDefaultMode  - 0 = discard addresses not found in the address table,
+ *                    1 = pass addresses not found in the address table.
+ * port - ETHERNET port number.
+ * Outputs
+ * address table is allocated and initialized.
+ * Always returns 1
+ */
+int
+initAddressTable(u32 port,
+		 u32 hashMode, u32 hashSizeSelector, u32 hashDefaultMode)
+{
+	u32 addr;
+	u32 bytes;
+	ETHERNET_PCR portControlReg;
+
+	addressTableHashMode[port] = hashMode;
+	addressTableHashSize[port] = hashSizeSelector;
+
+	/*
+	 * Allocate memory for the address table, which must reside
+	 * on an 8-byte boundary.
+	 */
+	bytes = MAC_ENTRY_SIZE * hashLength[hashSizeSelector];
+	if (bytes & ~PAGE_MASK) {
+		panic("initAddressTable: computed size isn't page-multiple.\n");
+	}
+	addr = (u32)dmaalloc(bytes, 0);
+	memset((void *) addr, 0, bytes);
+	dma_cache_wback_inv(addr, bytes);
+
+	MV_REG_WRITE(MV_ETH_HTPR + (ETHERNET_PORTS_DIFFERENCE_OFFSETS * port),
+		     virt_to_phys((void *) addr));
+
+	dma_cache_inv(addr, bytes);
+	mb();
+	addressTableBase[port] = (addrTblEntry *) addr;
+
+	/*
+	 * set hash {size,mode} and HDM in the PCR
+	 */
+	portControlReg = get_port_config(port);
+	portControlReg &= ~((1 << HASH_DEFAULT_MODE) | (1 << HASH_MODE)
+			    | (1 << HASH_SIZE));
+
+	portControlReg |= ((hashDefaultMode << HASH_DEFAULT_MODE)
+			   | (hashMode << HASH_MODE)
+			   | (hashSizeSelector << HASH_SIZE));
+
+	set_port_config(portControlReg, port);
+	enableFiltering(port);
+
+	return (1);
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function will calculate the hash function of the address.
+ * depends on the hash mode and hash size.
+ * Inputs
+ * macH             - the 2 most significant bytes of the MAC address.
+ * macL             - the 4 least significant bytes of the MAC address.
+ * hashMode         - hash mode 0 or hash mode 1.
+ * hashSizeSelector - indicates number of hash table entries (0=0x8000,1=0x800)
+ * Outputs
+ * return the calculated entry.
+ */
+static u32
+hashTableFunction(u32 macH, u32 macL, u32 HashSize, u32 hash_mode)
+{
+	u32 hashResult;
+	u32 addrH;
+	u32 addrL;
+	u32 addr0;
+	u32 addr1;
+	u32 addr2;
+	u32 addr3;
+	u32 addrHSwapped;
+	u32 addrLSwapped;
+
+	addrH = NIBBLE_SWAPPING_16_BIT(macH);
+	addrL = NIBBLE_SWAPPING_32_BIT(macL);
+
+	addrHSwapped = FLIP_4_BITS(addrH & 0xf)
+		+ ((FLIP_4_BITS((addrH >> 4) & 0xf)) << 4)
+		+ ((FLIP_4_BITS((addrH >> 8) & 0xf)) << 8)
+		+ ((FLIP_4_BITS((addrH >> 12) & 0xf)) << 12);
+
+	addrLSwapped = FLIP_4_BITS(addrL & 0xf)
+		+ ((FLIP_4_BITS((addrL >> 4) & 0xf)) << 4)
+		+ ((FLIP_4_BITS((addrL >> 8) & 0xf)) << 8)
+		+ ((FLIP_4_BITS((addrL >> 12) & 0xf)) << 12)
+		+ ((FLIP_4_BITS((addrL >> 16) & 0xf)) << 16)
+		+ ((FLIP_4_BITS((addrL >> 20) & 0xf)) << 20)
+		+ ((FLIP_4_BITS((addrL >> 24) & 0xf)) << 24)
+		+ ((FLIP_4_BITS((addrL >> 28) & 0xf)) << 28);
+
+	addrH = addrHSwapped;
+	addrL = addrLSwapped;
+
+	if (hash_mode == 0) {
+		addr0 = (addrL >> 2) & 0x03f;
+		addr1 = (addrL & 0x003) | ((addrL >> 8) & 0x7f) << 2;
+		addr2 = (addrL >> 15) & 0x1ff;
+		addr3 = ((addrL >> 24) & 0x0ff) | ((addrH & 1) << 8);
+	} else {
+		addr0 = FLIP_6_BITS(addrL & 0x03f);
+		addr1 = FLIP_9_BITS(((addrL >> 6) & 0x1ff));
+		addr2 = FLIP_9_BITS((addrL >> 15) & 0x1ff);
+		addr3 =
+			FLIP_9_BITS((((addrL >> 24) & 0x0ff) |
+				     ((addrH & 0x1) << 8)));
+	}
+
+	hashResult = (addr0 << 9) | (addr1 ^ addr2 ^ addr3);
+
+	if (HashSize == _8K_TABLE) {
+		hashResult = hashResult & 0xffff;
+	} else {
+		hashResult = hashResult & 0x07ff;
+	}
+
+	return (hashResult);
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function will add an entry to the address table.
+ * depends on the hash mode and hash size that was initialized.
+ * Inputs
+ * port - ETHERNET port number.
+ * macH - the 2 most significant bytes of the MAC address.
+ * macL - the 4 least significant bytes of the MAC address.
+ * skip - if 1, skip this address.
+ * rd   - the RD field in the address table.
+ * Outputs
+ * address table entry is added.
+ * 1 if success.
+ * 0 if table full
+ */
+static int
+addAddressTableEntry(u32 port, u32 macH, u32 macL, u32 rd, u32 skip)
+{
+	addrTblEntry *entry;
+	u32 newHi;
+	u32 newLo;
+	u32 i;
+
+	newLo = (((macH >> 4) & 0xf) << 15)
+		| (((macH >> 0) & 0xf) << 11)
+		| (((macH >> 12) & 0xf) << 7)
+		| (((macH >> 8) & 0xf) << 3)
+		| (((macL >> 20) & 0x1) << 31)
+		| (((macL >> 16) & 0xf) << 27)
+		| (((macL >> 28) & 0xf) << 23)
+		| (((macL >> 24) & 0xf) << 19)
+		| (skip << SKIP_BIT) | (rd << 2) | VALID;
+
+	newHi = (((macL >> 4) & 0xf) << 15)
+		| (((macL >> 0) & 0xf) << 11)
+		| (((macL >> 12) & 0xf) << 7)
+		| (((macL >> 8) & 0xf) << 3)
+		| (((macL >> 21) & 0x7) << 0);
+
+	/*
+	 * Pick the appropriate table, start scanning for free/reusable
+	 * entries at the index obtained by hashing the specified MAC address
+	 */
+	entry = addressTableBase[port];
+	entry += hashTableFunction(macH, macL, addressTableHashSize[port],
+				   addressTableHashMode[port]);
+	for (i = 0; i < HOP_NUMBER; i++, entry++) {
+		if (!(entry->lo & VALID) /*|| (entry->lo & SKIP) */ ) {
+			break;
+		} else {	/* if same address put in same position */
+			if (((entry->lo & 0xfffffff8) == (newLo & 0xfffffff8))
+			    && (entry->hi == newHi)) {
+				break;
+			}
+		}
+	}
+
+	if (i == HOP_NUMBER) {
+		printk("add address Table Entry: table section is full\n");
+		return (0);
+	}
+
+	/*
+	 * Update the selected entry
+	 */
+	entry->hi = newLo;
+	entry->lo = newHi;
+	/*
+	  entry->hi = newHi;
+	  entry->lo = newLo;
+	*/
+
+	dma_cache_wback_inv((u32)entry,  MAC_ENTRY_SIZE);
+
+	return (1);
+}
Index: linux-2.6.16/drivers/net/marvell/mv_eth.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/mv_eth.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,2287 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ ********************************************************************************
+ * 
+ * FILENAME:    $Workfile: mv_eth.c $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 7/16/03 2:01p $ 
+ * 
+ * DESCRIPTION:
+ *		Ethernet driver for Firehawk
+ *
+ * DEPENDENCIES:   
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+/*
+ * General note - Driver assumes that booter has resetted the ethernet interface
+ * and it's fully functional.
+ * The reset code can (and probably better) be added to this driver.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/fcntl.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ip.h>
+#include <linux/mii.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+#include <linux/ctype.h>
+
+#include <linux/marvell/mv_unimac.h>
+#include <linux/marvell/mv_eth.h>
+#include <linux/marvell/mv_eth_addrtbl.h>
+#include <linux/marvell/mv_os.h>
+#include <linux/marvell/mv_unm_netconf.h>
+
+
+#undef MC_BRIDGE_EXAMPLE /* Use MC bridge example */
+
+// #define DESC_CACHABLE
+
+
+/***************************************************/
+/* Definitions                                     */
+/***************************************************/
+
+#define BIT(n) (1<<(n))
+
+#if !defined(HEADERS) && !defined(TRAILERS)
+#error "You must define headers or trailers!!!"
+#endif
+
+#if defined(HEADERS) && defined(TRAILERS)
+#error "You must define headers or trailers not both !!!"
+#endif
+
+
+/***************************************************/
+/* Gloabl vars                                     */
+/***************************************************/
+
+/* The _binding structs represents per vlan binding 
+ * the binding is between the ethernet device (struct net_device)
+ * and its fields: HW access, link state, dev state and trailer/header
+ */ 
+typedef struct _binding {
+	struct net_device *dev;       /* the device associated with this binding entry */
+	mv_eth_hw         *pmvEthHw;  /* the global HW HAL */
+	bool               boLinkUp;  /* link state */
+	bool               boOpened;  /* device has allready been opened by the stack (hasn't been closed yet) */
+#ifdef HEADERS
+	char               header[HEADER_SIZE];
+#elif defined (TRAILERS)
+	char               trailer[TRAILER_SIZE];
+#endif
+} BINDING, *PBINDING;
+
+/* the irq number assigned to our MAC HW by th kernel */
+static u32  irq;       /* irq of our shared MAC HW */
+
+/*
+ * The static global array of bindings.
+ * each vlan has a binding that represents it
+ * the index in the array is the binding for it
+ * we are allocating the number of needed bindings in 
+ * mv_eth_start
+ */ 
+static BINDING * mvBindings[MV_UNM_VID_ISOLATED]= {0};
+
+/* a global spin lock to sync transmits */
+spinlock_t lock;
+
+/* the sole HW MAC presentation is SW */
+static mv_eth_hw   mvEthHw;
+
+/* In some implemantation we use the broadcast MAC to update HW tables */
+static unsigned char brdcast_mac[GT_ETHERNET_HEADER_SIZE] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; 
+
+#ifdef MC_BRIDGE_EXAMPLE
+/* a few mcast addresses for example */
+static unsigned char multicast_mac1[GT_ETHERNET_HEADER_SIZE] = {0x01, 0x00, 0x5E, 0x00, 0x00, 0x02}; 
+static unsigned char multicast_mac2[GT_ETHERNET_HEADER_SIZE] = {0x01, 0x00, 0x5E, 0x00, 0x00, 0x03}; 
+static unsigned char multicast_mac3[GT_ETHERNET_HEADER_SIZE] = {0x01, 0x00, 0x5E, 0x00, 0x00, 0x04}; 
+#endif
+
+/* the receive handler is not a part of the driver interface,
+ * rather, its a private function that signals packets to the kernel
+ * via the netif_rx function 
+ */
+static void mv_eth_receive_queue(unsigned long data);
+static void mv_eth_free_tx_queue(unsigned long queue);
+DECLARE_TASKLET(rxComplete, mv_eth_receive_queue, Q_INDEX_LIMIT);
+DECLARE_TASKLET(txComplete, mv_eth_free_tx_queue, MV_ETH_TX_QUEUE);
+
+extern void qdStatus(void);
+
+/*
+ * ----------------------------------------------------------------------------
+ * Set the MAC address for the specified interface
+ * to the specified value, forsaking all others.
+ *
+ * Input : pointer to ethernet interface network device structure and
+ *         a pointer to the designated entry to be added to the cache.
+ * Output : zero upon success, negative upon failure
+ */
+s32
+mv_eth_set_mac_address(struct net_device *dev, void *addr)
+{
+	u32 i;
+	struct sockaddr *sock;
+	u8 port = ((gt_eth_priv *) (dev->priv))->port;
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_set_mac_address\n");
+#endif
+
+	sock = (struct sockaddr *) addr;
+	for (i = 0; i < 6; i++) {
+		dev->dev_addr[i] = sock->sa_data[i];
+	}
+#ifdef ETH_DBG_INFO
+	printk("Setting MAC address for dev [%d]\n",((gt_eth_priv *) (dev->priv))->vid);
+#endif
+
+	/* addressTableClear(port); */	/* Does flush */
+	mv_eth_update_mac_address(dev->dev_addr, port );
+	return (0);
+}
+
+/*****************************************************************************
+ *
+ * int etherReadMIIReg (unsigned int portNumber , unsigned int MIIReg,
+ * unsigned int* value)
+ *
+ * Description
+ * This function will access the MII registers and will read the value of
+ * the MII register , and will retrieve the value in the pointer.
+ * Inputs
+ * portNumber - one of the 2 possiable Ethernet ports (0-1).
+ * MIIReg - the MII register offset.
+ * Outputs
+ * value - pointer to unsigned int which will receive the value.
+ * Returns Value
+ * 1 if success.
+ * 0 if fail to make the assignment.
+ * Error types (and exceptions if exist)
+ */
+static int etherReadMIIReg(unsigned int portNum, unsigned int miiReg,
+			   unsigned int *value);
+
+/*****************************************************************************
+ * 
+ * int etherWriteMIIReg (unsigned int portNumber , unsigned int MIIReg,
+ * unsigned int value)
+ * 
+ * Description
+ * This function will access the MII registers and will write the value
+ * to the MII register.
+ * Inputs
+ * portNumber - one of the 2 possiable Ethernet ports (0-1).
+ * MIIReg - the MII register offset.
+ * value -the value that will be written.
+ * Outputs
+ * Returns Value
+ * 1 if success.
+ * 0 if fail to make the assignment.
+ * Error types (and exceptions if exist)
+ */
+static int etherWriteMIIReg(unsigned int portNum, unsigned int miiReg,
+			    unsigned int value);
+
+
+/* set port config value */
+inline void set_port_config(u32 value, unsigned int port) {
+	MV_REG_WRITE(MV_ETH_PCR + ETHERNET_PORTS_DIFFERENCE_OFFSETS * port, value);
+}
+
+/* get port config value */
+inline u32 get_port_config(unsigned int port) {
+	return MV_REG_READ(MV_ETH_PCR + ETHERNET_PORTS_DIFFERENCE_OFFSETS * port);
+}
+
+
+inline void enableFiltering(u32 port)
+{
+	ETHERNET_PCR pcr;
+  
+	pcr = get_port_config(port);
+	pcr &= ~0x1; /* disable promiscuous unicast mode */
+	set_port_config(pcr, port);
+}
+
+
+static inline void disableFiltering(u32 port)
+{
+	ETHERNET_PCR pcr;
+
+	pcr = get_port_config(port);
+	pcr |= 0x1; /* enable promiscuous unicast mode */
+#ifdef ENABLE_MC
+	pcr |= 0x8; /* enable promiscuous multicast mode */
+#endif
+	set_port_config(pcr, port);
+}
+
+
+static inline void disableMulticastFiltering(u32 port)
+{
+	ETHERNET_PCR pcr;
+  
+	pcr = get_port_config(port);
+	pcr |= 0x8; /* enable promiscuous multicast mode */
+	set_port_config(pcr, port);
+}
+
+
+/* 
+ * The TX and RX descriptors are being placed in a non-chaced area.
+ * This is to reduce HW-SW synchronization
+ * The unchached area is handled here 
+ * 
+ * 40KB are being mapped as unchaced in the MPU,
+ * each page in the kernel is 4KB.
+ * the management of the 10 pages pool is being done here
+ */
+
+#if defined(MV88E6318) /* Firehawk */
+
+static void* dmaalloc(size_t size, dma_addr_t *dma_handle)
+{
+	void *ret;
+  
+	ret = (void *)__get_free_pages(GFP_ATOMIC | GFP_DMA, get_order(size));
+  
+	if (ret != NULL) {
+		dma_cache_inv((unsigned long)ret, size);
+		if (dma_handle != NULL)
+			*dma_handle = virt_to_phys(ret);
+    
+		/* bump virtual address up to non-cached area */
+		ret = (void*)KSEG1ADDR(ret);
+	}
+  
+	return ret;
+}
+
+#else /* Firefox */
+
+u32 uncachedPages(u32 pages)
+{
+	/* uncached 40KB defined in the MPU */
+#define MV_ETH_UNCACHED_REGION_BASE  0x7f6000
+#define MV_ETH_UNCACHED_REGION_END   0x800000
+
+	static u32 begin = MV_ETH_UNCACHED_REGION_BASE;
+	u32 ret;
+
+	ret = begin;
+	begin += pages * PAGE_SIZE;
+
+	if (begin >= MV_ETH_UNCACHED_REGION_END) { /* overflow */
+		begin -=  pages * PAGE_SIZE; /* undo */
+		ASSERT(0);
+		return 0; /* failed */
+	}
+#ifdef ETH_DBG_TRACE
+	printk("Allocated %d pages at address %08x\n", pages, ret); 
+#endif
+	return ret;
+}
+#endif
+
+/* Sometimes it seems the phy and the GT don't always agree. 
+ * Make sure they do, or restart autoneg. */
+static void
+check_phy_state(struct net_device *dev)
+{
+	gt_eth_priv *private = (gt_eth_priv *) dev->priv;
+	struct mii_if_info *mii = &private->mii_if;
+	int bmsr = mii->mdio_read(mii->dev, mii->phy_id, MII_BMSR);
+
+	if (mii_link_ok(&private->mii_if) && (bmsr & BMSR_ANEGCOMPLETE)) {
+		int advert = mii->mdio_read(dev, mii->phy_id, MII_ADVERTISE);
+		int lpa = mii->mdio_read(dev, mii->phy_id, MII_LPA);
+		int nego = mii_nway_result(advert & lpa);
+		int psr, wanted = -1;
+    
+		switch (nego) {
+		case LPA_100FULL:
+			wanted = 0x3;
+			break;
+		case LPA_100HALF:
+			wanted = 0x1;
+			break;
+		case LPA_10FULL:
+			wanted = 0x2;
+			break;
+		case LPA_10HALF:
+			wanted = 0x0;
+			break;
+		default:
+#ifdef ETH_DBG_INFO
+			printk("%s: MII negotiated strange settings %d\n",dev->name, nego);
+#endif
+			break;
+		}
+		psr = MV_REG_READ(MV_ETH_PSR + (ETH_ADDR_GAP * private->port));
+    
+		if ((psr & 0x3) != wanted) {
+#ifdef ETH_DBG_ERROR
+			printk("%s: MII said %x, GT said %x, restarting autoneg\n", dev->name, wanted, psr);
+#endif
+			mii_nway_restart(mii);
+		}
+	}
+}
+
+/*
+ * dump_link_state - prints the link state
+ * it informs: dev->name, speed, link, duplex, flow-control
+ */
+#ifdef ETH_DBG_INFO
+static void dump_link_state(struct net_device *dev)
+{
+	gt_eth_priv *private = (gt_eth_priv *) dev->priv;
+	unsigned int psr;
+
+	psr = MV_REG_READ(MV_ETH_PSR + (ETH_ADDR_GAP * private->port));
+	printk("%s: link state:\n"
+	       "  GT:%s:%s:%s:%s\n",
+	       dev->name,
+	       psr & 1 ? "100" : " 10",
+	       psr & 8 ? " Link" : "nLink",
+	       psr & 2 ? "FD" : "HD", psr & 4 ? " FC" : "nFC");
+
+}
+#endif /* ETH_DBG_INFO */
+
+/*
+ * ----------------------------------------------------------------------------
+ *  Update the statistics structure in the private data structure
+ *
+ *  Input : pointer to ethernet interface network device structure
+ *  Output : N/A
+ */
+void
+mv_eth_update_stat(struct net_device *dev)
+{
+	gt_eth_priv             *private;
+	struct net_device_stats *stat;
+	static int              first_time = 1;
+#if 0
+	u32 base    =   FIREHAWK_ENET_0_MIB_CTRS;
+#endif
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_update_stat\n");
+#endif
+
+	private =   dev->priv;
+	stat    = &(private->stat);
+
+	if (first_time) {
+		stat->rx_bytes = 0;
+		stat->tx_bytes = 0;
+		stat->rx_packets = 0;
+		stat->tx_packets = 0;
+		stat->rx_errors = 0;
+		stat->rx_dropped = 0;
+		stat->multicast = 0;
+		stat->collisions = 0;
+		stat->rx_length_errors = 0;
+		stat->rx_length_errors = 0;
+		stat->rx_crc_errors = 0;
+#if 0
+		/* Clear chips MIB counters */
+		MV_REG_READ( base + 0x00 );
+		MV_REG_READ( base + 0x04 );
+		MV_REG_READ( base + 0x08 );
+		MV_REG_READ( base + 0x0c );
+		MV_REG_READ( base + 0x50 );
+		MV_REG_READ( base + 0x20 );
+		MV_REG_READ( base + 0x1c );
+		MV_REG_READ( base + 0x30 );
+		MV_REG_READ( base + 0x60 );
+		MV_REG_READ( base + 0x24 );
+		MV_REG_READ( base + 0x20 );
+#endif
+		first_time = 0;
+	}
+#if 0
+	stat->rx_bytes         += MV_REG_READ( base + 0x00 );
+	stat->tx_bytes         += MV_REG_READ( base + 0x04 );
+	stat->rx_packets       += MV_REG_READ( base + 0x08 );
+	stat->tx_packets       += MV_REG_READ( base + 0x0c );
+	stat->rx_errors        += MV_REG_READ( base + 0x50 );
+
+	/*
+	 * Rx dropped is for received packet with CRC error
+	 */
+	stat->rx_dropped       += MV_REG_READ( base + 0x20 );
+	stat->multicast        += MV_REG_READ( base + 0x1c );
+	stat->collisions       += MV_REG_READ( base + 0x30 );
+
+	/*
+	 * detailed rx errors
+	 */
+	stat->rx_length_errors += MV_REG_READ( base + 0x60 );
+	stat->rx_length_errors += MV_REG_READ( base + 0x24 );
+	stat->rx_crc_errors    += MV_REG_READ( base + 0x20 );
+#endif
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * Returns a pointer to the interface statistics.
+ *
+ * Input : dev - a pointer to the required interface
+ *
+ * Output : a pointer to the interface's statistics
+ */
+struct net_device_stats *
+mv_eth_get_stats(struct net_device *dev)
+{
+	gt_eth_priv* priv = (gt_eth_priv*)(dev->priv); 
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_get_stats\n");
+#endif
+
+	mv_eth_update_stat(dev);
+	return &priv->stat;
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ *  change rx mode
+ *
+ *  Input : pointer to ethernet interface network device structure
+ *  Output : N/A
+ */
+void
+mv_eth_set_rx_mode(struct net_device *dev)
+{
+	gt_eth_priv *private;
+	int i;
+	struct dev_mc_list *mcList = dev->mc_list;
+	char* addr;
+    
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_set_rx_mode\n");
+#endif
+  
+	private = dev->priv;
+  
+	if (dev->flags & IFF_PROMISC) {
+		disableFiltering(private->port);
+#ifdef ETH_DBG_MC
+		printk ("Promiscuous mode is on.\n");
+#endif
+	} 
+	else if (dev->flags & IFF_ALLMULTI) {
+		disableMulticastFiltering(private->port);
+#ifdef ETH_DBG_MC
+		printk ("All Multicast mode is on.\n");
+#endif
+	}
+	else {
+#ifdef ENABLE_MC
+		disableFiltering(private->port);
+#ifdef ETH_DBG_MC
+		printk ("Multicast Addresses (%i)\n", dev->mc_count);
+#endif
+		for (i = 0; i < dev->mc_count; i++) {
+			addr = mcList->dmi_addr;
+#ifdef ETH_DBG_MC
+			printk("%02x:%02x:%02x:%02x:%02x:%02x\n",
+			       addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+#endif
+			mcList = mcList->next;
+		}
+#else /* !ENABLE_MC */
+		enableFiltering(private->port);
+#ifdef ETH_DBG_MC
+		printk ("Multicast Addresses (%i)\n", dev->mc_count);
+#endif
+		for (i = 0; i < dev->mc_count; i++) {
+			addr = mcList->dmi_addr;
+			mv_eth_update_mac_address(addr, private->port);
+#ifdef ETH_DBG_MC
+			printk("%02x:%02x:%02x:%02x:%02x:%02x\n",
+			       addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+#endif
+			mcList = mcList->next;
+		}
+#ifdef MC_BRIDGE_EXAMPLE
+		mv_eth_update_mac_address(multicast_mac1, private->port);
+		mv_eth_update_mac_address(multicast_mac2, private->port);
+		mv_eth_update_mac_address(multicast_mac3, private->port);
+		printk("Multicast Addresses (01-00-5e-00-00-02,-03,-04) are added\n");    
+#endif
+#endif /* ENABLE_MC */
+	}
+}
+
+static int
+mdio_read(struct net_device *dev, int phy_id, int location)
+{
+	unsigned int val;
+
+	etherReadMIIReg(phy_id & 0x1f, location & 0x1f, &val);
+
+	return (val & 0xffff);
+}
+
+static void
+mdio_write(struct net_device *dev, int phy_id, int location, int value)
+{
+	etherWriteMIIReg(phy_id & 0x1f, location & 0x1f, value);
+}
+
+#ifdef ETHERTOOL_FIXED
+static int
+netdev_ethtool_ioctl(struct net_device *dev, void *useraddr)
+{
+	gt_eth_priv *private = (gt_eth_priv *) dev->priv;
+	u32 ethcmd;
+
+	if (copy_from_user(&ethcmd, useraddr, sizeof (ethcmd)))
+		return -EFAULT;
+  
+	switch (ethcmd) {
+    
+		/* Get driver info */
+	case ETHTOOL_GDRVINFO:{
+		struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+		strncpy(info.driver, "firehawk",
+			sizeof (info.driver) - 1);
+		strncpy(info.version, version,
+			sizeof (info.version) - 1);
+		if (copy_to_user(useraddr, &info, sizeof (info)))
+			return -EFAULT;
+		return 0;
+	}
+		/* get settings */
+	case ETHTOOL_GSET:{
+		struct ethtool_cmd ecmd = { ETHTOOL_GSET };
+		spin_lock_irq(&private->lock);
+		mii_ethtool_gset(&private->mii_if, &ecmd);
+		spin_unlock_irq(&private->lock);
+		if (copy_to_user(useraddr, &ecmd, sizeof (ecmd)))
+			return -EFAULT;
+		return 0;
+	}
+		/* set settings */
+	case ETHTOOL_SSET:{
+		int r;
+		struct ethtool_cmd ecmd;
+		if (copy_from_user(&ecmd, useraddr, sizeof (ecmd)))
+			return -EFAULT;
+		spin_lock_irq(&private->lock);
+		r = mii_ethtool_sset(&private->mii_if, &ecmd);
+		spin_unlock_irq(&private->lock);
+		return r;
+	}
+		/* restart autonegotiation */
+	case ETHTOOL_NWAY_RST:{
+		return mii_nway_restart(&private->mii_if);
+	}
+		/* get link status */
+	case ETHTOOL_GLINK:{
+		struct ethtool_value edata = { ETHTOOL_GLINK };
+		edata.data = mii_link_ok(&private->mii_if);
+		if (copy_to_user(useraddr, &edata, sizeof (edata)))
+			return -EFAULT;
+		return 0;
+	}
+		/* get message-level */
+	case ETHTOOL_GMSGLVL:{
+		struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+		edata.data = 0;	/* XXX */
+		if (copy_to_user(useraddr, &edata, sizeof (edata)))
+			return -EFAULT;
+		return 0;
+	}
+		/* set message-level */
+	case ETHTOOL_SMSGLVL:{
+		struct ethtool_value edata;
+		if (copy_from_user(&edata, useraddr, sizeof (edata)))
+			return -EFAULT;
+		/* debug = edata.data; */
+		return 0;
+	}
+	}
+	return -EOPNOTSUPP;
+}
+#endif
+static int
+mv_eth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *) &rq->ifr_data;
+	int phy = dev->base_addr & 0x1f;
+	int retval = -EOPNOTSUPP;
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+#ifdef ETHERTOOL_FIXED
+		retval = netdev_ethtool_ioctl(dev, (void *) rq->ifr_data);
+#endif
+		break;
+    
+	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
+	case SIOCDEVPRIVATE:	/* for binary compat, remove in 2.5 */
+		data->phy_id = phy;
+		/* Fall through */
+    
+	case SIOCGMIIREG:	/* Read MII PHY register. */
+	case SIOCDEVPRIVATE + 1:	/* for binary compat, remove in 2.5 */
+		data->val_out =
+			mdio_read(dev, data->phy_id & 0x1f, data->reg_num & 0x1f);
+		retval = 0;
+		break;
+
+	case SIOCSMIIREG:	/* Write MII PHY register. */
+	case SIOCDEVPRIVATE + 2:	/* for binary compat, remove in 2.5 */
+		if (!capable(CAP_NET_ADMIN)) {
+			retval = -EPERM;
+		} else {
+			mdio_write(dev, data->phy_id & 0x1f,
+				   data->reg_num & 0x1f, data->val_in);
+			retval = 0;
+		}
+		break;
+    
+	default:
+		retval = -EOPNOTSUPP;
+		break;
+	}
+	return retval;
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * Initializes the ethernet interface's private structure.
+ * Statistics, descriptors, etc...
+ *
+ * Input : pointer to network device structure to be filled
+ * Output : N/A
+ */
+void
+mv_eth_init_priv(struct net_device *dev)
+{
+	gt_eth_priv *private;
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_init_priv\n");
+#endif
+
+	private = (gt_eth_priv *) kmalloc(sizeof (*private), GFP_KERNEL);
+	if (!private) {
+		panic("firehawk_eth_init_priv : kmalloc failed\n");
+	}
+	dev->priv = (void *) private;
+	memset(private, 0, sizeof (*(private)));
+
+	private->mii_if.dev = dev;
+	private->mii_if.phy_id = dev->base_addr;
+	private->mii_if.mdio_read = mdio_read;
+	private->mii_if.mdio_write = mdio_write;
+	private->mii_if.advertising = mdio_read(dev, dev->base_addr, MII_ADVERTISE);
+
+	spin_lock_init(&private->lock);
+	private->inited = false;
+
+#ifdef ETH_DBG_INFO
+	printk("Successful init of priv\n");
+#endif
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * Currently a no-op.  According to previous commentary, the hardware
+ * "cannot [!] be stuck because it is a built-in hardware - if we reach
+ * here the ethernet port might be [physically] disconnected..."
+ */
+void
+mv_eth_tx_timeout(struct net_device *dev)
+{
+#ifdef ETH_DBG_PKT
+	printk("mv_eth_tx_timeout\n");
+#endif
+
+#ifdef ETH_DBG_WARN
+	u32 cause = MV_REG_READ(MV_ETH_ICR );
+	u32 mask = MV_REG_READ(MV_ETH_IMR );
+	printk("mv_eth_tx_timeout: cause =%x, mask=%x\n", cause, mask);
+#endif /* ETH_DBG_WARN */
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ *  First function called after registering the network device.
+ *  It's purpose is to initialize the device as an ethernet device,
+ *  fill the structure that was given in registration with pointers
+ *  to functions, and setting the MAC address of the interface
+ *
+ *  Input : pointer to network device structure to be filled
+ *  Output : -ENONMEM if failed, 0 if success
+ */
+s32
+mv_eth_init(struct net_device * dev)
+{
+	int iNumOfVlans, i;
+	u32 queue;
+	gt_eth_priv *private;
+	bool boFound = false;
+	BINDING *pBinding = NULL;
+	int vid = 0;
+	int size;
+	char *namebuf;
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_init\n");
+#endif
+
+	/* setup the reguar Ethernet stuff with the kernel */
+	ether_setup(dev);
+	dev = init_etherdev(dev, sizeof (gt_eth_priv));
+	if (!dev) {
+		panic("mv_eth_init: init_etherdev failed\n");
+	}
+
+	/* find location in device array */
+	iNumOfVlans = mvUnmGetNumOfVlans();
+	for (i = 1; i <= iNumOfVlans; i++) {    
+		if (mvBindings[i] && (mvBindings[i]->dev == dev)) {
+			/* found - initialize it */
+			boFound = true;
+			pBinding = mvBindings[i];
+			vid = i;
+			break;
+		}
+	}
+
+	if (!boFound || !pBinding) {
+		panic("mv_eth_init: can't find my own device\n");
+	}
+	if ((vid == 0) || (vid > mvUnmGetNumOfVlans())) {
+		panic("mv_eth_init: init_etherdev dev->vid error\n");
+	}
+
+	mv_eth_init_priv(dev);
+	private = (gt_eth_priv*)(dev->priv);
+	private->vid = vid; 
+
+	/* get the interface names from netconf */
+	mv_nc_GetVIDName(vid, &size, &namebuf);
+	memcpy(dev->name, namebuf, size + 1);
+	dev->name[size] = '\0'; /* just in case... */
+
+#ifdef ETH_DBG_INFO
+	printk("dev[%d]->name = %s\n", vid, dev->name);
+#endif
+  
+	dev->open = mv_eth_open;
+	dev->stop = mv_eth_stop;
+	dev->set_config = NULL;	/* no runtime config support for now */
+	dev->hard_start_xmit = mv_eth_start_xmit;
+	dev->do_ioctl = mv_eth_ioctl;
+	dev->get_stats = mv_eth_get_stats;
+	dev->set_mac_address = mv_eth_set_mac_address;
+	dev->set_multicast_list = mv_eth_set_rx_mode;
+	dev->tx_timeout = mv_eth_tx_timeout;	/* Currently no-op */
+	dev->watchdog_timeo = 2 * HZ;
+	dev->flags &= ~IFF_RUNNING;
+
+	if (!private->inited) {
+		memcpy(dev->dev_addr, mv_nc_GetMacOfVlan(vid), GT_ETHERNET_HEADER_SIZE);
+		private->port = 0;
+		private->inited = true;
+	}
+
+	if (mvEthHw.hwState == HW_UNKNOWN) {
+		MV_REG_WRITE(MV_ETH_SDCR,
+			     (0x3 << 12) | (1 << 9) | (0xf << 2)
+			     | (1 << 6) | (1 << 7)); /*  0000.203c */
+
+		/* enable */
+		MV_REG_WRITE(MV_ETH_PCR, MV_REG_READ(MV_ETH_PCR) | (1 << 7));
+
+		/* no promisc */
+		MV_REG_WRITE(MV_ETH_PCR, MV_REG_READ(MV_ETH_PCR) & ~(1 << 0));
+
+		/* set full duplex  */
+		MV_REG_WRITE(MV_ETH_PCR, MV_REG_READ(MV_ETH_PCR) | (1 << 15));
+
+#ifdef HEADERS
+		MV_REG_WRITE(MV_ETH_PCXR,
+			     ((1<<22) | (1<<19) | (1<<18) | (1<<16)
+			      | (1<<14) | (1<<10) | (1<<9) /* |(1<<8)*/));
+#else
+		MV_REG_WRITE(MV_ETH_PCXR, ((1<<16) | (1<<14) | (1<<8)));
+#endif
+
+		/*
+		 * The FIREHAWK Enet engine accesses its queues of DMA
+		 * descriptors in uncached mode, so we dedicate a page
+		 * for each queue and mark each such page uncached.
+		 */
+		for (queue = 0; queue < NUM_TX_QUEUES; queue++) {
+			ASSERT(mvEthHw.TXqueue[queue] ==  NULL);
+			if (queue == MV_ETH_TX_QUEUE) {
+				mvEthHw.TXqueue[queue] = (gt_dma_desc*)dmaalloc(PAGE_SIZE, 0);
+				if(mvEthHw.TXqueue[queue] == NULL) {
+					panic("Can't allocate memory for descriptors\n");
+				}
+			}
+			else {
+				mvEthHw.TXqueue[queue] = (gt_dma_desc*)0;
+			}
+		}
+
+		for (queue = 0; queue < NUM_RX_QUEUES; queue++) {
+			ASSERT(mvEthHw.RXqueue[queue] == NULL);
+			if (queue == MV_ETH_RX_QUEUE) {
+				mvEthHw.RXqueue[queue] = (gt_dma_desc*)dmaalloc(PAGE_SIZE, 0);
+				if(mvEthHw.RXqueue[queue] == NULL) {
+					panic("Can't allocate memory for descriptors\n");
+				}
+			}
+			else {
+				mvEthHw.RXqueue[queue] = (gt_dma_desc*)0;
+			}
+		}
+
+		/* initialize address table for hash mode 0 with 1/2K size
+		 * the address will be added to address table at eth_open
+		 */
+		/* bchaikin: todo - move address management to ATU tables */
+		initAddressTable(private->port, 0, 1, 0);
+
+		mvEthHw.hwState = HW_INIT;
+	}
+  
+	/* read MIB counters in order to reset them, then zero all the
+	 * stats fields in memory
+	 */
+	mv_eth_update_stat(dev);
+
+	return 0;
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ *  This function is called when opening the network device. The function
+ *  should initialize all the hardware, initialize cyclic Rx/Tx
+ *  descriptors chain and buffers and allocate an IRQ to the network
+ *  device.
+ *
+ *  Input : a pointer to the network device structure
+ *
+ *  Output : zero if success, nonzero if fails.
+ */
+s32
+mv_eth_open(struct net_device * dev)
+{
+	gt_dma_desc *desc;
+	gt_eth_priv *priv;
+	s32 retval;
+	struct sk_buff *sk;
+	u32 count;
+	u32 gap = 0;
+	u32 port;
+	u32 port_status;
+	u32 queue;
+	unsigned int portsBitMask;
+	GT_STATUS status;
+	priv = dev->priv;
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_open: dev = %p\n", dev);
+#endif
+
+	ASSERT(mvEthHw.hwState != HW_UNKNOWN); /* already initialized by mv_eth_init */
+  
+	/* check if we need to move into HW_READY state */
+	if (mvEthHw.hwState == HW_INIT) { 
+		/*
+		 * Initialize the lists of Tx/Rx descriptors (as circular chains,
+		 * each in its own uncached page) using the physical addresses in
+		 * the "next" pointers that the Enet DMA engine expects.  The Rx
+		 * descriptors also get an sk_buff pre-allocated for them and their
+		 * "data" pointers set to point to the corresponding sk_buff buffer.
+		 */
+		for (queue = 0; queue < NUM_TX_QUEUES; queue++) {
+			mvEthHw.TXskbIndex[queue] =  mvEthHw.TXindex[queue] = 0;
+			desc = mvEthHw.TXqueue[queue];
+			if (desc) {
+				memset((void*)desc, 0, PAGE_SIZE); /* clean all descriptors */
+				for (count = 0; count < Q_INDEX_LIMIT; count++, desc++) {
+					desc->next = virt_to_phys((void*)(desc + 1));
+					mvEthHw.TXskbuff[queue][count] = 0;
+				}
+				--desc; /* link last desc to first desc, to make a ring */
+				desc->next = virt_to_phys((void*)(mvEthHw.TXqueue[queue]));
+				/* dma_cache_wback_inv(((u32)mvEthHw.TXqueue[queue]), PAGE_SIZE); */
+			}
+		}
+
+		for (queue = 0; queue < NUM_RX_QUEUES; queue++) {
+			mvEthHw.RXindex[queue] = 0;
+			desc = mvEthHw.RXqueue[queue];
+			if (desc) {
+				memset((void*)desc, 0, PAGE_SIZE); /* clean all descriptors */
+				for (count = 0; count < Q_INDEX_LIMIT; count++, desc++) {
+					desc->next = virt_to_phys((void*)(desc + 1));
+					desc->count.rx.bufferBytes = MAX_BUFF_SIZE;
+					desc->command_status = GT_ENET_DESC_OWNERSHIP | GT_ENET_DESC_INT_ENABLE;
+
+					sk = dev_alloc_skb(MAX_BUFF_SIZE);
+					desc->data = (void*)virt_to_phys((void*)(sk->data));
+					mvEthHw.RXskbuff[queue][count] = sk;
+					dma_cache_inv(((u32)(sk->data)), MAX_BUFF_SIZE);
+				}
+				--desc; /* link last desc to first desc, to make a ring */
+				desc->next = virt_to_phys((void *) (mvEthHw.RXqueue[queue]));
+				/* dma_cache_wback_inv(((u32)(mvEthHw.RXqueue[queue])), PAGE_SIZE); */
+			}
+		}
+
+		/* initialize DMA descriptor-pointer registers */
+		port = priv->port;
+		gap = ETH_ADDR_GAP * port;
+
+		/* Set Tx queues 0..1 */
+		MV_REG_WRITE(MV_ETH_CTDP0 + gap,
+			     virt_to_phys((void *)mvEthHw.TXqueue[0]));
+		MV_REG_WRITE(MV_ETH_CTDP1 + gap,
+			     virt_to_phys((void *)mvEthHw.TXqueue[1]));
+
+		/* Set Rx queues 0..3 */
+		MV_REG_WRITE(MV_ETH_FRDP0 + gap,
+			     virt_to_phys((void *)mvEthHw.RXqueue[0]));
+		MV_REG_WRITE(MV_ETH_CRDP0 + gap,
+			     virt_to_phys((void *)mvEthHw.RXqueue[0]));
+		MV_REG_WRITE(MV_ETH_FRDP1 + gap,
+			     virt_to_phys((void *)mvEthHw.RXqueue[1]));
+		MV_REG_WRITE(MV_ETH_CRDP1 + gap,
+			     virt_to_phys((void *)mvEthHw.RXqueue[1]));
+		MV_REG_WRITE(MV_ETH_FRDP2 + gap,
+			     virt_to_phys((void *)mvEthHw.RXqueue[2]));
+		MV_REG_WRITE(MV_ETH_CRDP2 + gap,
+			     virt_to_phys((void *)mvEthHw.RXqueue[2]));
+		MV_REG_WRITE(MV_ETH_FRDP3 + gap,
+			     virt_to_phys((void *)mvEthHw.RXqueue[3]));
+		MV_REG_WRITE(MV_ETH_CRDP3 + gap,
+			     virt_to_phys((void *)mvEthHw.RXqueue[3]));
+  
+		/* allocate IRQ */
+		retval = request_irq(MV88E6318INT_UNIMAC, mv_eth_int_handler,
+				     SA_INTERRUPT /* | SA_SAMPLE_RANDOM */, "mv_eth", NULL);
+		if (!retval) {
+			irq = MV88E6318INT_UNIMAC;
+#ifdef ETH_DBG_TRACE
+			printk("mv_eth_open: assigned IRQ %d to ISR\n", irq);
+#endif
+		}
+		else {
+			panic("mv_eth_open: cannot assign IRQ number to ISR\n");
+		}
+
+		/* clear all interrupts */
+		MV_REG_WRITE(MV_ETH_ICR + gap, 0x000000000);
+
+		/* enable interrupts */
+#ifdef DEBUG
+		MV_REG_WRITE(MV_ETH_IMR + gap, 0x90f10109);
+#else
+		/* enable the following interrupts:
+		 * bit 0 = Rx Buffer
+		 * bit 3 = Tx Done
+		 * bit 8 = Rx Error (to catch Rx ring overrun)
+		 */
+		MV_REG_WRITE(MV_ETH_IMR + gap, 0x90000109);
+#endif
+
+		mvEthHw.hwState = HW_READY;
+	}
+  
+	/* check link status on UniMAC.
+	 * no link on UniMAC indicates a HW unrecoverable error
+	 */
+	port_status = MV_REG_READ(MV_ETH_PSR + gap);
+	if ((port_status & 0x8) == 0) {
+		panic("mv_eth_open: no link on UniMAC\n");
+	}
+
+	/* check phy state */
+	check_phy_state(dev);
+#ifdef ETH_DBG_INFO
+	dump_link_state(dev);
+#endif
+
+	mv_eth_update_mac_address(dev->dev_addr, priv->port);  
+	if (mvEthHw.hwState == HW_READY) {
+		/* start RX (BIT(7) == EnableRXdma) */
+		MV_REG_WRITE(MV_ETH_SDCMR + gap, BIT(7));
+		mvEthHw.hwState = HW_ACTIVE;
+		mv_eth_update_mac_address(brdcast_mac, priv->port);
+	}
+
+	spin_lock_init(&dev->xmit_lock);
+	spin_lock_init(&lock);
+
+	portsBitMask = mvUnmGetPortMaskOfVid(priv->vid);
+
+#ifdef HEADERS  
+	mvBindings[priv->vid]->header[0] = 0; /* DBNUM = 0 */
+	mvBindings[priv->vid]->header[1] = portsBitMask;
+#elif defined (TRAILERS)
+	mvBindings[priv->vid]->trailer[0] = (1<<7); /* DBNUM = 0 */
+	mvBindings[priv->vid]->trailer[1] = portsBitMask;
+	mvBindings[priv->vid]->trailer[2] = 0; /* DBNUM = 0 */
+	mvBindings[priv->vid]->trailer[3] = 0;
+#endif
+
+	mvBindings[priv->vid]->boOpened = true;
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_open: VID %d is %s\n",
+	       priv->vid, (portsBitMask? "UP": "DOWN"));
+#endif
+
+	/* update logical link state, RUNNING flag and queue state */
+	if (portsBitMask == 0) {
+		netif_stop_queue(dev);
+		dev->flags &= ~IFF_RUNNING;
+		mvBindings[priv->vid]->boLinkUp = false;
+		netif_carrier_off(dev);
+	}
+	else {
+		netif_start_queue(dev);
+		dev->flags |= IFF_RUNNING;
+		mvBindings[priv->vid]->boLinkUp = true;
+		netif_carrier_on(dev);
+	}
+
+	status = mvUnmCreateVlan(priv->vid, portsBitMask);
+	if( status != GT_OK) {
+		panic("mv_eth_open: cannot create VID %d with bitmask %x\n",
+		      priv->vid, portsBitMask);
+		return -1;
+	}
+
+	MOD_INC_USE_COUNT;
+
+	return (0);
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function is used when closing the network device.  It should update
+ * the hardware, release all memory that holds buffers and descriptors and
+ * release the IRQ.
+ * Input : a pointer to the device structure
+ * Output : zero if success, nonzero if fails
+ */
+int
+mv_eth_stop(struct net_device *dev)
+{
+	gt_eth_priv *priv;
+	u32 queue;
+	u32 count;
+	bool boLastDev = false;
+	int iNumOfVlans, i;
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_stop\n");
+#endif
+
+	iNumOfVlans = mvUnmGetNumOfVlans();
+	priv = dev->priv;
+  
+	ASSERT(priv->vid);
+#ifdef ETH_DBG_INFO
+	printk("eth_stop for [%d]\n", priv->vid);
+#endif
+
+	if (mvBindings[priv->vid]->boOpened == false) {
+#ifdef ETH_DBG_ERROR
+		printk("Kernel is trying to close a closed interface!\n");
+#endif
+		return 0;
+	}
+  
+	/* mark this interface as closed */
+	mvBindings[priv->vid]->boOpened = false; 
+	netif_stop_queue(dev);
+
+	for (i = 1; i <= iNumOfVlans; i++) {
+		if (mvBindings[i]->boOpened) {
+			break; /* there are still open devices */
+		}
+	}
+	if (i == iNumOfVlans) {
+		boLastDev = true;
+	}
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_stop: closing (%s) interface (VID = %d)\n",
+	       boLastDev? "last": "not last", priv->vid );
+#endif
+
+	if (boLastDev) {
+		/* stop RX and mask interrupts */
+		MV_REG_WRITE(MV_ETH_SDCMR + (ETH_ADDR_GAP * priv->port), 0x00008000);
+		free_irq(irq, NULL); /* free_irq(dev->irq, dev); */
+
+		/* going down to ready */
+		mvEthHw.hwState = HW_READY;
+
+#ifdef ETH_DBG_TRACE
+		printk("mv_eth_stop: release RX buffers\n");
+#endif
+		for (queue = 0; queue < NUM_RX_QUEUES; queue++) {
+			for (count = 0; count < Q_INDEX_LIMIT; count++) {
+				if (mvEthHw.RXskbuff[queue][count]) {
+					dev_kfree_skb(mvEthHw.RXskbuff[queue][count]);
+					mvEthHw.RXskbuff[queue][count] = 0;
+				}
+			}
+		}
+
+#ifdef ETH_DBG_TRACE
+		printk("mv_eth_stop: release data structures\n");
+#endif
+		for (i = 1; i < iNumOfVlans; i++) {
+			if (mvBindings[i]) {
+				if (mvBindings[i]->dev) {
+					unregister_netdev(mvBindings[i]->dev);
+					if (mvBindings[i]->dev->priv) {
+						kfree(mvBindings[i]->dev->priv);
+					}
+					kfree(mvBindings[i]->dev);
+				}
+				kfree(mvBindings[i]);
+			} 
+		}
+		memset(mvBindings, 0, sizeof(mvBindings));
+	}
+
+	MOD_DEC_USE_COUNT; 
+	return (0);
+}
+
+
+static int start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	gt_eth_priv *priv = dev->priv;
+	u32 queue = MV_ETH_TX_QUEUE;
+
+	gt_dma_desc *tx;
+	u32 TXindex;
+	int i;
+
+#ifdef ETH_DBG_PKT
+	printk("start_xmit: skb = %p, dev = %p\n", skb, dev);
+#endif
+
+#if defined (HEADERS) || defined (TRAILERS) 
+	bool boCopy = false;
+	struct sk_buff *skb_copy;
+#endif
+
+#ifdef HEADERS
+	/*
+	 * Here we need to check header insertion and padding,
+	 * if we have no place at the beginning of buffer for header, or we have no sufficient padding space
+	 * we copy the packet to a fresh SKB 
+	 */
+#ifdef ETH_DBG_ECHO
+	printk("start_xmit: skb->data - skb->head == %d\n", (skb->data - skb->head));
+#endif /*  ETH_DBG_ECHO */
+
+	/* header check */
+	if( (skb->data - skb->head) < 2 ) {
+		boCopy = true;
+#ifdef ETH_DBG_ERROR
+		printk("start_xmit: dev %d: need to copy beacuse of header\n", priv->vid);
+#endif /* ETH_DBG_ERROR */
+	}
+
+	/* padding check */
+	/* instead of copy, we can DMA garbage from the packet's end ... (Security!!!) */
+#if 0
+	if (skb->len < MIN_ETH_PACKET_LEN) { /*  MINIMAL_ETH_PACKET_LEN == 60 */
+		if ((skb->end - skb->tail) < (MIN_ETH_PACKET_LEN - skb->len)) {
+			boCopy = true;
+#ifdef ETH_DBG_ERROR
+			printk("Dev [%d] - need to copy beacuse of padding\n", priv->vid);
+#endif
+		}
+	}
+#endif /* 0 */
+  
+	if (boCopy) {
+#ifdef ETH_DBG_PKT
+		printk("mv_eth_start_xmit: buffer copy for header insertion\n");
+#endif
+		skb_copy = dev_alloc_skb(MAX_BUFF_SIZE);
+		priv->privstat.tx_needed_copy++;
+		if( skb_copy == NULL ) { /* silently drop */
+#ifdef ETH_DBG_ERROR
+			printk(KERN_CRIT "silently drop\n");
+#endif /* ETH_DBG_ERROR */
+			priv->stat.tx_dropped++;
+			return -EBUSY;
+		}
+		skb_copy->dev = dev;
+		/* let's copy (we are placing the data in the real data, idea is to reflect a 'normal' packet */
+		skb_copy->data = skb_copy->head + HEADER_SIZE;
+		memcpy( skb_copy->data, skb->data, skb->len );
+		skb_copy->len = skb->len;
+		/* free the original skb */ 
+		dev_kfree_skb(skb);
+
+		/* in any case skb is now pointing to an skb with a place to
+		 * put the header in front and the length is not updated but
+		 * we do have a sufficient valid buffer at packet's end
+		 */
+		skb = skb_copy;
+	}
+	/* we need to check the length before adding the header's two bytes, after switch will extract
+	 * header the packet (with 4 bytes crc) should be 64 or longer
+	 */
+	if (skb->len < MIN_ETH_PACKET_LEN) {
+		skb->len = MIN_ETH_PACKET_LEN; /* this is safe because we allocated this skb */
+	}
+
+	/* prepare the header place and insert the header */
+	skb->data -= 2;
+	skb->len += 2;
+	ASSERT(((skb->data - skb->head) >= 0));
+	/* skb->data[0] = mvBindings[priv->vid]->header[0]; */
+	/* skb->data[1] = mvBindings[priv->vid]->header[1]; */
+	((unsigned short*)skb->data)[0] =
+		((unsigned short*)(mvBindings[priv->vid]->header))[0];
+
+#elif defined (TRAILERS)
+	/*
+	 * Here we need to check trailer insertion and padding,
+	 * if we have no place at the end of buffer for trailer, or we have no sufficient padding space
+	 * we copy the packet to a fresh SKB 
+	 */
+#ifdef ETH_DBG_ECHO
+	printk(" skb->end - skb->tail == %d\n",(skb->end - skb->tail));
+#endif 
+
+	/* padding check */
+	if( skb->len < MIN_ETH_PACKET_LEN ) { /*  MINIMAL_ETH_PACKET_LEN == 60 */
+		if( (skb->end - skb->tail) < (MIN_ETH_PACKET_LEN - skb->len +4 )  ) {
+			boCopy = true;
+#ifdef ETH_DBG_ERROR
+			printk("Dev [%d] - need to copy beacuse of padding\n", priv->vid);
+#endif
+		}
+	}
+
+	/* trailer check */
+	else if( (skb->end - skb->tail) < 4 ) {
+		boCopy = true;
+#ifdef ETH_DBG_ERROR
+		printk("Dev [%d] - need to copy beacuse of trailer\n", priv->vid);
+#endif
+	}
+
+	if( boCopy ) {
+		skb_copy = dev_alloc_skb(MAX_BUFF_SIZE);
+		priv->privstat.tx_needed_copy++;
+		if( skb_copy == NULL ) { /* silently drop */
+			priv->stat.tx_dropped++;
+			return -EBUSY;
+		}
+		skb_copy->dev = dev;
+		/* let's copy (we are placing the data in the real data, idea is to reflect a 'normal' packet */
+		memcpy( skb_copy->data, skb->data, skb->len );
+		skb_copy->len = skb->len;
+		/* free the original skb */ 
+		dev_kfree_skb(skb);
+
+		/* in any casy skb is now pointing to an skb with a place to put the header in front and
+		 * the length is not updated but we do have a sufficient valid buffer at packet's end
+		 */
+		skb = skb_copy;
+	}
+	/* we need to check the length before adding the header's two bytes, after switch will extract
+	 * header the packet (with 4 bytes crc) should be 64 or longer
+	 */
+	if(skb->len < MIN_ETH_PACKET_LEN ) {
+		skb->len = MIN_ETH_PACKET_LEN; /* this is safe because we allocated this skb */
+	}
+
+	/* prepare the trailer place and insert the trailer */
+
+	ASSERT( ((skb->end - skb->tail) >= 0) );
+	/* TODO - use a faster memcpy */
+	skb->data[skb->len]   = mvBindings[priv->vid]->trailer[0];
+	skb->data[skb->len+1] = mvBindings[priv->vid]->trailer[1];
+	skb->data[skb->len+2] = mvBindings[priv->vid]->trailer[2];
+	skb->data[skb->len+3] = mvBindings[priv->vid]->trailer[3];
+	skb->len += 4;
+#endif /*  HEADERS elif TRAILERS */
+
+	dev->trans_start = jiffies;	/* timestamp */
+	TXindex = mvEthHw.TXindex[queue];
+	if (mvEthHw.TXskbuff[queue][TXindex]) {
+		panic("Error on mv_eth device driver");
+	}
+
+	mvEthHw.TXskbuff[queue][TXindex] = skb;
+	tx = &mvEthHw.TXqueue[queue][TXindex];
+
+#ifdef DESC_CACHABLE
+	dma_cache_inv(((u32)tx), 32);
+#endif
+
+	tx->data = (void*)virt_to_phys((void*)skb->data);
+	tx->count.tx.bytes = skb->len;
+	tx->count.tx.reserved = (u16)priv->vid;
+  
+	/* flush/sync before transferring ownership */
+	dma_cache_wback_inv(((u32)(skb->data)), ((u32)(skb->len)));
+	wmb();
+  
+	/* Officially transfer ownership of descriptor
+	   31: Owner = 1 HW
+	   23: EI    = 1 Interrupt Enabled
+	   22: GC    = 1 Generate CRC
+	   18: P     = 1 Pad zeros
+	   17: F     = 1 First in packet
+	   16: L     = 1 Last in packet
+	*/
+	tx->command_status = (1 << 31) | (1 << 23) | (1 << 22) | (7 << 16);
+#ifdef DESC_CACHABLE
+	dma_cache_wback_inv((u32)tx, u32);
+#endif
+  
+	TXindex++;
+	if (TXindex == Q_INDEX_LIMIT) {
+		TXindex = 0;
+	}
+
+	/* if next descriptor is GT owned then the tx queue is full */
+	if (mvEthHw.TXskbuff[queue][TXindex]) {
+		/* we will stop all queues, as HW is a shared resource */
+		for (i = 1; i <= mvUnmGetNumOfVlans(); i++) {
+#ifdef ETH_DBG_PKT
+			printk ("start_xmit: stopping queue %d\n", i);
+#endif
+			netif_stop_queue(mvBindings[i]->dev);
+		}
+	}
+	mvEthHw.TXindex[queue] = TXindex;
+
+	/* start Tx LOW dma */
+	MV_REG_WRITE(MV_ETH_SDCMR + (ETH_ADDR_GAP * priv->port),
+		     queue? (1 << 23): (1 << 24));
+
+	return 0; /* success */
+}
+
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function queues a packet in the Tx descriptor for required
+ * port.  It checks the IPTOS_PREC_FLASHOVERRIDE bit of the ToS
+ * field in the IP header and decides where to queue the packet,
+ * in the high priority queue or in the low priority queue.
+ *
+ * Input : skb - a pointer to socket buffer
+ *         dev - a pointer to the required port
+ *
+ * Output : zero upon success, negative number upon failure
+ *         (-EBUSY when the interface is busy)
+ */
+int mv_eth_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	unsigned long flags;
+	int stat;
+
+#ifdef ETH_DBG_PKT
+	printk("mv_eth_start_xmit: skb = %p, dev = %p\n", skb, dev);
+#endif
+
+	ASSERT(dev && dev->priv);
+
+	if (!skb) {
+		((gt_eth_priv*)(dev->priv))->stat.tx_dropped++;
+#ifdef ETH_DBG_ERROR
+		printk(KERN_CRIT "Fatal Error SKB == NULL in start tx\n");
+#endif /* ETH_DBG_ERROR */
+		return -EBUSY;
+	}
+	ASSERT(netif_carrier_ok(mvBindings[priv->vid]->dev));
+	ASSERT(mvBindings[priv->vid]->boLinkUp == true);
+
+	spin_lock_irqsave(&lock, flags);
+	stat = start_xmit(skb, dev);
+	spin_unlock_irqrestore(&lock, flags);
+
+	return stat;
+}
+
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function is forward packets that are received from the port's
+ * queues toward kernel core or FastRoute them to another interface.
+ *
+ * Input : dev - a pointer to the required interface
+ *
+ * Output : number of served packets
+ */
+void
+mv_eth_receive_queue(unsigned long data)
+{
+	gt_dma_desc *rx;
+	struct sk_buff *skb;
+	struct sk_buff *new_skb;
+	u32 RXindex;
+	u32 served;
+	MV_UNM_VID vid;
+	u32 eth_int_mask;
+	int queue = MV_ETH_RX_QUEUE;
+	unsigned int max = (unsigned int)data;
+	gt_eth_priv* priv;
+
+#if defined (HEADERS) || defined (TRAILERS)
+	unsigned char ucSrcPort;
+#endif
+
+#ifdef MC_BRIDGE_EXAMPLE
+	int isMulticast;
+#endif
+
+#ifdef ETH_DBG_PKT
+	printk("mv_eth_receive_queue\n");
+#endif
+
+	/* Taken from original ISR */
+	/* We are clearing the interrupt rx bit here, in order to avoid spending unneccesary
+	 * time in acknowledging sparious interrupts
+	 */
+	MV_REG_WRITE(MV_ETH_ICR, (u32)~0x1);
+
+	RXindex =  mvEthHw.RXindex[queue];	/* Where we left off... */
+	served = 0;
+	while (max) {
+		rx = &(mvEthHw.RXqueue[queue][RXindex]);
+#ifdef DESC_CACHABLE
+		invalidate_dcache(rx);
+#endif
+
+		if (rx->command_status & GT_ENET_DESC_OWNERSHIP) {
+			break;
+		}
+		max--;
+    
+#ifdef ETH_DBG_PKT
+		printk("mv_eth_receive_queue %d: rx == %p\n", max, rx);
+#endif
+
+		/*
+		 * If received packet has errors, keep the socket buffer and change
+		 * descriptor to GT ownership and continue analyzing next descriptor.
+		 */
+		if (rx->command_status & GT_ENET_DESC_ERROR_SUMMARY) {
+			rx->command_status = GT_ENET_DESC_OWNERSHIP | GT_ENET_DESC_INT_ENABLE;
+#ifdef DESC_CACHABLE
+			flush_dcache(rx);
+#endif
+			RXindex++;
+			if (RXindex == Q_INDEX_LIMIT) {
+				RXindex = 0;
+			}
+			continue;
+		}
+
+#ifdef ETH_DBG_PKT
+		printk("mv_eth_receive_queue %d: good rx\n", max);
+#endif
+
+		/*
+		 * We never leave descriptors without an skb
+		 * we will allocate new skb, if we cannot allocate we will return the 'just-closed'
+		 * descriptor to HW ownership and will not! indicate current packet up the stack
+		 */
+		new_skb = dev_alloc_skb(MAX_BUFF_SIZE);
+		if( new_skb == NULL ) {
+#ifdef ETH_DBG_ERROR
+			printk(KERN_CRIT "Could not alloc new skb\n");
+#endif /* ETH_DBG_ERROR */
+			rx->command_status = GT_ENET_DESC_OWNERSHIP | GT_ENET_DESC_INT_ENABLE;
+
+#ifdef DESC_CACHABLE
+			flush_dcache(rx);
+#endif
+
+			RXindex++;
+			if (RXindex == Q_INDEX_LIMIT) {
+				RXindex = 0;
+			}
+			continue;
+		}
+    
+#ifdef ETH_DBG_PKT
+		printk("mv_eth_receive_queue %d: new_skb == %p\n", max, new_skb);
+#endif
+
+		/* okay, let's deal with the packet */
+		served++;
+		skb = mvEthHw.RXskbuff[queue][RXindex];
+
+#ifdef DESC_CACHABLE    
+		invalidate_dcache(rx);
+#endif
+
+
+#ifdef ETH_DBG_ERROR
+		if( skb == NULL || skb->len != 0 )
+			printk("mv_eth_receive_queue: SKB error\n");
+#endif /* ETH_DBG_ERROR */
+
+#ifdef ETH_DBG_PKT
+		printk("mv_eth_receive_queue %d: skb == %p\n", max, skb);
+#endif
+
+		if (skb) {
+			if (skb->len) {
+#ifdef ETH_DBG_ERROR
+				printk("mv_eth_receive_queue: nonzero existing SKB\n");
+#endif /* ETH_DBG_ERROR */
+				dev_kfree_skb(skb);
+				skb = dev_alloc_skb(MAX_BUFF_SIZE);
+			}
+			/* tail - point to data end, len and data fileds will be updated manualy to extract header */
+
+#ifdef ETH_DBG_PKT
+			printk("mv_eth_receive_queue %d: skb->len == %d\n", max, skb->len);
+#endif
+
+#ifdef HEADERS
+			ucSrcPort = ((skb->data[1]) & 0xf );
+
+#ifdef MC_BRIDGE_EXAMPLE
+			if (((skb->data[2] & 0x1) != 0) &&
+			    (*(unsigned int*)&skb->data[4] != 0xFFFFFFFF)) {
+				isMulticast = 1;
+#ifdef ETH_DBG_MC
+				printk("Received a multi packet (PCR : %0#x)\n",
+				       get_port_config(0));
+				printk("%0#x-%0#x-%0#x-%0#x-%0#x-%0#x\n",
+				       skb->data[2], skb->data[3], skb->data[4],
+				       skb->data[5],skb->data[6],skb->data[7]);
+#endif
+			}
+			else {
+				isMulticast = 0;
+			}
+#endif /* MC_BRIDGE_EXAMPLE */
+      
+			skb_put(skb, (rx->count.rx.bytesReceived - 4 ));
+			skb->data += 2;
+			skb->len = skb->len - 2; /* skb_put above updated the init value */
+
+#elif defined (TRAILERS)
+			ucSrcPort = ((skb->data[rx->count.rx.bytesReceived - 8 + 1])    & 0xf );
+			memmove( skb->data + 2, skb->data, (rx->count.rx.bytesReceived - 8));
+			skb->data += 2;
+			skb_put(skb, (rx->count.rx.bytesReceived - 8 ));
+#else
+			memmove( skb->data + 2, skb->data, (rx->count.rx.bytesReceived - 4));
+			skb->data += 2;
+			skb_put(skb, (rx->count.rx.bytesReceived - 4 ));
+#endif /* HEADERS */
+
+
+#ifdef DESC_CACHABLE      
+			invalidate_dcache(rx);
+#endif
+
+#ifdef ETH_DBG_PKT
+			printk("mv_eth_receive_queue %d: skb_put done\n", max);
+#endif
+
+#if defined (HEADERS) || defined (TRAILERS) 
+			/* we need to find our device from the source port */
+
+			ASSERT( ucSrcPort <= GT_NUM_OF_SWITCH_PORTS );
+			ASSERT( ucSrcPort != GT_CPU_SWITCH_PORT );
+			vid = mvUnmGetVidOfPort(ucSrcPort);
+
+			ASSERT( vid != 0);
+			ASSERT( mvBindings[vid] != NULL );
+			ASSERT( mvBindings[vid]->dev != NULL);
+      
+			skb->dev = mvBindings[vid]->dev;
+			skb->protocol = eth_type_trans(skb,  mvBindings[vid]->dev);
+      
+			ASSERT( netif_carrier_ok(mvBindings[vid]->dev) );
+			ASSERT( mvBindings[vid]->boLinkUp == true);
+ 
+#else /*  ! (defined (HEADERS) || defined (TRAILERS)) */
+			skb->dev = mvBindings[1]->dev;
+			skb->protocol = eth_type_trans(skb,  mvBindings[1]->dev);
+#endif /*  defined (HEADERS) || defined (TRAILERS) */
+
+#ifdef ETH_DBG_PKT
+			printk("mv_eth_receive_queue %d: skb details filled\n", max);
+#endif
+
+			priv = (gt_eth_priv*)(skb->dev->priv);
+			priv->stat.rx_packets++;
+
+#ifdef MC_BRIDGE_EXAMPLE
+			if (isMulticast) {
+				skb->data -= 14;
+				skb->len += 14;
+				start_xmit(skb, mvBindings[vid^3]->dev); /* vid 1 -> vid 2, vid 2 -> vid 1 */
+			}
+			else
+#endif
+			{
+				netif_rx(skb);
+			}
+			/*
+			  if( netif_rx(skb) != NET_RX_SUCCESS ) {
+			  printk(KERN_CRIT "netif_rx error\n");
+			  ((gt_eth_priv*)(mvBindings[vid]->dev->priv))->stat.rx_fifo_errors++;
+			  }
+			*/
+
+#ifdef ETH_DBG_PKT
+			printk("mv_eth_receive_queue %d: netif_rx done\n", max);
+#endif
+		}
+    
+		skb = new_skb; /* dev_alloc_skb(MAX_BUFF_SIZE);*/
+		mvEthHw.RXskbuff[queue][RXindex] = skb;
+		ASSERT(skb);
+
+		dma_cache_inv(((u32)(skb->data)), MAX_BUFF_SIZE);
+		/* invalidate_dcache_range((u32) (skb->data),
+		   (u32) (skb->data) + MAX_BUFF_SIZE); */
+
+		/* skb->dev = dev; GM: removed */
+		rx->data = (void *) virt_to_phys((void *) skb->data);
+    
+		/*
+		 * Officially transfer ownership of descriptor to GT
+		 */
+		rx->command_status = 0x80800000;	/* GT owner bit */
+#ifdef DESC_CACHABLE
+		flush_dcache(rx);
+#endif
+    
+		RXindex++;
+		if (RXindex == Q_INDEX_LIMIT) {
+			RXindex = 0;
+		}
+
+#ifdef ETH_DBG_PKT
+		printk("mv_eth_receive_queue %d: rx == %p done\n", max, rx);
+#endif
+	}
+  
+	mvEthHw.RXindex[queue] = RXindex;
+  
+#ifdef ETH_DBG_ECHO
+	if(served) {
+		printk("Rx served %d\n",served);
+	}
+#endif /* ETH_DBG_ECHO */
+  
+	/* here we open the rx interrupt back again */
+#ifdef DEBUG
+	MV_REG_WRITE(MV_ETH_IMR + (ETH_ADDR_GAP * port), 0x90f10109);
+#else
+	eth_int_mask = MV_REG_READ(MV_ETH_IMR); /* Enhance to shadow this register */
+	MV_REG_WRITE(MV_ETH_IMR, (eth_int_mask | 0x00000101) );
+#endif
+
+#ifdef ETH_DBG_PKT
+	printk("mv_eth_receive_queue: %d packets served\n", served);
+#endif
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * Input : dev - a pointer to the required interface
+ *
+ * Output : N/A
+ */
+static void
+mv_eth_free_tx_queue(unsigned long queue)
+{
+	gt_eth_priv *priv;
+	gt_dma_desc *tx;
+	struct sk_buff *sk;
+	u32 freed_skbs;
+	u32 TXskbIndex;
+	struct net_device * dev;
+	MV_UNM_VID vid;
+	int i;
+	u32 eth_int_mask;
+  
+#ifdef ETH_DBG_PKT
+	printk("mv_eth_free_tx_queue: queue = %d\n",(int)queue);
+#endif
+
+	spin_lock(&lock);
+	freed_skbs = 0;
+	TXskbIndex = mvEthHw.TXskbIndex[queue];
+
+	while (1) {
+		sk = mvEthHw.TXskbuff[queue][TXskbIndex];
+		if (!sk) {
+			break;
+		}
+		tx = &(mvEthHw.TXqueue[queue][TXskbIndex]);	/* No write to tx here */
+		if (tx->command_status & 0x80000000) {
+			break;
+		}
+		vid = (int)(tx->count.tx.reserved);
+		ASSERT(vid != 0);
+
+#ifdef ETH_DBG_ECHO
+		if (vid == 0) {
+			panic("something went wrong with VID in TX END\n");
+		}
+		printk("Freeing TX packet for [%d]\n",vid);
+#endif
+
+		/* we need the dev (and the VID in tx descriptor - only for counters */
+		dev = mvBindings[vid]->dev;
+		priv = dev->priv;
+
+#ifdef DESC_CACHABLE
+		invalidate_dcache(tx);
+#endif
+
+		if (tx->command_status & 0x40) {
+			priv->stat.tx_fifo_errors++;
+		}
+		dev_kfree_skb_irq(sk);
+		mvEthHw.TXskbuff[queue][TXskbIndex] = 0;
+		TXskbIndex++;
+		if (TXskbIndex == Q_INDEX_LIMIT) {
+			TXskbIndex = 0;
+		}
+		freed_skbs++;
+		priv->stat.tx_packets++;
+	}
+	mvEthHw.TXskbIndex[queue] = TXskbIndex;
+  
+	spin_unlock(&lock);
+
+	if (mvEthHw.TXskbuff[queue][mvEthHw.TXindex[queue]] == 0) {
+		/* there is room in the Tx queue for more SKBs */
+		for (i = 1; i <= mvUnmGetNumOfVlans(); i++) {
+			if (netif_queue_stopped(mvBindings[i]->dev)
+			    && (mvBindings[i]->boLinkUp) /* && (mvBindings[i]->dev->flags & IFF_RUNNING) */
+				)
+			{
+				netif_wake_queue(mvBindings[i]->dev);
+#ifdef ETH_DBG_PKT
+				printk("mv_eth_free_tx_queue: netif_wake_queue %d\n", i);
+#endif
+			}
+		}
+	}
+	eth_int_mask = MV_REG_READ(MV_ETH_IMR); /* Enhance to shadow this register */
+	MV_REG_WRITE(MV_ETH_IMR, (eth_int_mask | 0x00000008));
+}
+
+
+/*
+ * ----------------------------------------------------------------------------
+ */
+void
+mv_eth_int_handler(s32 irq, void * unused, struct pt_regs *regs)
+{
+	u32 eth_int_cause;
+	u32 eth_int_mask;
+
+#ifdef ETH_DBG_PKT
+	printk("mv_eth_int_handler\n");
+#endif
+
+	eth_int_cause = MV_REG_READ(MV_ETH_ICR);
+	eth_int_mask = MV_REG_READ(MV_ETH_IMR); /* Enhance to shadow this register */
+
+#ifdef ETH_DBG_INFO
+	printk("mv_eth_int_handler: irq=%d, cause=0x%08x, mask=0x%08x\n",
+	       irq, eth_int_cause, eth_int_mask);
+#endif
+
+	if (eth_int_cause & 0x8) { /* TxDone */
+		eth_int_mask &= ~0x8;
+		MV_REG_WRITE(MV_ETH_IMR, eth_int_mask);
+		tasklet_schedule(&txComplete);
+		MV_REG_WRITE(MV_ETH_ICR, ~0x8);
+	}
+  
+	if (eth_int_cause & 0x1) { /* RxBuffer */
+		eth_int_mask &= ~0x1;
+		MV_REG_WRITE(MV_ETH_IMR, eth_int_mask);
+		tasklet_schedule(&rxComplete);
+		MV_REG_WRITE(MV_ETH_ICR, ~0x1);
+	}
+
+	if (eth_int_cause & 0x100) { /* RxError */
+		eth_int_mask &= ~0x101; /* clear pending Rx buffers */
+		MV_REG_WRITE(MV_ETH_IMR, eth_int_mask);
+		tasklet_schedule(&rxComplete);
+		MV_REG_WRITE(MV_ETH_ICR, ~0x101);
+	}
+
+#if 0
+
+	if (eth_int_cause & 0x10000000) {	/* MII PHY status changed */
+		u32 port_status;
+#ifdef ETH_DBG_INFO
+		printk(" MII PHY status interrupt\n");
+#endif
+    
+		/* check link status */
+		port_status = MV_REG_READ(MV_ETH_PSR);
+		if (!(port_status & 0x8)) {
+			/* here we have link down for our MAC, this should not happen in our QD<-->MAC connection */
+			panic("Phy link for MAC port is down!\n");
+		} 
+		eth_int_cause &= ~0x10000000;
+		MV_REG_WRITE(MV_ETH_ICR, ~0x10000000);
+	}
+
+	if (eth_int_cause & 0x20000000) {	/* MII SMI complete */
+		eth_int_cause &= ~0x20000000;
+		MV_REG_WRITE(MV_ETH_ICR, ~0x20000000);
+	}
+  
+	if (eth_int_cause & ~(1 << 31)) {
+#ifdef ETH_DBG_ERROR
+		printk("unhandled int %08x\n", eth_int_cause);
+#endif /* ETH_DBG_ERROR */
+		MV_REG_WRITE(MV_ETH_ICR, 0);
+	}
+#endif
+}
+
+/*********************************************************************/
+/* MII/SMI interface                                                 */
+/*********************************************************************/
+
+/*****************************************************************************
+ *
+ * int etherReadMIIReg (unsigned int portNumber , unsigned int MIIReg,
+ * unsigned int* value)
+ *
+ * Description
+ * This function will access the MII registers and will read the value of
+ * the MII register , and will retrieve the value in the pointer.
+ * Inputs
+ * portNumber - one of the 2 possiable Ethernet ports (0-1).
+ * MIIReg - the MII register offset.
+ * Outputs
+ * value - pointer to unsigned int which will receive the value.
+ * Returns Value
+ * 1 if success.
+ * 0 if fail to make the assignment.
+ * Error types (and exceptions if exist)
+ */
+
+static int
+etherReadMIIReg(unsigned int portNumber, unsigned int MIIReg,
+		unsigned int *value)
+{
+	SMI_REG smiReg;
+	unsigned int phyAddr;
+	unsigned int timeOut = 1000;
+	int i;
+	
+	phyAddr = PHY_ADD0 + portNumber;
+
+	/* first check that it is not busy */
+	smiReg = MV_REG_READ(MV_ETH_SMIR);
+	while (smiReg & SMI_BUSY) {
+		if (timeOut-- < 1) {
+#ifdef ETH_DBG_WARNING
+			printk("TimeOut Passed Phy is busy\n");
+#endif
+			return 0;
+		}
+		for (i = 0; i < 1000; i++) ;
+		smiReg = MV_REG_READ(MV_ETH_SMIR);
+	}
+	/* not busy */
+
+	MV_REG_WRITE(MV_ETH_SMIR,
+		     (SMI_OP_CODE_BIT_READ << 26) | (MIIReg << 21) | (phyAddr <<
+								      16));
+
+	timeOut = 1000;		/* initialize the time out var again */
+
+	for (i = 0; i < 1000; i++) ;
+	smiReg = MV_REG_READ(MV_ETH_SMIR);
+	while (!(smiReg & READ_VALID)) {
+		for (i = 0; i < 1000; i++) ;
+		smiReg = MV_REG_READ(MV_ETH_SMIR);
+		if (timeOut-- < 1) {
+#ifdef ETH_DBG_WARNING
+			printk("TimeOut Passed Read is not valid\n");
+#endif
+			return 0;
+		}
+	}
+
+	*value = (unsigned int) (smiReg & 0xffff);
+
+	return 1;
+}
+
+
+/*****************************************************************************
+ * 
+ * int etherWriteMIIReg (unsigned int portNumber , unsigned int MIIReg,
+ * unsigned int value)
+ * 
+ * Description
+ * This function will access the MII registers and will write the value
+ * to the MII register.
+ * Inputs
+ * portNumber - one of the 2 possiable Ethernet ports (0-1).
+ * MIIReg - the MII register offset.
+ * value -the value that will be written.
+ * Outputs
+ * Returns Value
+ * 1 if success.
+ * 0 if fail to make the assignment.
+ * Error types (and exceptions if exist)
+ */
+
+static int
+etherWriteMIIReg(unsigned int portNumber, unsigned int MIIReg,
+		 unsigned int value)
+{
+	SMI_REG smiReg;
+	unsigned int phyAddr;
+	unsigned int timeOut = 10;	/* in 100MS units */
+	int i;
+
+	/* first check that it is not busy */
+	(unsigned int) smiReg = MV_REG_READ(MV_ETH_SMIR);
+	if (smiReg & SMI_BUSY) {
+		for (i = 0; i < 10000000; i++) ;
+		do {
+			(unsigned int) smiReg = MV_REG_READ(MV_ETH_SMIR);
+			if (timeOut-- < 1) {
+#ifdef ETH_DBG_WARNING
+				printk("TimeOut Passed Phy is busy\n");
+#endif
+				return 0;
+			}
+		} while (smiReg & SMI_BUSY);
+	}
+	/* not busy */
+
+	phyAddr = PHY_ADD0 + portNumber;
+
+	smiReg = 0;		/* make sure no garbage value in reserved bits */
+	smiReg = smiReg | (phyAddr << 16) | (SMI_OP_CODE_BIT_WRITE << 26) |
+		(MIIReg << 21) | (value & 0xffff);
+
+	MV_REG_WRITE(MV_ETH_SMIR, *((unsigned int *) &smiReg));
+
+	return (1);
+}
+
+
+/*********************************************************************/
+/* port manipulation                                                 */
+/*********************************************************************/
+
+/*
+ * GT_STATUS  mv_eth_remove_port_from_vlan 
+ *
+ * remove a port from a given vlan.
+ * this function will remove the port from the vlan, update its trailer/header
+ * if this is the last port in this vlan we will signal the link of this vid to be down
+ * the interface will stop its RUNNING flag in this case
+ *
+ * Inputs:
+ * port - the port number to remove.
+ * vid  - the vid to remove the port from.
+ * newPortsBitMask - the new bit mask of this vid after a logical removal of this port.
+ *
+ * Outputs:
+ * GT_STATUS - operation status.
+ */
+static GT_STATUS  mv_eth_remove_port_from_vlan( unsigned int port, MV_UNM_VID vid, int newPortsBitMask) {
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_remove_port\n");
+#endif
+
+
+	if( vid < 1 || vid > mvUnmGetNumOfVlans() ) {
+		ASSERT(0); /*  that's a bug */
+		return GT_FAIL;
+	}
+	ASSERT(vid <= mvUnmGetNumOfVlans() );
+	ASSERT(vid>0); /*  ypu cannot remove from vid zero */
+	ASSERT(mvBindings[vid]->dev);
+  
+	/* if the new bit mask is zero it means we have left without any ports in this vlan,
+	 * and the link state should be updated (to DOWN)
+	 */	
+	if( newPortsBitMask != 0 ) { /*  not last port in this vlan */
+#if defined (HEADERS)
+		mvBindings[vid]->header[1] = (unsigned char)newPortsBitMask;
+#elif defined (TRAILERS)
+		mvBindings[vid]->trailer[1] = (unsigned char)newPortsBitMask;
+#else 
+#error "no trailers and no headers?"
+#endif
+	}
+	else { /*  last port in this vlan */
+#if defined (HEADERS)
+		mvBindings[vid]->header[0] = 0;
+		mvBindings[vid]->header[1] = 0;
+#elif defined (TRAILERS)
+		mvBindings[vid]->trailer[0] = 0;
+		mvBindings[vid]->trailer[1] = 0;
+#else 
+#error "no trailers and no headers?"
+#endif   
+		netif_stop_queue(mvBindings[vid]->dev);
+		(mvBindings[vid]->dev)->flags &= ~IFF_RUNNING;
+		netif_carrier_off(mvBindings[vid]->dev);    
+		mvBindings[vid]->boLinkUp = false;
+	}
+	return GT_OK;
+}
+
+/*
+ * GT_STATUS  mv_eth_add_port_to_vlan 
+ *
+ * add a port to a given vlan.
+ * this function will add the port to the vlan, update its trailer/header
+ * if this is the first port in this vlan we will signal the link of this vid to be up
+ * the interface will start and its RUNNING flag will be set in this case
+ *
+ * Inputs:
+ * port - the port number to add.
+ * vid  - the vid to add the port to.
+ * newPortsBitMask - the new bit mask of this vid after a logical removal of this port.
+ * numOfPorts - the number of ports in the vlan after a logical add of this (being added) port
+ *
+ * Outputs:
+ * GT_STATUS - operation status.
+ */
+static GT_STATUS  mv_eth_add_port_to_vlan( unsigned int port, MV_UNM_VID vid, int newPortsBitMask, int numOfPorts) {
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_add_port\n");
+#endif
+
+	ASSERT(vid);
+	ASSERT(mvBindings[vid]->dev);
+
+	if( vid < 1 || vid > mvUnmGetNumOfVlans() ) {
+		ASSERT(0); /*  that's a bug */
+		return GT_FAIL;
+	}
+
+	/* if number of ports is exactly one, then this port (being added now) is the fisrt
+	 * port in this vlan, and the link state should be updated
+	 */
+	if(numOfPorts != 1 ) { /*  not the first port, just update trailer/header */
+#if defined (HEADERS)
+		mvBindings[vid]->header[1] = (unsigned char)newPortsBitMask;
+#elif defined (TRAILERS)
+		mvBindings[vid]->trailer[1] = (unsigned char)newPortsBitMask;
+#else 
+#error "no trailers and no headers?"
+#endif
+	}
+	else { /*  first port in this vlan */
+#if defined (HEADERS)
+		mvBindings[vid]->header[0] = 0;
+		mvBindings[vid]->header[1] = (unsigned char)newPortsBitMask;
+#elif defined (TRAILERS)
+		mvBindings[vid]->trailer[0] = (1<<7); /*  INGRESS_TRAILER_OVERRIDE */
+		mvBindings[vid]->trailer[1] = (unsigned char)newPortsBitMask;
+#else 
+#error "no trailers and no headers?"
+#endif   
+		mvBindings[vid]->boLinkUp = true;
+		netif_carrier_on(mvBindings[vid]->dev);  
+		netif_start_queue(mvBindings[vid]->dev);
+		(mvBindings[vid]->dev)->flags |= IFF_RUNNING;
+	}
+	return GT_OK;
+}
+
+GT_STATUS mvDisassociatePort(int qdPort, int fromVlanId, int newPortsBitMask) {
+	return mv_eth_remove_port_from_vlan(qdPort, fromVlanId, newPortsBitMask);
+}
+GT_STATUS mvAssociatePort(int qdPort, int toVlanId, int newPortsBitMask, int numOfPorts) {
+	return mv_eth_add_port_to_vlan( qdPort, toVlanId, newPortsBitMask, numOfPorts);
+}
+
+
+/*********************************************************************/
+/* module start                                                      */
+/*********************************************************************/
+extern int qdEntryPoint(void);
+extern void qdExitPoint(void);
+extern int qdModuleStart(void);
+
+/* 
+ * int mv_eth_start(void) 
+ *
+ * the start function is to enable to split the real initialization of QD and networking 
+ * from the module initialization (either threw kernel boot or threw insmod command).
+ */
+int mv_eth_start(void) {
+	int cards = 0;
+	int status = GT_OK;
+	int iNumOfVlans,i;
+	BINDING * pBinding;
+	struct net_device * pNetDev = NULL;
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth_start\n");
+#endif
+
+	memset(mvBindings, 0, sizeof(mvBindings));
+	memset(&mvEthHw, 0, sizeof(mvEthHw));
+
+	if (qdModuleStart() != 0) {
+#ifdef ETH_DBG_ERROR
+		printk("Error in QD init\n");
+#endif
+	}
+
+	if ((status = mvUnmInitialize()) != GT_OK) {
+#ifdef ETH_DBG_ERROR
+		printk("Error - NetConfig is invalid, can't start network device\n");
+#endif
+		return -ENODEV;
+	}
+
+#ifdef ETH_DBG_INFO
+	printk("mv_eth_start UNM is initialized\n");
+#endif
+  
+	mvEthHw.hwState = HW_UNKNOWN;
+
+	iNumOfVlans = mvUnmGetNumOfVlans();
+#ifdef ETH_DBG_INFO
+	printk ("mv_eth init: iNumOfVlans = %d\n", iNumOfVlans);
+	mv_nc_printConf();
+#endif
+
+	/* When the first interface (represented by network device) is
+	   started, it creates and registers all interfaces.  Note that
+	   VID 0 is reserved */
+	for (i = 1; i <= iNumOfVlans; i++) {
+		/* allocate and clean data structures */
+		pBinding = (BINDING*)kmalloc(sizeof(BINDING), GFP_KERNEL);
+		pNetDev = (struct net_device *)kmalloc(sizeof(struct net_device), GFP_KERNEL); 
+		if (!pNetDev || !pBinding) {
+			panic("mv_eth_module_init : kmalloc failed\n");
+		}
+		memset(pBinding, 0, sizeof(BINDING));
+		memset(pNetDev, 0, sizeof(struct net_device));
+
+		/* initialize structs */
+		mvBindings[i] = pBinding;
+		pBinding->pmvEthHw = &mvEthHw;
+		pBinding->dev = pNetDev;   
+		pNetDev->base_addr = PLATFORM_GTREG_BASE + FAST_ETH_MAC_OFFSET;
+		pNetDev->init = mv_eth_init;
+    
+		if (register_netdev(mvBindings[i]->dev) == 0) {
+			cards++;
+		}
+	}
+
+#if 0
+	/* CleanUP - deregister net devices */
+	if (cards < iNumOfVlans) {
+		panic("mv_eth_module_init : bad status\n");
+	}
+#endif
+
+#ifdef ETH_DBG_TRACE
+	printk("mv_eth module inited with %d devices\n", cards);
+#endif
+	return (cards > 0)? 0: -ENODEV;
+}
+
+
+/*********************************************************************/
+/* module initialization and deinitialization                        */
+/*********************************************************************/
+int __init mv_eth_module_init(void) {
+#ifdef ETH_DBG_INFO
+	printk("mv_eth module init\n");
+#endif
+	/* init the QD hidden module */
+	qdEntryPoint();
+	return 0;
+}
+
+void
+mv_eth_module_exit(void)
+{
+	/* exit for the QD hidden module */
+	qdExitPoint();
+#ifdef ETH_DBG_INFO
+	printk("mv_eth module exited\n");
+#endif
+
+}
+
+module_init(mv_eth_module_init);
+module_exit(mv_eth_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Marvell");
+MODULE_DESCRIPTION("Ethernet driver for Firehawk");
Index: linux-2.6.16/drivers/net/marvell/mv_unm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/mv_unm.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,497 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_unm.c $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file implements ???.
+ */
+
+/*#define MV_DEBUG*/
+
+#include <linux/marvell/mv_platform.h>
+#include <linux/marvell/mv_os.h>
+#include <linux/marvell/mv_debug.h>
+#include <linux/marvell/mv_qd.h>
+#include <linux/marvell/mv_unimac.h>
+
+
+typedef struct
+{
+	MV_UNM_VID		vidOfPort[GT_NUM_OF_SWITCH_PORTS];     /* map port to VLAN  */
+	int				numberOfVids;
+	GT_U32			cpuPortBitmask;
+	GT_U32 			portsOfVid[MV_UNM_MAX_VID];  
+	int  			numPortsOfVid[MV_UNM_MAX_VID];   
+	GT_BOOL			initiatedVids[MV_UNM_MAX_VID];
+} MV_UNM_NETCONFIG;
+
+static GT_BOOL			mvUnmIsInitialized = GT_FALSE;
+
+static MV_UNM_NETCONFIG	mvUnmNetConfig;
+
+const MV_UNM_CONFIG		mvUnmDefaultConfig = 
+{{1, 2, 2, 2, 2, 1, MV_UNM_VID_DISABLED}}; 
+
+extern GT_QD_DEV       	*qd_dev[2];
+
+extern GT_STATUS mvDisassociatePort(int qdPort, int fromVlanId, 
+				    int newPortsBitMask);
+
+extern GT_STATUS mvAssociatePort(int qdPort, int toVlanId, 
+				 int newPortsBitMask, int numOfPorts);
+
+void	mvUnmPrintStatus(void);
+
+/* Convert portMask to portList, exclude itself and set vlan port group */
+static GT_STATUS	mvUnmSetVlanPortMask(int port, GT_U32	portMask)
+{
+	GT_STATUS	status;
+	GT_LPORT	portList[GT_NUM_OF_SWITCH_PORTS];
+	int			i, idx=0;
+	
+	for(i=0; i<GT_NUM_OF_SWITCH_PORTS; i++)
+	{
+		if(i == port)
+			continue;
+
+		if( GT_CHKBIT(portMask, i) )
+		{
+			portList[idx] = i;
+			idx++;
+		}
+	}
+	status = gvlnSetPortVlanPorts(qd_dev[1], port, portList, (GT_U8)idx);
+	if(status != GT_OK)
+	{
+		gtOsPrintf("gvlnSetPortVlanPorts fail. Status = 0x%x\n", status);				
+		return status;
+	}
+
+	return GT_OK;
+}
+
+/* Convert VID to string name */
+static char*  mvUnmGetVlanName(int vid, char* name)
+{
+	switch(vid)
+	{
+	case MV_UNM_VID_DISABLED:
+		sprintf(name, "DISABLED(%d)", vid);
+		break;
+	case MV_UNM_VID_ISOLATED:
+		sprintf(name, "ISOLATED(%d)", vid);
+		break;
+	default:
+		sprintf(name, "VLAN_%d", vid);
+	}
+	return name;
+}
+
+/* This function initializes the network configuration data structure */
+static GT_STATUS mvUnmNetConfigInit(IN const MV_UNM_CONFIG* pUnmConfig)
+{
+	MV_UNM_NETCONFIG	nc;	
+	int					port, vid;
+
+	for(vid=0; vid<MV_UNM_MAX_VID; vid++)
+	{
+		nc.initiatedVids[vid] = GT_FALSE;
+		nc.portsOfVid[vid] = 0;
+		nc.numPortsOfVid[vid] = 0;
+	}    
+	nc.numberOfVids   = 0;
+	nc.cpuPortBitmask = 0;
+
+	/* ISOLATED and DISABLED VLANs always initiated */
+	nc.initiatedVids[MV_UNM_VID_ISOLATED] = GT_TRUE;
+	nc.initiatedVids[MV_UNM_VID_DISABLED] = GT_TRUE;
+
+	for(port=0; port<GT_NUM_OF_SWITCH_PORTS; port++)
+	{
+		if(port == GT_CPU_SWITCH_PORT)
+			continue;
+
+		vid = pUnmConfig->vidOfPort[port];
+		if(nc.initiatedVids[vid] == GT_FALSE)
+		{
+			nc.initiatedVids[vid] = GT_TRUE;
+			nc.numberOfVids++;
+		}
+		nc.numPortsOfVid[vid]++;
+		GT_SETBIT(nc.portsOfVid[vid], port); 
+		nc.vidOfPort[port] = vid;
+		if( (vid != MV_UNM_VID_ISOLATED) && (vid != MV_UNM_VID_DISABLED) )
+			GT_SETBIT(nc.cpuPortBitmask, port);
+	}   
+	memcpy(&mvUnmNetConfig, &nc, sizeof(nc));
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+ * mvUnmInitialize - initialize UniMAC manager
+ *
+ * DESCRIPTION:
+ *		Restore and initialize the UniMAC network configuration 
+ *		data structure
+ * 	
+ * INPUT: None
+
+ * RETURN:		
+ *		GT_OK			- on success
+ *		GT_BAD_PARAM	- if both unmConfig pointer and restoreCallback
+ *						are NULL or the unmConfig is not properly initialized 
+ *		GT_FAIL			- otherwise
+ *******************************************************************************/
+GT_STATUS  mvUnmInitialize(void)
+{	
+	GT_STATUS		status = GT_OK;
+	MV_UNM_CONFIG	unmConfig;
+	GT_U32			portMask;
+	int				port;
+
+	if( (getNetConfig(&unmConfig) != GT_OK) ) 
+	{
+		gtOsPrintf("Can't get netConfig: Use default\n");
+		status = mvUnmNetConfigInit(&mvUnmDefaultConfig);
+	}
+	else
+	{
+		status = mvUnmNetConfigInit(&unmConfig);
+	}
+	if (status != GT_OK)
+	{
+		gtOsPrintf("Can't Init netConfig: status = 0x%x\n", status);
+		return status;
+	}
+    
+#ifdef MV_DEBUG
+	mvUnmPrintStatus();	
+#endif
+
+	/* Create ISOLATED Vlan */
+	portMask = mvUnmNetConfig.portsOfVid[MV_UNM_VID_ISOLATED];
+	if(portMask != 0)
+	{
+		status = mvUnmCreateVlan(MV_UNM_VID_ISOLATED, portMask);
+		if (status != GT_OK)
+		{
+			gtOsPrintf("Can't create ISOLATED VID for portMask = %d: status = 0x%x\n", 
+				   (int)portMask, status);
+			return status;
+		}
+	}
+	/* Disable ports belongs to DISABLED Vlan */
+	portMask = mvUnmNetConfig.portsOfVid[MV_UNM_VID_DISABLED];
+	for(port=0; port<GT_NUM_OF_SWITCH_PORTS; port++)
+	{
+		if( GT_CHKBIT(portMask, port) )
+		{
+			status = gstpSetPortState(qd_dev[1], port, GT_PORT_DISABLE);
+			if (status != GT_OK)
+			{
+				gtOsPrintf("Can't disable port %d: status = 0x%x\n", port, status);
+				return status;
+			}
+		}
+	}
+
+	mvUnmIsInitialized  = GT_TRUE;
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * mvUnmGetNetConfig - Get port map association table
+ *
+ * DESCRIPTION:
+ *		Return existing UniMAC configuration to caller
+ *		
+ * INPUT:
+ *		None
+ *					
+ * OUTPUT:
+ *		unmConfig - pointer to network configuration structure
+ * RETURN:		
+ *		GT_OK	on success
+ *		GT_FAIL on error
+ *
+ * COMMENTS:
+ *******************************************************************************/
+
+GT_STATUS mvUnmGetNetConfig(OUT MV_UNM_CONFIG *config)
+{
+	if(mvUnmIsInitialized == GT_FALSE)
+		return GT_FAIL;
+
+	memcpy(config, &mvUnmNetConfig.vidOfPort, sizeof(MV_UNM_CONFIG) );
+	return GT_OK;
+}
+
+/*******************************************************************************
+ * mvUnmPortMoveTo - move to specific VLAN. Port 5 cannot be used in this function
+ *					Moving port to MV_UNM_VID_DISABLED VLAN cause this port to be 
+ *					disabled
+ * DESCRIPTION:
+ *		Move port to specific VLAN. 
+ * 		Port 5 cannot be used in this function
+ * INPUT:
+ *		qdPort:				port number
+ *		vid: 				VLAN id
+ * 	   
+ * OUTPUT:
+ *		None
+ * RETURN:		
+ *		GT_OK			on success
+ *		GT_BAD_PARAM	if a port number is invalid
+ *		GT_FAIL			on driver error
+ *
+ *******************************************************************************/
+GT_STATUS mvUnmPortMoveTo(IN int qdPort, IN const MV_UNM_VID vid)
+{	
+	GT_STATUS			status = GT_OK;
+	int					port, oldVid, vidPortNum, oldVidPortNum;
+	GT_U32				oldVidPortMask, vidPortMask, cpuPortMask;
+
+	if(mvUnmIsInitialized == GT_FALSE)
+		return GT_FAIL;
+
+	if( (vid >= MV_UNM_MAX_VID) || 
+	    (vid < 0) )
+	{
+		return GT_BAD_PARAM;
+	}
+
+	if( (qdPort == GT_CPU_SWITCH_PORT) || (qdPort < 0) || 
+	    (qdPort >= GT_NUM_OF_SWITCH_PORTS) )
+	{
+		return GT_BAD_PARAM;
+	}
+
+	if(mvUnmNetConfig.vidOfPort[qdPort] == vid)
+	{
+		/* Nothing to do. The port already belong to this vid */
+		return GT_OK;
+	}
+
+	/* Check if we perform the valid operation */	
+	if (mvUnmNetConfig.initiatedVids[vid] == GT_FALSE) 
+	{ 
+		/* Cannot create new VLAN */
+		return GT_NOT_INITIALIZED;
+	}
+
+	oldVid = mvUnmNetConfig.vidOfPort[qdPort];
+
+	/* Disable port */
+	if(oldVid != MV_UNM_VID_DISABLED)
+	{
+		status = gstpSetPortState(qd_dev[1], qdPort, GT_PORT_DISABLE);
+		if (status != GT_OK)
+		{
+			return status;
+		}
+	}
+   
+	oldVidPortMask = mvUnmNetConfig.portsOfVid[oldVid]; 
+	GT_CLRBIT(oldVidPortMask, qdPort);
+	oldVidPortNum = mvUnmNetConfig.numPortsOfVid[oldVid];
+	oldVidPortNum--;
+	cpuPortMask = mvUnmNetConfig.cpuPortBitmask;
+
+	if( (oldVid != MV_UNM_VID_DISABLED) && (oldVid != MV_UNM_VID_ISOLATED) )
+	{
+		status = mvDisassociatePort(qdPort, oldVid, oldVidPortMask);
+		if (status != GT_OK)
+		{
+			return status;
+		}
+		GT_CLRBIT(cpuPortMask, qdPort);
+		GT_SETBIT(oldVidPortMask, GT_CPU_SWITCH_PORT);
+	}
+
+	vidPortMask = mvUnmNetConfig.portsOfVid[vid]; 
+	GT_SETBIT(vidPortMask, qdPort);
+	vidPortNum = mvUnmNetConfig.numPortsOfVid[vid];
+	vidPortNum++;
+
+	if( (vid != MV_UNM_VID_DISABLED) && (vid != MV_UNM_VID_ISOLATED) )
+	{
+		status = mvAssociatePort(qdPort, vid, vidPortMask, vidPortNum);
+		if (status != GT_OK)
+		{
+			return status;
+		}
+		GT_SETBIT(cpuPortMask, qdPort);
+		GT_SETBIT(vidPortMask, GT_CPU_SWITCH_PORT);
+	}
+
+	/* Update portList for all ports belong to oldVid and vid */
+	for(port=0; port<GT_NUM_OF_SWITCH_PORTS; port++)
+	{
+		if(port == GT_CPU_SWITCH_PORT)
+		{
+			mvUnmSetVlanPortMask(port, cpuPortMask);
+			continue;
+		}
+
+		if( GT_CHKBIT(vidPortMask, port) )
+			mvUnmSetVlanPortMask(port, vidPortMask);
+
+		if( GT_CHKBIT(oldVidPortMask, port) )
+			mvUnmSetVlanPortMask(port, oldVidPortMask);
+	}
+
+	/* Update PVID ??? of the moved port */
+	status = gvlnSetPortVid(qd_dev[1], (GT_LPORT)qdPort, (GT_U16)vid);
+	if(status != GT_OK)
+	{
+		gtOsPrintf("gvlnSetPortVid failed: status = 0x%x\n", status); 
+		return status;
+	}			
+
+	/* Enable port */
+	if(vid != MV_UNM_VID_DISABLED)
+	{
+		status = gstpSetPortState(qd_dev[1], qdPort, GT_PORT_FORWARDING);
+		if (status != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	/* update new configuration if no error occurrs */ 
+	GT_CLRBIT(vidPortMask, GT_CPU_SWITCH_PORT);
+	GT_CLRBIT(oldVidPortMask, GT_CPU_SWITCH_PORT);
+	mvUnmNetConfig.portsOfVid[oldVid] = oldVidPortMask; 
+	mvUnmNetConfig.portsOfVid[vid] = vidPortMask; 
+	mvUnmNetConfig.numPortsOfVid[oldVid] = oldVidPortNum;
+	mvUnmNetConfig.numPortsOfVid[vid] = vidPortNum;
+	mvUnmNetConfig.vidOfPort[qdPort] = vid;
+	mvUnmNetConfig.cpuPortBitmask = cpuPortMask;
+
+	MV_DEBUG_PRINT("port %d moved from vlan %d to vlan %d\n", qdPort, oldVid, vid);
+
+	return GT_OK;	
+}
+
+/* Create port based VLAN */
+GT_STATUS mvUnmCreateVlan(int vid, GT_U32 vlanPortMask)
+{
+	GT_STATUS	status = GT_OK;
+	GT_LPORT	port;
+	GT_U32		portMask;
+	MV_UNM_VID	portVid;
+    
+	MV_DEBUG_PRINT("Create VLAN %d: PortMask = 0x%X\n", vid, vlanPortMask);
+
+	if( (vid <= MV_UNM_VID_DISABLED) || (vid >= MV_UNM_MAX_VID) )
+		return GT_BAD_PARAM;
+
+	if(mvUnmNetConfig.initiatedVids[vid] == GT_FALSE)
+		return GT_NOT_INITIALIZED;
+
+	/*  set PVID for each port. ??? */
+	for(port=0; port<GT_NUM_OF_SWITCH_PORTS; port++)
+	{
+		portVid = vid;
+		if(port == GT_CPU_SWITCH_PORT)
+		{
+			portMask = mvUnmNetConfig.cpuPortBitmask;
+		}
+		else
+		{
+			if( GT_CHKBIT(vlanPortMask, port) )
+			{
+				/* port belong this vlan */
+				status = gvlnSetPortVid(qd_dev[1], (GT_LPORT)port, (GT_U16)vid);
+				if(status != GT_OK)
+				{
+					gtOsPrintf("gvlnSetPortVid failed: status = 0x%x\n", status); 
+					return status;
+				}			
+				portMask = vlanPortMask;
+			}
+			else
+			{
+				portVid = mvUnmNetConfig.vidOfPort[port];
+				/* port is not belong this vlan */
+				portMask = mvUnmNetConfig.portsOfVid[portVid];
+			}
+			/* Add CPU port if vid != ISOLATED */
+			if( (portVid != MV_UNM_VID_ISOLATED) && (portVid != MV_UNM_VID_DISABLED) )
+				GT_SETBIT(portMask, GT_CPU_SWITCH_PORT);
+		}
+		status = mvUnmSetVlanPortMask(port, portMask);
+		if(status != GT_OK)
+		{
+			return status;
+		}
+	}
+	return GT_OK;
+}
+
+/* Return port mask belong this vid */
+INLINE GT_U32		mvUnmGetPortMaskOfVid(MV_UNM_VID vid)
+{
+	return mvUnmNetConfig.portsOfVid[vid];
+}
+                                   
+
+/* Return vid, that port belong to */
+INLINE MV_UNM_VID	mvUnmGetVidOfPort(int port)
+{
+	return mvUnmNetConfig.vidOfPort[port];
+}
+
+/* Return total number of vids, without ISOLATED and DISABLED  */
+INLINE int			mvUnmGetNumOfVlans(void)
+{
+	return mvUnmNetConfig.numberOfVids;
+}
+
+
+void	mvUnmPrintStatus(void)
+{
+	int		vid, port;
+	char	name[20];
+
+	if(mvUnmIsInitialized == GT_FALSE)
+		gtOsPrintf("UNM is not initialized yet\n");
+
+	gtOsPrintf("%d VLANs created: CpuPortMask = 0x%x\n", 
+		   (unsigned int)(mvUnmNetConfig.numberOfVids),
+		   (unsigned int)(mvUnmNetConfig.cpuPortBitmask));
+	for(vid=0; vid<MV_UNM_MAX_VID; vid++)
+	{
+		mvUnmGetVlanName(vid, name);
+		if(mvUnmNetConfig.initiatedVids[vid] == GT_TRUE)
+		{
+			gtOsPrintf("vid=%d: %12s, portMask=0x%02x, portNum=%d\n", 
+				   vid, name,
+				   (unsigned int)(mvUnmNetConfig.portsOfVid[vid]), 
+				   (unsigned int)(mvUnmNetConfig.numPortsOfVid[vid]));
+		}
+	}
+	gtOsPrintf("Port - Vlan\n");
+	for(port=0; port<GT_NUM_OF_SWITCH_PORTS; port++)
+	{
+		if(port == GT_CPU_SWITCH_PORT)
+			sprintf(name, "VLAN_ALL");
+		else
+			mvUnmGetVlanName(mvUnmNetConfig.vidOfPort[port], name);
+		gtOsPrintf(" %d  - %s\n", port, name);
+	}
+}
Index: linux-2.6.16/drivers/net/marvell/mv_unm_netconf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/mv_unm_netconf.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,260 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ ********************************************************************************
+ * 
+ * FILENAME:    $Workfile: mv_unm_netconf.c $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $ 
+ * 
+ * DESCRIPTION:
+ *       	This file holds common definition for dynamic network configuration OS WRRAPER
+ *	        A unimac manager wrraper to support VLAN names and MACs properties,
+ *               and to init the net-config structure 
+ *
+ * DEPENDENCIES:   
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+#include <linux/marvell/mv_unm_netconf.h>
+#include <linux/marvell/mv_unimac.h>
+
+/* is the net-config has been inited allready? */
+static bool inited = false;
+
+/* the null-mac is a comparison helper to find un initialized MAC addresses */
+static unsigned char null_mac[GT_ETHERNET_HEADER_SIZE] = {0};
+
+/* the net-config (nc) file, are structures that have been parsed from a 'file' 
+ * the setNetConfig initialize all of those structures
+ * the three structures holds the net-conf that have already parsed
+ */
+static unsigned char mv_nc_file_macs[MV_UNM_MAX_VID][GT_ETHERNET_HEADER_SIZE]; 
+static char          mv_nc_file_names[MV_UNM_MAX_VID][MAX_VLAN_NAME]; 
+static MV_UNM_CONFIG file_cnf;
+
+/* the net-config (nc) , are structures holds VALID info for netconf
+ * the getNetConfig functions fill those structures from the 
+ * allready-parsed nc_file structures
+ */
+static unsigned char	mv_nc_macs[MV_UNM_MAX_VID][GT_ETHERNET_HEADER_SIZE];
+static WCHAR	        mv_nc_vlan_names[MV_UNM_MAX_VID][MAX_VLAN_NAME];
+
+
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function returns the name of a given VID.
+ *
+ * Inputs:
+ * vid - the vlan id to retirive its name.
+ *
+ * Outputs:
+ * pNameLength - the length of this string's name.
+ * pszVlanName - a const pointer to the name.
+ *
+ * NOTICE: this function returns an unsafe pointer to the string itself
+ *         it doesn't copy nor allocate.
+ */
+VOID mv_nc_GetVIDName(IN MV_UNM_VID vid,OUT unsigned int *pNameLength,OUT char **pszVlanName) {
+	*pNameLength = strlen(mv_nc_vlan_names[vid]);
+	*pszVlanName = mv_nc_vlan_names[vid];  
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function returns the MAC of a given VID.
+ *
+ * Inputs:
+ * vid - the vlan id to retirive its mac.
+ *
+ * Outputs:
+ * A pointer to the mac address (bytes array) of this vlan.
+ *
+ */
+unsigned char* mv_nc_GetMacOfVlan(IN MV_UNM_VID vid) {
+	return mv_nc_macs[vid];
+}
+
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function prints the port association table of the unimac manger.
+ *
+ * Inputs:
+ *
+ * Outputs:
+ *
+ */
+#ifdef ETH_DBG_INFO
+void mv_nc_printConf(void)
+{
+	MV_UNM_CONFIG	cfg;
+	GT_STATUS		status = mvUnmGetNetConfig(&cfg);
+	int i;
+  
+	if (status == GT_OK) {
+		gtOsPrintf ("Port association table:\n"); 
+		gtOsPrintf("---------------------------------------\n");
+		gtOsPrintf("| Port |");
+		for (i = 0; i < (GT_NUM_OF_SWITCH_PORTS-2); i++) {
+			gtOsPrintf("%4d |", i);
+		}		
+		gtOsPrintf("\n| VID  |");
+		for (i = 0; i < (GT_NUM_OF_SWITCH_PORTS-2); i++) {
+			gtOsPrintf("%4d |", cfg.vidOfPort[i]);
+		}
+		gtOsPrintf("\n---------------------------------------\n");
+	}
+	else {
+		gtOsPrintf("Configuration error %d.\n", status);
+	}
+}
+#endif /* ETH_DBG_INFO */
+
+/*
+ * ----------------------------------------------------------------------------
+ * printUnimacStructs - prints a given configuration.
+ *
+ * Inputs:
+ *
+ * Outputs:
+ *
+ */
+#ifdef ETH_DBG_INFO
+static void printUnimacStructs(OUT MV_UNM_CONFIG* _cnf, 
+			       char _names[MV_UNM_MAX_VID][MAX_VLAN_NAME],
+			       unsigned char _macs[MV_UNM_MAX_VID][GT_ETHERNET_HEADER_SIZE]) 
+{
+	int i;
+	for(i=0;i<MV_UNM_MAX_VID;i++) {
+		gtOsPrintf("[%d] - MAC=%x%x%x%x%x%x Name=%s\n",i, 
+			   _macs[i][0], 
+			   _macs[i][1],
+			   _macs[i][2],
+			   _macs[i][3],
+			   _macs[i][4],
+			   _macs[i][5], 
+			   _names[i]);
+	}
+	for(i=0;i<GT_NUM_OF_SWITCH_PORTS;i++) {
+		gtOsPrintf(" %d", _cnf->vidOfPort[i]);
+	}
+	gtOsPrintf("\n");
+}
+#endif /* ETH_DBG_INFO */
+
+/*
+ * ----------------------------------------------------------------------------
+ * GT_STATUS  setNetConfig(OUT MV_UNM_CONFIG* unmConfig, 
+ *						char names[MV_UNM_MAX_VID][MAX_VLAN_NAME],
+ *  					unsigned char macs[MV_UNM_MAX_VID][GT_ETHERNET_HEADER_SIZE])
+ *
+ * The initialization phase calls this set function in order to 
+ * init private fields of this modules.
+ * the private fields holds the net-conf data.
+ * a caller to the 'get' function will retreive this data (see above).
+ *
+ * Inputs:
+ * unmConfig - A pointer to the net config with the init data.
+ * names     - An array of the vlan names in the net-conf.
+ * macs      - An array of mac addresses in the net-conf.
+ *
+ * Outputs:
+ * GT_STATUS - the status of the operation.
+ *
+ */
+GT_STATUS  setNetConfig(OUT MV_UNM_CONFIG* unmConfig, 
+			char names[MV_UNM_MAX_VID][MAX_VLAN_NAME],
+			unsigned char macs[MV_UNM_MAX_VID][GT_ETHERNET_HEADER_SIZE])
+
+{
+	/* init all structures to zero */
+	memset(mv_nc_file_macs, 0, sizeof(mv_nc_file_macs));
+	memset(mv_nc_file_names, 0, sizeof(mv_nc_file_names));; 
+	memset(&file_cnf, 0, sizeof(file_cnf));
+  
+	/* set net-conf by structure copy 
+	 * this is only updates the 'file' structures, thos will be parsed
+	 * in the getNetConfig to initialize unimac manger
+	 */
+	memcpy(mv_nc_file_macs, macs, sizeof(mv_nc_file_macs));
+	memcpy(mv_nc_file_names, names, sizeof(mv_nc_file_names)); 
+	memcpy(&file_cnf, unmConfig, sizeof(file_cnf));
+  
+	inited = true;
+
+#ifdef ETH_DBG_INFO
+	printUnimacStructs(&file_cnf, mv_nc_file_names, mv_nc_file_macs );
+#endif /* ETH_DBG_INFO */
+
+	return (GT_OK);
+
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * GT_STATUS  getNetConfig(OUT MV_UNM_CONFIG* unmConfig)
+ *
+ * This function is a part of the unimca manager API.
+ * The unimac manager API (mv_unimac_mgr.c) requires a get function 
+ * in order to init the net-conf data.
+ * While being loaded, the unimac manager request for its init 
+ * configuration data with that function.
+ *
+ * Inputs:
+ *
+ * Outputs:
+ * unmConfig - A pointer to the net config to be filled with the init data.
+ *
+ */
+GT_STATUS  getNetConfig(OUT MV_UNM_CONFIG* unmConfig)
+{
+	int i;
+
+	/* Let's fill it with the following defaults for now:
+	   WAN - port 0.
+	   LAN - ports 1,2,3,4.
+	*/
+	memset( mv_nc_macs, 0 , sizeof(mv_nc_macs) );
+	memset( mv_nc_vlan_names, 0 , sizeof(mv_nc_vlan_names) );
+
+	if(!inited) 
+		return GT_FAIL;
+
+	memcpy(unmConfig, &file_cnf, sizeof(MV_UNM_CONFIG));
+
+	/* init all VLAN fields */
+	/* We are using two set of structures here
+	 * 1. The: mv_nc_conf_file_macs, mv_nc_conf_file_names, mv_nc_unmConfig
+	 *    those three conf structs are being filled by an IOCTL call of a configuration application
+	 *
+	 * 2. mv_nc_macs, mv_nc_vlan_names, cnf, that are being updated here from the structures above
+	 *    here at the context of UNM initialize, the system gets ready to work.
+	 */
+  
+	for( i = 0 ; i < MV_UNM_MAX_VID ; i++) {
+		if(strlen(mv_nc_file_names[i]) > 0 ) {
+			memcpy(mv_nc_vlan_names[i], mv_nc_file_names[i], strlen(mv_nc_file_names[i]));
+			if( i > 0 && i < MV_UNM_VID_ISOLATED ) { 
+				memcpy(mv_nc_macs[i], mv_nc_file_macs[i],  GT_ETHERNET_HEADER_SIZE);
+				if( memcmp(mv_nc_file_macs[i], null_mac, GT_ETHERNET_HEADER_SIZE) == 0  ) {
+					gtOsPrintf("Error - No MAC ADDR is set for VLAN WAN\n");
+					return GT_FAIL;  
+				}
+			}
+		}
+	}
+#ifdef ETH_DBG_INFO
+	printUnimacStructs(unmConfig, mv_nc_vlan_names, mv_nc_macs);  
+#endif /* ETH_DBG_INFO */
+	return (GT_OK);
+}
+
Index: linux-2.6.16/drivers/net/marvell/platformDeps.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/platformDeps.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,86 @@
+#include <linux/marvell/Copyright.h>
+/********************************************************************************
+ * platformDeps.c
+ *
+ * DESCRIPTION:
+ *       platform dependent functions
+ *
+ * DEPENDENCIES:   Platform.
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtDrvEvents.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/platformDeps.h>
+
+#if 0
+/*******************************************************************************
+ * gtAssignFunctions
+ *
+ * DESCRIPTION:
+ *       Exchange MII access functions and QuarterDeck Int Handler.
+ *		MII access functions will be called by QuarterDeck driver and
+ *		QD Int Handler should be called by BSP when BSP sees an interrupt which is related to
+ *		QD (This interrupt has to be initialized by BSP, since QD has no idea which
+ *		interrupt is assigned to QD)
+ *
+ * INPUTS:
+ *       fReadMii 	- function to read MII registers
+ *		fWriteMii	- functino to write MII registers
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *       GT_TRUE, if input is valid. GT_FALSE, otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+GT_BOOL gtAssignFunctions
+(
+	GT_QD_DEV      *dev,
+	FGT_READ_MII   fReadMii,
+	FGT_WRITE_MII fWriteMii
+	)
+{
+	if((fReadMii == NULL) || (fWriteMii == NULL))
+		return GT_FALSE;
+
+	dev->fgtReadMii = fReadMii;
+	dev->fgtWriteMii = fWriteMii;
+	
+	return GT_TRUE;
+}
+
+#endif
+
+GT_BOOL defaultMiiRead (unsigned int portNumber , unsigned int miiReg, unsigned int* value)
+{
+	if (portNumber > GLOBAL_REGS_START_ADDR)
+		portNumber -= GLOBAL_REGS_START_ADDR;
+
+	if (portNumber > GLOBAL_REGS_START_ADDR)
+		return GT_FALSE;
+
+	*value = 0;
+
+	return GT_TRUE;
+}
+
+GT_BOOL defaultMiiWrite (unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+	if (portNumber > GLOBAL_REGS_START_ADDR)
+		portNumber -= GLOBAL_REGS_START_ADDR;
+
+	if (portNumber > GLOBAL_REGS_START_ADDR)
+		return GT_FALSE;
+
+	value = value;
+
+	return GT_TRUE;
+}
Index: linux-2.6.16/drivers/net/marvell/qdFFmii.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/qdFFmii.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,211 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ *********************************************************************************/
+/* 
+ * FILENAME:    $Workfile: qdFFmii.c $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $ 
+ * 
+ * DESCRIPTION: SMI access routines for Firefox board
+ *     
+ */
+#include <linux/marvell/mv_platform.h>
+#include <linux/marvell/mv_os.h>
+#include <linux/marvell/mv_qd.h>
+
+
+/*
+ * For each platform, all we need is 
+ * 1) Assigning functions into 
+ * 		fgtReadMii : to read MII registers, and
+ * 		fgtWriteMii : to write MII registers.
+ *
+ * 2) Register Interrupt (Not Defined Yet.)
+ */
+
+/* 
+ *  Firefox Specific Definition
+ */
+/* #define SMI_OP_CODE_BIT_READ                    1 */
+/* #define SMI_OP_CODE_BIT_WRITE                   0 */
+/* #define SMI_BUSY                                1<<28 */
+/* #define READ_VALID                              1<<27 */
+
+/* #define SMI_TIMEOUT_COUNTER				1000 */
+
+/*****************************************************************************
+ *
+ * GT_BOOL qdFFReadMii (GT_QD_DEV* dev, unsigned int portNumber , 
+ *                      unsigned int MIIReg, unsigned int* value)
+ *
+ * Description
+ * This function will access the MII registers and will read the value of
+ * the MII register , and will retrieve the value in the pointer.
+ * Inputs
+ * portNumber - one of the 2 possiable Ethernet ports (0-1).
+ * MIIReg - the MII register offset.
+ * Outputs
+ * value - pointer to unsigned int which will receive the value.
+ * Returns Value
+ * true if success.
+ * false if fail to make the assignment.
+ * Error types (and exceptions if exist)
+ */
+/* GT_BOOL ffReadMii(GT_QD_DEV* dev, */
+/* 		  unsigned int portNumber, */
+/* 		  unsigned int MIIReg, */
+/* 		  unsigned int* value) */
+/* { */
+/*   GT_U32       smiReg; */
+/*   unsigned int phyAddr; */
+/*   unsigned int timeOut = SMI_TIMEOUT_COUNTER; /\* in 100MS units *\/ */
+/*   int          i; */
+  
+/*   /\* first check that it is not busy *\/ */
+/*   smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG);	 */
+/*   if (smiReg & SMI_BUSY) { */
+/*     for (i = 0; i < SMI_TIMEOUT_COUNTER; i++) */
+/*       ; */
+/*     do { */
+/*       smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG); */
+/*       if (timeOut-- < 1) { */
+/* 	printk("ffReadMii: timeout expired\n"); */
+/* 	return GT_FALSE; */
+/*       } */
+/*     } while (smiReg & SMI_BUSY); */
+/*   } */
+
+/*   /\* not busy *\/ */
+/*   phyAddr = portNumber; */
+/*   smiReg =  */
+/*     (phyAddr << 16) */
+/*     | (SMI_OP_CODE_BIT_READ << 26) */
+/*     | (MIIReg << 21); */
+  
+/*   gtOsGtRegWrite(GT_REG_ETHER_SMI_REG, smiReg); */
+/*   timeOut = SMI_TIMEOUT_COUNTER; /\* initialize the time out var again *\/ */
+/*   smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG); */
+/*   if (!(smiReg & READ_VALID)) { */
+/*       for (i = 0; i < SMI_TIMEOUT_COUNTER; i++) */
+/* 	; */
+/*       do { */
+/* 	smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG); */
+/* 	if (timeOut-- < 1) { */
+/* 	  printk("ffReadMii: timeout expired\n"); */
+/* 	  return GT_FALSE; */
+/* 	} */
+/*       } while (!(smiReg & READ_VALID)); */
+/*   } */
+/*   *value = (unsigned int)(smiReg & 0xffff);     */
+  
+/*   return GT_TRUE; */
+/* } */
+
+
+/*****************************************************************************
+ * 
+ * GT_BOOL qdFFWriteMii (GT_QD_DEV* dev, unsigned int portNumber , 
+ *                       unsigned int MIIReg, unsigned int value)
+ * 
+ * Description
+ * This function will access the MII registers and will write the value
+ * to the MII register.
+ * Inputs
+ * portNumber - one of the 2 possiable Ethernet ports (0-1).
+ * MIIReg - the MII register offset.
+ * value -the value that will be written.
+ * Outputs
+ * Returns Value
+ * true if success.
+ * false if fail to make the assignment.
+ * Error types (and exceptions if exist)
+ */
+/* GT_BOOL ffWriteMii(GT_QD_DEV* dev, */
+/* 		   unsigned int portNumber, */
+/* 		   unsigned int MIIReg, */
+/*                    unsigned int value) */
+/* { */
+/*   GT_U32       smiReg; */
+/*   unsigned int phyAddr; */
+/*   unsigned int timeOut = SMI_TIMEOUT_COUNTER; /\* in 100MS units *\/ */
+/*   int          i; */
+
+/*   /\* first check that it is not busy *\/	 */
+/*   smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG); */
+/*   if (smiReg & SMI_BUSY) { */
+/*     for (i = 0; i < SMI_TIMEOUT_COUNTER; i++) */
+/*       ; */
+/*     do { */
+/*       smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG); */
+/*       if (timeOut-- < 1) { */
+/* 	printk("ffWriteMii: timeout expired\n"); */
+/* 	return GT_FALSE; */
+/*       }			 */
+/*     } while (smiReg & SMI_BUSY); */
+/*   } */
+
+/*   /\* not busy *\/ */
+/*   phyAddr = portNumber; */
+  
+/*   smiReg = 0; /\* make sure no garbage value in reserved bits *\/ */
+/*   smiReg = */
+/*     smiReg */
+/*     | (phyAddr << 16) */
+/*     | (SMI_OP_CODE_BIT_WRITE << 26) */
+/*     | (MIIReg << 21) */
+/*     | (value & 0xffff);	 */
+/*   gtOsGtRegWrite(GT_REG_ETHER_SMI_REG, smiReg);	 */
+  
+/*   return GT_TRUE; */
+/* } */
+
+
+/*
+ * read mii register 
+ */ 
+GT_BOOL ffReadMii(GT_QD_DEV* dev, 
+		  unsigned int portNumber , 
+		  unsigned int MIIReg, unsigned int* value)
+{
+	int ret;
+	unsigned short data=0xffff;
+  
+	if(!dev || !value)
+		return GT_FALSE;
+	DBG_INFO(("%s, %s, %d, calling miiphy_read(%u, %u, 0x%x)\n", __FILE__, __FUNCTION__, __LINE__, (unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short*)value));
+	ret=miiphy_read((unsigned char)(dev->phyAddr), (unsigned char)MIIReg, &data);
+	DBG_INFO(("%s, %s, %d, got value = %04x\n", __FILE__, __FUNCTION__, __LINE__, data));
+	if(ret==0) {
+		*value=(unsigned int)data;
+		return GT_TRUE;
+	}
+	return GT_FALSE;
+}
+
+/*
+ * write mii register
+ */ 
+GT_BOOL ffWriteMii(GT_QD_DEV* dev, 
+		   unsigned int portNumber , 
+		   unsigned int MIIReg, 
+		   unsigned int value)
+{
+	int ret;
+
+	if(!dev)
+		return GT_FALSE;
+	DBG_INFO(("%s, %s, %d, calling miiphy_write(%u, %u, %04x)\n", __FILE__, __FUNCTION__, __LINE__, (unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short)(value & 0x0000ffff)));
+	ret=miiphy_write((unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short)(value & 0x0000ffff));
+	DBG_INFO(("%s, %s, %d, got ret = %d\n", __FILE__, __FUNCTION__, __LINE__, ret));
+	if(ret==0)
+		return GT_TRUE;
+	return GT_FALSE;
+}
+
Index: linux-2.6.16/drivers/net/marvell/qdInit.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/qdInit.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,285 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ *********************************************************************************/
+/* 
+ * FILENAME:    $Workfile: qdInit.c $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $ 
+ * 
+ * DESCRIPTION: QD initialization module
+ *     
+ */
+#include <linux/marvell/gtDrvConfig.h>
+#include <linux/marvell/gtHwCntl.h>
+#include <linux/marvell/mv_qd.h>
+#include <linux/marvell/mv_debug.h>
+#include <linux/marvell/mv_os.h>
+
+
+/*
+ * A system configuration structure
+ * It used to configure the QD driver with configuration data
+ * and with platform specific implementation functions 
+ */
+GT_SYS_CONFIG cfg;
+
+/*
+ * The QD device.
+ * This struct is a logical representation of the QD switch HW device.
+ */
+GT_QD_DEV qddev[2]; /* 0 =  external, 1 = internal */
+GT_QD_DEV* qd_dev[2]; /* 0 =  external, 1 = internal */
+
+
+/*
+ * read mii register - see qdFFmii.c
+ */ 
+extern GT_BOOL ffReadMii(GT_QD_DEV* dev, 
+			 unsigned int portNumber , 
+			 unsigned int MIIReg, unsigned int* value);
+
+/*
+ * write mii register - see qdFFmii.c
+ */ 
+extern GT_BOOL ffWriteMii(GT_QD_DEV* dev, 
+			  unsigned int portNumber , 
+			  unsigned int MIIReg, 
+			  unsigned int value);
+
+/*
+ * A phy patch for deviceId == GT_88E6063
+ */
+static GT_STATUS phyPatch(GT_QD_DEV *dev)
+{
+	GT_U32 u32Data;
+	/*
+	 * Set Bit2 of Register 29 of any phy
+	 */
+	if (gsysReadMiiReg(dev, dev->baseRegAddr,29,&u32Data) != GT_OK) {		
+		return GT_FAIL;
+	}
+  
+	if (gsysWriteMiiReg(dev, (GT_U32)dev->baseRegAddr,29,(GT_U16)(u32Data|0x4)) != GT_OK) {		
+		return GT_FAIL;
+	}
+  
+	/*
+	 * ReSet Bit6 of Register 30 of any phy
+	 */
+	if (gsysReadMiiReg(dev,dev->baseRegAddr,30,&u32Data) != GT_OK) {		
+		return GT_FAIL;
+	}
+  
+	if (gsysWriteMiiReg(dev, (GT_U32)dev->baseRegAddr,30,(GT_U16)(u32Data&(~0x40))) != GT_OK) {		
+		return GT_FAIL;
+	}
+	return GT_OK;
+}
+
+/*
+ *  Initialize the QuarterDeck. This should be done in BSP driver init routine.
+ *	Since BSP is not combined with QuarterDeck driver, we are doing here.
+ */
+GT_STATUS qdStart(GT_QD_DEV* dev)
+{
+	GT_STATUS status;
+
+	dev->cpuPortNum = GT_CPU_SWITCH_PORT;
+  
+	if ((status = qdLoadDriver(&cfg, dev)) != GT_OK) {
+		gtOsPrintf("qdLoadDriver failed: status = 0x%x\n", status);
+		return status;
+	}
+  
+	/*
+	 *  start the QuarterDeck
+	 */
+
+	/* bchaikin: hack to restore the default value corrupted by MIPSBoot ver 1.0 */
+	if ((status = hwSetGlobalRegField(dev, QD_REG_GLOBAL_CONTROL, 0, 16, 0x81)) != GT_OK) {
+		gtOsPrintf("hwSetGlobalRegField failed.\n");
+		return status;
+	}
+  
+	if (dev->deviceId == GT_88E6063) {
+		phyPatch(dev);
+	}
+
+	/* to which VID should we set the CPU_PORT? (1 is temporary)*/
+	if ((status = gvlnSetPortVid(dev, GT_CPU_SWITCH_PORT, 1)) != GT_OK) {
+		gtOsPrintf("gprtSetPortVid fail for CPU port.\n");
+		return status;
+	}
+  
+#ifdef QD_TRAILER_MODE
+	/* set ingress and egress trailer mode*/
+	gprtSetIngressMode(dev, GT_CPU_SWITCH_PORT, GT_TRAILER_INGRESS);	
+	gprtSetTrailerMode(dev, GT_CPU_SWITCH_PORT, GT_TRUE);
+#endif
+  
+#ifdef QD_HEADER_MODE
+	gprtSetHeaderMode(dev, GT_CPU_SWITCH_PORT, GT_TRUE);
+#endif
+
+	return GT_OK;
+}
+
+
+void qdClose(GT_QD_DEV* dev) 
+{
+	if (dev->devEnabled) {
+		qdUnloadDriver(dev);
+	}
+}
+
+
+GT_STATUS qdInit(void)
+{
+	GT_STATUS status = GT_OK;	
+	unsigned int i;
+
+	/*
+	 *  Register all the required functions to QuarterDeck Driver.
+	 */
+	cfg.BSPFunctions.readMii   = ffReadMii;
+	cfg.BSPFunctions.writeMii  = ffWriteMii;
+#ifdef USE_SEMAPHORE
+	cfg.BSPFunctions.semCreate = osSemCreate;
+	cfg.BSPFunctions.semDelete = osSemDelete;
+	cfg.BSPFunctions.semTake   = osSemWait;
+	cfg.BSPFunctions.semGive   = osSemSignal;
+#else /* USE_SEMAPHORE */
+	cfg.BSPFunctions.semCreate = NULL;
+	cfg.BSPFunctions.semDelete = NULL;
+	cfg.BSPFunctions.semTake   = NULL;
+	cfg.BSPFunctions.semGive   = NULL;
+#endif /* USE_SEMAPHORE */
+  
+	cfg.initPorts = GT_TRUE;
+	cfg.cpuPortNum = GT_CPU_SWITCH_PORT;
+
+#if 0 /* bchaikin: no external switch support now */
+	qd_dev[0] = &qddev[0]; /* external */
+	status = qdStart(qd_dev[0]);
+	if (GT_OK != status) {
+		gtOsPrintf("External switch startup failure: status = 0x%x\n", status);
+		return status;
+	}
+#endif
+
+	qd_dev[1] = &qddev[1]; /* internal */
+	status = qdStart(qd_dev[1]);
+	if (GT_OK != status) {
+		gtOsPrintf("Internal switch startup failure: status = 0x%x\n", status);
+		return status;
+	}
+
+	for (i = 0; i < GT_NUM_OF_SWITCH_PORTS; i++) {
+		/* default port prio to three */
+		gcosSetPortDefaultTc(qd_dev[1], i, 3);       
+		/* disable IP TOS Prio */
+		gqosIpPrioMapEn(qd_dev[1], i, GT_FALSE);  
+		/* disable QOS Prio */
+		gqosUserPrioMapEn(qd_dev[1], i, GT_FALSE);
+		/* Force flow control for all ports */
+		gprtSetForceFc(qd_dev[1], i, GT_FALSE);
+	}
+
+	gprtClearAllCtr(qd_dev[1]);
+	gprtSetCtrMode(qd_dev[1], 0);
+
+	for (i=0; i<GT_CPU_SWITCH_PORT; i++) {
+		gprtSetMcRateLimit(qd_dev[1], i, GT_MC_100_PERCENT_RL);
+	}
+
+#ifdef QD_DEBUG
+	for (i = 0; i < GT_NUM_OF_SWITCH_PORTS; i++) {
+		short sdata;
+    
+		hwReadPortReg(qd_dev[1], i, 0x4, &sdata);
+		gtOsPrintf("Control reg for port[%d] is: %x\n",i, sdata);
+    
+		hwReadPortReg(qd_dev[1], i, 0x0, &sdata);
+		gtOsPrintf("Status reg for port[%d] is: %x\n",i, sdata);
+	}
+
+#endif /* QD_DEBUG */
+  
+	gtOsPrintf("Switch driver initialized\n");
+	return status;    
+}
+
+
+static const char* qdPortStpStates[] = {
+	"DISABLED",
+	"BLOCKING",
+	"LEARNING",
+	"FORWARDING"
+};
+
+static char* qdPortListToStr(GT_LPORT* portList,
+			     int portListNum,
+			     char* portListStr)
+{
+	int port, idx, strIdx = 0;
+  
+	for (idx = 0; idx < portListNum; idx++) {
+		port = portList[idx];
+		sprintf(&portListStr[strIdx], "%d,", port);
+		strIdx = strlen(portListStr);
+	}  
+	portListStr[strIdx] = '\0';
+	return portListStr;
+}
+
+
+void qdStatus(GT_QD_DEV* dev) {
+	int               port;
+	GT_BOOL           linkState;
+	GT_PORT_STP_STATE stpState;
+	GT_PORT_STAT      counters;
+	GT_U16            pvid;
+	GT_LPORT          portList[GT_NUM_OF_SWITCH_PORTS];
+	GT_U8             portNum;
+	char              portListStr[100];
+	unsigned int      phy, reg, val;
+
+	gtOsPrintf("Port register table:\n");
+	gtOsPrintf("reg\\phy  ");
+	for (phy = 0x18; phy < 0x20; phy++) {
+		gtOsPrintf("%4x ", phy - 0x18);
+	}
+	gtOsPrintf("\n");
+  
+	for (reg = 0; reg < 32; reg++) {
+		gtOsPrintf("%04x:    ", reg);
+		for (phy = 0x18; phy < 0x20; phy++) {
+			ffReadMii(0, phy, reg, &val);
+			gtOsPrintf("%04x ", val);
+		}
+		gtOsPrintf("\n");
+	}
+
+	gtOsPrintf("Summary table:\n");
+	gtOsPrintf("Port  Link   PVID    Group       State       RxCntr      TxCntr\n\n");
+	for (port = 0; port < GT_NUM_OF_SWITCH_PORTS; port++) {
+		gprtGetLinkState(dev, port, &linkState);
+		gstpGetPortState(dev, port, &stpState);
+		gprtGetPortCtr(dev,port, &counters);
+		gstpGetPortState(dev, port, &stpState);
+		gvlnGetPortVid(dev, port, &pvid);
+		gvlnGetPortVlanPorts(dev, port, portList, &portNum);
+		qdPortListToStr(portList, portNum, portListStr); 
+		gtOsPrintf(" %d.   %4s    %d     %-10s  %-10s   0x%-8x  0x%-8x\n",
+			   port, (linkState==GT_TRUE) ? "UP" : "DOWN",
+			   pvid, portListStr, qdPortStpStates[stpState],
+			   counters.rxCtr, counters.txCtr);
+	}
+}
Index: linux-2.6.16/drivers/net/marvell/qdIoctl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/qdIoctl.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,4038 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ ********************************************************************************
+ * 
+ * FILENAME:    $Workfile: qdIoctl.c $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 7/16/03 2:01p $ 
+ * 
+ * qdIoctl.c
+ *
+ * DESCRIPTION:
+ *       QD IOCTL API
+ *
+ * DEPENDENCIES:   Platform.
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/marvell/qdModule.h>
+#include <linux/marvell/mv_unm_netconf.h>
+
+/*
+ * #define IOCTL_DEBUG
+ *
+ */
+
+#define ERROR_SUCCESS           (0)
+#define ERROR_NOT_SUPPORTED     (-1)
+#define ERROR_INVALID_PARAMETER (-2)
+#define ERROR_GEN_FAILURE       (-3)
+
+
+extern GT_QD_DEV* qd_dev[2];
+extern int mv_eth_start(void);
+extern void qdStatus(GT_QD_DEV* dev);
+
+static bool initialized = false;
+
+static void SetLastError(DWORD dwErr)
+{
+	static DWORD dwLastError = 0;
+
+	dwLastError = dwErr;
+}
+
+
+/************************************************************************/
+/* IOCTL API                                                            */
+/************************************************************************/
+static bool qdUnmNetIoctl(DWORD  hOpenContext,
+			  DWORD  dwCode,
+			  UCHAR *pInBuf,
+			  DWORD  InBufLen,
+			  UCHAR *pOutBuf,
+			  DWORD  OutBufLen,
+			  DWORD *pdwBytesTransferred);
+static GT_STATUS UNM_GetVlanNames(UCHAR *pOutBuf,
+				  DWORD  OutBufLen,
+				  DWORD *pdwBytesTransferred);
+static GT_STATUS UNM_GetVlanParams(UCHAR *pInBuf,
+				   DWORD  InBufLen,
+				   UCHAR *pOutBuf,
+				   DWORD  OutBufLen,
+				   DWORD *pdwBytesTransferred);
+static GT_STATUS UNM_GetPortVlan(DWORD port,
+				 UCHAR *pOutBuf,
+				 DWORD  OutBufLen,
+				 DWORD *pdwBytesTransferred);
+static GT_STATUS UNM_DisassocPort(DWORD port);
+static GT_STATUS UNM_AssocPort(DWORD port,
+			       WCHAR* szVlanName);
+
+bool qdUnmNetIoctl(DWORD  hOpenContext,
+		   DWORD  dwCode,
+		   UCHAR *pInBuf,
+		   DWORD  InBufLen,
+		   UCHAR *pOutBuf,
+		   DWORD  OutBufLen,
+		   DWORD *pdwBytesTransferred)
+{
+	bool bRc = false;
+	GT_STATUS rc;
+	DWORD port;
+
+	if (!pdwBytesTransferred) {
+		return false;
+	}
+	*pdwBytesTransferred = 0;
+
+	switch(dwCode) {
+    
+	case IOCTL_UNM_READ_REG:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			break;
+		}
+		if (OutBufLen < sizeof(GT_IOCTL_PARAM)) {
+			break;
+		}
+		((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u32Data =
+			*(GT_U32*)((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u32Data;
+		bRc = true;
+		*pdwBytesTransferred = sizeof(GT_U32);
+		break;
+    
+	case IOCTL_UNM_WRITE_REG:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			break;
+		}
+		*(GT_U32*)((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u32Data =
+			((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u32Data;
+		bRc = true;
+		*pdwBytesTransferred = 0;
+		break;
+    
+	case IOCTL_UNM_STATUS:
+		if (OutBufLen < sizeof(bool)) {
+			break;
+		}
+		*pdwBytesTransferred = sizeof(bool);
+		*(bool*)pOutBuf = initialized;
+		bRc = true;
+		break;
+    
+	case IOCTL_UNM_INIT:
+		if (initialized || (InBufLen != sizeof(GT_IOCTL_PARAM))) {
+			break;
+		}
+		rc = setNetConfig(&(((GT_IOCTL_PARAM*)pInBuf)->FirstParam.netconf),
+				  (((GT_IOCTL_PARAM*)pInBuf)->SecondParam.vlan_names),
+				  (((GT_IOCTL_PARAM*)pInBuf)->ThirdParam.macs)); 
+		if (rc != GT_OK) {
+			break;
+		}
+		/* init net-device and qd-device */
+		mv_eth_start();
+		initialized = true;
+		bRc = true;
+		break;
+    
+	case IOCTL_UNM_GET_VLAN_NAMES:
+		*pdwBytesTransferred = 0;
+		if (!initialized || (OutBufLen < 2)) {
+			break;
+		}
+		rc = UNM_GetVlanNames(pOutBuf, OutBufLen, pdwBytesTransferred);
+		if (rc != GT_OK) {
+			break;
+		}
+		bRc = true;
+		break;
+    
+	case IOCTL_UNM_GET_VLAN_PARMS:
+		*pdwBytesTransferred = 0;
+		if (!initialized || (OutBufLen < sizeof(GT_IOCTL_PARAM))) {
+			break;
+		}
+		rc = UNM_GetVlanParams( pInBuf, InBufLen, pOutBuf, OutBufLen, pdwBytesTransferred);
+		if( rc != GT_OK) {
+			break;
+		}
+		bRc = true;
+		break;
+    
+	case IOCTL_UNM_GET_PORT_VLAN:
+		*pdwBytesTransferred = 0;
+		if (!initialized || (OutBufLen < sizeof(GT_IOCTL_PARAM))
+		    || (InBufLen != sizeof(GT_IOCTL_PARAM))) {
+			break;
+		}
+		port = ((GT_IOCTL_PARAM*)pInBuf)->FirstParam.port;
+		if ((port == GT_CPU_SWITCH_PORT) || (port > GT_NUM_OF_SWITCH_PORTS)) {
+			break;
+		}
+		rc = UNM_GetPortVlan(port, pOutBuf, OutBufLen, pdwBytesTransferred);
+		if (rc != GT_OK) {
+			break;
+		}
+		bRc = true;
+		break;
+    
+	case IOCTL_UNM_ASSOC_PORT:
+		*pdwBytesTransferred = 0;
+		if (!initialized || (InBufLen != sizeof(GT_IOCTL_PARAM))) {
+			printk("ASSOC: InBufLen != sizeof(GT_IOCTL_PARAM) \n");
+			break;
+		}
+		port = ((GT_IOCTL_PARAM*)pInBuf)->FirstParam.port;
+		if ((port == GT_CPU_SWITCH_PORT) || (port > GT_NUM_OF_SWITCH_PORTS)) {
+			printk("ASSOC: port = 5 || port > 6 \n");
+			break;
+		}
+		rc = UNM_AssocPort(port, ((GT_IOCTL_PARAM*)pInBuf)->SecondParam.szVlanName);
+		if (rc != GT_OK) {
+			break;
+		}
+		bRc = true;
+		break;
+      
+	case IOCTL_UNM_DISASSSOC_PORT:
+		if(!initialized || (InBufLen != sizeof(GT_IOCTL_PARAM))) {
+			break;
+		}
+		port = ((GT_IOCTL_PARAM*)pInBuf)->FirstParam.port;
+		if ((port == GT_CPU_SWITCH_PORT) || (port > GT_NUM_OF_SWITCH_PORTS)) {
+			break;
+		}
+		rc = UNM_DisassocPort(port);
+		if (rc != GT_OK) {
+			break;
+		}
+		bRc = true;
+		break;
+    
+	default:
+		break;
+	}
+	return bRc;
+}
+
+
+bool qdSystemConfig(DWORD  hOpenContext,
+		    DWORD  Ioctl,
+		    UCHAR *pInBuf,
+		    DWORD  InBufLen, 
+		    UCHAR *pOutBuf,
+		    DWORD  OutBufLen,
+		    DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+	int devId;
+
+	switch (Ioctl)
+	{
+	case IOCTL_sysConfig: 
+		if (OutBufLen < sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_IOCTL_PARAM);
+		qdStatus(qd_dev[1]);
+		memcpy( &( ((GT_IOCTL_PARAM*)pOutBuf)->FirstParam.qd_dev), qd_dev[1], sizeof(GT_QD_DEV));
+		break;
+
+	case IOCTL_gsysReadMiiReg:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen < sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		devId = (((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u32Data < 0x10)? 0: 1;
+		if(gsysReadMiiReg(qd_dev[devId],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u32Data,
+				  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u32Data,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u32Data
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U32);
+		break;
+
+	case IOCTL_gsysWriteMiiReg:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		devId = (((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u32Data < 0x10)? 0: 1;
+		if(gsysWriteMiiReg(qd_dev[devId],
+				   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u32Data,
+				   ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u32Data,
+				   ((PGT_IOCTL_PARAM)pInBuf)->ThirdParam.u16Data
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gtVersion:
+		if (InBufLen < GT_QD_VERSION_MAX_LEN)
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gtVersion((GT_VERSION*)pInBuf) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = strlen(pInBuf);
+		break;
+
+	case IOCTL_gLoadDriver:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(qdLoadDriver(&((PGT_IOCTL_PARAM)pInBuf)->FirstParam.sysCfg,
+				&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.qd_dev
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_QD_DEV);
+		break;
+
+	case IOCTL_gUnloadDriver:
+		if(qdUnloadDriver(qd_dev[1]) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gSysEnable:
+		if(sysEnable(qd_dev[1]) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+bool
+qdFdbIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gfdbSetAtuSize: 
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbSetAtuSize(qd_dev[1],((PGT_IOCTL_PARAM)pInBuf)->FirstParam.atuSize) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gfdbGetAgingTimeRange:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbGetAgingTimeRange(qd_dev[1],
+					 &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u32Data,
+					 &((PGT_IOCTL_PARAM)pOutBuf)->SecondParam.u32Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 2*sizeof(GT_U32);
+		break;
+
+	case IOCTL_gfdbSetAgingTimeout:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbSetAgingTimeout(qd_dev[1],
+				       ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u32Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gfdbGetAtuDynamicCount:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbGetAtuDynamicCount(qd_dev[1],
+					  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u32Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U32);
+		break;
+
+	case IOCTL_gfdbGetAtuEntryFirst:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbGetAtuEntryFirst(qd_dev[1],
+					&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.atuEntry
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_ATU_ENTRY);
+		break;
+
+	case IOCTL_gfdbGetAtuEntryNext:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbGetAtuEntryNext(qd_dev[1],
+				       &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.atuEntry
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+
+		memcpy(
+			&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.atuEntry,
+			&((PGT_IOCTL_PARAM)pInBuf)->FirstParam.atuEntry,
+			sizeof(GT_ATU_ENTRY)
+			);
+
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_ATU_ENTRY);
+		break;
+
+	case IOCTL_gfdbFindAtuMacEntry:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbFindAtuMacEntry(qd_dev[1],
+				       &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.atuEntry,
+				       &((PGT_IOCTL_PARAM)pOutBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+
+		memcpy(&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.atuEntry,
+		       &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.atuEntry,
+		       sizeof(GT_ATU_ENTRY)
+			);
+
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_ATU_ENTRY);
+		break;
+
+	case IOCTL_gfdbFlush:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbFlush(qd_dev[1],
+			     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.flushCmd
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gfdbAddMacEntry:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbAddMacEntry(qd_dev[1],
+				   &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.atuEntry
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gfdbDelMacEntry:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbDelMacEntry(qd_dev[1],
+				   &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.etherAddr
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gfdbLearnEnable:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbLearnEnable(qd_dev[1],
+				   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gfdbDelAtuEntry:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbDelAtuEntry(qd_dev[1],
+				   &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.atuEntry
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gfdbFlushInDB:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gfdbFlushInDB(qd_dev[1],
+				 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.flushCmd,
+				 ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u8Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+bool
+qdStpIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gstpSetMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gstpSetMode(qd_dev[1],
+			       ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gstpSetPortState:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gstpSetPortState(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.stpState
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gstpGetPortState:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gstpGetPortState(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.stpState
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_PORT_STP_STATE);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+bool
+qdVlanIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl) {
+	case IOCTL_gprtSetEgressMode: 
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gprtSetEgressMode(qd_dev[1],
+				     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				     ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.egressMode
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetEgressMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gprtGetEgressMode(qd_dev[1],
+				     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				     &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.egressMode
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_EGRESS_MODE);
+		break;
+
+	case IOCTL_gprtSetVlanTunnel: 
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gprtSetVlanTunnel(qd_dev[1],
+				     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				     ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetVlanTunnel:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gprtGetVlanTunnel(qd_dev[1],
+				     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				     &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+
+	case IOCTL_gvlnSetPortVlanPorts: 
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnSetPortVlanPorts(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					((PGT_IOCTL_PARAM)pInBuf)->SecondParam.portList,
+					((PGT_IOCTL_PARAM)pInBuf)->ThirdParam.u8Data
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gvlnGetPortVlanPorts:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnGetPortVlanPorts(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.portList,
+					&((PGT_IOCTL_PARAM)pOutBuf)->SecondParam.u8Data
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_IOCTL_PARAM);
+		break;
+
+	case IOCTL_gvlnSetPortUserPriLsb: 
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnSetPortUserPriLsb(qd_dev[1],
+					 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					 ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gvlnGetPortUserPriLsb:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnGetPortUserPriLsb(qd_dev[1],
+					 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					 &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+
+	case IOCTL_gvlnSetPortVid: 
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnSetPortVid(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u16Data
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gvlnGetPortVid:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnGetPortVid(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u16Data
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U16);
+		break;
+
+	case IOCTL_gvlnSetPortVlanDBNum:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnSetPortVlanDBNum(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u8Data
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gvlnGetPortVlanDBNum:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnGetPortVlanDBNum(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u8Data
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U8);
+		break;
+
+	case IOCTL_gvlnSetPortVlanDot1qMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnSetPortVlanDot1qMode(qd_dev[1],
+					    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					    ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.dot1QMode
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gvlnGetPortVlanDot1qMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnGetPortVlanDot1qMode(qd_dev[1],
+					    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.dot1QMode
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_DOT1Q_MODE);
+		break;
+
+	case IOCTL_gvlnSetPortVlanForceDefaultVID:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnSetPortVlanForceDefaultVID(qd_dev[1],
+						  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+						  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gvlnGetPortVlanForceDefaultVID:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvlnGetPortVlanForceDefaultVID(qd_dev[1],
+						  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+						  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+bool
+qdSysEventIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_eventSetActive:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(eventSetActive(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u32Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_eventGetIntStatus:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(eventGetIntStatus(qd_dev[1],
+				     &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u16Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U16);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+bool
+qdPhyCtrlIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gprtPhyReset:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtPhyReset(qd_dev[1],
+				((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtSetPortLoopback:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetPortLoopback(qd_dev[1],
+				       ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				       ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtSetPortSpeed:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetPortSpeed(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtPortAutoNegEnable:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtPortAutoNegEnable(qd_dev[1],
+					 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					 ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtPortPowerDown:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtPortPowerDown(qd_dev[1],
+				     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				     ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtPortRestartAutoNeg:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtPortRestartAutoNeg(qd_dev[1],
+					  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtSetPortDuplexMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetPortDuplexMode(qd_dev[1],
+					 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					 ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtSetPortAutoMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetPortAutoMode(qd_dev[1],
+				       ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				       ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.phyAutoMode
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtSetPause:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetPause(qd_dev[1],
+				((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+bool
+qdPhyIntIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gprtPhyIntEnable:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtPhyIntEnable(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u16Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetPhyIntStatus:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetPhyIntStatus(qd_dev[1],
+				       ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				       &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u16Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U16);
+		break;
+
+	case IOCTL_gprtGetPhyIntPortSummary:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetPhyIntPortSummary(qd_dev[1],
+					    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u16Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U16);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+bool
+qdPortCtrlIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gprtSetForceFc:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetForceFc(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetForceFc:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetForceFc(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtSetTrailerMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetTrailerMode(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetTrailerMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetTrailerMode(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtSetIngressMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetIngressMode(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.ingressMode
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetIngressMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetIngressMode(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.ingressMode
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_INGRESS_MODE);
+		break;
+
+
+	case IOCTL_gprtSetMcRateLimit:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetMcRateLimit(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.mcRate
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetMcRateLimit:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetMcRateLimit(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.mcRate
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_MC_RATE);
+		break;
+
+	case IOCTL_gprtSetHeaderMode: 
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gprtSetHeaderMode(qd_dev[1],
+				     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				     ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetHeaderMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetHeaderMode(qd_dev[1],
+				     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				     &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtSetIGMPSnoop:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gprtSetIGMPSnoop(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+    
+	case IOCTL_gprtGetIGMPSnoop:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gprtGetIGMPSnoop(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+    
+	case IOCTL_gprtSetDuplex: 
+		if (InBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gprtSetDuplex(qd_dev[1],
+				 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				 ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+bool
+qdPortStatsIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gprtSetCtrMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtSetCtrMode(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.ctrMode
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtClearAllCtr:
+
+		if(gprtClearAllCtr(qd_dev[1]) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gprtGetPortCtr:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetPortCtr(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.portStat
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_PORT_STAT);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+bool
+qdPortStatusIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gprtGetPartnerLinkPause:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetPartnerLinkPause(qd_dev[1],
+					   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					   &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtGetSelfLinkPause:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetSelfLinkPause(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtGetResolve:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetResolve(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtGetLinkState:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetLinkState(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtGetPortMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetPortMode(qd_dev[1],
+				   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				   &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtGetPhyMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetPhyMode(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtGetDuplex:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetDuplex(qd_dev[1],
+				 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				 &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gprtGetSpeed:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gprtGetSpeed(qd_dev[1],
+				((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+bool
+qdQoSMapIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gcosSetPortDefaultTc:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gcosSetPortDefaultTc(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u8Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gcosGetPortDefaultTc:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gcosGetPortDefaultTc(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u8Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U8);
+		break;
+
+	case IOCTL_gqosSetPrioMapRule:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gqosSetPrioMapRule(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gqosGetPrioMapRule:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gqosGetPrioMapRule(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gqosIpPrioMapEn:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gqosIpPrioMapEn(qd_dev[1],
+				   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				   ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gqosGetIpPrioMapEn:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gqosGetIpPrioMapEn(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				      &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gqosUserPrioMapEn:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gqosUserPrioMapEn(qd_dev[1],
+				     ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				     ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gqosGetUserPrioMapEn:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gqosGetUserPrioMapEn(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+
+	case IOCTL_gcosSetUserPrio2Tc:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gcosSetUserPrio2Tc(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u8Data,
+				      ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u8Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gcosGetUserPrio2Tc:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gcosGetUserPrio2Tc(qd_dev[1],
+				      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u8Data,
+				      &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u8Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U8);
+		break;
+
+	case IOCTL_gcosSetDscp2Tc:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gcosSetDscp2Tc(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u8Data,
+				  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u8Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gcosGetDscp2Tc:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gcosGetDscp2Tc(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.u8Data,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u8Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U8);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+
+bool
+qdSysCtrlIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gsysSwReset:
+
+		if(gsysSwReset(qd_dev[1]) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gsysSetDiscardExcessive:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysSetDiscardExcessive(qd_dev[1],
+					   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gsysGetDiscardExcessive:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysGetDiscardExcessive(qd_dev[1],
+					   &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gsysSetSchedulingMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysSetSchedulingMode(qd_dev[1],
+					 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gsysGetSchedulingMode:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysGetSchedulingMode(qd_dev[1],
+					 &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gsysSetMaxFrameSize:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysSetMaxFrameSize(qd_dev[1],
+				       ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gsysGetMaxFrameSize:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysGetMaxFrameSize(qd_dev[1],
+				       &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gsysReLoad:
+
+		if(gsysReLoad(qd_dev[1]) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gsysSetWatchDog:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysSetWatchDog(qd_dev[1],
+				   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gsysGetWatchDog:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysGetWatchDog(qd_dev[1],
+				   &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_gsysSetDuplexPauseMac:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysSetDuplexPauseMac(qd_dev[1],
+					 &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.etherAddr
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gsysGetDuplexPauseMac:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysGetDuplexPauseMac(qd_dev[1],
+					 &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.etherAddr
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_ETHERADDR);
+		break;
+
+	case IOCTL_gsysSetPerPortDuplexPauseMac:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysSetPerPortDuplexPauseMac(qd_dev[1],
+						((PGT_IOCTL_PARAM)pInBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gsysGetPerPortDuplexPauseMac:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gsysGetPerPortDuplexPauseMac(qd_dev[1],
+						&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+bool
+qdStatsSysIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gsysGetSW_Mode:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gsysGetSW_Mode(qd_dev[1],
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.swMode
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_SW_MODE);
+		break;
+
+	case IOCTL_gsysGetInitReady:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM)) {
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gsysGetInitReady(qd_dev[1],
+				    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK) {
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+
+bool
+qdPavIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gpavSetPAV:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gpavSetPAV(qd_dev[1],
+			      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+			      ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.u16Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+    
+	case IOCTL_gpavGetPAV:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gpavGetPAV(qd_dev[1],
+			      ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+			      &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u16Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U16);
+		break;
+
+	case IOCTL_gpavSetIngressMonitor:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gpavSetIngressMonitor(qd_dev[1],
+					 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					 ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gpavGetIngressMonitor:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gpavGetIngressMonitor(qd_dev[1],
+					 ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					 &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+
+bool
+qdPrcIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_grcSetLimitMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcSetLimitMode(qd_dev[1],
+				   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				   ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.rateLimitMode
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+    
+	case IOCTL_grcGetLimitMode:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcGetLimitMode(qd_dev[1],
+				   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				   &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.rateLimitMode
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_RATE_LIMIT_MODE);
+		break;
+
+	case IOCTL_grcSetEgressRate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcSetEgressRate(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.egressRate
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+    
+	case IOCTL_grcGetEgressRate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcGetEgressRate(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.egressRate
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_EGRESS_RATE);
+		break;
+
+	case IOCTL_grcSetPri3Rate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcSetPri3Rate(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_grcGetPri3Rate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcGetPri3Rate(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_grcSetPri2Rate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcSetPri2Rate(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_grcGetPri2Rate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcGetPri2Rate(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_grcSetPri1Rate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcSetPri1Rate(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_grcGetPri1Rate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcGetPri1Rate(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_grcSetPri0Rate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcSetPri0Rate(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_grcGetPri0Rate:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcGetPri0Rate(qd_dev[1],
+				  ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				  &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_BOOL);
+		break;
+
+	case IOCTL_grcSetBytesCount:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcSetBytesCount(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    ((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData,
+				    ((PGT_IOCTL_PARAM)pInBuf)->ThirdParam.boolData,
+				    ((PGT_IOCTL_PARAM)pInBuf)->FourthParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_grcGetBytesCount:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(grcGetBytesCount(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    &((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData,
+				    &((PGT_IOCTL_PARAM)pInBuf)->ThirdParam.boolData,
+				    &((PGT_IOCTL_PARAM)pInBuf)->FourthParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+
+		memcpy(
+			&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.boolData,
+			&((PGT_IOCTL_PARAM)pInBuf)->SecondParam.boolData,
+			sizeof(GT_BOOL)
+			);
+
+		memcpy(
+			&((PGT_IOCTL_PARAM)pOutBuf)->SecondParam.boolData,
+			&((PGT_IOCTL_PARAM)pInBuf)->ThirdParam.boolData,
+			sizeof(GT_BOOL)
+			);
+
+		memcpy(
+			&((PGT_IOCTL_PARAM)pOutBuf)->ThirdParam.boolData,
+			&((PGT_IOCTL_PARAM)pInBuf)->FourthParam.boolData,
+			sizeof(GT_BOOL)
+			);
+
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = (3 * sizeof(GT_BOOL));
+		break;
+      
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+bool
+qdVtuIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gvtuGetIntStatus:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gvtuGetIntStatus(qd_dev[1],
+				    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.vtuIntStatus
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_VTU_INT_STATUS);
+		break;
+
+	case IOCTL_gvtuGetEntryCount:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gvtuGetEntryCount(qd_dev[1],
+				     &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u32Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U32);
+		break;
+
+	case IOCTL_gvtuGetEntryFirst:
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gvtuGetEntryFirst(qd_dev[1],
+				     &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.vtuEntry
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_VTU_ENTRY);
+		break;
+
+	case IOCTL_gvtuGetEntryNext:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvtuGetEntryNext(qd_dev[1],
+				    &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.vtuEntry
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+
+		memcpy(
+			&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.vtuEntry,
+			&((PGT_IOCTL_PARAM)pInBuf)->FirstParam.vtuEntry,
+			sizeof(GT_VTU_ENTRY)
+			);
+
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_VTU_ENTRY);
+		break;
+
+	case IOCTL_gvtuFindVidEntry:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvtuFindVidEntry(qd_dev[1],
+				    &((PGT_IOCTL_PARAM)pInBuf)->FirstParam.vtuEntry,
+				    &((PGT_IOCTL_PARAM)pOutBuf)->SecondParam.boolData
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+
+		memcpy(
+			&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.vtuEntry,
+			&((PGT_IOCTL_PARAM)pInBuf)->FirstParam.vtuEntry,
+			sizeof(GT_VTU_ENTRY)
+			);
+
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_VTU_ENTRY);
+		break;
+
+	case IOCTL_gvtuFlush:
+		if(gvtuFlush(qd_dev[1]) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gvtuAddEntry:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvtuAddEntry(qd_dev[1],
+				&((PGT_IOCTL_PARAM)pInBuf)->FirstParam.vtuEntry
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gvtuDelEntry:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+	
+		if(gvtuDelEntry(qd_dev[1],
+				&((PGT_IOCTL_PARAM)pInBuf)->FirstParam.vtuEntry
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+
+bool
+qdStatsRmonIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gstatsFlushAll:
+		if(gstatsFlushAll(qd_dev[1]) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gstatsFlushPort:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gstatsFlushPort(qd_dev[1],
+				   ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = 0;
+		break;
+
+	case IOCTL_gstatsGetPortCounter:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gstatsGetPortCounter(qd_dev[1],
+					((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					((PGT_IOCTL_PARAM)pInBuf)->SecondParam.statsCounter,
+					&((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.u32Data
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_U32);
+		break;
+
+	case IOCTL_gstatsGetPortAllCounters:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gstatsGetPortAllCounters(qd_dev[1],
+					    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.statsCounterSet
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_STATS_COUNTER_SET);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+
+	return bRc;
+}
+
+
+
+bool
+qdVctIoctl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD * pdwBytesTransferred
+	)
+{
+	DWORD  dwErr = ERROR_NOT_SUPPORTED;
+	bool   bRc = false;
+
+	switch (Ioctl)
+	{
+	case IOCTL_gvctGetCableDiag:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gvctGetCableDiag(qd_dev[1],
+				    ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+				    &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.cableStatus
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_CABLE_STATUS);
+		break;
+
+	case IOCTL_gvctGet1000BTExtendedStatus:
+		if (InBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if (OutBufLen != sizeof(GT_IOCTL_PARAM))
+		{
+			dwErr = ERROR_INVALID_PARAMETER;
+			break;
+		}
+
+		if(gvctGet1000BTExtendedStatus(qd_dev[1],
+					       ((PGT_IOCTL_PARAM)pInBuf)->FirstParam.port,
+					       &((PGT_IOCTL_PARAM)pOutBuf)->FirstParam.extStatus
+			   ) != GT_OK)
+		{
+			dwErr = ERROR_GEN_FAILURE;
+			break;
+		}
+		bRc = true;
+		dwErr = ERROR_SUCCESS;
+		*pdwBytesTransferred = sizeof(GT_1000BT_EXTENDED_STATUS);
+		break;
+
+	default:
+		break;
+	}
+
+	if (ERROR_SUCCESS != dwErr) {
+		SetLastError(dwErr);
+		bRc = false;
+	}
+ 
+	return bRc;
+}
+
+
+
+
+
+bool
+UNM_IOControl(
+	DWORD  hOpenContext,
+	DWORD  Ioctl,
+	UCHAR *pInBuf,
+	DWORD  InBufLen, 
+	UCHAR *pOutBuf,
+	DWORD  OutBufLen,
+	DWORD *pdwRet
+	)
+{
+	bool   bRc = false;
+
+	switch (SUB_FUNC_MASK & GET_FUNC_FROM_CTL_CODE(Ioctl)) {
+	case SYS_CFG_FUNC_MASK:
+		bRc = qdSystemConfig(hOpenContext, Ioctl,pInBuf, InBufLen, 
+				     pOutBuf,OutBufLen,pdwRet);
+		break;
+      
+	case FDB_FUNC_MASK:
+		bRc = qdFdbIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				 pOutBuf, OutBufLen, pdwRet);
+		break;
+      
+	case STP_FUNC_MASK:
+		bRc = qdStpIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				 pOutBuf, OutBufLen,pdwRet);       
+		break;
+      
+	case VLAN_FUNC_MASK:
+		bRc = qdVlanIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				  pOutBuf, OutBufLen,pdwRet);       
+
+		break;
+      
+	case SYS_EVENT_FUNC_MASK:
+		bRc = qdSysEventIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				      pOutBuf, OutBufLen,pdwRet);       
+		break;
+
+	case PHY_CTRL_FUNC_MASK:
+		bRc = qdPhyCtrlIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				     pOutBuf, OutBufLen,pdwRet);       
+		break;
+      
+	case PHY_INT_FUNC_MASK:
+		bRc = qdPhyIntIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				    pOutBuf, OutBufLen,pdwRet);       
+		break;
+      
+	case PORT_CTRL_FUNC_MASK:
+		bRc = qdPortCtrlIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				      pOutBuf, OutBufLen,pdwRet);       
+		break;
+      
+	case PORT_STATS_FUNC_MASK:
+		bRc = qdPortStatsIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				       pOutBuf, OutBufLen,pdwRet);       
+		break;
+      
+	case PORT_STATUS_FUNC_MASK:
+		bRc = qdPortStatusIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+					pOutBuf, OutBufLen,pdwRet);       
+		break;
+      
+	case QOS_FUNC_MASK:
+		bRc = qdQoSMapIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				    pOutBuf, OutBufLen,pdwRet);       
+		break;
+      
+	case SYS_CTRL_FUNC_MASK:
+		bRc = qdSysCtrlIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				     pOutBuf, OutBufLen,pdwRet);       
+		break;
+      
+	case PAV_FUNC_MASK:
+		bRc = qdPavIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				 pOutBuf, OutBufLen,pdwRet);       
+		break;
+
+	case PRC_FUNC_MASK:
+		bRc = qdPrcIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				 pOutBuf, OutBufLen,pdwRet);       
+		break;
+
+	case VTU_FUNC_MASK:
+		bRc = qdVtuIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				 pOutBuf, OutBufLen,pdwRet);       
+		break;
+
+	case STATS_RMON_FUNC_MASK:
+		bRc = qdStatsRmonIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				       pOutBuf, OutBufLen,pdwRet);       
+		break;
+
+	case STATS_SYS_FUNC_MASK:
+		bRc = qdStatsSysIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				      pOutBuf, OutBufLen,pdwRet);       
+		break;
+
+	case VCT_FUNC_MASK:
+		bRc = qdVctIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				 pOutBuf, OutBufLen,pdwRet);       
+		break;
+
+	case UNM_NET_FUNC_MASK:
+		bRc = qdUnmNetIoctl(hOpenContext, Ioctl, pInBuf, InBufLen, 
+				    pOutBuf, OutBufLen,pdwRet);       
+		break;
+
+	default:
+		printk("Unsupported IOCTL code\n");
+		break;
+	}
+    
+	return bRc;
+}
+
+
+/* IOCTL - replies from UNM
+ *
+ * we need to access the global NETCONFIG (NetConfig) structure
+ * we will do it here
+ * 
+ * its not so OOD, but in future NetConf lib, QD and IM will be one DLL!
+ */
+GT_STATUS UNM_GetVlanNames(UCHAR *pOutBuf,  DWORD  OutBufLen, DWORD *pdwBytesTransferred)
+{
+	GT_STATUS rc = GT_OK;
+	UINT i;
+	DWORD bytesCtr = 0, bytesPerName;
+	UCHAR *pOutTemp = pOutBuf;
+	WCHAR szNullChar[1] = { '\0' }; 
+	WCHAR *pszVlanName; 
+
+	do {
+    
+		if( OutBufLen < 2 ) {
+			*pdwBytesTransferred = 0;
+			rc = GT_FAIL;
+			break;
+		}
+		
+		for( i=1; i <= mvUnmGetNumOfVlans() ; i++ ) {
+			mv_nc_GetVIDName(i, &bytesPerName, &pszVlanName);
+			bytesPerName += 1; /* for the '\0' wchar */
+			bytesCtr += bytesPerName;
+			if(bytesCtr > OutBufLen ) {
+				rc = GT_FAIL;
+				*pdwBytesTransferred = 0;
+				break;
+			}
+			memcpy(pOutTemp, pszVlanName, bytesPerName );
+			pOutTemp[bytesPerName-1] = '\0';
+			pOutTemp += bytesPerName;
+		}
+		if(rc != GT_OK)
+			break;
+		
+		/* okay, now lets add the last '\0' */
+		if( bytesCtr == 0 ) {
+			((WCHAR*)pOutBuf)[0] = '\0';
+			*pdwBytesTransferred = 1;
+			break;
+		}
+		
+		bytesCtr += 1;
+		if(bytesCtr > OutBufLen ) {
+			rc = GT_FAIL;
+			*pdwBytesTransferred = 0;
+			break;
+		}
+		memcpy(pOutTemp, szNullChar, 1);
+		*pdwBytesTransferred = bytesCtr;
+	}while(0);
+	return rc;
+
+}
+
+GT_STATUS 
+UNM_GetVlanParams(UCHAR *pInBuf,
+		  DWORD  InBufLen,
+		  UCHAR *pOutBuf,
+		  DWORD  OutBufLen,
+		  DWORD *pdwBytesTransferred 
+	)
+{
+	DWORD bytesPerName;
+	GT_STATUS rc = GT_OK;
+	UINT i;
+	bool found = false;
+	WCHAR *pszVlanName;   
+	GT_IOCTL_PARAM *pOutIoctlParam;
+	do {
+		for( i=1; i <= MV_UNM_MAX_VID; i++ ) {
+			if( i <= mvUnmGetNumOfVlans() ) {
+				mv_nc_GetVIDName(i, &bytesPerName, &pszVlanName);
+				if( !memcmp( pInBuf, pszVlanName, InBufLen) ) {
+					found = true;
+					break;
+				}
+			}
+		}
+		if(!found) {
+			rc = GT_FAIL;
+			break;
+		}
+		pOutIoctlParam = (GT_IOCTL_PARAM *)pOutBuf;
+		memmove( pOutIoctlParam->FirstParam.etherAddr.arEther , 
+			 mv_nc_GetMacOfVlan(i),
+			 GT_ETHERNET_HEADER_SIZE  );
+		/* memmove( pOutBuf, &(NetConfig.CpuVlans[i].NetParams), sizeof(VLAN_NET_PARAMS) ); */
+		*pdwBytesTransferred = sizeof(GT_IOCTL_PARAM);
+	}while(0);
+	return rc;
+}
+
+GT_STATUS 
+UNM_GetPortVlan( DWORD  port,
+		 UCHAR *pOutBuf,
+		 DWORD  OutBufLen,
+		 DWORD *pdwBytesTransferred 
+	)
+{
+	DWORD bytesPerName;
+	WCHAR *pszVlanName; 
+
+	GT_STATUS rc = GT_OK;
+	DWORD vid;
+	GT_IOCTL_PARAM *pOutIoctlParam;
+	do {
+    
+		vid = (DWORD)mvUnmGetVidOfPort(port);
+		if( vid == 0 ) {
+			/* this port is not belong to any VLAN */
+			*pdwBytesTransferred = 0;
+			break;
+		}
+
+		pOutIoctlParam = (GT_IOCTL_PARAM *)pOutBuf;
+		mv_nc_GetVIDName(vid, &bytesPerName, &pszVlanName);
+		/* memcpy(pOutBuf, NetConfig.CpuVlans[vid].szVlanName, NetConfig.CpuVlans[vid].NameLength + 2 ); */
+		memmove( pOutIoctlParam->SecondParam.szVlanName, pszVlanName, bytesPerName + 1);
+		pOutIoctlParam->SecondParam.szVlanName[bytesPerName] = '\0';
+		*pdwBytesTransferred = sizeof(GT_IOCTL_PARAM); /* NetConfig.CpuVlans[vid].NameLength + 1; */
+
+	}while(0);
+	return rc;
+}
+
+
+
+GT_STATUS 
+UNM_DisassocPort( DWORD port )
+{
+	GT_STATUS status;
+	MV_UNM_VID vidFrom;
+	GT_STATUS rc = GT_OK;
+
+	do {
+		/* 1. check validity */
+		if( port == GT_CPU_SWITCH_PORT || port > GT_NUM_OF_SWITCH_PORTS )
+		{
+			rc = GT_FAIL;
+			break;
+		}
+		
+		vidFrom = (DWORD)mvUnmGetVidOfPort(port);
+
+		ASSERT( vidFrom <= mvUnmGetNumOfVlans() );
+		
+		/* if its allready free just return a success */
+		if( vidFrom == 0 )
+		{
+			rc = GT_OK;
+			break;		
+		}
+
+		/* in order to free a port we need to do the follwoing:
+		 * QD
+		 *    1. close this port in the switch
+		 *    2. if its connected to the cpu, disconnect it from cpu table
+		 *    3. erase its VLAN table (????)
+		 * IM
+		 *    4. find its vlan
+		 *    5. adjust the trailer of its vlan
+		 * NETCONF
+		 *    6. adjust netconf structure
+		 *    7. update registry (???)
+		 *		
+		 * Done with in unimac manager
+		 * gstpSetPortState(qd_dev[1], port, GT_PORT_DISABLE);
+		 *	
+		 * we need to update netconf and recalculate LAN_PORTS_MODE
+		 * this port is not belong to any vlan now
+		 */	
+		status = mvUnmPortMoveTo(port, MV_UNM_VID_ISOLATED);
+		if(status != GT_OK)
+		{
+			rc = GT_FAIL;
+			/* TODO: rollback???? */
+			break;
+		
+		}
+		/* TODO: update registry!!! */
+
+			
+	}while(0);
+	
+	return rc;
+
+}
+GT_STATUS 
+UNM_AssocPort( DWORD port, WCHAR* szVlanName)
+{
+  
+	MV_UNM_VID vidTo = 0, vidFrom = 0;
+	GT_STATUS rc = GT_OK;
+	UINT i, uiNumOfVlans;
+	WCHAR *pszVlnaName;
+	UINT uiVlanNameLen;
+
+	do {
+		uiNumOfVlans = mvUnmGetNumOfVlans();
+		/* 1. check validity */
+		if( port == GT_CPU_SWITCH_PORT || port > GT_NUM_OF_SWITCH_PORTS )
+		{
+			rc = GT_FAIL;
+			break;
+		}
+		/* do we have this VLAN? */
+		for( i=1 ; i <= uiNumOfVlans; i++ )
+		{
+			mv_nc_GetVIDName(i, &uiVlanNameLen, &pszVlnaName);
+			if( !memcmp( szVlanName, pszVlnaName, uiVlanNameLen) ) {
+				vidTo = i;
+			}
+		}
+		
+		if( vidTo == 0 ) /* couldn't find the VLAN name to add to */
+		{
+			rc = GT_FAIL;
+			break;		
+		}
+
+		vidFrom = (DWORD)mvUnmGetVidOfPort(port);
+		ASSERT( vidFrom <= mvUnmGetNumOfVlans() );
+		if( vidFrom == vidTo)
+		{
+			rc = GT_OK;
+			break;		
+		}
+		
+		
+		/* if its not free we first need to free the port */
+		if( vidFrom != 0 )
+		{
+			rc = UNM_DisassocPort(port);
+			if( rc != GT_OK )
+			{
+				rc = GT_FAIL;
+				break;		
+			}
+		}
+		/* okay, we have a free port and a valid vidTo to add it to
+		 * in order to free a port we need to do the follwoing:
+		 * NETCONF
+		 *    1. adjust netconf structure
+		 * IM
+		 *    2. find its vlan
+		 *    3. adjust the trailer of its vlan
+		 * QD
+		 *    1. update the VLAN table of this port
+		 *	  2. connect it to the cpu
+		 *    3. open this port in the switch
+		 * NETCONF
+		 *    7. update registry (???)
+		 *	
+		 * we need to update netconf and recalculate LAN_PORTS_MODE
+		 * this port is not belong to any vlan now
+		 */
+		rc = mvUnmPortMoveTo(port, vidTo);
+		if(rc != GT_OK)
+			break;
+
+
+
+		/* gstpSetPortState(qd_dev[1],port, GT_PORT_FORWARDING); */
+
+		/* TODO: update registry!!! */
+			
+	}while(0);
+	
+	return rc;
+
+
+}
+
+
+
+
Index: linux-2.6.16/drivers/net/marvell/qdModule.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/drivers/net/marvell/qdModule.c	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,183 @@
+/*******************************************************************************
+ *                Copyright 2001, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ ********************************************************************************
+ * qdModule.c
+ *
+ * DESCRIPTION:
+ *		Defines the entry point for the QD module
+ *
+ * DEPENDENCIES:   Platform.
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/marvell/qdModule.h>
+#include <linux/marvell/mv_unm_netconf.h>
+
+/*
+ * #define IOCTL_DBG
+ *
+ */
+
+
+/************************************************************************/
+/* file io API                                                          */
+/*                                                                      */
+/* The io API is a proc-fs implementation of ioctl                      */
+/************************************************************************/
+static struct proc_dir_entry *evb_resource_dump;
+
+/*
+ * The lengh of the result buffer
+ */
+DWORD evb_resource_dump_result_len;
+
+/*
+ * A 1024 bytes, (in dwords because of alignment) of the result buffer.  
+ */
+DWORD dwevb_resource_dump_result[1024/sizeof(DWORD)];
+
+/*
+ * The result buffer pointer
+ */
+static char *evb_resource_dump_result = (char*)dwevb_resource_dump_result ;
+
+/********************************************************************
+ * evb_resource_dump_write -
+ *
+ * When written to the /proc/resource_dump file this function is called
+ *
+ * Inputs: file / data are not used. Buffer and count are the pointer
+ *         and length of the input string
+ * Returns: Read from GT register
+ * Outputs: count
+ *********************************************************************/
+static int evb_resource_dump_write (struct file *file, const char *buffer, unsigned long count, void *data) 
+{
+	bool rc;
+	unsigned int lenIn = 0 , code;
+
+	evb_resource_dump_result_len = 0;
+	memset(evb_resource_dump_result, 0, sizeof(dwevb_resource_dump_result));
+
+	code = *((unsigned int*)buffer);
+	if(!code)
+		return count;
+	lenIn = *((unsigned int*)(buffer + sizeof(code) ));
+#ifdef IOCTL_DBG
+	printk("Got IOCTL for code=%x, len=%d count = %d\n", code, lenIn, count);
+#endif /* IOCTL_DBG */
+	rc = UNM_IOControl( 0, code, (char*)(buffer + sizeof(code) + sizeof(lenIn) ), lenIn, 
+			    evb_resource_dump_result,    
+			    sizeof(dwevb_resource_dump_result) , 
+			    &evb_resource_dump_result_len 
+		);
+	if(rc == false) {
+		evb_resource_dump_result_len = 0xFFFFFFFF;
+		printk("Error for IOCTL code %x\n", code);
+	}
+#ifdef IOCTL_DBG
+	else {
+		int i;
+		printk("Success for IOCTL code %x outlen = %d\n", code, evb_resource_dump_result_len);
+		for(i=0;i<evb_resource_dump_result_len; i++) {
+			printk("%x ",evb_resource_dump_result[i]);
+		}
+		printk("\n"); 
+	}
+#endif /* IOCTL_DBG */
+	return count;
+}
+
+/********************************************************************
+ * evb_resource_dump_read -
+ *
+ * When read from the /proc/resource_dump file this function is called
+ *
+ * Inputs: buffer_location and buffer_length and zero are not used.
+ *         buffer is the pointer where to post the result
+ * Returns: N/A
+ * Outputs: length of string posted
+ *********************************************************************/
+static int evb_resource_dump_read (char *buffer, char **buffer_location, off_t offset, 
+				   int buffer_length, int *zero, void *ptr) 
+{
+	if (offset > 0)
+		return 0;
+	/* first four bytes are the len of the out buffer */
+	memcpy(buffer, (char*)&evb_resource_dump_result_len, sizeof(evb_resource_dump_result_len) );
+
+	/* in offset of 4 bytes the out buffer begins */
+	memcpy((buffer + sizeof (evb_resource_dump_result_len )), 
+	       evb_resource_dump_result, 
+	       sizeof(dwevb_resource_dump_result)
+		);
+  
+	return ( evb_resource_dump_result_len + sizeof(evb_resource_dump_result_len));
+}
+
+
+
+/************************************************************************/
+/* module API                                                           */
+/************************************************************************/
+/*
+ * The qd start actually strarts the qd operation.
+ * It calls the qdInit() to the the actual work (see qdInit.c).
+ */
+int qdModuleStart(void)
+{
+	GT_STATUS status;
+
+	if( (status=qdInit()) != GT_OK) {
+		DBG_INFO(("\n qdModuleInit: Cannot start the QD switch!\n"));
+		return -1;
+	}
+	
+	DBG_INFO(("\n qdModuleInit is done!\n\n"));	
+	return 0;
+}
+
+/*
+ * At the entry point we init only the IOCTL hook.
+ * An init IOCTL call will triger the real initialization of
+ * the QD, with the start function above
+ */
+int qdEntryPoint(void)
+{
+
+	/* start_regdump_memdump -
+	 *
+	 * Register the /proc/rgcfgio file at the /proc filesystem
+	 */
+	evb_resource_dump = create_proc_entry (RG_IO_FILENAME , 0666 , &proc_root);
+	if(!evb_resource_dump)
+		panic("Can't allocate UNM FILE-IO device\n");
+	evb_resource_dump->read_proc = evb_resource_dump_read;
+	evb_resource_dump->write_proc = evb_resource_dump_write;
+	evb_resource_dump->nlink = 1;
+
+
+	DBG_INFO(("\n qdEntryPoint is done!\n\n"));	
+	return 0;
+}
+
+/*
+ * Exit point of the module.
+ */
+void qdExitPoint(void)
+{
+	printk("QD Switch driver exited!\n");
+}
Index: linux-2.6.16/include/linux/debmax_sw6095.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/debmax_sw6095.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,103 @@
+/*
+ * Cyclades:
+ *   Support for Marvell's 88E6095 11-port switch chips for ONBOARD board.
+ *
+ * Got from SOHO's msSample.h
+ * 
+ */
+
+#ifndef __DEBMAX_SW6095_H__
+#define __DEBMAX_SW6095_H__
+
+#include <linux/config.h>
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/mv_platform.h>
+#include <linux/marvell/mv_mvtag.h>
+
+#include <linux/skbuff.h>
+
+#ifndef MAX_NR_SWITCHES
+#define MAX_NR_SWITCHES 	5
+#endif
+
+#ifndef MAX_PORTS_PER_SWITCH
+#define MAX_PORTS_PER_SWITCH 	11
+#endif
+
+#define NR_FE_PER_SWITCH	8
+#define NR_GE_PER_SWITCH	(MAX_PORTS_PER_SWITCH - NR_FE_PER_SWITCH)
+
+#define MAX_NET_PORT_TOTAL	(NR_FE_PER_SWITCH * MAX_NR_SWITCHES)
+
+/* input network port# is from 0 to 39,
+ * output switch # is from 0 to 4
+ */
+static inline int port_nr_to_sw_nr(int port_nr) {
+	if(port_nr>=MAX_NET_PORT_TOTAL || port_nr<0) return -1;
+	return (port_nr/NR_FE_PER_SWITCH);
+}
+
+/* input network port# is from 0 to 39,
+ * output FE # is from 0 to 7
+ */
+static inline int port_nr_to_fe_nr(int port_nr) {
+	if(port_nr>=MAX_NET_PORT_TOTAL || port_nr<0) return -1;
+	return (port_nr%NR_FE_PER_SWITCH);
+}
+
+
+#undef USE_SEMAPHORE
+
+#ifdef USE_SEMAPHORE
+GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state);
+GT_STATUS osSemDelete(GT_SEM smid);
+GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut);
+GT_STATUS osSemSignal(GT_SEM smid);
+#endif
+
+/*
+ *	Structure mt_pair is for passing MT to ARP/Routing code
+ *	through skb->cb.
+ *
+ *	To prevent confusing other protocols, we pass mt_pair by using
+ *	the end of skb->cb.
+ */
+
+typedef struct mt_pair {
+	mvtag_t	 mvt;
+	unsigned long xor_mvt_deadbeef;
+	unsigned long beefdead;
+} mt_pair_t;
+
+/* Using end part of skb->cb to store mt_pair */
+#define MT_PAIR_SKB_CB(skb)	((mt_pair_t *)(&((skb)->cb[0]) + sizeof(skb->cb) - sizeof(mt_pair_t)))
+
+static inline int mt_pair_is_valid(mt_pair_t *mp)
+{
+	if (!mp)
+		return 0;
+
+	return (mp->beefdead == 0xbeefdead && (mp->mvt ^ mp->xor_mvt_deadbeef) == 0xdeadbeef);
+}
+
+static inline mt_pair_t * mt_pair_create(mt_pair_t *mp, mvtag_t mvt)
+{
+	if (!mp)
+		return NULL;
+
+	mp->mvt = mvt;
+	mp->xor_mvt_deadbeef = mvt ^ 0xdeadbeef;
+	mp->beefdead = 0xbeefdead;
+	return mp;
+}
+
+static inline mt_pair_t * mt_pair_init(mt_pair_t *mp)
+{
+	if (!mp)
+		return NULL;
+
+	memset(mp, 0, sizeof(mt_pair_t));
+	return mp;
+}
+
+#endif /* __DEBMAX_SW6095_H__ */
Index: linux-2.6.16/include/linux/fsl_devices.h
===================================================================
--- linux-2.6.16.orig/include/linux/fsl_devices.h	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/include/linux/fsl_devices.h	2007-05-24 14:47:01.000000000 -0400
@@ -52,7 +52,10 @@
 	u32 board_flags;
 	u32 bus_id;
 	u32 phy_id;
+	u32 real_phyid;
 	u8 mac_addr[6];
+
+	struct net_device *dev;
 };
 
 struct gianfar_mdio_data {
@@ -69,11 +72,37 @@
 #define FSL_GIANFAR_DEV_HAS_VLAN		0x00000020
 #define FSL_GIANFAR_DEV_HAS_EXTENDED_HASH	0x00000040
 #define FSL_GIANFAR_DEV_HAS_PADDING		0x00000080
+#define FSL_GIANFAR_DEV_HAS_SMI_AGENT		0x00000100
+#define FSL_GIANFAR_DEV_HAS_FAKE_PHY		0x00000200
 
 /* Flags in gianfar_platform_data */
 #define FSL_GIANFAR_BRD_HAS_PHY_INTR	0x00000001 /* set or use a timer */
 #define FSL_GIANFAR_BRD_IS_REDUCED	0x00000002 /* Set if RGMII, RMII */
 
+/*
+ * phyid: used when not directly connecting to an external PHY, but an MAC.
+ *        Also remember to add HAS_FAKEPHY flag above.
+ */
+#define GFAR_MAX_PHY_ADDR                 0x001f
+#define GFAR_ALWAYS_LINK_UP               0x8000
+#define GFAR_1000MBPS                     0x4000
+#define GFAR_100MBPS                      0x2000
+#define GFAR_10MBPS                       0x1000
+#define GFAR_FULL_DPLX                    0x0800
+#define GFAR_HALF_DPLX                    0x0400
+#define GFAR_FLOW_CTRL                    0x0200
+
+/*
+ * Details about the relation of SMI_AGENT, HAS_FAKEPHY, phyid, real_phyid:
+ *
+ * 1) check flags <> HAS_FAKEPHY, then do normal op using phyid.
+ * 2) else flags == HAS_FAKEPHY, then phyid has above extra meanings.
+ * 3)     check flags == SMI_AGENT, then use real_phyid do normal op.
+ * 4)     else  flags <> SMI_AGENT, then do NOTHING to phyid or real_phyid,
+ *                       which means read() return 0xffff, write() do nothing.
+ *
+ */
+
 struct fsl_i2c_platform_data {
 	/* device specific information */
 	u32 device_flags;
Index: linux-2.6.16/include/linux/marvell/Copyright.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/Copyright.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,17 @@
+/*******************************************************************************
+ *                Copyright 2000 ~ 2005, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ *******************************************************************************/
+#ifndef _msCopyright_h
+#define _msCopyright_h
+
+#define MSAPI_COPYRIGHT "Copyright 2000~2005, Marvell International Ltd."
+#define MSAPI_VERSION "2.3b"
+
+#endif /* _msCopyright_h */
Index: linux-2.6.16/include/linux/marvell/gtDrvConfig.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/gtDrvConfig.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,80 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtDrvConfig.h
+ *
+ * DESCRIPTION:
+ *       Includes driver level configuration and initialization function.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#ifndef __gtDrvConfigh
+#define __gtDrvConfigh
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/gtDrvSwRegs.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+ * driverConfig
+ *
+ * DESCRIPTION:
+ *       This function initializes the driver level of the quarterDeck software.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success, or
+ *       GT_OUT_OF_CPU_MEM   - if failed to allocate CPU memory,
+ *       GT_FAIL             - otherwise.
+ *
+ * COMMENTS:
+ *       1.  This function should perform the following:
+ *           -   Initialize the global switch configuration structure.
+ *           -   Initialize Mii Interface
+ *           -   Set the CPU port into trailer mode (Ingress and Egress).
+ *
+ *******************************************************************************/
+	GT_STATUS driverConfig(IN GT_QD_DEV *dev);
+
+/*******************************************************************************
+ * driverEnable
+ *
+ * DESCRIPTION:
+ *       This function enables the switch for full operation, after the driver
+ *       Config function was called.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_FAIL othrwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS driverEnable(IN GT_QD_DEV *dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtDrvConfigh */
Index: linux-2.6.16/include/linux/marvell/gtDrvEvents.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/gtDrvEvents.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,87 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtDrvEvents.h
+ *
+ * DESCRIPTION:
+ *       This file includes function declarations for QuarterDeck interrupts
+ *       configuration and handling.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#ifndef __gtDrvEventsh
+#define __gtDrvEventsh
+
+#include <linux/marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+ * drvEventInit
+ *
+ * DESCRIPTION:
+ *       This function initializes the driver's interrupt handling mechanism.
+ *
+ * INPUTS:
+ *       intVecNum   - The interrupt vector the switch is connected to.
+ *       isrFunc     - A pointer to the Interrupt Service Routine to be
+ *                     connected to the given interrupt vector.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success,
+ *       GT_FAIL - otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS drvEventsInit
+	(
+		IN  GT_QD_DEV     *dev,
+		IN GT_U32         intVecNum,
+		IN GT_VOIDFUNCPTR isrFunc
+		);
+
+
+
+/*******************************************************************************
+ * eventQdSr
+ *
+ * DESCRIPTION:
+ *       QuarterDeck interrupt service routine.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       None.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_BOOL eventQdSr
+	(
+		IN  GT_QD_DEV  *dev,
+		OUT GT_U16*    intCause
+		);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtDrvEventsh */
Index: linux-2.6.16/include/linux/marvell/gtDrvSwRegs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/gtDrvSwRegs.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,178 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * * gtDrvSwRegs.h
+ * *
+ * * DESCRIPTION:
+ * *       definitions of the register map of QuarterDeck Device
+ * *
+ * * DEPENDENCIES:
+ * *
+ * * FILE REVISION NUMBER:
+ * *
+ * *******************************************************************************/
+#ifndef __gtDrvSwRegsh
+#define __gtDrvSwRegsh
+
+/* QuarterDeck Per Port Registers */
+#define QD_REG_PORT_STATUS		0x0
+#define QD_REG_PCS_CONTROL		0x1		/* for Sapphire family */
+#define QD_REG_SWITCH_ID		0x3
+#define QD_REG_PORT_CONTROL		0x4
+#define QD_REG_PORT_CONTROL1		0x5
+#define QD_REG_PORT_VLAN_MAP		0x6
+#define QD_REG_PVID			0x7
+#define QD_REG_PORT_CONTROL2		0x8	/* for Sapphire family */
+#define QD_REG_INGRESS_RATE_CTRL	0x9	/* for Sapphire family */
+#define QD_REG_EGRESS_RATE_CTRL		0xA	/* for Sapphire family */
+#define QD_REG_RATE_CTRL		0xA
+#define QD_REG_PAV			0xB
+#define QD_REG_RX_COUNTER		0x10
+#define QD_REG_TX_COUNTER		0x11
+
+#define QD_REG_INDISCARD_LO_COUNTER		0x10
+#define QD_REG_INDISCARD_HI_COUNTER		0x11
+#define QD_REG_INFILTERED_COUNTER		0x12
+#define QD_REG_OUTFILTERED_COUNTER		0x13
+
+#define QD_REG_Q_COUNTER		0x1B
+#define QD_REG_RATE_CONTROL		0x0A
+#define QD_REG_PORT_ASSOCIATION		0x0B
+#define QD_REG_IEEE_PRI_REMAP_3_0	0x18	/* for Sapphire family */
+#define QD_REG_IEEE_PRI_REMAP_7_4	0x19	/* for Sapphire family */
+
+
+/* QuarterDeck Global Registers */
+#define QD_REG_GLOBAL_STATUS		0x0
+#define QD_REG_MACADDR_01		0x1
+#define QD_REG_MACADDR_23		0x2
+#define QD_REG_MACADDR_45		0x3
+#define QD_REG_GLOBAL_CONTROL		0x4
+#define QD_REG_GLOBAL_CONTROL2		0x1C	/* for Sapphire family */
+#define QD_REG_CORETAG_TYPE		0x19		/* for Ruby family */
+#define QD_REG_MONITOR_CONTROL	0x1A		/* for Ruby family */
+
+/* QuarterDeck Global 2 Registers */
+#define QD_REG_MGMT_ENABLE		0x3
+#define QD_REG_FLOWCTRL_DELAY	0x4
+#define QD_REG_MANAGEMENT		0x5
+#define QD_REG_ROUTING_TBL		0x6
+#define QD_REG_TRUNK_MASK_TBL	0x7
+#define QD_REG_TRUNK_ROUTING	0x8
+
+/* the following VTU entries are added for Fullsail and Clippership */
+#define QD_REG_VTU_OPERATION		0x5
+#define QD_REG_VTU_VID_REG		0x6
+#define QD_REG_VTU_DATA1_REG		0x7
+#define QD_REG_VTU_DATA2_REG		0x8
+#define QD_REG_VTU_DATA3_REG		0x9
+#define QD_REG_STATS_OPERATION		0x1D
+#define QD_REG_STATS_COUNTER3_2		0x1E
+#define QD_REG_STATS_COUNTER1_0		0x1F
+ 
+
+#define QD_REG_ATU_CONTROL		0xA
+#define QD_REG_ATU_OPERATION		0xB
+#define QD_REG_ATU_DATA_REG		0xC
+#define QD_REG_ATU_MAC_BASE		0xD
+#define QD_REG_IP_PRI_BASE		0x10
+#define QD_REG_IEEE_PRI			0x18
+
+/* Definitions for MIB Counter */
+#define GT_STATS_NO_OP			0x0
+#define GT_STATS_FLUSH_ALL		0x1
+#define GT_STATS_FLUSH_PORT		0x2
+#define GT_STATS_READ_COUNTER		0x4
+#define GT_STATS_CAPTURE_PORT		0x5
+
+#define QD_PHY_CONTROL_REG			0
+#define QD_PHY_AUTONEGO_AD_REG			4
+#define QD_PHY_NEXTPAGE_TX_REG			7
+#define QD_PHY_SPEC_CONTROL_REG			16
+#define QD_PHY_INT_ENABLE_REG			18
+#define QD_PHY_INT_STATUS_REG			19
+#define QD_PHY_INT_PORT_SUMMARY_REG		20
+
+/* Bit Definition for QD_PHY_CONTROL_REG */
+#define QD_PHY_RESET			0x8000
+#define QD_PHY_LOOPBACK			0x4000
+#define QD_PHY_SPEED			0x2000
+#define QD_PHY_AUTONEGO			0x1000
+#define QD_PHY_POWER			0x800
+#define QD_PHY_ISOLATE			0x400
+#define QD_PHY_RESTART_AUTONEGO		0x200
+#define QD_PHY_DUPLEX			0x100
+
+#define QD_PHY_POWER_BIT			11
+#define QD_PHY_RESTART_AUTONEGO_BIT		9
+
+/* Bit Definition for QD_PHY_AUTONEGO_AD_REG */
+#define QD_PHY_NEXTPAGE			0x8000
+#define QD_PHY_REMOTEFAULT		0x4000
+#define QD_PHY_PAUSE			0x400
+#define QD_PHY_100_FULL			0x100
+#define QD_PHY_100_HALF			0x80
+#define QD_PHY_10_FULL			0x40
+#define QD_PHY_10_HALF			0x20
+
+#define QD_PHY_MODE_AUTO_AUTO	(QD_PHY_100_FULL | QD_PHY_100_HALF | QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_100_AUTO	(QD_PHY_100_FULL | QD_PHY_100_HALF)
+#define QD_PHY_MODE_10_AUTO		(QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_AUTO_FULL	(QD_PHY_100_FULL | QD_PHY_10_FULL)
+#define QD_PHY_MODE_AUTO_HALF	(QD_PHY_100_HALF | QD_PHY_10_HALF)
+
+#define QD_PHY_MODE_100_FULL	QD_PHY_100_FULL
+#define QD_PHY_MODE_100_HALF	QD_PHY_100_HALF
+#define QD_PHY_MODE_10_FULL		QD_PHY_10_FULL	
+#define QD_PHY_MODE_10_HALF		QD_PHY_10_HALF	
+
+/* Gigabit Phy related definition */
+#define QD_GIGPHY_1000X_FULL_CAP	0x8
+#define QD_GIGPHY_1000X_HALF_CAP	0x4
+#define QD_GIGPHY_1000T_FULL_CAP	0x2
+#define QD_GIGPHY_1000T_HALF_CAP	0x1
+
+#define QD_GIGPHY_1000X_CAP		(QD_GIGPHY_1000X_FULL_CAP|QD_GIGPHY_1000X_HALF_CAP)
+#define QD_GIGPHY_1000T_CAP		(QD_GIGPHY_1000T_FULL_CAP|QD_GIGPHY_1000T_HALF_CAP)
+
+#define QD_GIGPHY_1000X_FULL		0x20
+#define QD_GIGPHY_1000X_HALF		0x40
+
+#define QD_GIGPHY_1000T_FULL		0x200
+#define QD_GIGPHY_1000T_HALF		0x100
+
+/* Bit definition for QD_PHY_INT_ENABLE_REG */
+#define QD_PHY_INT_SPEED_CHANGED		0x4000
+#define QD_PHY_INT_DUPLEX_CHANGED		0x2000
+#define QD_PHY_INT_PAGE_RECEIVED		0x1000
+#define QD_PHY_INT_AUTO_NEG_COMPLETED		0x800
+#define QD_PHY_INT_LINK_STATUS_CHANGED		0x400
+#define QD_PHY_INT_SYMBOL_ERROR			0x200
+#define QD_PHY_INT_FALSE_CARRIER		0x100
+#define QD_PHY_INT_FIFO_FLOW			0x80
+#define QD_PHY_INT_CROSSOVER_CHANGED		0x40
+#define QD_PHY_INT_POLARITY_CHANGED		0x2
+#define QD_PHY_INT_JABBER			0x1
+
+/* Definition for Multi Address Mode */
+#define QD_REG_SMI_COMMAND		0x0
+#define QD_REG_SMI_DATA			0x1
+
+/* Bit definition for QD_REG_SMI_COMMAND */
+#define QD_SMI_BUSY				0x8000
+#define QD_SMI_MODE				0x1000
+#define QD_SMI_MODE_BIT			12
+#define QD_SMI_OP_BIT			10
+#define QD_SMI_OP_SIZE			2
+#define QD_SMI_DEV_ADDR_BIT		5
+#define QD_SMI_DEV_ADDR_SIZE	5
+#define QD_SMI_REG_ADDR_BIT		0
+#define QD_SMI_REG_ADDR_SIZE	5
+
+#define QD_SMI_CLAUSE45			0
+#define QD_SMI_CLAUSE22			1
+
+#define QD_SMI_WRITE			0x01
+#define QD_SMI_READ				0x02
+
+#endif /* __gtDrvSwRegsh */
Index: linux-2.6.16/include/linux/marvell/gtHwCntl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/gtHwCntl.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,701 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtHwCntl.h
+ *
+ * DESCRIPTION:
+ *       Functions declarations for Hw accessing quarterDeck phy, internal and
+ *       global registers.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#ifndef __gtHwCntlh
+#define __gtHwCntlh
+
+#include <linux/marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This macro is used to calculate the register's SMI   */
+/* device address, according to the baseAddr            */
+/* field in the Switch configuration struct.            */
+#define CALC_SMI_DEV_ADDR(_dev, _portNum, _accessType)        \
+            portToSmiMapping(_dev, _portNum, _accessType)
+
+/* This macro calculates the mask for partial read /    */
+/* write of register's data.                            */
+#define CALC_MASK(fieldOffset,fieldLen,mask)        \
+            if((fieldLen + fieldOffset) >= 16)      \
+                mask = (0 - (1 << fieldOffset));    \
+            else                                    \
+                mask = (((1 << (fieldLen + fieldOffset))) - (1 << fieldOffset))
+
+/* Start address of phy related register.               */
+#define PHY_REGS_START_ADDR     0x0
+#define PHY_REGS_START_ADDR_8PORT	0x0
+
+/* Start address of ports related register.             */
+#define PORT_REGS_START_ADDR    	0x8
+#define PORT_REGS_START_ADDR_8PORT	0x10
+
+/* Start address of global register.                    */
+#define GLOBAL_REGS_START_ADDR  0xF
+#define GLOBAL_REGS_START_ADDR_8PORT  0x1B
+
+#define PHY_ACCESS			1
+#define PORT_ACCESS			2
+#define GLOBAL_REG_ACCESS	3
+#define GLOBAL2_REG_ACCESS	4
+
+/****************************************************************************/
+/* Phy registers related functions.                                         */
+/****************************************************************************/
+
+/*******************************************************************************
+ * hwReadPhyReg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch's port phy register.
+ *
+ * INPUTS:
+ *       portNum - Port number to read the register for.
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwReadPhyReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     portNum,
+		IN  GT_U8     regAddr,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwWritePhyReg
+ *
+ * DESCRIPTION:
+ *       This function writes to a switch's port phy register.
+ *
+ * INPUTS:
+ *       portNum - Port number to write the register for.
+ *       regAddr - The register's address.
+ *       data    - The data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwWritePhyReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     portNum,
+		IN  GT_U8     regAddr,
+		IN  GT_U16    data
+		);
+
+
+/*******************************************************************************
+ * hwGetPhyRegField
+ *
+ * DESCRIPTION:
+ *       This function reads a specified field from a switch's port phy register.
+ *
+ * INPUTS:
+ *       portNum     - Port number to read the register for.
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to read.
+ *
+ * OUTPUTS:
+ *       data        - The read register field.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+	GT_STATUS hwGetPhyRegField
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     portNum,
+		IN  GT_U8     regAddr,
+		IN  GT_U8     fieldOffset,
+		IN  GT_U8     fieldLength,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwSetPhyRegField
+ *
+ * DESCRIPTION:
+ *       This function writes to specified field in a switch's port phy register.
+ *
+ * INPUTS:
+ *       portNum     - Port number to write the register for.
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to write.
+ *       data        - Data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+	GT_STATUS hwSetPhyRegField
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     portNum,
+		IN  GT_U8     regAddr,
+		IN  GT_U8     fieldOffset,
+		IN  GT_U8     fieldLength,
+		IN  GT_U16    data
+		);
+
+
+/****************************************************************************/
+/* Per port registers related functions.                                    */
+/****************************************************************************/
+
+/*******************************************************************************
+ * hwReadPortReg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch's port register.
+ *
+ * INPUTS:
+ *       portNum - Port number to read the register for.
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwReadPortReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     portNum,
+		IN  GT_U8     regAddr,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwWritePortReg
+ *
+ * DESCRIPTION:
+ *       This function writes to a switch's port register.
+ *
+ * INPUTS:
+ *       portNum - Port number to write the register for.
+ *       regAddr - The register's address.
+ *       data    - The data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwWritePortReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     portNum,
+		IN  GT_U8     regAddr,
+		IN  GT_U16    data
+		);
+
+
+/*******************************************************************************
+ * hwGetPortRegField
+ *
+ * DESCRIPTION:
+ *       This function reads a specified field from a switch's port register.
+ *
+ * INPUTS:
+ *       portNum     - Port number to read the register for.
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to read.
+ *
+ * OUTPUTS:
+ *       data        - The read register field.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+	GT_STATUS hwGetPortRegField
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     portNum,
+		IN  GT_U8     regAddr,
+		IN  GT_U8     fieldOffset,
+		IN  GT_U8     fieldLength,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwSetPortRegField
+ *
+ * DESCRIPTION:
+ *       This function writes to specified field in a switch's port register.
+ *
+ * INPUTS:
+ *       portNum     - Port number to write the register for.
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to write.
+ *       data        - Data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+	GT_STATUS hwSetPortRegField
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     portNum,
+		IN  GT_U8     regAddr,
+		IN  GT_U8     fieldOffset,
+		IN  GT_U8     fieldLength,
+		IN  GT_U16    data
+		);
+
+
+/****************************************************************************/
+/* Global registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+ * hwReadGlobalReg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch's global register.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwReadGlobalReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     regAddr,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwWriteGlobalReg
+ *
+ * DESCRIPTION:
+ *       This function writes to a switch's global register.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *       data    - The data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwWriteGlobalReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     regAddr,
+		IN  GT_U16    data
+		);
+
+
+/*******************************************************************************
+ * hwGetGlobalRegField
+ *
+ * DESCRIPTION:
+ *       This function reads a specified field from a switch's global register.
+ *
+ * INPUTS:
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to read.
+ *
+ * OUTPUTS:
+ *       data        - The read register field.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+	GT_STATUS hwGetGlobalRegField
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     regAddr,
+		IN  GT_U8     fieldOffset,
+		IN  GT_U8     fieldLength,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwSetGlobalRegField
+ *
+ * DESCRIPTION:
+ *       This function writes to specified field in a switch's global register.
+ *
+ * INPUTS:
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to write.
+ *       data        - Data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+	GT_STATUS hwSetGlobalRegField
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     regAddr,
+		IN  GT_U8     fieldOffset,
+		IN  GT_U8     fieldLength,
+		IN  GT_U16    data
+		);
+
+
+/****************************************************************************/
+/* Global 2 registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+ * hwReadGlobal2Reg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch's global 2 register.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwReadGlobal2Reg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     regAddr,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwWriteGlobal2Reg
+ *
+ * DESCRIPTION:
+ *       This function writes to a switch's global 2 register.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *       data    - The data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwWriteGlobal2Reg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     regAddr,
+		IN  GT_U16    data
+		);
+
+
+/*******************************************************************************
+ * hwGetGlobal2RegField
+ *
+ * DESCRIPTION:
+ *       This function reads a specified field from a switch's global 2 register.
+ *
+ * INPUTS:
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to read.
+ *
+ * OUTPUTS:
+ *       data        - The read register field.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+ *           equal to 16.
+ *
+ *******************************************************************************/
+	GT_STATUS hwGetGlobal2RegField
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     regAddr,
+		IN  GT_U8     fieldOffset,
+		IN  GT_U8     fieldLength,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwSetGlobal2RegField
+ *
+ * DESCRIPTION:
+ *       This function writes to specified field in a switch's global 2 register.
+ *
+ * INPUTS:
+ *       regAddr     - The register's address.
+ *       fieldOffset - The field start bit index. (0 - 15)
+ *       fieldLength - Number of bits to write.
+ *       data        - Data to be written.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+	GT_STATUS hwSetGlobal2RegField
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     regAddr,
+		IN  GT_U8     fieldOffset,
+		IN  GT_U8     fieldLength,
+		IN  GT_U16    data
+		);
+
+
+/*******************************************************************************
+ * hwReadMiiReg
+ *
+ * DESCRIPTION:
+ *       This function reads a switch register.
+ *
+ * INPUTS:
+ *       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwReadMiiReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     phyAddr,
+		IN  GT_U8     regAddr,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * hwWriteMiiReg
+ *
+ * DESCRIPTION:
+ *       This function writes a switch register.
+ *
+ * INPUTS:
+ *       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK on success, or
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS hwWriteMiiReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     phyAddr,
+		IN  GT_U8     regAddr,
+		IN  GT_U16    data
+		);
+
+/*******************************************************************************
+ * hwReadPPU
+ *
+ * DESCRIPTION:
+ *			This function reads PPU bit in Global Register
+ *
+ * INPUTS:
+ *			None.
+ *
+ * OUTPUTS:
+ *			data    - The read register's data.
+ *
+ * RETURNS:
+ *			GT_OK on success, or
+ *			GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *			This function can be used to access PHY register connected to Gigabit
+ *			Switch.
+ *
+ *******************************************************************************/
+	GT_STATUS hwReadPPU
+	(
+		IN  GT_QD_DEV *dev,
+		OUT GT_U16    *data
+		);
+
+/*******************************************************************************
+ * hwWritePPU
+ *
+ * DESCRIPTION:
+ *			This function writes PPU bit in Global Register
+ *
+ * INPUTS:
+ *			data - The value to write into PPU bit
+ *
+ * OUTPUTS:
+ *			None.
+ *
+ * RETURNS:
+ *			GT_OK on success, or
+ *			GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *			This function can be used to access PHY register connected to Gigabit
+ *			Switch.
+ *
+ *******************************************************************************/
+	GT_STATUS hwWritePPU
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U16    data
+		);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __gtHwCntlh */
Index: linux-2.6.16/include/linux/marvell/gtMiiSmiIf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/gtMiiSmiIf.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,156 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtMiiSmiIf.h
+ *
+ * DESCRIPTION:
+ *       Includes functions prototypes for initializing and accessing the
+ *       MII / SMI interface.
+ *       This is the only file to be included from upper layers.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *
+ *******************************************************************************/
+
+#ifndef __gtMiiSmiIfh
+#define __gtMiiSmiIfh
+
+
+#include <linux/marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+ * miiSmiIfInit
+ *
+ * DESCRIPTION:
+ *       This function initializes the MII / SMI interface.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       highSmiDevAddr - Indicates whether to use the high device register
+ *                     addresses when accessing switch's registers (of all kinds)
+ *                     i.e, the devices registers range is 0x10 to 0x1F, or to
+ *                     use the low device register addresses (range 0x0 to 0xF).
+ *                       GT_TRUE     - use high addresses (0x10 to 0x1F).
+ *                       GT_FALSE    - use low addresses (0x0 to 0xF).
+ *
+ * RETURNS:
+ *       DEVICE_ID       - on success
+ *       0     - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_U16 miiSmiIfInit
+	(
+		IN  GT_QD_DEV *dev,
+		OUT GT_BOOL   * highSmiDevAddr
+		);
+
+/*******************************************************************************
+ * miiSmiManualIfInit
+ *
+ * DESCRIPTION:
+ *       This function returns Device ID from the given base address
+ *
+ * INPUTS:
+ *       baseAddr - either 0x0 or 0x10. Indicates whether to use the low device 
+ *					register address or high device register address.
+ *					The device register range is from 0x0 to 0xF or from 0x10 
+ *					to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port 
+ *					switchs.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       DEVICE_ID       - on success
+ *       0    - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_U16 miiSmiManualIfInit
+	(
+		IN  GT_QD_DEV   *dev,
+		IN  GT_U32		baseAddr
+		);
+
+/*******************************************************************************
+ * miiSmiIfReadRegister
+ *
+ * DESCRIPTION:
+ *       This function reads a register throw the SMI / MII interface, to be used
+ *       by upper layers.
+ *
+ * INPUTS:
+ *       phyAddr     - The PHY address to be read.
+ *       regAddr     - The register address to read.
+ *
+ * OUTPUTS:
+ *       data        - The register's data.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS miiSmiIfReadRegister
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     phyAddr,
+		IN  GT_U8     regAddr,
+		OUT GT_U16    *data
+		);
+
+
+/*******************************************************************************
+ * miiSmiIfWriteRegister
+ *
+ * DESCRIPTION:
+ *       This function writes to a register throw the SMI / MII interface, to be
+ *       used by upper layers.
+ *
+ * INPUTS:
+ *       phyAddr     - The PHY address to be read.
+ *       regAddr     - The register address to read.
+ *       data        - The data to be written to the register.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS miiSmiIfWriteRegister
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U8     phyAddr,
+		IN  GT_U8     regAddr,
+		IN  GT_U16    data
+		);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtMiiSmiIfh */
Index: linux-2.6.16/include/linux/marvell/gtSem.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/gtSem.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,153 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * gtOs.h
+ *
+ * DESCRIPTION:
+ *       Operating System wrapper
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#ifndef __gtSemh
+#define __gtSemh
+
+#include <linux/marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***** Defines  ********************************************************/
+
+#define OS_WAIT_FOREVER             0
+
+#define OS_MAX_TASKS                30
+#define OS_MAX_TASK_NAME_LENGTH     10
+
+#define OS_MAX_QUEUES               30
+#define OS_MAX_QUEUE_NAME_LENGTH    10
+
+#define OS_MAX_EVENTS               10
+
+#define OS_MAX_SEMAPHORES           50
+
+#define OS_EOF                      (-1)
+
+
+/*******************************************************************************
+ * gtSemCreate
+ *
+ * DESCRIPTION:
+ *       Create semaphore.
+ *
+ * INPUTS:
+ *		state - beginning state of the semaphore, either SEM_EMPTY or SEM_FULL
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_SEM if success. Otherwise, NULL
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	GT_SEM gtSemCreate
+	(
+		IN GT_QD_DEV    *dev,
+		IN GT_SEM_BEGIN_STATE state
+		);
+
+/*******************************************************************************
+ * gtSemDelete
+ *
+ * DESCRIPTION:
+ *       Delete semaphore.
+ *
+ * INPUTS:
+ *       smid - semaphore Id
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	GT_STATUS gtSemDelete
+	(
+		IN GT_QD_DEV    *dev,
+		IN GT_SEM       smid
+		);
+
+/*******************************************************************************
+ * gtSemTake
+ *
+ * DESCRIPTION:
+ *       Wait for semaphore.
+ *
+ * INPUTS:
+ *       smid    - semaphore Id
+ *       timeOut - time out in miliseconds or 0 to wait forever
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       OS_TIMEOUT - on time out
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	GT_STATUS gtSemTake
+	(
+		IN GT_QD_DEV    *dev,
+		IN GT_SEM       smid,
+		IN GT_U32       timeOut
+		);
+
+/*******************************************************************************
+ * gtSemGive
+ *
+ * DESCRIPTION:
+ *       release the semaphore which was taken previously.
+ *
+ * INPUTS:
+ *       smid    - semaphore Id
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	GT_STATUS gtSemGive
+	(
+		IN GT_QD_DEV    *dev,
+		IN GT_SEM       smid
+		);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* __gtSemh */
+/* Do Not Add Anything Below This Line */
Index: linux-2.6.16/include/linux/marvell/gtVct.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/gtVct.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,64 @@
+/*******************************************************************************
+ *              Copyright 2002, GALILEO TECHNOLOGY, LTD.
+ *
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL. NO RIGHTS ARE GRANTED
+ * HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT OF MARVELL OR ANY THIRD
+ * PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE DISCRETION TO REQUEST THAT THIS
+ * CODE BE IMMEDIATELY RETURNED TO MARVELL. THIS CODE IS PROVIDED "AS IS".
+ * MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED OR OTHERWISE, REGARDING ITS
+ * ACCURACY, COMPLETENESS OR PERFORMANCE. MARVELL COMPRISES MARVELL TECHNOLOGY
+ * GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, MARVELL INTERNATIONAL LTD. (MIL),
+ * MARVELL TECHNOLOGY, INC. (MTI), MARVELL SEMICONDUCTOR, INC. (MSI), MARVELL
+ * ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K. (MJKK), GALILEO TECHNOLOGY LTD. (GTL)
+ * AND GALILEO TECHNOLOGY, INC. (GTI).
+ ********************************************************************************
+ * gtVct.h
+ *
+ * DESCRIPTION:
+ *       API definitions for Marvell Virtual Cable Tester functionality.
+ *
+ * DEPENDENCIES:
+ *       None.
+ *
+ * FILE REVISION NUMBER:
+ *       $Revision: 1.3 $
+ *******************************************************************************/
+
+#ifndef __gtVcth
+#define __gtVcth
+
+#include <linux/marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MARVELL_OUI_MSb		0x0141
+#define MARVELL_OUI_LSb		0x0C00
+#define OUI_LSb_MASK		0xFC00
+#define PHY_MODEL_MASK		0x03F0
+#define PHY_REV_MASK		0x000F
+
+#define DEV_E3082		0x8 << 4
+#define DEV_E104X		0x2 << 4
+#define DEV_E1111		0xC << 4
+#define DEV_E1112		0x9 << 4
+#define DEV_E114X		0xD << 4
+#define DEV_E1149		0xA << 4
+#define DEV_E1180		0xE << 4
+#define DEV_EC010		0x3 << 4
+
+/* definition for formula to calculate actual distance */
+#ifdef FP_SUPPORT
+#define FORMULA_PHY100M(_data)	((_data)*0.7861 - 18.862)
+#define FORMULA_PHY1000M(_data)	((_data)*0.8018 - 28.751)
+#else
+#define FORMULA_PHY100M(_data)	(((long)(_data)*7861 - 188620)/10000 + (((((long)(_data)*7861 - 188620)%10000) >= 5000)?1:0))
+#define FORMULA_PHY1000M(_data)	(((long)(_data)*8018 - 287510)/10000 + (((((long)(_data)*8018 - 287510)%10000) >= 5000)?1:0))
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtVcth */
Index: linux-2.6.16/include/linux/marvell/msApiDefs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/msApiDefs.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,1365 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * msApiDefs.h
+ *
+ * DESCRIPTION:
+ *       API definitions for QuarterDeck Device
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#ifndef __msApiDefs_h
+#define __msApiDefs_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <linux/marvell/msApiTypes.h>
+/* Debug function   */
+
+#ifdef DEBUG_QD
+#define DBG_INFO(x) gtDbgPrint x
+#else
+#define DBG_INFO(x)
+#endif /* DEBUG_QD */
+
+	typedef GT_U32 GT_SEM;
+
+#define ETHERNET_HEADER_SIZE	GT_ETHERNET_HEADER_SIZE
+#define IS_MULTICAST_MAC		GT_IS_MULTICAST_MAC
+#define IS_BROADCAST_MAC		GT_IS_BROADCAST_MAC
+
+/*
+ *   Logical Port value based on a Port
+ *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |0|  reserved                                   |    port       |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ *
+ *   The following macros should be used to extract specific info
+ *   from a Logical Port index
+ */
+	typedef GT_U32 GT_LPORT;
+
+
+/* Define the different device type that may exist in system        */
+	typedef enum
+	{
+		GT_88E6021  = 0x021,
+		GT_88E6051  = 0x051,
+		GT_88E6052  = 0x052,
+		GT_88E6060  = 0x060,
+		GT_88E6063	= 0x153,
+		GT_FH_VPN	= 0xF53,
+		GT_FF_EG	= 0xF91,
+		GT_FF_HG	= 0xF93,
+		GT_88E6083	= 0x083,
+		GT_88E6181	= 0x1A0,
+		GT_88E6153	= 0x1A1,
+		GT_88E6183	= 0x1A3,
+		GT_88E6093	= 0x093,
+		GT_88E6092	= 0x097,
+		GT_88E6095	= 0x095,
+		GT_88E6152	= 0x1A4,
+		GT_88E6155	= 0x1A5,
+		GT_88E6182	= 0x1A6,
+		GT_88E6185	= 0x1A7
+	}GT_DEVICE;
+
+	typedef enum
+	{
+		INTR_MODE_DISABLE =0,
+		INTR_MODE_ENABLE
+	}INTERRUPT_MODE;
+
+	typedef enum
+	{
+		PORT_SPEED_10_MBPS,
+		PORT_SPEED_100_MBPS,
+		PORT_SPEED_1000_MBPS
+	} GT_PORT_SPEED_MODE;
+
+	typedef enum
+	{
+		PORT_FORCE_SPEED_10_MBPS,
+		PORT_FORCE_SPEED_100_MBPS,
+		PORT_FORCE_SPEED_1000_MBPS,
+		PORT_DO_NOT_FORCE_SPEED
+	} GT_PORT_FORCED_SPEED_MODE;
+
+	typedef enum
+	{
+		PORT_DO_NOT_FORCE_DUPLEX,
+		PORT_FORCE_FULL_DUPLEX,
+		PORT_FORCE_HALF_DUPLEX
+	} GT_PORT_FORCED_DUPLEX_MODE;
+
+	typedef enum
+	{
+		PORT_DO_NOT_FORCE_LINK,
+		PORT_FORCE_LINK_UP,
+		PORT_FORCE_LINK_DOWN
+	} GT_PORT_FORCED_LINK_MODE;
+
+	typedef enum
+	{
+		PORT_DO_NOT_FORCE_FC,
+		PORT_FORCE_FC_ENABLED,
+		PORT_FORCE_FC_DISABLED
+	} GT_PORT_FORCED_FC_MODE;
+
+	typedef enum
+	{
+		PPU_STATE_DISABLED_AT_RESET,
+		PPU_STATE_ACTIVE,
+		PPU_STATE_DISABLED_AFTER_RESET,
+		PPU_STATE_POLLING
+	} GT_PPU_STATE;
+
+	typedef enum
+	{
+		PORTCFG_GMII_125MHZ,		/* Px_GTXCLK = 125MHz, 1000BASE - Port 9 Only */
+		PORTCFG_FD_MII_0MHZ,		/* Px_GTXCLK = 0 MHz, Power Save - Port 9 Only */
+		PORTCFG_FDHD_MII_25MHZ,		/* Px_GTXCLK = 25MHz, 100BASE - Port 9 Only */ 
+		PORTCFG_FDHD_MII_2_5MHZ,	/* Px_GTXCLK = 2.5MHz, 10BASE - Port 9 Only */
+		PORTCFG_FD_SERDES,			/* Default value */
+		PORTCFG_FD_1000BASE_X,		/* Port 7,8,9 only */
+		PORTCFG_MGMII,				/* duplex, speed determined by the PPU */
+		PORTCFG_DISABLED			/* Port 9 Only */
+	} GT_PORT_CONFIG_MODE;
+
+/* Maximal number of ports a switch may have.   */
+#define MAX_SWITCH_PORTS    11
+#define VERSION_MAX_LEN 30
+
+/*
+ * Typedef: struct GT_VERSION
+ *
+ * Description: This struct holds the package version.
+ *
+ * Fields:
+ *      version - string array holding the version.
+ *
+ */
+	typedef struct
+	{
+		GT_U8   version[VERSION_MAX_LEN];
+	}GT_VERSION;
+
+
+
+/*
+ * Typedef: enum GT_ATU_OPERARION
+ *
+ * Description: Defines the different ATU and VTU operations
+ *
+ * Fields:
+ *      FLUSH_ALL           - Flush all entries.
+ *      FLUSH_UNLOCKED      - Flush all unlocked entries in ATU.
+ *      LOAD_PURGE_ENTRY    - Load / Purge entry.
+ *      GET_NEXT_ENTRY      - Get next ATU or VTU  entry.
+ *      FLUSH_ALL_IN_DB     - Flush all entries in a particular DBNum.
+ *      FLUSH_UNLOCKED_IN_DB - Flush all unlocked entries in a particular DBNum.
+ *      SERVICE_VIOLATONS   - sevice violations of VTU
+ *
+ */
+	typedef enum
+	{
+		FLUSH_ALL = 1,	/* for both atu and vtu */
+		FLUSH_UNLOCKED,	/* for atu only */
+		LOAD_PURGE_ENTRY,	/* for both atu and vtu */
+		GET_NEXT_ENTRY,	/* for both atu and vtu */
+		FLUSH_ALL_IN_DB,	/* for atu only */
+		FLUSH_UNLOCKED_IN_DB,	/* for atu only */
+		SERVICE_VIOLATIONS 	/* for vtu only */
+	} GT_ATU_OPERATION, GT_VTU_OPERATION;
+
+
+/*
+ * typedef: enum GT_FLUSH_CMD
+ *
+ * Description: Enumeration of the address translation unit flush operation.
+ *
+ * Enumerations:
+ *   GT_FLUSH_ALL       - flush all entries.
+ *   GT_FLUSH_ALL_UNBLK - flush all unblocked.
+ */
+	typedef enum
+	{
+		GT_FLUSH_ALL       = 1,
+		GT_FLUSH_ALL_UNBLK
+	}GT_FLUSH_CMD;
+
+/*
+ * typedef: enum GT_MOVE_CMD
+ *
+ * Description: Enumeration of the address translation unit flush operation.
+ *
+ * Enumerations:
+ *   GT_MOVE_ALL       - move all entries.
+ *   GT_MOVE_ALL_UNBLK - move all unblocked.
+ */
+	typedef enum
+	{
+		GT_MOVE_ALL       = 1,
+		GT_MOVE_ALL_UNBLK
+	}GT_MOVE_CMD;
+
+
+/*
+ * typedef: enum GT_ATU_UC_STATE
+ *
+ * Description:
+ *      Enumeration of the address translation unit entry state of unicast
+ *      entris.
+ *
+ * Enumerations:
+ *      GT_UC_INVALID   - invalid entry.
+ *      GT_UC_DYNAMIC   - unicast dynamic entry.
+ *		GT_UC_NO_PRI_TO_CPU_STATIC - static unicast entry with To_CPU Marvell tag without forcing priority.
+ *		GT_UC_TO_CPU_STATIC - static unicast entry with To_CPU Marvell tag.
+ *      GT_UC_NO_PRI_STATIC - static unicast entry without forcing priority.
+ *      GT_UC_STATIC    - static unicast entry.
+ *
+ * Note: GT_UC_NO_PRI_STATIC is supported only by 88E6183 family and 88E6093 family.
+ */
+	typedef enum
+	{
+		GT_UC_INVALID      = 0,
+		GT_UC_DYNAMIC      = 0x1,
+		GT_UC_NO_PRI_TO_CPU_STATIC       = 0xC,
+		GT_UC_TO_CPU_STATIC       = 0xD,
+		GT_UC_NO_PRI_STATIC       = 0xE,
+		GT_UC_STATIC       = 0xF
+	} GT_ATU_UC_STATE;
+
+
+/*
+ * typedef: enum GT_ATU_MC_STATE
+ *
+ * Description:
+ *      Enumeration of the address translation unit entry state of multicast
+ *      entris.
+ *
+ * Enumerations:
+ *      GT_MC_INVALID         - invalid entry.
+ *      GT_MC_MGM_STATIC      - static multicast management entries.
+ *      GT_MC_STATIC          - static multicast regular entris.
+ *      GT_MC_PRIO_MGM_STATIC - static multicast management entries with
+ *                              priority.
+ *      GT_MC_PRIO_STATIC     - static multicast regular entris with priority.
+ */
+	typedef enum
+	{
+		GT_MC_INVALID         = 0,
+		GT_MC_STATIC_UNLIMITED_RATE	= 0x5,
+		GT_MC_MGM_STATIC      = 0x6,
+		GT_MC_STATIC          = 0x7,
+		GT_MC_PRIO_STATIC_UNLIMITED_RATE	= 0xD,
+		GT_MC_PRIO_MGM_STATIC = 0xE,
+		GT_MC_PRIO_STATIC     = 0xF
+	} GT_ATU_MC_STATE;
+
+
+
+/*
+ *  typedef: struct GT_ATU_ENTRY
+ *
+ *  Description: address tarnslaton unit Entry
+ *
+ *  Fields:
+ *      macAddr    - mac address
+ *      trunkMember- GT_TRUE if entry belongs to a Trunk. This field will be
+ *					ignored if device does not support Trunk.
+ *      portVec    - port Vector. 
+ *					If trunkMember field is GT_TRUE, this value represents trunk ID.
+ *      prio       - entry priority.
+ *      entryState - the entry state.
+ *		DBNum	   - ATU MAC Address Database number. If multiple address 
+ *					databases are not being used, DBNum should be zero.
+ *					If multiple address databases are being used, this value
+ *					should be set to the desired address database number.
+ *
+ *  Comment:
+ *      The entryState union Type is determine according to the Mac Type.
+ */
+	typedef struct
+	{
+		GT_ETHERADDR 	macAddr;
+		GT_BOOL			trunkMember;
+		GT_U32			portVec;
+		GT_U8			prio;
+		GT_U8			DBNum;
+		union
+		{
+			GT_ATU_UC_STATE ucEntryState;
+			GT_ATU_MC_STATE mcEntryState;
+		} entryState;
+	} GT_ATU_ENTRY;
+
+
+/*
+ *  typedef: struct GT_VTU_DATA
+ *
+ *  Description: VLAN  tarnslaton unit Data Register
+ *
+ *  Fields:
+ *      memberTagP - Membership and Egress Tagging
+ *                   memberTagP[0] is for Port 0, MemberTagP[1] is for port 1, and so on 
+ *
+ *  Comment:
+ * 	MAX_SWITCH_PORTS is 10 for Octane.
+ * 	In the case of FullSail, there are 3 ports. So, the rest 7 is ignored in memeberTagP
+ */
+	typedef struct
+	{
+		GT_U8     memberTagP[MAX_SWITCH_PORTS];
+		GT_U8     portStateP[MAX_SWITCH_PORTS];
+	} GT_VTU_DATA;
+
+/*
+ *  definition for MEMBER_TAG
+ */
+#define MEMBER_EGRESS_UNMODIFIED	0
+#define NOT_A_MEMBER				1
+#define MEMBER_EGRESS_UNTAGGED		2
+#define MEMBER_EGRESS_TAGGED		3
+ 
+/*
+ *  typedef: struct GT_VTU_ENTRY
+ *
+ *  Description: VLAN  tarnslaton unit Entry
+ *
+ *  Fields:
+ *      DBNum      - database number 
+ *      vid        - VLAN ID 
+ *      vtuData    - VTU data
+ *		vidPriOverride - override the priority on any frame associated with this VID
+ *		vidPriority - VID Priority bits (0 ~ 7)
+ */
+	typedef struct
+	{
+		GT_U8         DBNum;
+		GT_U16         vid;
+		GT_VTU_DATA   vtuData;
+		GT_BOOL		  vidPriOverride;
+		GT_U8		  vidPriority;
+	} GT_VTU_ENTRY;
+
+/*
+ *  typedef: struct GT_VTU_INT_STATUS
+ *
+ *  Description: VLAN tarnslaton unit interrupt status
+ *
+ *  Fields:
+ *      intCause  - VTU Interrupt Cause
+ *					GT_VTU_FULL_VIOLATION,GT_MEMEBER_VIOLATION,or
+ *					GT_MISS_VIOLATION
+ *      SPID      - source port number
+ * 					if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ *      vid       - VLAN ID 
+ * 					if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ */
+	typedef struct
+	{
+		GT_U16   vtuIntCause;
+		GT_U8    spid;
+		GT_U16   vid;
+	} GT_VTU_INT_STATUS;
+
+/*
+ *  typedef: struct GT_ATU_INT_STATUS
+ *
+ *  Description: VLAN tarnslaton unit interrupt status
+ *
+ *  Fields:
+ *      intCause  - ATU Interrupt Cause
+ *					GT_FULL_VIOLATION,GT_MEMEBER_VIOLATION,or
+ *					GT_MISS_VIOLATION
+ *      SPID      - source port number
+ * 					if intCause is GT_FULL_VIOLATION, it means nothing
+ *      DBNum     - DB Num
+ * 					if intCause is GT_FULL_VIOLATION, it means nothing
+ *		macAddr	  - MAC Address
+ */
+	typedef struct
+	{
+		GT_U16   atuIntCause;
+		GT_U8    spid;
+		GT_U8    dbNum;
+		GT_ETHERADDR  macAddr;
+	} GT_ATU_INT_STATUS;
+
+/*
+ * Definition for VTU interrupt
+ */
+#define GT_MEMBER_VIOLATION		0x4
+#define GT_MISS_VIOLATION		0x2
+#define GT_VTU_FULL_VIOLATION	0x1
+/*
+ * Definitions for ATU interrupt in Gigabit switch are the same as 
+ * the ones for VTU interrupt. Here we just redefine the FULL_VIOLATION for
+ * both VTU and ATU.
+ */
+#define GT_FULL_VIOLATION		0x1
+
+
+/*
+ * Typedef:
+ *
+ * Description: Defines the different sizes of the Mac address table.
+ *
+ * Fields:
+ *      ATU_SIZE_256    -   256 entries Mac address table.
+ *      ATU_SIZE_512    -   512 entries Mac address table.
+ *      ATU_SIZE_1024   -   1024 entries Mac address table.
+ *      ATU_SIZE_2048   -   2048 entries Mac address table.
+ *      ATU_SIZE_4096   -   4096 entries Mac address table.
+ *
+ */
+	typedef enum
+	{
+		ATU_SIZE_256,
+		ATU_SIZE_512,
+		ATU_SIZE_1024,
+		ATU_SIZE_2048,
+		ATU_SIZE_4096
+	}ATU_SIZE;
+
+
+/*
+ * typedef: enum GT_PORT_STP_STATE
+ *
+ * Description: Enumeration of the port spanning tree state.
+ *
+ * Enumerations:
+ *   GT_PORT_DISABLE    - port is disabled.
+ *   GT_PORT_BLOCKING   - port is in blocking/listening state.
+ *   GT_PORT_LEARNING   - port is in learning state.
+ *   GT_PORT_FORWARDING - port is in forwarding state.
+ */
+	typedef enum
+	{
+		GT_PORT_DISABLE = 0,
+		GT_PORT_BLOCKING,
+		GT_PORT_LEARNING,
+		GT_PORT_FORWARDING
+	} GT_PORT_STP_STATE;
+
+
+/*
+ * typedef: enum GT_EGRESS_MODE
+ *
+ * Description: Enumeration of the port egress mode.
+ *
+ * Enumerations:
+ *   GT_UNMODIFY_EGRESS - frames are transmited unmodified.
+ *   GT_TAGGED_EGRESS   - all frames are transmited tagged.
+ *   GT_UNTAGGED_EGRESS - all frames are transmited untagged.
+ *   GT_ADD_TAG         - always add a tag. (or double tag)
+ */
+	typedef enum
+	{
+		GT_UNMODIFY_EGRESS = 0,
+		GT_UNTAGGED_EGRESS,
+		GT_TAGGED_EGRESS,
+		GT_ADD_TAG
+	} GT_EGRESS_MODE;
+
+/*  typedef: enum GT_DOT1Q_MODE */
+
+	typedef enum
+	{
+		GT_DISABLE = 0,
+		GT_FALLBACK,
+		GT_CHECK,
+		GT_SECURE
+	} GT_DOT1Q_MODE;
+
+
+/* typedef: enum GT_SW_MODE */
+
+	typedef enum
+	{
+		GT_CPU_ATTATCHED = 0, /* ports come up disabled */
+		GT_BACKOFF,           /* EEPROM attac mode with old half duplex backoff mode */
+		GT_STAND_ALONE,       /* ports come up enabled, ignore EEPROM */
+		GT_EEPROM_ATTATCHED   /* EEPROM defined prot states */
+	} GT_SW_MODE;
+
+/* typedef: enum GT_RATE_LIMIT_MODE
+ * The ingress limit mode in the rate control register (0xA)
+ */
+
+	typedef enum
+	{
+		GT_LIMT_ALL = 0, 		/* limit and count all frames */
+		GT_LIMIT_FLOOD,      	/* limit and count Broadcast, Multicast and flooded unicast frames */
+		GT_LIMIT_BRDCST_MLTCST,	/* limit and count Broadcast and Multicast frames */
+		GT_LIMIT_BRDCST   		/* limit and count Broadcast frames */
+	} GT_RATE_LIMIT_MODE;
+
+/* typedef: enum GT_PRI0_RATE
+ * The ingress data rate limit for priority 0 frames 
+ */
+
+	typedef enum
+	{
+		GT_NO_LIMIT = 0, 	/* Not limited   */
+		GT_128K,      		/* 128K bits/sec */
+		GT_256K,      		/* 256K bits/sec */
+		GT_512K,      		/* 512 bits/sec */
+		GT_1M,      		/* 1M  bits/sec */
+		GT_2M,      		/* 2M  bits/sec */
+		GT_4M,      		/* 4M  bits/sec */
+		GT_8M,      		/* 8M  bits/sec */
+		GT_16M,      		/* 16M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+		GT_32M,      		/* 32M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+		GT_64M,      		/* 64M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+		GT_128M,      		/* 128M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+		GT_256M      		/* 256M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+	} GT_PRI0_RATE,GT_EGRESS_RATE;
+/*
+ * Formula for Gigabit Switch family's Rate Limit
+ */
+#define GT_GET_RATE_LIMIT(_kbps)	((_kbps)?(8000000 / (28 * (_kbps))):0)
+#define GT_GET_RATE_LIMIT2(_kbps)	((_kbps)?(8000000 / (32 * (_kbps))):0)
+
+#define MAX_RATE_LIMIT		256000	/* unit of Kbps */
+#define MIN_RATE_LIMIT		65		/* unit of Kbps */
+
+/*
+ * typedef: enum GT_EVENT_TYPE
+ *
+ * Description: Enumeration of the available hardware driven events.
+ *
+ * Enumerations:
+ *   GT_STATS_DONE - Statistics Operation Done interrrupt Enable 
+ *   GT_VTU_PROB - VLAN Problem/Violation Interrupt Enable
+ *   GT_VTU_DONE - VALN Table Operation Done Interrupt Enable
+ *   GT_ATU_PROB - ATU Problem/Violation Interrupt Enable, for Gigabit Switch
+ *   GT_ATU_FULL - ATU full interrupt enable, for Fast Ethernet Switch
+ *   GT_ATU_DONE - ATU Done interrupt enable.
+ *   GT_PHY_INT  - PHY interrupt enable, for Fast Ethernet Switch
+ *   GT_EE_INT   - EEPROM Done interrupt enable.
+ */
+#define GT_STATS_DONE           0x40
+#define GT_VTU_PROB             0x20
+#define GT_VTU_DONE             0x10
+#define GT_ATU_PROB 		0x8
+#define GT_ATU_FULL 		0x8
+#define GT_ATU_DONE		0x4
+#define GT_PHY_INTERRUPT	0x2	/* For Fast Ethernet Switch (not supported by Gigabit Switch) */
+#define GT_EE_INTERRUPT		0x1
+
+#define GT_INT_MASK		(GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_FULL | GT_ATU_DONE | GT_PHY_INTERRUPT | GT_EE_INTERRUPT)
+#define GT_NO_INTERNAL_PHY_INT_MASK		(GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_PROB | GT_ATU_DONE | GT_EE_INTERRUPT)
+
+/*
+ * typedef: enum GT_PHY_INT
+ *
+ * Description: Enumeration of PHY interrupt
+ */
+
+#define GT_SPEED_CHANGED 		0x4000
+#define GT_DUPLEX_CHANGED		0x2000
+#define GT_PAGE_RECEIVED		0x1000
+#define GT_AUTO_NEG_COMPLETED	0x800
+#define GT_LINK_STATUS_CHANGED	0x400
+#define GT_SYMBOL_ERROR			0x200
+#define GT_FALSE_CARRIER		0x100
+#define GT_FIFO_FLOW			0x80
+#define GT_CROSSOVER_CHANGED	0x40
+#define GT_POLARITY_CHANGED		0x2
+#define GT_JABBER				0x1
+
+#define GT_AUTO_NEG_ERROR		0x8000
+#define GT_DOWNSHIFT_DETECT		0x20
+#define GT_ENERGY_DETECT		0x10
+
+/*
+ * typedef: enum GT_PHY_AUTO_MODE
+ *
+ * Description: Enumeration of Autonegotiation mode.
+ *	Auto for both speed and duplex.
+ *	Auto for speed only and Full duplex.
+ *	Auto for speed only and Half duplex. (1000Mbps is not supported)
+ *	Auto for duplex only and speed 1000Mbps.
+ *	Auto for duplex only and speed 100Mbps.
+ *	Auto for duplex only and speed 10Mbps.
+ *	1000Mbps Full duplex.
+ *	100Mbps Full duplex.
+ *	100Mbps Half duplex.
+ *	10Mbps Full duplex.
+ *	10Mbps Half duplex.
+ */
+
+	typedef enum
+	{
+		SPEED_AUTO_DUPLEX_AUTO,
+		SPEED_1000_DUPLEX_AUTO,
+		SPEED_100_DUPLEX_AUTO,
+		SPEED_10_DUPLEX_AUTO,
+		SPEED_AUTO_DUPLEX_FULL,
+		SPEED_AUTO_DUPLEX_HALF,
+		SPEED_1000_DUPLEX_FULL,
+		SPEED_1000_DUPLEX_HALF,
+		SPEED_100_DUPLEX_FULL,
+		SPEED_100_DUPLEX_HALF,
+		SPEED_10_DUPLEX_FULL,
+		SPEED_10_DUPLEX_HALF
+	}GT_PHY_AUTO_MODE;
+
+
+
+/*
+ * typedef: enum GT_INGRESS_MODE
+ *
+ * Description: Enumeration of the port ingress mode.
+ *
+ * Enumerations:
+ *   GT_UNMODIFY_INGRESS - frames are receive unmodified.
+ *   GT_TRAILER_INGRESS  - all frames are received with trailer.
+ *   GT_UNTAGGED_INGRESS  - remove tag on receive (for double tagging).
+ *   GT_CPUPORT_INGRESS - no trailer. used to identify the CPU port for IGMP/MLD Snooping
+ */
+	typedef enum
+	{
+		GT_UNMODIFY_INGRESS = 0,  /* 0x00 */
+		GT_TRAILER_INGRESS,       /* 0x01 */
+		GT_UNTAGGED_INGRESS,      /* 0x10 */
+		GT_CPUPORT_INGRESS        /* 0x11 */
+	} GT_INGRESS_MODE;
+
+
+/*
+ *  typedef: enum GT_INGRESS_MODE
+ *
+ *  Description: Enumeration of the port ingress mode.
+ *
+ *  Enumerations:
+ *      GT_MC_3_PERCENT_RL   - multicast rate is limited to 3 percent.
+ *      GT_MC_6_PERCENT_RL   - multicast rate is limited to 6 percent.
+ *      GT_MC_12_PERCENT_RL  - multicast rate is limited to 12 percent.
+ *      GT_MC_100_PERCENT_RL - unlimited multicast rate.
+ */
+	typedef enum
+	{
+		GT_MC_3_PERCENT_RL = 0,
+		GT_MC_6_PERCENT_RL,
+		GT_MC_12_PERCENT_RL,
+		GT_MC_100_PERCENT_RL,
+	} GT_MC_RATE;
+
+
+
+/*
+ *  typedef: struct GT_PORT_STAT
+ *
+ *  Description: port statistic struct.
+ *
+ *  Fields:
+ *      rxCtr    - port receive counter.
+ *      txCtr    - port transmit counter.
+ *
+ *  Comment:
+ */
+	typedef struct
+	{
+		GT_U16  rxCtr;
+		GT_U16  txCtr;
+	} GT_PORT_STAT;
+
+/*
+ *  typedef: struct GT_PORT_STAT2
+ *
+ *  Description: port statistic struct.
+ *
+ *  Fields:
+ *      inDiscardLo - InDiscards Low Frame Counter
+ *      inDiscardHi - InDiscards High Frame Counter
+ *      inFiltered  - InFiltered Frame Counter
+ *      outFiltered - OutFiltered Frame Counter
+ *
+ *  Comment:
+ */
+	typedef struct
+	{
+		GT_U16  inDiscardLo;
+		GT_U16  inDiscardHi;
+		GT_U16  inFiltered;
+		GT_U16  outFiltered;
+	} GT_PORT_STAT2;
+
+
+/*
+**  typedef: struct GT_PORT_Q_COUNTERS
+**
+**  Description: port queue statistic struct.
+**
+**  Fields:
+**      OutQ_Size - port egress queue size coi
+**      Rsv_Size  - ingress reserved e counter
+**
+**/
+	typedef struct
+	{
+		GT_U16  OutQ_Size;
+		GT_U16  Rsv_Size;
+	} GT_PORT_Q_STAT;
+
+/*
+ * typedef: enum GT_CTR_MODE
+ *
+ * Description: Enumeration of the port counters mode.
+ *
+ * Enumerations:
+ *   GT_CTR_ALL    - In this mode the counters counts Rx receive and transmit
+ *                   frames.
+ *   GT_CTR_ERRORS - In this mode the counters counts Rx Errors and collisions.
+ */
+	typedef enum
+	{
+		GT_CTR_ALL = 0,
+		GT_CTR_ERRORS,
+	} GT_CTR_MODE;
+
+	typedef struct _GT_QD_DEV GT_QD_DEV;
+
+/*
+ * semaphore related definitions.
+ * User Applications may register Semaphore functions using following definitions
+ */
+	typedef enum
+	{
+		GT_SEM_EMPTY,
+		GT_SEM_FULL
+	} GT_SEM_BEGIN_STATE;
+
+	typedef GT_SEM (*FGT_SEM_CREATE)(
+		GT_SEM_BEGIN_STATE state);
+	typedef GT_STATUS (*FGT_SEM_DELETE)(
+		GT_SEM semId);
+	typedef GT_STATUS (*FGT_SEM_TAKE)(
+		GT_SEM semId, GT_U32 timOut);
+	typedef GT_STATUS (*FGT_SEM_GIVE)(
+		GT_SEM semId);
+
+	typedef struct
+	{
+		FGT_SEM_CREATE	semCreate; 	/* create semapore */
+		FGT_SEM_DELETE	semDelete; 	/* delete the semapore */
+		FGT_SEM_TAKE	semTake;	/* try to get a semapore */
+		FGT_SEM_GIVE	semGive;	/* return semaphore */
+	}GT_SEM_ROUTINES;
+
+/*
+ * definitions for registering MII access functions.
+ *
+ */
+	typedef GT_BOOL (*FGT_READ_MII)(
+		GT_QD_DEV*   dev,
+		unsigned int phyAddr, 
+		unsigned int miiReg, 
+		unsigned int* value);
+	typedef GT_BOOL (*FGT_WRITE_MII)(
+		GT_QD_DEV*   dev,
+		unsigned int phyAddr, 
+		unsigned int miiReg, 
+		unsigned int value);
+	typedef GT_BOOL (*FGT_INT_HANDLER)(
+		GT_QD_DEV*   dev,
+		GT_U16*);
+
+	typedef struct _BSP_FUNCTIONS
+	{
+		FGT_READ_MII 	readMii;	/* read MII Registers */
+		FGT_WRITE_MII 	writeMii;	/* write MII Registers */
+		FGT_SEM_CREATE	semCreate; 	/* create semapore */
+		FGT_SEM_DELETE	semDelete; 	/* delete the semapore */
+		FGT_SEM_TAKE	semTake;	/* try to get a semapore */
+		FGT_SEM_GIVE	semGive;	/* return semaphore */
+	}BSP_FUNCTIONS;
+
+
+/*
+ *	Type definition for MIB counter operation
+ */
+	typedef enum 
+	{
+		STATS_FLUSH_ALL,		/* Flush all counters for all ports */
+		STATS_FLUSH_PORT,		/* Flush all counters for a port */
+		STATS_READ_COUNTER,	/* Read a specific counter from a port */
+		STATS_READ_ALL		/* Read all counters from a port */
+
+	} GT_STATS_OPERATION;
+
+	typedef struct _GT_STATS_COUNTER_SET
+	{
+		GT_U32	InUnicasts;
+		GT_U32	InBroadcasts;
+		GT_U32	InPause;
+		GT_U32	InMulticasts;
+		GT_U32	InFCSErr;
+		GT_U32	AlignErr;
+		GT_U32	InGoodOctets;
+		GT_U32	InBadOctets;
+		GT_U32	Undersize;
+		GT_U32	Fragments;
+		GT_U32	In64Octets;		/* 64 Octets */
+		GT_U32	In127Octets;	/* 65 to 127 Octets */
+		GT_U32	In255Octets;	/* 128 to 255 Octets */
+		GT_U32	In511Octets;	/* 256 to 511 Octets */
+		GT_U32	In1023Octets;	/* 512 to 1023 Octets */
+		GT_U32	InMaxOctets;	/* 1024 to Max Octets */
+		GT_U32	Jabber;
+		GT_U32	Oversize;
+		GT_U32	InDiscards;
+		GT_U32	Filtered;
+		GT_U32	OutUnicasts;
+		GT_U32	OutBroadcasts;
+		GT_U32	OutPause;
+		GT_U32	OutMulticasts;
+		GT_U32	OutFCSErr;
+		GT_U32	OutGoodOctets;
+		GT_U32	Out64Octets;	/* 64 Octets */
+		GT_U32	Out127Octets;	/* 65 to 127 Octets */
+		GT_U32	Out255Octets;	/* 128 to 255 Octets */
+		GT_U32	Out511Octets;	/* 256 to 511 Octets */
+		GT_U32	Out1023Octets;	/* 512 to 1023 Octets */
+		GT_U32	OutMaxOctets;	/* 1024 to Max Octets */
+		GT_U32	Collisions;
+		GT_U32	Late;
+		GT_U32	Excessive;
+		GT_U32	Multiple;
+		GT_U32	Single;
+		GT_U32	Deferred;
+		GT_U32	OutDiscards;
+
+	} GT_STATS_COUNTER_SET;
+
+
+	typedef enum
+	{
+		STATS_InUnicasts = 0,
+		STATS_InBroadcasts,
+		STATS_InPause,
+		STATS_InMulticasts,
+		STATS_InFCSErr,
+		STATS_AlignErr,
+		STATS_InGoodOctets,
+		STATS_InBadOctets,
+		STATS_Undersize,
+		STATS_Fragments,
+		STATS_In64Octets,
+		STATS_In127Octets,
+		STATS_In255Octets,
+		STATS_In511Octets,
+		STATS_In1023Octets,
+		STATS_InMaxOctets,
+		STATS_Jabber,
+		STATS_Oversize,
+		STATS_InDiscards,
+		STATS_Filtered,
+		STATS_OutUnicasts,
+		STATS_OutBroadcasts,
+		STATS_OutPause,
+		STATS_OutMulticasts,
+		STATS_OutFCSErr,
+		STATS_OutGoodOctets,
+		STATS_Out64Octets,
+		STATS_Out127Octets,
+		STATS_Out255Octets,
+		STATS_Out511Octets,
+		STATS_Out1023Octets,
+		STATS_OutMaxOctets,
+		STATS_Collisions,
+		STATS_Late,
+		STATS_Excessive,
+		STATS_Multiple,
+		STATS_Single,
+		STATS_Deferred,
+		STATS_OutDiscards
+
+	} GT_STATS_COUNTERS;
+/*
+ * typedef: enum GT_HISTOGRAM_MODE
+ *
+ * Description: Enumeration of the histogram counters mode.
+ *
+ * Enumerations:
+ *   GT_COUNT_RX_ONLY - In this mode, Rx Histogram Counters are counted.
+ *   GT_COUNT_TX_ONLY - In this mode, Tx Histogram Counters are counted.
+ *   GT_COUNT_RX_TX   - In this mode, Rx and Tx Histogram Counters are counted.
+ */
+	typedef enum
+	{
+		GT_COUNT_RX_ONLY = 0,
+		GT_COUNT_TX_ONLY,
+		GT_COUNT_RX_TX
+	} GT_HISTOGRAM_MODE;
+
+/*
+  Counter set 2 is used by 88E6183
+*/
+	typedef struct _GT_STATS_COUNTER_SET2
+	{
+		GT_U32	InGoodOctetsHi;
+		GT_U32	InGoodOctetsLo;
+		GT_U32	InBadOctets;
+		GT_U32	OutDiscards;
+		GT_U32	InGoodFrames;
+		GT_U32	InBadFrames;
+		GT_U32	InBroadcasts;
+		GT_U32	InMulticasts;
+		/* 
+		   Histogram Counters : Rx Only, Tx Only, or both Rx and Tx 
+		   (refer to Histogram Mode) 
+		*/
+		GT_U32	Octets64;		/* 64 Octets */
+		GT_U32	Octets127;		/* 65 to 127 Octets */
+		GT_U32	Octets255;		/* 128 to 255 Octets */
+		GT_U32	Octets511;		/* 256 to 511 Octets */
+		GT_U32	Octets1023;		/* 512 to 1023 Octets */
+		GT_U32	OctetsMax;		/* 1024 to Max Octets */
+		GT_U32	OutOctetsHi;
+		GT_U32	OutOctetsLo;
+		GT_U32	OutFrames;
+		GT_U32	Excessive;
+		GT_U32	OutMulticasts;
+		GT_U32	OutBroadcasts;
+		GT_U32	InBadMACCtrl;
+
+		GT_U32	OutPause;
+		GT_U32	InPause;
+		GT_U32	InDiscards;
+		GT_U32	Undersize;
+		GT_U32	Fragments;
+		GT_U32	Oversize;
+		GT_U32	Jabber;
+		GT_U32	MACRcvErr;
+		GT_U32	InFCSErr;
+		GT_U32	Collisions;
+		GT_U32	Late;
+
+	} GT_STATS_COUNTER_SET2;
+
+
+	typedef enum
+	{
+		STATS2_InGoodOctetsHi = 0,
+		STATS2_InGoodOctetsLo,
+		STATS2_InBadOctets,
+	
+		STATS2_OutDiscards,
+		STATS2_InGoodFrames,
+		STATS2_InBadFrames,
+		STATS2_InBroadcasts,
+		STATS2_InMulticasts,
+		STATS2_64Octets,
+		STATS2_127Octets,
+		STATS2_255Octets,
+		STATS2_511Octets,
+		STATS2_1023Octets,
+		STATS2_MaxOctets,
+		STATS2_OutOctetsHi,
+		STATS2_OutOctetsLo,
+		STATS2_OutFrames,
+		STATS2_Excessive,
+		STATS2_OutMulticasts,
+		STATS2_OutBroadcasts,
+		STATS2_InBadMACCtrl,
+		STATS2_OutPause,
+		STATS2_InPause,
+		STATS2_InDiscards,
+		STATS2_Undersize,
+		STATS2_Fragments,
+		STATS2_Oversize,
+		STATS2_Jabber,
+		STATS2_MACRcvErr,
+		STATS2_InFCSErr,
+		STATS2_Collisions,
+		STATS2_Late
+
+	} GT_STATS_COUNTERS2;
+
+/*
+  Counter set 3 is used by 88E6093
+*/
+	typedef struct _GT_STATS_COUNTER_SET3
+	{
+		GT_U32	InGoodOctetsLo;	/* offset 0 */
+		GT_U32	InGoodOctetsHi;	/* offset 1 */
+		GT_U32	InBadOctets;		/* offset 2 */
+		GT_U32	OutFCSErr;			/* offset 3 */
+		GT_U32	InUnicasts;			/* offset 4 */
+		GT_U32	Deferred;			/* offset 5 */
+		GT_U32	InBroadcasts;		/* offset 6 */
+		GT_U32	InMulticasts;		/* offset 7 */
+		/* 
+		   Histogram Counters : Rx Only, Tx Only, or both Rx and Tx 
+		   (refer to Histogram Mode) 
+		*/
+		GT_U32	Octets64;		/* 64 Octets, offset 8 */
+		GT_U32	Octets127;		/* 65 to 127 Octets, offset 9 */
+		GT_U32	Octets255;		/* 128 to 255 Octets, offset 10 */
+		GT_U32	Octets511;		/* 256 to 511 Octets, offset 11 */
+		GT_U32	Octets1023;		/* 512 to 1023 Octets, offset 12 */
+		GT_U32	OctetsMax;		/* 1024 to Max Octets, offset 13 */
+		GT_U32	OutOctetsLo;	/* offset 14 */
+		GT_U32	OutOctetsHi;	/* offset 15 */
+		GT_U32	OutUnicasts;	/* offset 16 */
+		GT_U32	Excessive;		/* offset 17 */
+		GT_U32	OutMulticasts;	/* offset 18 */
+		GT_U32	OutBroadcasts;	/* offset 19 */
+		GT_U32	Single;			/* offset 20 */
+
+		GT_U32	OutPause;		/* offset 21 */
+		GT_U32	InPause;			/* offset 22 */
+		GT_U32	Multiple;		/* offset 23 */
+		GT_U32	Undersize;		/* offset 24 */
+		GT_U32	Fragments;		/* offset 25 */
+		GT_U32	Oversize;		/* offset 26 */
+		GT_U32	Jabber;			/* offset 27 */
+		GT_U32	InMACRcvErr;	/* offset 28 */
+		GT_U32	InFCSErr;		/* offset 29 */
+		GT_U32	Collisions;		/* offset 30 */
+		GT_U32	Late;				/* offset 31 */
+
+	} GT_STATS_COUNTER_SET3;
+
+
+	typedef enum
+	{
+		STATS3_InGoodOctetsLo = 0,
+		STATS3_InGoodOctetsHi,
+		STATS3_InBadOctets,
+	
+		STATS3_OutFCSErr,
+		STATS3_InUnicasts,
+		STATS3_Deferred,			/* offset 5 */
+		STATS3_InBroadcasts,
+		STATS3_InMulticasts,
+		STATS3_64Octets,
+		STATS3_127Octets,
+		STATS3_255Octets,			/* offset 10 */
+		STATS3_511Octets,
+		STATS3_1023Octets,
+		STATS3_MaxOctets,
+		STATS3_OutOctetsLo,
+		STATS3_OutOctetsHi,
+		STATS3_OutUnicasts,		/* offset 16 */
+		STATS3_Excessive,
+		STATS3_OutMulticasts,
+		STATS3_OutBroadcasts,
+		STATS3_Single,
+		STATS3_OutPause,
+		STATS3_InPause,
+		STATS3_Multiple,
+		STATS3_Undersize,			/* offset 24 */
+		STATS3_Fragments,
+		STATS3_Oversize,
+		STATS3_Jabber,
+		STATS3_InMACRcvErr,
+		STATS3_InFCSErr,
+		STATS3_Collisions,
+		STATS3_Late					/* offset 31 */
+
+	} GT_STATS_COUNTERS3;
+
+
+
+/*
+ * typedef: struct GT_1000T_MASTER_SLAVE
+ *
+ * Description: 1000Base-T Master/Slave Configuration
+ *
+ * Fields:
+ *      autoConfig   - GT_TRUE for auto-config, GT_FALSE for manual setup.
+ *      masterPrefer - GT_TRUE if Master configuration is preferred.
+ *
+ */
+	typedef struct _GT_1000T_MASTER_SLAVE
+	{
+		GT_BOOL	autoConfig;
+		GT_BOOL masterPrefer;
+	} GT_1000T_MASTER_SLAVE;
+
+
+#define GT_MDI_PAIR_NUM     	4	/* (1,2),(3,6),(4,5),(7,8) */
+#define GT_CHANNEL_PAIR_NUM     2	/* (channel A,B),(channel C,D) */
+
+/*
+ * typedef: enum GT_TEST_STATUS
+ *
+ * Description: Enumeration of VCT test status
+ *
+ * Enumerations:
+ *      GT_TEST_FAIL    - virtual cable test failed.
+ *      GT_NORMAL_CABLE - normal cable.
+ *      GT_IMPEDANCE_MISMATCH - impedance mismatch.
+ *      GT_OPEN_CABLE   - open in cable.
+ *      GT_SHORT_CABLE  - short in cable.
+ *
+ */
+	typedef enum
+	{
+		GT_TEST_FAIL,
+		GT_NORMAL_CABLE,
+		GT_IMPEDANCE_MISMATCH,
+		GT_OPEN_CABLE,
+		GT_SHORT_CABLE,
+	} GT_TEST_STATUS;
+
+
+/*
+ * typedef: enum GT_NORMAL_CABLE_LEN
+ *
+ * Description: Enumeration for normal cable length
+ *
+ * Enumerations:
+ *      GT_LESS_THAN_50M - cable length less than 50 meter.
+ *      GT_50M_80M       - cable length between 50 - 80 meter.
+ *      GT_80M_110M      - cable length between 80 - 110 meter.
+ *      GT_110M_140M     - cable length between 110 - 140 meter.
+ *      GT_MORE_THAN_140 - cable length more than 140 meter.
+ *      GT_UNKNOWN_LEN   - unknown length.
+ *
+ */
+	typedef enum
+	{
+		GT_LESS_THAN_50M,
+		GT_50M_80M,
+		GT_80M_110M,
+		GT_110M_140M,
+		GT_MORE_THAN_140,
+		GT_UNKNOWN_LEN,
+
+	} GT_NORMAL_CABLE_LEN;
+
+
+/*
+ * typedef: enum GT_CABLE_LEN
+ *
+ * Description: Enumeration cable length
+ *
+ * Enumerations:
+ *      normCableLen - cable lenght for normal cable.
+ *      errCableLen  - for cable failure the estimate fault distance in meters.
+ *
+ */
+	typedef union
+	{
+		GT_NORMAL_CABLE_LEN normCableLen;
+		GT_U8               errCableLen;
+
+	} GT_CABLE_LEN;
+
+/*
+ * typedef: struct GT_CABLE_STATUS
+ *
+ * Description: virtual cable diagnostic status per MDI pair.
+ *
+ * Fields:
+ *      cableStatus - VCT cable status.
+ *      cableLen    - VCT cable length.
+ *	phyType	    - type of phy (100M phy or Gigabit phy)
+ */
+	typedef struct
+	{
+		GT_TEST_STATUS  cableStatus[GT_MDI_PAIR_NUM];
+		GT_CABLE_LEN    cableLen[GT_MDI_PAIR_NUM];
+		GT_U16	    phyType;
+
+	} GT_CABLE_STATUS;
+
+
+/*
+ * typedef: enum GT_CABLE_TYPE
+ *
+ * Description: Enumeration of Cable Type
+ *
+ * Enumerations:
+ *		GT_STRAIGHT_CABLE	_ straight cable
+ *      GT_CROSSOVER_CABLE 	- crossover cable
+ */
+	typedef enum
+	{
+		GT_STRAIGHT_CABLE,
+		GT_CROSSOVER_CABLE
+
+	} GT_CABLE_TYPE;
+
+/*
+ * typedef: enum GT_POLARITY_STATUS
+ *
+ * Description: Enumeration of polarity status
+ *
+ * Enumerations:
+ *		GT_POSITIVE	- positive polarity
+ *      GT_NEGATIVE	- negative polarity
+ */
+	typedef enum
+	{
+		GT_POSITIVE,
+		GT_NEGATIVE
+
+	} GT_POLARITY_STATUS;
+
+
+/*
+ * typedef: struct GT_1000BT_EXTENDED_STATUS
+ *
+ * Description: Currently the 1000Base-T PCS can determine the cable polarity
+ * 		on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among 
+ *		the pares. These status enhance the capability of the virtual cable tester
+ *
+ * Fields:
+ *      isValid		- GT_TRUE if this structure have valid information, 
+ * 					  GT_FALSE otherwise.
+ *					  It is valid only if 1000BASE-T Link is up.
+ *      pairSwap    - GT_CROSSOVER_CABLE, if the cable is crossover,
+ *					  GT_STRAIGHT_CABLE, otherwise
+ *		pairPolarity- GT_POSITIVE, if polarity is positive,
+ *					  GT_NEGATIVE, otherwise
+ *		pairSkew	- pair skew in units of ns
+ */
+	typedef struct
+	{
+		GT_BOOL				isValid;
+		GT_CABLE_TYPE		pairSwap[GT_CHANNEL_PAIR_NUM];
+		GT_POLARITY_STATUS	pairPolarity[GT_MDI_PAIR_NUM];
+		GT_U32			    pairSkew[GT_MDI_PAIR_NUM];
+
+	} GT_1000BT_EXTENDED_STATUS;
+
+
+/*
+ * if isGigPhy in GT_CABLE_STATUS is not GT_TRUE, cableStatus and cableLen 
+ * will have only 2 pairs available.
+ * One is RX Pair and the other is TX Pair.
+ */
+#define MDI_RX_PAIR		0	/* cableStatus[0] or cableLen[0] */
+#define MDI_TX_PAIR		1	/* cableStatus[1] or cableLen[1] */
+
+/* definition for Phy Type */
+#define PHY_100M		0 /* 10/100M phy, E3082 or E3083 */
+#define PHY_1000M		1 /* Gigabit phy, the rest phys */
+#define PHY_10000M		2 /* 10 Gigabit phy, unused */
+#define PHY_1000M_B		3 /* Gigabit phy which needs work-around */
+#define PHY_1000M_MP	4 /* Gigabit phy with multiple page mode */
+
+
+/* definition for Trunking */
+#define IS_TRUNK_ID_VALID(_dev, _id)	(((_id) < 16) ? 1 : 0)
+
+
+/* definition for device scan mode */
+#define SMI_AUTO_SCAN_MODE		0	/* Scan 0 or 0x10 base address to find the QD */
+#define SMI_MANUAL_MODE			1	/* Use QD located at manually defined base addr */
+#define SMI_MULTI_ADDR_MODE		2	/* Use QD at base addr and use indirect access */
+	typedef struct
+	{
+		GT_U32	scanMode;	/* check definition for device scan mode */
+		GT_U32	baseAddr;	/* meaningful if scanMode is not SMI_AUTO_SCAN_MODE */
+	} GT_SCAN_MODE;
+
+
+/*
+ * Typedef: struct GT_SYS_CONFIG
+ *
+ * Description: System configuration Parameters struct.
+ *
+ * Fields:
+ *	devNum		- Switch Device Number 
+ *      cpuPortNum      - The physical port used to connect the device to CPU.
+ *                        This is the port to which packets destined to CPU are
+ *                        forwarded.
+ *      initPorts       - Whether to initialize the ports state.
+ *                          GT_FALSE    - leave in default state.
+ *                          GT_TRUE     - Initialize to Forwarding state.
+ *	BSPFunctions	- Group of BSP specific functions.
+ *				SMI Read/Write and Semaphore Related functions.
+ */
+	typedef struct
+	{
+		GT_U8         devNum;
+		GT_U8         cpuPortNum;
+		GT_BOOL       initPorts;
+		BSP_FUNCTIONS BSPFunctions;
+		GT_SCAN_MODE  mode;
+	}GT_SYS_CONFIG;
+
+
+
+/*
+ * Typedef: struct GT_QD_DEV
+ *
+ * Description: Includes Tapi layer switch configuration data.
+ *
+ * Fields:
+ *   deviceId        - The device type identifier.
+ *   revision        - The device revision number.
+ *   baseRegAddr     - Switch Base Register address.
+ *   numOfPorts      - Number of active ports.
+ *   cpuPortNum      - The physical port connected to the CPU.
+ *   maxPhyNum       - max configurable Phy address.
+ *	  stpMode         - current switch STP mode (0 none, 1 en, 2 dis)
+ *	  accessMode	   - shows how to find and access the device.
+ *   phyAddr         - SMI address used to access Switch registers(only for SMI_MULTI_ADDR_MODE).
+ *   devGroup	      - the device group
+ *   devName	      - name of the device
+ *	  atuRegsSem	- Semaphore for ATU access
+ *	  vtuRegsSem	- Semaphore for VTU access
+ *	  statsRegsSem	- Semaphore for RMON counter access
+ *	  fgtReadMii	   - platform specific SMI register Read function
+ *	  fgtWriteMii	   - platform specific SMI register Write function
+ *	  semCreate	   - function to create semapore
+ *	  semDelete	   - function to delete the semapore
+ *	  semTake		- function to get a semapore
+ *	  semGive		- function to return semaphore
+ *	  appData	      - application data that user may use
+ */
+	struct _GT_QD_DEV
+	{
+		GT_DEVICE   deviceId;
+		GT_U8       revision;
+		GT_U8		devNum;
+		GT_U8		devEnabled;
+		GT_U8       baseRegAddr;
+		GT_U8       numOfPorts;
+		GT_U8       cpuPortNum;
+		GT_U8       maxPhyNum;
+		GT_U8		stpMode;
+		GT_U8		accessMode;
+		GT_U8		phyAddr;
+		GT_U16		devGroup;
+		GT_U32		devName;
+		GT_SEM		multiAddrSem;
+		GT_SEM		atuRegsSem;
+		GT_SEM		vtuRegsSem;
+		GT_SEM		statsRegsSem;
+
+		FGT_READ_MII 	fgtReadMii;
+		FGT_WRITE_MII 	fgtWriteMii;
+
+		FGT_SEM_CREATE	semCreate; 	/* create semapore */
+		FGT_SEM_DELETE	semDelete; 	/* delete the semapore */
+		FGT_SEM_TAKE	semTake;	/* try to get a semapore */
+		FGT_SEM_GIVE	semGive;	/* return semaphore */
+		void*		appData;
+
+	};
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApi_h */
Index: linux-2.6.16/include/linux/marvell/msApi.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/msApi.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,22 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * msApi.h
+ *
+ * DESCRIPTION:
+ *       API definitions for QuarterDeck Device
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#ifndef __msApi_h
+#define __msApi_h
+
+#include <linux/marvell/msApiDefs.h>
+#include <linux/marvell/msApiInternal.h>
+#include <linux/marvell/msApiPrototype.h>
+
+#endif /* __msApi_h */
Index: linux-2.6.16/include/linux/marvell/msApiInternal.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/msApiInternal.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,670 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * msApiPrototype.h
+ *
+ * DESCRIPTION:
+ *       API Prototypes for QuarterDeck Device
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#ifndef __msApiInternal_h
+#define __msApiInternal_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define GT_LPORT_2_PORT(_lport)      (GT_U8)((_lport) & 0xff)
+#define GT_PORT_2_LPORT(_port)       (GT_32)((_port) & 0xff)
+
+/* The following macro converts a binary    */
+/* value (of 1 bit) to a boolean one.       */
+/* 0 --> GT_FALSE                           */
+/* 1 --> GT_TRUE                            */
+#define BIT_2_BOOL(binVal,boolVal)                                  \
+            (boolVal) = (((binVal) == 0) ? GT_FALSE : GT_TRUE)
+
+/* The following macro converts a boolean   */
+/* value to a binary one (of 1 bit).        */
+/* GT_FALSE --> 0                           */
+/* GT_TRUE --> 1                            */
+#define BOOL_2_BIT(boolVal,binVal)                                  \
+            (binVal) = (((boolVal) == GT_TRUE) ? 1 : 0)
+
+/* device name - devName */
+#define DEV_88E6051                      0x0001    /* quarterdeck 6051      */
+#define DEV_88E6052                      0x0002    /* quarterdeck 6052      */
+#define DEV_88E6021                      0x0004    /* fullsail              */
+#define DEV_88E6060                      0x0008    /* Gondola               */
+#define DEV_88E6063                      0x0010    /* clippership 6063      */
+#define DEV_FF_EG                        0x0020    /* FireFox-EG            */
+#define DEV_FF_HG                        0x0040    /* FireFox-HG            */
+#define DEV_FH_VPN                       0x0080    /* FireHawk-VPN          */
+#define DEV_88E6083                      0x0100    /* Octane 6083           */
+#define DEV_88E6181                      0x0200    /* Sapphire 88E6181      */
+#define DEV_88E6183                      0x0400    /* Sapphire 88E6153,88E6183 */
+#define DEV_88E6093	 	                    0x0800   /* 88E6093                  */
+#define DEV_88E6092	 	                    0x1000   /* 88E6092                  */
+#define DEV_88E6095	 	                    0x2000   /* 88E6095                  */
+#define DEV_88E6182                      0x4000   /* Jade 88E6152, 88E6182 */
+#define DEV_88E6185                      0x8000   /* Jade 88E6155, 88E6185 */
+
+#define DEV_88E6095_FAMILY	( DEV_88E6092 | DEV_88E6095 )
+#define DEV_88E6185_FAMILY	( DEV_88E6182 | DEV_88E6185 )
+
+/* DEV_8PORT_SWITCH is used to access the given device's Register Map */
+#define DEV_8PORT_SWITCH	( DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 	\
+							  DEV_88E6093 | 								\
+							  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_PORT_SECURITY	( DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 	\
+							  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_BROADCAST_INVALID	( DEV_88E6051 | DEV_88E6052 | DEV_FF_EG | DEV_FF_HG)
+
+#define DEV_ATU_256_2048 		( DEV_88E6021 | DEV_88E6060 )
+#define DEV_ATU_562_2048 		\
+						( DEV_88E6052 | DEV_88E6063 | DEV_FF_HG | 	\
+						  DEV_FH_VPN | DEV_88E6083 )
+
+#define DEV_DBNUM_FULL 	\
+						( DEV_88E6021 | DEV_88E6060 | DEV_88E6063 | 	\
+						  DEV_FH_VPN |  DEV_88E6083 |					\
+						  DEV_88E6183 | DEV_88E6093 )
+
+#define DEV_DBNUM_256 	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_STATIC_ADDR	\
+						( DEV_88E6021 | DEV_FF_EG | DEV_FF_HG |			\
+						  DEV_88E6052 | DEV_88E6063 | DEV_FH_VPN |		\
+						  DEV_88E6083 |	DEV_88E6183 | DEV_88E6093 | 	\
+						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY)
+
+#define DEV_TRAILER		\
+						( DEV_88E6021 | DEV_FF_HG | DEV_88E6052 |  		\
+						  DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+
+#define DEV_TRAILER_P5		( DEV_FF_EG )
+#define DEV_TRAILER_P4P5	( DEV_88E6060 )
+
+#define DEV_HEADER		\
+						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |	\
+						  DEV_88E6083 |	DEV_88E6183 | DEV_88E6093 | \
+						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_HEADER_P5		( DEV_FF_EG )
+#define DEV_HEADER_P4P5		( DEV_88E6060 )
+
+/* DEV_QoS : Devices with multiple Queues for QoS Priority Support */
+#define DEV_QoS			\
+						( DEV_88E6021 | DEV_FF_HG |	DEV_88E6051 | 		\
+						  DEV_88E6052 | DEV_88E6063 | DEV_FH_VPN |		\
+						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 	\
+						  DEV_88E6093 | DEV_88E6095_FAMILY |			\
+						  DEV_88E6185_FAMILY )
+
+#define DEV_TAGGING			DEV_QoS
+
+#define DEV_EGRESS_DOUBLE_TAGGING	\
+						( DEV_QoS & ~(DEV_88E6051 | DEV_88E6092 | DEV_88E6182) )
+
+#define DEV_INGRESS_DOUBLE_TAGGING	\
+						( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
+						  DEV_88E6095 | DEV_88E6185 )
+
+#define DEV_PRIORITY_REMAPPING		\
+						( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
+						  DEV_88E6095 | DEV_88E6185 )
+
+
+#define DEV_802_1Q		( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | 			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
+						  DEV_88E6095 | DEV_88E6092 | DEV_88E6185_FAMILY )
+
+#define DEV_802_1S		( DEV_88E6095 | DEV_88E6185 )
+
+#define DEV_802_1W		( DEV_88E6183 | DEV_88E6093 )
+
+#define DEV_RMON		( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | 			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
+						  DEV_88E6092 | DEV_88E6095 | DEV_88E6185_FAMILY ) 
+
+#define DEV_RMON_TYPE_1	( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 ) 
+#define DEV_RMON_TYPE_2 ( DEV_88E6183 )
+#define DEV_RMON_TYPE_3 ( DEV_88E6093 | DEV_88E6095 | DEV_88E6092 | 	\
+						  DEV_88E6185_FAMILY )
+
+#define DEV_IGMP_SNOOPING	\
+						( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
+						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_PORT_MONITORING	\
+						( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
+						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_ENABLE_MONITORING	\
+						( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 )
+
+#define DEV_MC_RATE_PERCENT	\
+						( DEV_88E6021 | DEV_88E6051 | DEV_88E6052 )
+
+#define DEV_MC_RATE_KBPS	\
+						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 )
+
+#define DEV_INGRESS_RATE_KBPS	\
+						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 		\
+						  DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY)
+
+#define DEV_EGRESS_RATE_KBPS	\
+						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 		\
+						  DEV_88E6093 | DEV_88E6095 | DEV_88E6185 )
+
+#define DEV_MII_DUPLEX_CONFIG	\
+						( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 )
+
+#define DEV_QD_PLUS 	\
+					( DEV_88E6021 | DEV_FF_EG | DEV_FF_HG |					\
+					  DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |				\
+					  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 			\
+					  DEV_88E6093 | 										\
+					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_FASTETH_SWITCH	\
+					( DEV_88E6051 | DEV_88E6052 | DEV_88E6021 | 		\
+					  DEV_FF_EG | DEV_FF_HG | DEV_88E6060 | 			\
+					  DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+
+#define DEV_EXTERNAL_PHY	\
+					( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |			\
+					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_EXTERNAL_PHY_ONLY	( DEV_88E6181 | DEV_88E6183 | DEV_88E6185_FAMILY )
+
+#define DEV_FC_WITH_VALUE	( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_CORE_TAG		( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_PCS_LINK		( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_MGMII_STATUS	( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_88E6183_FAMILY		( DEV_88E6183 | DEV_88E6185_FAMILY )
+#define DEV_88E6093_FAMILY		( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_UNMANAGED_SWITCH	( DEV_88E6181 )
+
+#define DEV_GIGABIT_SWITCH		\
+					( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
+					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_GIGABIT_MANAGED_SWITCH	\
+					( DEV_88E6183 | DEV_88E6093 | \
+					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_CROSS_CHIP_VLAN		\
+					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_TRUNK	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_FRAME_SIZE_1632		\
+					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_FLOW_CTRL_DELAY		\
+					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_ENHANCED_CPU_PORT	\
+					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+/* supports Reserved Multicast, etc */
+#define DEV_ENHANCED_MULTICAST	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_ARP_SUPPORT		( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_MARVELL_TAG_FLOW_CTRL	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_USE_DOUBLE_TAG_DATA		( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_MARVELL_TAG_LOOP_BLOCK	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_PRIORITY_OVERRIDE	\
+					( DEV_88E6183 | DEV_88E6093 | DEV_88E6095 | 	\
+					  DEV_88E6185 )
+
+#define DEV_STACKING	\
+					( DEV_88E6095 | DEV_88E6185 )
+
+#define DEV_8_TRUNKING	( DEV_88E6092 | DEV_88E6182 )
+
+
+#define IS_IN_DEV_GROUP(dev,_group) (dev->devName & (_group))
+
+/* need to check port number(_hwPort) later */
+#define IS_VALID_API_CALL(dev,_hwPort, _devName)	    	\
+	(!(dev->devName & (_devName)) ? GT_NOT_SUPPORTED : GT_OK)
+
+#define DOES_DEVPORT_SUPPORT_PCS(dev, _hwPort)			\
+	(!(dev->devName & DEV_GIGABIT_SWITCH) || \
+	(!(dev->devName & DEV_EXTERNAL_PHY_ONLY) && (((_hwPort) < 8) || ((_hwPort) > 10)))	\
+	? 0 : 1)
+
+#define IS_CONFIGURABLE_PHY(dev,_hwPort)	(dev->maxPhyNum > (_hwPort))
+
+	typedef struct _EXTRA_OP_DATA
+	{
+		GT_U32 moveFrom;
+		GT_U32 moveTo;
+		GT_U32 intCause;
+		GT_U32 reserved;
+	} GT_EXTRA_OP_DATA;
+
+/*******************************************************************************
+ * gvtuGetViolation
+ *
+ * DESCRIPTION:
+ *       Get VTU Violation data
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       vtuIntStatus - interrupt cause, source portID, and vid.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORT  - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This is an internal function. No user should call this function.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuGetViolation
+	(
+		IN GT_QD_DEV*       dev,
+		OUT GT_VTU_INT_STATUS *vtuIntStatus
+		);
+
+/*******************************************************************************
+ * gvtuGetViolation2
+ *
+ * DESCRIPTION:
+ *       Get VTU Violation data (for Gigabit Device)
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       vtuIntStatus - interrupt cause, source portID, and vid.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORT  - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This is an internal function. No user should call this function.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuGetViolation2
+	(
+		IN GT_QD_DEV*       dev,
+		OUT GT_VTU_INT_STATUS *vtuIntStatus
+		);
+
+/*******************************************************************************
+ * gatuGetViolation
+ *
+ * DESCRIPTION:
+ *       Get ATU Violation data
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       atuIntStatus - interrupt cause, source portID, and vid.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORT  - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This is an internal function. No user should call this function.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gatuGetViolation
+	(
+		IN  GT_QD_DEV         *dev,
+		OUT GT_ATU_INT_STATUS *atuIntStatus
+		);
+
+/*******************************************************************************
+ * gsysSetRetransmitMode
+ *
+ * DESCRIPTION:
+ *       This routine set the Retransmit Mode.
+ *
+ * INPUTS:
+ *       en - GT_TRUE Retransimt Mode is enabled, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetRetransmitMode
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_BOOL en
+		);
+
+/*******************************************************************************
+ * gsysGetRetransmitMode
+ *
+ * DESCRIPTION:
+ *       This routine get the Retransmit Mode.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE Retransmit Mode is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetRetransmitMode
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_BOOL *en
+		);
+
+/*******************************************************************************
+ * gsysSetLimitBackoff
+ *
+ * DESCRIPTION:
+ *       This routine set the Limit Backoff bit.
+ *
+ * INPUTS:
+ *       en - GT_TRUE:  uses QoS half duplex backoff operation  
+ *            GT_FALSE: uses normal half duplex backoff operation
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetLimitBackoff
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_BOOL en
+		);
+
+/*******************************************************************************
+ * gsysGetLimitBackoff
+ *
+ * DESCRIPTION:
+ *       This routine set the Limit Backoff bit.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE:  uses QoS half duplex backoff operation  
+ *            GT_FALSE: uses normal half duplex backoff operation
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetLimitBackoff
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_BOOL *en
+		);
+
+/*******************************************************************************
+ * gsysSetRsvRegPri
+ *
+ * DESCRIPTION:
+ *       This routine set the Reserved Queue's Requesting Priority 
+ *
+ * INPUTS:
+ *       en - GT_TRUE: use the last received frome's priority
+ *            GT_FALSE:use the last switched frame's priority 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetRsvReqPri
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_BOOL en
+		);
+
+/*******************************************************************************
+ * gsysGetRsvReqPri
+ *
+ * DESCRIPTION:
+ *       This routine get the Reserved Queue's Requesting Priority 
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE: use the last received frome's priority
+ *            GT_FALSE:use the last switched frame's priority 
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetRsvReqPri
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_BOOL *en
+		);
+
+/*******************************************************************************
+ * gsysGetPtrCollision
+ *
+ * DESCRIPTION:
+ *       This routine get the QC Pointer Collision.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ * 		This feature is for both clippership and fullsail
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetPtrCollision
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_BOOL *mode
+		);
+
+/*******************************************************************************
+ * gsysGetDpvCorrupt
+ *
+ * DESCRIPTION:
+ *       This routine get the DpvCorrupt bit. This bit is set to a one when the 
+ *       QC detects a destination vector error
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: destination vector corrupt, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ * 	This feature is on clippership, but not on fullsail
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetDpvCorrupt
+	(
+		IN GT_BOOL *mode
+		);
+
+/*******************************************************************************
+ * gsysGetMissingPointers
+ *
+ * DESCRIPTION:
+ *       This routine get the Missing Pointer bit. This bit is set to a one when  
+ *       the Register File detects less than 64 pointers in the Link List. 
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: Missing Pointers error, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ * 	This feature is on clippership, but not on fullsail
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetMissingPointers
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_BOOL *mode
+		);
+
+/*******************************************************************************
+ * gtDbgPrint
+ *
+ * DESCRIPTION:
+ *       .
+ *
+ * INPUTS:
+ *       None
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	void gtDbgPrint(char* format, ...);
+
+
+/*******************************************************************************
+ * gtSemRegister
+ *
+ * DESCRIPTION:
+ *       Assign QuarterDeck Semaphore functions to the given semaphore set.
+ *		QuarterDeck maintains its own memory for the structure.
+ *
+ * INPUTS:
+ *		semFunctions - point to the GT_SEM_ROUTINES
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       None
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	GT_STATUS gtSemRegister
+	(
+		IN GT_QD_DEV*       dev,
+		IN  GT_SEM_ROUTINES* semRoutines
+		);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApiInternal_h */
Index: linux-2.6.16/include/linux/marvell/msApiPrototype.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/msApiPrototype.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,9199 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * msApiPrototype.h
+ *
+ * DESCRIPTION:
+ *       API Prototypes for QuarterDeck Device
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#ifndef __msApiPrototype_h
+#define __msApiPrototype_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+ * gfdbSetAtuSize
+ *
+ * DESCRIPTION:
+ *       Sets the Mac address table size.
+ *
+ * INPUTS:
+ *       size    - Mac address table size.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbSetAtuSize
+	(
+		IN GT_QD_DEV *dev,
+		IN ATU_SIZE size
+		);
+
+
+/*******************************************************************************
+ * gfdbGetAgingTimeRange
+ *
+ * DESCRIPTION:
+ *       Gets the maximal and minimum age times that the hardware can support.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       maxTimeout - max aging time in secounds.
+ *       minTimeout - min aging time in secounds.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbGetAgingTimeRange
+	(
+		IN GT_QD_DEV *dev,
+		OUT GT_U32 *maxTimeout,
+		OUT GT_U32 *minTimeout
+		);
+
+
+/*******************************************************************************
+ * gfdbSetAgingTimeout
+ *
+ * DESCRIPTION:
+ *       Sets the timeout period in seconds for aging out dynamically learned
+ *       forwarding information. The standard recommends 300 sec.
+ *
+ * INPUTS:
+ *       timeout - aging time in seconds.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbSetAgingTimeout
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_U32 timeout
+		);
+
+
+
+/*******************************************************************************
+ * gfdbGetAtuDynamicCount
+ *
+ * DESCRIPTION:
+ *       Gets the current number of dynamic unicast entries in this
+ *       Filtering Database.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       numDynEntries - number of dynamic entries.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *       GT_NO_SUCH - vlan does not exist.
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbGetAtuDynamicCount
+	(
+		IN GT_QD_DEV *dev,
+		OUT GT_U32 *numDynEntries
+		);
+
+
+
+/*******************************************************************************
+ * gfdbGetAtuEntryFirst
+ *
+ * DESCRIPTION:
+ *       Gets first lexicographic MAC address entry from the ATU.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       atuEntry - match Address translate unit entry.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *       GT_NO_SUCH - table is empty.
+ *
+ * COMMENTS:
+ *       Search starts from Mac[00:00:00:00:00:00]
+ *
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbGetAtuEntryFirst
+	(
+		IN GT_QD_DEV *dev,
+		OUT GT_ATU_ENTRY    *atuEntry
+		);
+
+
+
+/*******************************************************************************
+ * gfdbGetAtuEntryNext
+ *
+ * DESCRIPTION:
+ *       Gets next lexicographic MAC address from the specified Mac Addr.
+ *
+ * INPUTS:
+ *       atuEntry - the Mac Address to start the search.
+ *
+ * OUTPUTS:
+ *       atuEntry - match Address translate unit entry.
+ *
+ * RETURNS:
+ *       GT_OK      - on success.
+ *       GT_FAIL    - on error or entry does not exist.
+ *       GT_NO_SUCH - no more entries.
+ *
+ * COMMENTS:
+ *       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
+ *       user.
+ *
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbGetAtuEntryNext
+	(
+		IN GT_QD_DEV *dev,
+		INOUT GT_ATU_ENTRY  *atuEntry
+		);
+
+
+
+/*******************************************************************************
+ * gfdbFindAtuMacEntry
+ *
+ * DESCRIPTION:
+ *       Find FDB entry for specific MAC address from the ATU.
+ *
+ * INPUTS:
+ *       atuEntry - the Mac address to search.
+ *
+ * OUTPUTS:
+ *       found    - GT_TRUE, if the appropriate entry exists.
+ *       atuEntry - the entry parameters.
+ *
+ * RETURNS:
+ *       GT_OK      - on success.
+ *       GT_FAIL    - on error or entry does not exist.
+ *       GT_NO_SUCH - no more entries.
+ *
+ * COMMENTS:
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbFindAtuMacEntry
+	(
+		IN GT_QD_DEV *dev,
+		INOUT GT_ATU_ENTRY  *atuEntry,
+		OUT GT_BOOL         *found
+		);
+
+
+
+/*******************************************************************************
+ * gfdbFlush
+ *
+ * DESCRIPTION:
+ *       This routine flush all or unblocked addresses from the MAC Address
+ *       Table.
+ *
+ * INPUTS:
+ *       flushCmd - the flush operation type.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NO_RESOURCE  - failed to allocate a t2c struct
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbFlush
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_FLUSH_CMD flushCmd
+		);
+
+/*******************************************************************************
+ * gfdbFlushInDB
+ *
+ * DESCRIPTION:
+ *       This routine flush all or unblocked addresses from the particular
+ *       ATU Database (DBNum). If multiple address databases are being used, this
+ *		API can be used to flush entries in a particular DBNum database.
+ *
+ * INPUTS:
+ *       flushCmd - the flush operation type.
+ *		DBNum	 - ATU MAC Address Database Number. 
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORTED- if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbFlushInDB
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_FLUSH_CMD flushCmd,
+		IN GT_U8 DBNum
+		);
+
+/*******************************************************************************
+ * gfdbAddMacEntry
+ *
+ * DESCRIPTION:
+ *       Creates the new entry in MAC address table.
+ *
+ * INPUTS:
+ *       macEntry    - mac address entry to insert to the ATU.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK             - on success
+ *       GT_FAIL           - on error
+ *       GT_NO_RESOURCE    - failed to allocate a t2c struct
+ *       GT_OUT_OF_CPU_MEM - oaMalloc failed
+ *
+ * COMMENTS:
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbAddMacEntry
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_ATU_ENTRY *macEntry
+		);
+
+
+
+/*******************************************************************************
+ * gfdbDelMacEntry
+ *
+ * DESCRIPTION:
+ *       Deletes MAC address entry.
+ *
+ * INPUTS:
+ *       macAddress - mac address.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NO_RESOURCE  - failed to allocate a t2c struct
+ *       GT_NO_SUCH      - if specified address entry does not exist
+ *
+ * COMMENTS:
+ *       For SVL mode vlan Id is ignored.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbDelMacEntry
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_ETHERADDR  *macAddress
+		);
+
+/*******************************************************************************
+ * gfdbDelAtuEntry
+ *
+ * DESCRIPTION:
+ *       Deletes ATU entry.
+ *
+ * INPUTS:
+ *       atuEntry - the ATU entry to be deleted.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NO_RESOURCE  - failed to allocate a t2c struct
+ *       GT_NO_SUCH      - if specified address entry does not exist
+ *
+ * COMMENTS:
+ *		DBNum in atuEntry - 
+ *			ATU MAC Address Database number. If multiple address 
+ *			databases are not being used, DBNum should be zero.
+ *			If multiple address databases are being used, this value
+ *			should be set to the desired address database number.
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbDelAtuEntry
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_ATU_ENTRY  *atuEntry
+		);
+
+/*******************************************************************************
+ * gfdbLearnEnable
+ *
+ * DESCRIPTION:
+ *       Enable/disable automatic learning of new source MAC addresses on port
+ *       ingress.
+ *
+ * INPUTS:
+ *       en - GT_TRUE for enable  or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbLearnEnable
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_BOOL  en
+		);
+
+
+
+/*******************************************************************************
+ * gstpSetMode
+ *
+ * DESCRIPTION:
+ *       This routine Enable the Spanning tree.
+ *
+ * INPUTS:
+ *       en - GT_TRUE for enable, GT_FALSE for disable.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       when enabled, this function sets all port to blocking state, and inserts
+ *       the BPDU MAC into the ATU to be captured to CPU, on disable all port are
+ *       being modified to be in forwarding state.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstpSetMode
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_BOOL  en
+		);
+
+
+
+/*******************************************************************************
+ * gstpSetPortState
+ *
+ * DESCRIPTION:
+ *       This routine set the port state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *       state - the port state to set.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstpSetPortState
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT           port,
+		IN GT_PORT_STP_STATE  state
+		);
+
+
+
+/*******************************************************************************
+ * gstpGetPortState
+ *
+ * DESCRIPTION:
+ *       This routine returns the port state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - the current port state.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstpGetPortState
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT           port,
+		OUT GT_PORT_STP_STATE  *state
+		);
+
+/*******************************************************************************
+ * gprtSetEgressMode
+ *
+ * DESCRIPTION:
+ *       This routine set the egress mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the egress mode.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetEgressMode
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT        port,
+		IN GT_EGRESS_MODE  mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetEgressMode
+ *
+ * DESCRIPTION:
+ *       This routine get the egress mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - the egress mode.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetEgressMode
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT        port,
+		OUT GT_EGRESS_MODE  *mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtSetVlanTunnel
+ *
+ * DESCRIPTION:
+ *       This routine sets the vlan tunnel mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the vlan tunnel mode.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetVlanTunnel
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetVlanTunnel
+ *
+ * DESCRIPTION:
+ *       This routine get the vlan tunnel mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - the vlan tunnel mode..
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetVlanTunnel
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+
+/*******************************************************************************
+ * gprtSetIGMPSnoop
+ *
+ * DESCRIPTION:
+ * 		This routine set the IGMP Snoop. When set to one and this port receives
+ *		IGMP frame, the frame is switched to the CPU port, overriding all other 
+ *		switching decisions, with exception for CPU's Trailer.
+ *		CPU port is determined by the Ingress Mode bits. A port is considered 
+ *		the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or 
+ *		GT_CPUPORT_INGRESS.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetIGMPSnoop
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+/*******************************************************************************
+ * gprtGetIGMPSnoop
+ *
+ * DESCRIPTION:
+ *		This routine get the IGMP Snoop mode.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: IGMP Snoop enabled
+ *  			GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetIGMPSnoop
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+/* the following two APIs are added to support clippership */
+
+/*******************************************************************************
+ * gprtSetHeaderMode
+ *
+ * DESCRIPTION:
+ *		This routine set ingress and egress header mode of a switch port. 
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for header mode  or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetHeaderMode
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+/*******************************************************************************
+ * gprtGetHeaderMode
+ *
+ * DESCRIPTION:
+ *		This routine gets ingress and egress header mode of a switch port. 
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: header mode enabled
+ *  			GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetHeaderMode
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+
+/*******************************************************************************
+ * gprtSetProtectedMode
+ *
+ * DESCRIPTION:
+ *		This routine set protected mode of a switch port. 
+ *		When this mode is set to GT_TRUE, frames are allowed to egress port
+ *		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+ *		by the port's VLANTable if 802.1Q is enabled on the port. Both must
+ *		allow the frame to Egress.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for protected mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetProtectedMode
+	(
+		IN  GT_QD_DEV   *dev,
+		IN GT_LPORT     port,
+		IN GT_BOOL      mode
+		);
+
+/*******************************************************************************
+ * gprtGetProtectedMode
+ *
+ * DESCRIPTION:
+ *		This routine gets protected mode of a switch port. 
+ *		When this mode is set to GT_TRUE, frames are allowed to egress port
+ *		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+ *		by the port's VLANTable if 802.1Q is enabled on the port. Both must
+ *		allow the frame to Egress.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: header mode enabled
+ *  			GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetProtectedMode
+	(
+		IN  GT_QD_DEV		*dev,
+		IN  GT_LPORT		port,
+		OUT GT_BOOL		*mode
+		);
+
+/*******************************************************************************
+ * gprtSetForwardUnknown
+ *
+ * DESCRIPTION:
+ *		This routine set Forward Unknown mode of a switch port. 
+ *		When this mode is set to GT_TRUE, normal switch operation occurs.
+ *		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+ *		will not egress out this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for protected mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetForwardUnknown
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetForwardUnknown
+ *
+ * DESCRIPTION:
+ *		This routine gets Forward Unknown mode of a switch port. 
+ *		When this mode is set to GT_TRUE, normal switch operation occurs.
+ *		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+ *		will not egress out this port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: header mode enabled
+ *				GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetForwardUnknown
+	(
+		IN  GT_QD_DEV		*dev,
+		IN  GT_LPORT		port,
+		OUT GT_BOOL		*mode
+		);
+
+/*******************************************************************************
+ * gprtGetSwitchReg
+ *
+ * DESCRIPTION:
+ *       This routine reads Switch Port Registers.
+ *
+ * INPUTS:
+ *       port    - logical port number
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetSwitchReg
+	(
+		IN  GT_QD_DEV    *dev,
+		IN  GT_LPORT     port,
+		IN  GT_U32	     regAddr,
+		OUT GT_U16	     *data
+		);
+
+/*******************************************************************************
+ * gprtSetSwitchReg
+ *
+ * DESCRIPTION:
+ *       This routine writes Switch Port Registers.
+ *
+ * INPUTS:
+ *       port    - logical port number
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetSwitchReg
+	(
+		IN  GT_QD_DEV    *dev,
+		IN  GT_LPORT     port,
+		IN  GT_U32	     regAddr,
+		IN  GT_U16	     data
+		);
+
+
+/*******************************************************************************
+ * gprtGetGlobalReg
+ *
+ * DESCRIPTION:
+ *       This routine reads Switch Global Registers.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetGlobalReg
+	(
+		IN  GT_QD_DEV    *dev,
+		IN  GT_U32	     regAddr,
+		OUT GT_U16	     *data
+		);
+
+/*******************************************************************************
+ * gprtSetGlobalReg
+ *
+ * DESCRIPTION:
+ *       This routine writes Switch Global Registers.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetGlobalReg
+	(
+		IN  GT_QD_DEV    *dev,
+		IN  GT_U32	     regAddr,
+		IN  GT_U16	     data
+		);
+
+
+
+/*******************************************************************************
+ * gvlnSetPortVlanPorts
+ *
+ * DESCRIPTION:
+ *       This routine sets the port VLAN group port membership list.
+ *
+ * INPUTS:
+ *       port        - logical port number to set.
+ *       memPorts    - array of logical ports.
+ *       memPortsLen - number of members in memPorts array
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnSetPortVlanPorts
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_LPORT memPorts[],
+		IN GT_U8    memPortsLen
+		);
+
+
+
+/*******************************************************************************
+ * gvlnGetPortVlanPorts
+ *
+ * DESCRIPTION:
+ *       This routine gets the port VLAN group port membership list.
+ *
+ * INPUTS:
+ *       port        - logical port number to set.
+ *
+ * OUTPUTS:
+ *       memPorts    - array of logical ports.
+ *       memPortsLen - number of members in memPorts array
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnGetPortVlanPorts
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_LPORT memPorts[],
+		OUT GT_U8    *memPortsLen
+		);
+
+
+
+
+/*******************************************************************************
+ * gvlnSetPortUserPriLsb
+ *
+ * DESCRIPTION:
+ *       This routine Set the user priority (VPT) LSB bit, to be added to the
+ *       user priority on the egress.
+ *
+ * INPUTS:
+ *       port       - logical port number to set.
+ *       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnSetPortUserPriLsb
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  userPriLsb
+		);
+
+
+
+/*******************************************************************************
+ * gvlnGetPortUserPriLsb
+ *
+ * DESCRIPTION:
+ *       This routine gets the user priority (VPT) LSB bit.
+ *
+ * INPUTS:
+ *       port       - logical port number to set.
+ *
+ * OUTPUTS:
+ *       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnGetPortUserPriLsb
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT    port,
+		OUT GT_BOOL     *userPriLsb
+		);
+
+
+/*******************************************************************************
+ * gvlnSetPortVid
+ *
+ * DESCRIPTION:
+ *       This routine Set the port default vlan id.
+ *
+ * INPUTS:
+ *       port - logical port number to set.
+ *       vid  - the port vlan id.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnSetPortVid
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_U16   vid
+		);
+
+
+/*******************************************************************************
+ * gvlnGetPortVid
+ *
+ * DESCRIPTION:
+ *       This routine Get the port default vlan id.
+ *
+ * INPUTS:
+ *       port - logical port number to set.
+ *
+ * OUTPUTS:
+ *       vid  - the port vlan id.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnGetPortVid
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_U16   *vid
+		);
+
+/*******************************************************************************
+ * gvlnSetPortVlanDBNum
+ *
+ * DESCRIPTION:
+ *       This routine sets the port VLAN database number (DBNum).
+ *
+ * INPUTS:
+ *       port	- logical port number to set.
+ *       DBNum 	- database number for this port 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:IN GT_INGRESS_MODE mode
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnSetPortVlanDBNum
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_U8    DBNum
+		);
+
+
+/*******************************************************************************
+ * gvlnGetPortVlanDBNum
+ *
+ * DESCRIPTION:IN GT_INGRESS_MODE mode
+ *       This routine gets the port VLAN database number (DBNum).
+ *
+ * INPUTS:
+ *       port 	- logical port number to get.
+ *
+ * OUTPUTS:
+ *       DBNum 	- database number for this port 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnGetPortVlanDBNum
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_U8    *DBNum
+		);
+
+/********************************************************************
+ * gvlnSetPortVlanDot1qMode
+ *
+ * DESCRIPTION:
+ *       This routine sets the port 802.1q mode (11:10) 
+ *
+ * INPUTS:
+ *       port	- logical port number to set.
+ *       mode 	- 802.1q mode for this port 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:IN GT_INGRESS_MODE mode
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnSetPortVlanDot1qMode
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT 	port,
+		IN GT_DOT1Q_MODE	mode
+		);
+
+/*******************************************************************************
+ * gvlnGetPortVlanDot1qMode
+ *
+ * DESCRIPTION:
+ *       This routine gets the port 802.1q mode (bit 11:10).
+ *
+ * INPUTS:
+ *       port 	- logical port number to get.
+ *
+ * OUTPUTS:
+ *       mode 	- 802.1q mode for this port 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnGetPortVlanDot1qMode
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_DOT1Q_MODE    *mode
+		);
+
+
+/********************************************************************
+ * gvlnSetPortVlanForceDefaultVID
+ *
+ * DESCRIPTION:
+ *       This routine sets the port 802.1q mode (11:10) 
+ *
+ * INPUTS:
+ *       port	- logical port number to set.
+ *       mode    - GT_TRUE, force to use default VID
+ *                 GT_FAULSE, otherwise 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnSetPortVlanForceDefaultVID
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL  	mode
+		);
+
+/*******************************************************************************
+ * gvlnGetPortVlanForceDefaultVID
+ *
+ * DESCRIPTION:
+ *       This routine gets the port mode for ForceDefaultVID (bit 12).
+ *
+ * INPUTS:
+ *       port 	- logical port number to get.
+ *
+ * OUTPUTS:
+ *       mode 	- ForceDefaultVID mode for this port 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvlnGetPortVlanForceDefaultVID
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT 	 port,
+		OUT GT_BOOL    	*mode
+		);
+
+/*******************************************************************************
+ * eventSetActive
+ *
+ * DESCRIPTION:
+ *       This routine enables/disables the receive of an hardware driven event.
+ *
+ * INPUTS:
+ *       eventType - the event type. any combination of the folowing: 
+ *       	GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+ *       	GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS eventSetActive
+	(
+		IN GT_QD_DEV 	*dev,
+		IN GT_U32 		eventType
+		);
+
+/*******************************************************************************
+ * eventGetIntStatus
+ *
+ * DESCRIPTION:
+ *       This routine reads an hardware driven event status.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       intCause -  It provides the source of interrupt of the following:
+ *       GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+ *       GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT.
+ *		For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_FULL and 
+ *		GT_PHY_INTERRUPT is not supported.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS eventGetIntStatus
+	(
+		IN  GT_QD_DEV 	*dev,
+		OUT GT_U16		*intCause
+		);
+
+/*******************************************************************************
+ * gvtuGetIntStatus
+ *
+ * DESCRIPTION:
+ * 		Check to see if a specific type of VTU interrupt occured
+ *
+ * INPUTS:
+ *       intType - the type of interrupt which causes an interrupt.
+ *			any combination of 
+ *			GT_MEMEBER_VIOLATION,
+ *			GT_MISS_VIOLATION,
+ *			GT_FULL_VIOLATION
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK   - on success
+ * 		GT_FAIL - on error
+ *
+ * COMMENTS:
+ * 		FULL_VIOLATION is only for Fast Ethernet Switch (not for Gigabit Switch).
+ *
+ *******************************************************************************/
+
+	GT_STATUS gvtuGetIntStatus
+	(
+		IN  GT_QD_DEV 			*dev,
+		OUT GT_VTU_INT_STATUS 	*vtuIntStatus
+		);
+
+/*******************************************************************************
+ * gvtuGetEntryCount
+ *
+ * DESCRIPTION:
+ *       Gets the current number of entries in the VTU table
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       numEntries - number of VTU entries.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *       GT_NO_SUCH - vlan does not exist.
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuGetEntryCount
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_U32 		*numEntries
+		);
+
+/*******************************************************************************
+ * gvtuGetEntryFirst
+ *
+ * DESCRIPTION:
+ *       Gets first lexicographic entry from the VTU.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       vtuEntry - match VTU entry.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *       GT_NO_SUCH - table is empty.
+ *
+ * COMMENTS:
+ *       Search starts from vid of all one's
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuGetEntryFirst
+	(
+		IN  GT_QD_DEV 		*dev,
+		OUT GT_VTU_ENTRY	*vtuEntry
+		);
+
+/*******************************************************************************
+ * gvtuGetEntryNext
+ *
+ * DESCRIPTION:
+ *       Gets next lexicographic VTU entry from the specified VID.
+ *
+ * INPUTS:
+ *       vtuEntry - the VID to start the search.
+ *
+ * OUTPUTS:
+ *       vtuEntry - match VTU  entry.
+ *
+ * RETURNS:
+ *       GT_OK      - on success.
+ *       GT_FAIL    - on error or entry does not exist.
+ *       GT_NO_SUCH - no more entries.
+ *
+ * COMMENTS:
+ *       Search starts from the VID specified by the user.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuGetEntryNext
+	(
+		IN  GT_QD_DEV 		*dev,
+		INOUT GT_VTU_ENTRY  *vtuEntry
+		);
+
+/*******************************************************************************
+ * gvtuFindVidEntry
+ *
+ * DESCRIPTION:
+ *       Find VTU entry for a specific VID, it will return the entry, if found, 
+ *       along with its associated data 
+ *
+ * INPUTS:
+ *       vtuEntry - contains the VID to search for.
+ *
+ * OUTPUTS:
+ *       found    - GT_TRUE, if the appropriate entry exists.
+ *       vtuEntry - the entry parameters.
+ *
+ * RETURNS:
+ *       GT_OK      - on success.
+ *       GT_FAIL    - on error or entry does not exist.
+ *       GT_NO_SUCH - no more entries.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuFindVidEntry
+	(
+		IN GT_QD_DEV 		*dev,
+		INOUT GT_VTU_ENTRY  *vtuEntry,
+		OUT GT_BOOL         *found
+		);
+
+/*******************************************************************************
+ * gvtuFlush
+ *
+ * DESCRIPTION:
+ *       This routine removes all entries from VTU Table.
+ *
+ * INPUTS:
+ *       None
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuFlush
+	(
+		IN GT_QD_DEV *dev
+		);
+
+/*******************************************************************************
+ * gvtuAddEntry
+ *
+ * DESCRIPTION:
+ *       Creates the new entry in VTU table based on user input.
+ *
+ * INPUTS:
+ *       vtuEntry    - vtu entry to insert to the VTU.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK             - on success
+ *       GT_FAIL           - on error
+ *       GT_FULL			  - vtu table is full
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuAddEntry
+	(
+		IN GT_QD_DEV 	*dev,
+		IN GT_VTU_ENTRY *vtuEntry
+		);
+
+/*******************************************************************************
+ * gvtuDelEntry
+ *
+ * DESCRIPTION:
+ *       Deletes VTU entry specified by user.
+ *
+ * INPUTS:
+ *       vtuEntry - the VTU entry to be deleted 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NO_SUCH      - if specified address entry does not exist
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gvtuDelEntry
+	(
+		IN GT_QD_DEV 	*dev,
+		IN GT_VTU_ENTRY *vtuEntry
+		);
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+ * gprtPhyReset
+ *
+ * DESCRIPTION:
+ *		This routine preforms PHY reset.
+ *		After reset, phy will be in Autonegotiation mode.
+ *
+ * INPUTS:
+ * 		port - The logical port number
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ * COMMENTS:
+ * 		data sheet register 0.15 - Reset
+ * 		data sheet register 0.13 - Speed
+ * 		data sheet register 0.12 - Autonegotiation
+ * 		data sheet register 0.8  - Duplex Mode
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtPhyReset
+	(
+		IN GT_QD_DEV 	*dev,
+		IN GT_LPORT 	port
+		);
+
+
+/*******************************************************************************
+ * gprtSetPortLoopback
+ *
+ * DESCRIPTION:
+ * 		Enable/Disable Internal Port Loopback. Enabling Loopback will disable the 
+ * 		Autonegotiation and set the phy mode to 10 Half duplex.
+ * 		To test Loopback on a different mode, such as 100 Full duplex, 
+ * 		user may need to call gprtSetPortSpeed and gprtSetPortDuplexMode.
+ * 		Disabling Loopback does not enable the Autonegotiation, so user may need to call
+ * 		gprtPortAutoNegEnable in order to enable Autonegotiation.
+ *
+ * INPUTS:
+ * 		port - logical port number
+ * 		enable - If GT_TRUE, enable loopback mode
+ * 					If GT_FALSE, disable loopback mode
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.14 - Loop_back
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtSetPortLoopback
+	(
+		IN GT_QD_DEV 	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL 		enable
+		);
+
+
+/*******************************************************************************
+ * gprtSetPortSpeed
+ *
+ * DESCRIPTION:
+ * 		Sets speed for a specific logical port. This function will keep the duplex 
+ *		mode and loopback mode to the previous value, but disable others, such as 
+ *		Autonegotiation.
+ *
+ * INPUTS:
+ * 		port  - logical port number
+ * 		speed - port speed. 	GT_TRUE=100Mb/s, GT_FALSE=10Mb/s
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.13 - Speed Selection (LSB)
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtSetPortSpeed
+	(
+		IN GT_QD_DEV 	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL  	speed
+		);
+
+
+/*******************************************************************************
+ * gprtPortAutoNegEnable
+ *
+ * DESCRIPTION:
+ * 		Enable/disable an Auto-Negotiation for duplex mode on specific
+ * 		logical port. When Autonegotiation is disabled, phy will be in 10Mbps Half 
+ *		Duplex mode. Enabling Autonegotiation will set 100BASE-TX Full Duplex, 
+ *		100BASE-TX Full Duplex, 100BASE-TX Full Duplex, and 100BASE-TX Full Duplex
+ *		in AutoNegotiation Advertisement register.
+ *
+ * INPUTS:
+ * 		port - logical port number
+ * 		state - GT_TRUE for enable Auto-Negotiation for duplex mode,
+ * 					GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.12 - Auto-Negotiation Enable
+ * 		data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtPortAutoNegEnable
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL 		state
+		);
+
+
+/*******************************************************************************
+ * gprtPortPowerDown
+ *
+ * DESCRIPTION:
+ * 		Enable/disable (power down) on specific logical port. When this function 
+ *		is called with normal operation request, phy will set to Autonegotiation 
+ *		mode.
+ *
+ * INPUTS:
+ * 		port	- logical port number
+ * 		state	-  GT_TRUE: power down
+ * 					GT_FALSE: normal operation
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.11 - Power Down
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtPortPowerDown
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		state
+		);
+
+
+/*******************************************************************************
+ * gprtPortRestartAutoNeg
+ *
+ * DESCRIPTION:
+ * 		Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
+ *		it. Loopback and Power Down will be disabled by this routine.
+ *
+ * INPUTS:
+ * 		port - logical port number
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.9 - Restart Auto-Negotiation
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtPortRestartAutoNeg
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port
+		);
+
+
+/*******************************************************************************
+ * gprtSetPortDuplexMode
+ *
+ * DESCRIPTION:
+ * 		Sets duplex mode for a specific logical port. This function will keep 
+ *		the speed and loopback mode to the previous value, but disable others,
+ *		such as Autonegotiation.
+ *
+ * INPUTS:
+ * 		port 	- logical port number
+ * 		dMode	- dulpex mode
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ * 		data sheet register 0.8 - Duplex Mode
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtSetPortDuplexMode
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		dMode
+		);
+
+
+/*******************************************************************************
+ * gprtSetPortAutoMode
+ *
+ * DESCRIPTION:
+ * 		This routine sets up the port with given Auto Mode.
+ *		Supported mode is as follows:
+ *		- Auto for both speed and duplex.
+ *		- Auto for speed only and Full duplex.
+ *		- Auto for speed only and Half duplex.
+ *		- Auto for duplex only and speed 1000Mbps.
+ *		- Auto for duplex only and speed 100Mbps.
+ *		- Auto for duplex only and speed 10Mbps.
+ *		- Speed 1000Mbps and Full duplex.
+ *		- Speed 1000Mbps and Half duplex.
+ *		- Speed 100Mbps and Full duplex.
+ *		- Speed 100Mbps and Half duplex.
+ *		- Speed 10Mbps and Full duplex.
+ *		- Speed 10Mbps and Half duplex.
+ *		
+ *
+ * INPUTS:
+ * 		port - The logical port number
+ * 		mode - Auto Mode to be written
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ * COMMENTS:
+ * 		data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+ * 		data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+ * 		data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+ *******************************************************************************/
+
+	GT_STATUS gprtSetPortAutoMode
+	(
+		IN GT_QD_DEV 	*dev,
+		IN GT_LPORT 	port,
+		IN GT_PHY_AUTO_MODE mode
+		);
+
+/*******************************************************************************
+ * gprtSetPause
+ *
+ * DESCRIPTION:
+ *		This routine will set the pause bit in Autonegotiation Advertisement
+ *		Register. And restart the autonegotiation.
+ *
+ * INPUTS:
+ * 		port 	- The logical port number
+ * 		state - either GT_TRUE(for enable) or GT_FALSE(for disable)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ * COMMENTS:
+ * 		data sheet register 4.10 Autonegotiation Advertisement Register
+ *******************************************************************************/
+
+	GT_STATUS gprtSetPause
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL 		state
+		);
+
+/*******************************************************************************
+ * gprtGetPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine reads Phy Registers.
+ *
+ * INPUTS:
+ *       port    - logical port number
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPhyReg
+	(
+		IN  GT_QD_DEV    *dev,
+		IN  GT_LPORT     port,
+		IN  GT_U32	     regAddr,
+		OUT GT_U16	     *data
+		);
+
+/*******************************************************************************
+ * gprtSetPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine writes Phy Registers.
+ *
+ * INPUTS:
+ *       port    - logical port number
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetPhyReg
+	(
+		IN  GT_QD_DEV    *dev,
+		IN  GT_LPORT     port,
+		IN  GT_U32	     regAddr,
+		IN  GT_U16	     data
+		);
+
+
+/*******************************************************************************
+ * gprtPhyIntEnable
+ *
+ * DESCRIPTION:
+ * Enable/Disable one PHY Interrupt
+ * This register determines whether the INT# pin is asserted when an interrupt 
+ * event occurs. When an interrupt occurs, the corresponding bit is set and
+ * remains set until register 19 is read via the SMI. When interrupt enable
+ * bits are not set in register 18, interrupt status bits in register 19 are 
+ * still set when the corresponding interrupt events occur. However, the INT# 
+ * is not asserted.
+ *
+ * INPUTS:
+ * port    - logical port number
+ * intType - the type of interrupt to enable/disable. any combination of 
+ *			GT_SPEED_CHANGED,
+ *			GT_DUPLEX_CHANGED,
+ *			GT_PAGE_RECEIVED,
+ *			GT_AUTO_NEG_COMPLETED,
+ *			GT_LINK_STATUS_CHANGED,
+ *			GT_SYMBOL_ERROR,
+ *			GT_FALSE_CARRIER,
+ *			GT_FIFO_FLOW,
+ *			GT_CROSSOVER_CHANGED,
+ *			GT_POLARITY_CHANGED, and
+ *			GT_JABBER
+ *
+ * OUTPUTS:
+ * None.
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * 88E3081 data sheet register 18
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtPhyIntEnable
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT   port,
+		IN GT_U16	intType
+		);
+
+
+/*******************************************************************************
+ * gprtGetPhyIntStatus
+ *
+ * DESCRIPTION:
+ * Check to see if a specific type of  interrupt occured
+ *
+ * INPUTS:
+ * port - logical port number
+ * intType - the type of interrupt which causes an interrupt.
+ *			any combination of 
+ *			GT_SPEED_CHANGED,
+ *			GT_DUPLEX_CHANGED,
+ *			GT_PAGE_RECEIVED,
+ *			GT_AUTO_NEG_COMPLETED,
+ *			GT_LINK_STATUS_CHANGED,
+ *			GT_SYMBOL_ERROR,
+ *			GT_FALSE_CARRIER,
+ *			GT_FIFO_FLOW,
+ *			GT_CROSSOVER_CHANGED,
+ *			GT_POLARITY_CHANGED, and
+ *			GT_JABBER
+ *
+ * OUTPUTS:
+ * None.
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * 88E3081 data sheet register 19
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtGetPhyIntStatus
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT  GT_U16* intType
+		);
+
+/*******************************************************************************
+ * gprtGetPhyIntPortSummary
+ *
+ * DESCRIPTION:
+ * Lists the ports that have active interrupts. It provides a quick way to 
+ * isolate the interrupt so that the MAC or switch does not have to poll the
+ * interrupt status register (19) for all ports. Reading this register does not
+ * de-assert the INT# pin
+ *
+ * INPUTS:
+ * none
+ *
+ * OUTPUTS:
+ * GT_U8 *intPortMask - bit Mask with the bits set for the corresponding 
+ * phys with active interrupt. E.g., the bit number 0 and 2 are set when 
+ * port number 0 and 2 have active interrupt
+ *
+ * RETURNS:
+ * GT_OK - on success
+ * GT_FAIL - on error
+ *
+ * COMMENTS:
+ * 88E3081 data sheet register 20
+ *
+ *******************************************************************************/
+
+	GT_STATUS gprtGetPhyIntPortSummary
+	(
+		IN GT_QD_DEV *dev,
+		OUT GT_U16 *intPortMask
+		);
+
+
+
+/*******************************************************************************
+ * gprtSetForceFc
+ *
+ * DESCRIPTION:
+ *       This routine set the force flow control state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetForceFc
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  force
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetForceFc
+ *
+ * DESCRIPTION:
+ *       This routine get the force flow control state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetForceFc
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *force
+		);
+
+
+
+/*******************************************************************************
+ * gprtSetTrailerMode
+ *
+ * DESCRIPTION:
+ *       This routine set the egress trailer mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetTrailerMode
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetTrailerMode
+ *
+ * DESCRIPTION:
+ *       This routine get the egress trailer mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetTrailerMode
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtSetIngressMode
+ *
+ * DESCRIPTION:
+ *       This routine set the ingress mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the ingress mode.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetIngressMode
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT        port,
+		IN GT_INGRESS_MODE mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetIngressMode
+ *
+ * DESCRIPTION:
+ *       This routine get the ingress mode.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - the ingress mode.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetIngressMode
+	(
+		IN GT_QD_DEV        *dev,
+		IN  GT_LPORT        port,
+		OUT GT_INGRESS_MODE *mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtSetMcRateLimit
+ *
+ * DESCRIPTION:
+ *       This routine set the port multicast rate limit.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetMcRateLimit
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT     port,
+		IN GT_MC_RATE   rate
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetMcRateLimit
+ *
+ * DESCRIPTION:
+ *       This routine Get the port multicast rate limit.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetMcRateLimit
+	(
+		IN GT_QD_DEV    *dev,
+		IN  GT_LPORT    port,
+		OUT GT_MC_RATE  *rate
+		);
+
+
+
+/*******************************************************************************
+ * gprtSetCtrMode
+ *
+ * DESCRIPTION:
+ *       This routine sets the port counters mode of operation.
+ *
+ * INPUTS:
+ *       mode  - the counter mode.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetCtrMode
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_CTR_MODE  mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtClearAllCtr
+ *
+ * DESCRIPTION:
+ *       This routine clears all port counters.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtClearAllCtr
+	(
+		IN GT_QD_DEV *dev
+		);
+
+
+/*******************************************************************************
+ * gprtGetPortCtr
+ *
+ * DESCRIPTION:
+ *       This routine gets the port counters.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       ctr - the counters value.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPortCtr
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT        port,
+		OUT GT_PORT_STAT    *ctr
+		);
+
+
+
+
+/*******************************************************************************
+ * gprtGetPartnerLinkPause
+ *
+ * DESCRIPTION:
+ *       This routine retrives the link partner pause state.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - GT_TRUE for enable  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPartnerLinkPause
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *state
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetSelfLinkPause
+ *
+ * DESCRIPTION:
+ *       This routine retrives the link pause state.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - GT_TRUE for enable  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetSelfLinkPause
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *state
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetResolve
+ *
+ * DESCRIPTION:
+ *       This routine retrives the resolve state.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - GT_TRUE for Done  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetResolve
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *state
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetLinkState
+ *
+ * DESCRIPTION:
+ *       This routine retrives the link state.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       state - GT_TRUE for Up  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetLinkState
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *state
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetPortMode
+ *
+ * DESCRIPTION:
+ *       This routine retrives the port mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for MII  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPortMode
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetPhyMode
+ *
+ * DESCRIPTION:
+ *       This routine retrives the PHY mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for MII PHY  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPhyMode
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetDuplex
+ *
+ * DESCRIPTION:
+ *       This routine retrives the port duplex mode.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for Full  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetDuplex
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+
+
+/*******************************************************************************
+ * gprtGetSpeed
+ *
+ * DESCRIPTION:
+ *       This routine retrives the port speed.
+ *
+ * INPUTS:
+ *       speed - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for 100Mb/s  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetSpeed
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *speed
+		);
+
+/*******************************************************************************
+ * gprtSetDuplex
+ *
+ * DESCRIPTION:
+ *       This routine sets the duplex mode of MII/SNI/RMII ports.
+ *
+ * INPUTS:
+ *       port - 	the logical port number.
+ *				(for FullSail, it will be port 2, and for ClipperShip, 
+ *				it could be either port 5 or port 6.)
+ *       mode -  GT_TRUE for Full Duplex,
+ *				GT_FALSE for Half Duplex.
+ *
+ * OUTPUTS: None
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetDuplex
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		IN  GT_BOOL  mode
+		);
+
+
+/*******************************************************************************
+ * gqosSetPortDefaultTc
+ *
+ * DESCRIPTION:
+ *       Sets the default traffic class for a specific port.
+ *
+ * INPUTS:
+ *       port      - logical port number
+ *       trafClass - default traffic class of a port.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gcosSetPortDefaultTc
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_U8    trafClass
+		);
+
+
+/*******************************************************************************
+ * gcosGetPortDefaultTc
+ *
+ * DESCRIPTION:
+ *       Gets the default traffic class for a specific port.
+ *
+ * INPUTS:
+ *       port      - logical port number
+ *
+ * OUTPUTS:
+ *       trafClass - default traffic class of a port.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gcosGetPortDefaultTc
+	(
+		IN  GT_QD_DEV *dev,
+		IN GT_LPORT   port,
+		OUT GT_U8     *trafClass
+		);
+
+
+/*******************************************************************************
+ * gqosSetPrioMapRule
+ *
+ * DESCRIPTION:
+ *       This routine sets priority mapping rule.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gqosSetPrioMapRule
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+
+
+/*******************************************************************************
+ * gqosGetPrioMapRule
+ *
+ * DESCRIPTION:
+ *       This routine get the priority mapping rule.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gqosGetPrioMapRule
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+
+
+/*******************************************************************************
+ * gqosIpPrioMapEn
+ *
+ * DESCRIPTION:
+ *       This routine enables the IP priority mapping.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gqosIpPrioMapEn
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  en
+		);
+
+
+
+/*******************************************************************************
+ * gqosGetIpPrioMapEn
+ *
+ * DESCRIPTION:
+ *       This routine return the IP priority mapping state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gqosGetIpPrioMapEn
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *en
+		);
+
+
+
+/*******************************************************************************
+ * gqosUserPrioMapEn
+ *
+ * DESCRIPTION:
+ *       This routine enables the user priority mapping.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gqosUserPrioMapEn
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  en
+		);
+
+
+
+/*******************************************************************************
+ * gqosGetUserPrioMapEn
+ *
+ * DESCRIPTION:
+ *       This routine return the user priority mapping state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gqosGetUserPrioMapEn
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *en
+		);
+
+
+
+/*******************************************************************************
+ * gcosGetUserPrio2Tc
+ *
+ * DESCRIPTION:
+ *       Gets the traffic class number for a specific 802.1p user priority.
+ *
+ * INPUTS:
+ *       userPrior - user priority
+ *
+ * OUTPUTS:
+ *       trClass - The Traffic Class the received frame is assigned.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *       Table - UserPrio2Tc
+ *
+ *******************************************************************************/
+	GT_STATUS gcosGetUserPrio2Tc
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_U8    userPrior,
+		OUT GT_U8   *trClass
+		);
+
+
+/*******************************************************************************
+ * gcosSetUserPrio2Tc
+ *
+ * DESCRIPTION:
+ *       Sets the traffic class number for a specific 802.1p user priority.
+ *
+ * INPUTS:
+ *       userPrior - user priority of a port.
+ *       trClass   - the Traffic Class the received frame is assigned.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *       Table - UserPrio2Tc
+ *
+ *******************************************************************************/
+	GT_STATUS gcosSetUserPrio2Tc
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_U8    userPrior,
+		IN GT_U8    trClass
+		);
+
+
+/*******************************************************************************
+ * gcosGetDscp2Tc
+ *
+ * DESCRIPTION:
+ *       This routine retrieves the traffic class assigned for a specific
+ *       IPv4 Dscp.
+ *
+ * INPUTS:
+ *       dscp    - the IPv4 frame dscp to query.
+ *
+ * OUTPUTS:
+ *       trClass - The Traffic Class the received frame is assigned.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *       Table - UserPrio2Tc
+ *
+ *******************************************************************************/
+	GT_STATUS gcosGetDscp2Tc
+	(
+		IN GT_QD_DEV *dev,
+		IN  GT_U8   dscp,
+		OUT GT_U8   *trClass
+		);
+
+
+/*******************************************************************************
+ * gcosSetDscp2Tc
+ *
+ * DESCRIPTION:
+ *       This routine sets the traffic class assigned for a specific
+ *       IPv4 Dscp.
+ *
+ * INPUTS:
+ *       dscp    - the IPv4 frame dscp to map.
+ *       trClass - the Traffic Class the received frame is assigned.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *       Table - UserPrio2Tc
+ *
+ *******************************************************************************/
+	GT_STATUS gcosSetDscp2Tc
+	(
+		IN GT_QD_DEV *dev,
+		IN GT_U8    dscp,
+		IN GT_U8    trClass
+		);
+
+
+/*******************************************************************************
+ * qdLoadDriver
+ *
+ * DESCRIPTION:
+ *       QuarterDeck Driver Initialization Routine. 
+ *       This is the first routine that needs be called by system software. 
+ *       It takes sysCfg from system software, and retures a pointer (*dev) 
+ *       to a data structure which includes infomation related to this QuarterDeck
+ *       device. This pointer (*dev) is then used for all the API functions. 
+ *
+ * INPUTS:
+ *       sysCfg      - Holds system configuration parameters.
+ *
+ * OUTPUTS:
+ *       dev         - Holds general system information.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_ALREADY_EXIST    - if device already started
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ * COMMENTS:
+ * 	qdUnloadDriver is provided when the driver is not to be used anymore.
+ *
+ *******************************************************************************/
+	GT_STATUS qdLoadDriver
+	(
+		IN  GT_SYS_CONFIG   *sysCfg,
+		OUT GT_QD_DEV	*dev
+		);
+
+
+/*******************************************************************************
+ * qdUnloadDriver
+ *
+ * DESCRIPTION:
+ *       This function unloads the QuaterDeck Driver.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       1.  This function should be called only after successful execution of
+ *           qdLoadDriver().
+ *
+ *******************************************************************************/
+	GT_STATUS qdUnloadDriver
+	(
+		IN GT_QD_DEV* dev
+		);
+
+
+/*******************************************************************************
+ * sysEnable
+ *
+ * DESCRIPTION:
+ *       This function enables the system for full operation.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+	GT_STATUS sysEnable
+	(
+		IN GT_QD_DEV* dev
+		);
+
+
+/*******************************************************************************
+ * gsysSwReset
+ *
+ * DESCRIPTION:
+ *       This routine preforms switch software reset.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSwReset
+	(
+		IN GT_QD_DEV* dev
+		);
+
+
+/*******************************************************************************
+ * gsysSetDiscardExcessive
+ *
+ * DESCRIPTION:
+ *       This routine set the Discard Excessive state.
+ *
+ * INPUTS:
+ *       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetDiscardExcessive
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_BOOL en
+		);
+
+
+
+/*******************************************************************************
+ * gsysGetDiscardExcessive
+ *
+ * DESCRIPTION:
+ *       This routine get the Discard Excessive state.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetDiscardExcessive
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_BOOL *en
+		);
+
+
+
+/*******************************************************************************
+ * gsysSetSchedulingMode
+ *
+ * DESCRIPTION:
+ *       This routine set the Scheduling Mode.
+ *
+ * INPUTS:
+ *       mode - GT_TRUE wrr, GT_FALSE strict.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetSchedulingMode
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_BOOL mode
+		);
+
+
+
+/*******************************************************************************
+ * gsysGetSchedulingMode
+ *
+ * DESCRIPTION:
+ *       This routine get the Scheduling Mode.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE wrr, GT_FALSE strict.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetSchedulingMode
+	(
+		IN GT_QD_DEV *dev,
+		OUT GT_BOOL *mode
+		);
+
+
+
+/*******************************************************************************
+ * gsysSetMaxFrameSize
+ *
+ * DESCRIPTION:
+ *       This routine Set the max frame size allowed.
+ *
+ * INPUTS:
+ *       mode - GT_TRUE max size 1522, GT_FALSE max size 1535.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetMaxFrameSize
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_BOOL mode
+		);
+
+
+
+/*******************************************************************************
+ * gsysGetMaxFrameSize
+ *
+ * DESCRIPTION:
+ *       This routine Get the max frame size allowed.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE max size 1522, GT_FALSE max size 1535.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetMaxFrameSize
+	(
+		IN GT_QD_DEV *dev,
+		OUT GT_BOOL *mode
+		);
+
+
+
+/*******************************************************************************
+ * gsysReLoad
+ *
+ * DESCRIPTION:
+ *       This routine cause to the switch to reload the EEPROM.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysReLoad
+	(
+		IN GT_QD_DEV* dev
+		);
+
+
+/*******************************************************************************
+ * gsysSetWatchDog
+ *
+ * DESCRIPTION:
+ *       This routine Set the the watch dog mode.
+ *
+ * INPUTS:
+ *       en - GT_TRUE enables, GT_FALSE disable.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetWatchDog
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_BOOL en
+		);
+
+
+
+/*******************************************************************************
+ * gsysGetWatchDog
+ *
+ * DESCRIPTION:
+ *       This routine Get the the watch dog mode.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       en - GT_TRUE enables, GT_FALSE disable.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetWatchDog
+	(
+		IN GT_QD_DEV* dev,
+		OUT GT_BOOL *en
+		);
+
+
+/*******************************************************************************
+ * gsysSetDuplexPauseMac
+ *
+ * DESCRIPTION:
+ *       This routine sets the full duplex pause src Mac Address.
+ *
+ * INPUTS:
+ *       mac - The Mac address to be set.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetDuplexPauseMac
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_ETHERADDR *mac
+		);
+
+
+/*******************************************************************************
+ * gsysGetDuplexPauseMac
+ *
+ * DESCRIPTION:
+ *       This routine Gets the full duplex pause src Mac Address.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mac - the Mac address.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetDuplexPauseMac
+	(
+		IN GT_QD_DEV* dev,
+		OUT GT_ETHERADDR *mac
+		);
+
+
+
+/*******************************************************************************
+ * gsysSetPerPortDuplexPauseMac
+ *
+ * DESCRIPTION:
+ *       This routine sets whether the full duplex pause src Mac Address is per
+ *       port or per device.
+ *
+ * INPUTS:
+ *       en - GT_TURE per port mac, GT_FALSE global mac.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetPerPortDuplexPauseMac
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_BOOL en
+		);
+
+
+
+/*******************************************************************************
+ * gsysGetPerPortDuplexPauseMac
+ *
+ * DESCRIPTION:
+ *       This routine Gets whether the full duplex pause src Mac Address is per
+ *       port or per device.
+ *
+ * INPUTS:
+ *       en - GT_TURE per port mac, GT_FALSE global mac.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetPerPortDuplexPauseMac
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_BOOL *en
+		);
+
+
+/*******************************************************************************
+ * gsysReadMiiRegister
+ *
+ * DESCRIPTION:
+ *       This routine reads QuarterDeck Registers. Since this routine is only for
+ *		Diagnostic Purpose, no error checking will be performed.
+ *		User has to know exactly which phy address(0 ~ 0x1F) will be read.
+ *
+ * INPUTS:
+ *       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysReadMiiReg
+	(
+		IN GT_QD_DEV* dev,
+		IN  GT_U32	phyAddr,
+		IN  GT_U32	regAddr,
+		OUT GT_U32	*data
+		);
+
+/*******************************************************************************
+ * gsysWriteMiiRegister
+ *
+ * DESCRIPTION:
+ *       This routine writes QuarterDeck Registers. Since this routine is only for
+ *		Diagnostic Purpose, no error checking will be performed.
+ *		User has to know exactly which phy address(0 ~ 0x1F) will be read.
+ *
+ * INPUTS:
+ *       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+ *       regAddr - The register's address.
+ *       data    - data to be written.
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysWriteMiiReg
+	(
+		IN GT_QD_DEV* dev,
+		IN  GT_U32	phyAddr,
+		IN  GT_U32	regAddr,
+		IN  GT_U16	data
+		);
+
+/*******************************************************************************
+ * gsysGetSW_Mode
+ *
+ * DESCRIPTION:
+ *       This routine get the Switch mode. These two bits returen 
+ *       the current value of the SW_MODE[1:0] pins.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ * 		This feature is for both clippership and fullsail
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetSW_Mode
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_SW_MODE *mode
+		);
+
+/*******************************************************************************
+ * gsysGetInitReady
+ *
+ * DESCRIPTION:
+ *       This routine get the InitReady bit. This bit is set to a one when the ATU,
+ *       the Queue Controller and the Statistics Controller are done with their 
+ *       initialization and are ready to accept frames.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_BAD_PARAM    - on bad parameter
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ * 		This feature is for both clippership and fullsail
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetInitReady
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_BOOL *mode
+		);
+
+
+/*******************************************************************************
+ * gstatsFlushAll
+ *
+ * DESCRIPTION:
+ *       Flush All RMON counters for all ports.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsFlushAll
+	(
+		IN GT_QD_DEV* dev
+		);
+
+/*******************************************************************************
+ * gstatsFlushPort
+ *
+ * DESCRIPTION:
+ *       Flush All RMON counters for a given port.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsFlushPort
+	(
+		IN GT_QD_DEV* dev,
+		IN GT_LPORT	port
+		);
+
+/*******************************************************************************
+ * gstatsGetPortCounter
+ *
+ * DESCRIPTION:
+ *		This routine gets a specific counter of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		counter - the counter which will be read
+ *
+ * OUTPUTS:
+ *		statsData - points to 32bit data storage for the MIB counter
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsGetPortCounter
+	(
+		IN  GT_QD_DEV		*dev,
+		IN  GT_LPORT		port,
+		IN  GT_STATS_COUNTERS	counter,
+		OUT GT_U32			*statsData
+		);
+
+/*******************************************************************************
+ * gstatsGetPortAllCounters
+ *
+ * DESCRIPTION:
+ *       This routine gets all RMON counters of the given port
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+ *
+ * RETURNS:
+ *       GT_OK      - on success
+ *       GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *       None
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsGetPortAllCounters
+	(
+		IN  GT_QD_DEV* dev,
+		IN  GT_LPORT		port,
+		OUT GT_STATS_COUNTER_SET	*statsCounterSet
+		);
+
+
+/*******************************************************************************
+ * grcSetLimitMode
+ *
+ * DESCRIPTION:
+ *       This routine sets the port's rate control ingress limit mode.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *       mode 	- rate control ingress limit mode. 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *******************************************************************************/
+	GT_STATUS grcSetLimitMode
+	(
+		IN GT_QD_DEV*            dev,
+		IN GT_LPORT 	     port,
+		IN GT_RATE_LIMIT_MODE    mode
+		);
+
+/*******************************************************************************
+ * grcGetLimitMode
+ *
+ * DESCRIPTION:
+ *       This routine gets the port's rate control ingress limit mode.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *
+ * OUTPUTS:
+ *       mode 	- rate control ingress limit mode. 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcGetLimitMode
+	(
+		IN GT_QD_DEV* dev,
+		IN  GT_LPORT port,
+		OUT GT_RATE_LIMIT_MODE    *mode
+		);
+
+/*******************************************************************************
+ * grcSetPri3Rate
+ *
+ * DESCRIPTION:
+ *       This routine sets the ingress data rate limit for priority 3 frames.
+ *       Priority 3 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the priority 3 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri2Rate
+ *              GT_TRUE:  use twice the rate as Pri2Rate
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ *******************************************************************************/
+	GT_STATUS grcSetPri3Rate
+	(
+		IN GT_QD_DEV*            dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+/*******************************************************************************
+ * grcGetPri3Rate
+ *
+ * DESCRIPTION:
+ *       This routine gets the ingress data rate limit for priority 3 frames.
+ *       Priority 3 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       
+ * OUTPUTS:
+ *       mode - the priority 3 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri2Rate
+ *              GT_TRUE:  use twice the rate as Pri2Rate
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcGetPri3Rate
+	(
+		IN GT_QD_DEV* dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+/*******************************************************************************
+ * grcSetPri2Rate
+ *
+ * DESCRIPTION:
+ *       This routine sets the ingress data rate limit for priority 2 frames.
+ *       Priority 2 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the priority 2 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri1Rate
+ *              GT_TRUE:  use twice the rate as Pri1Rate
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ *******************************************************************************/
+	GT_STATUS grcSetPri2Rate
+	(
+		IN GT_QD_DEV*            dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+/*******************************************************************************
+ * grcGetPri2Rate
+ *
+ * DESCRIPTION:
+ *       This routine gets the ingress data rate limit for priority 2 frames.
+ *       Priority 2 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       
+ * OUTPUTS:
+ *       mode - the priority 2 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri1Rate
+ *              GT_TRUE:  use twice the rate as Pri1Rate
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcGetPri2Rate
+	(
+		IN GT_QD_DEV*            dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+/*******************************************************************************
+ * grcSetPri1Rate
+ *
+ * DESCRIPTION:
+ *       This routine sets the ingress data rate limit for priority 1 frames.
+ *       Priority 1 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the priority 1 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri0Rate
+ *              GT_TRUE:  use twice the rate as Pri0Rate
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ *******************************************************************************/
+	GT_STATUS grcSetPri1Rate
+	(
+		IN GT_QD_DEV*            dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+/*******************************************************************************
+ * grcGetPri1Rate
+ *
+ * DESCRIPTION:
+ *       This routine gets the ingress data rate limit for priority 1 frames.
+ *       Priority 1 frames will be discarded after the ingress rate selection
+ *       is reached or exceeded.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       
+ * OUTPUTS:
+ *       mode - the priority 1 frame rate limit mode
+ *              GT_FALSE: use the same rate as Pri0Rate
+ *              GT_TRUE:  use twice the rate as Pri0Rate
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcGetPri1Rate
+	(
+		IN GT_QD_DEV*            dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+/*******************************************************************************
+ * grcSetPri0Rate
+ *
+ * DESCRIPTION:
+ *       This routine sets the port's ingress data limit for priority 0 frames.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *       rate    - ingress data rate limit for priority 0 frames. These frames
+ *       	  will be discarded after the ingress rate selected is reached 
+ *       	  or exceeded. 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcSetPri0Rate
+	(
+		IN GT_QD_DEV*            dev,
+		IN GT_LPORT        port,
+		IN GT_PRI0_RATE    rate
+		);
+
+/*******************************************************************************
+ * grcGetPri0Rate
+ *
+ * DESCRIPTION:
+ *       This routine gets the port's ingress data limit for priority 0 frames.
+ *
+ * INPUTS:
+ *       port	- logical port number to set.
+ *
+ * OUTPUTS:
+ *       rate    - ingress data rate limit for priority 0 frames. These frames
+ *       	  will be discarded after the ingress rate selected is reached 
+ *       	  or exceeded. 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcGetPri0Rate
+	(
+		IN GT_QD_DEV*            dev,
+		IN  GT_LPORT port,
+		OUT GT_PRI0_RATE    *rate
+		);
+
+/*******************************************************************************
+ * grcSetBytesCount
+ *
+ * DESCRIPTION:
+ *       This routine sets the byets to count for limiting needs to be determined
+ *
+ * INPUTS:
+ *       port	  - logical port number to set.
+ *    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+ *    		    GT_FALSE: otherwise
+ *    	countIFG  - GT_TRUE: To count IFG bytes
+ *    		    GT_FALSE: otherwise
+ *    	countPre  - GT_TRUE: To count Preamble bytes
+ *    		    GT_FALSE: otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcSetBytesCount
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_LPORT        	port,
+		IN GT_BOOL 		limitMGMT,
+		IN GT_BOOL 		countIFG,
+		IN GT_BOOL 		countPre
+		);
+
+/*******************************************************************************
+ * grcGetBytesCount
+ *
+ * DESCRIPTION:
+ *       This routine gets the byets to count for limiting needs to be determined
+ *
+ * INPUTS:
+ *       port	- logical port number 
+ *
+ * OUTPUTS:
+ *    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+ *    		    GT_FALSE: otherwise
+ *    	countIFG  - GT_TRUE: To count IFG bytes
+ *    		    GT_FALSE: otherwise
+ *    	countPre  - GT_TRUE: To count Preamble bytes
+ *    		    GT_FALSE: otherwise
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcGetBytesCount
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_LPORT        	port,
+		IN GT_BOOL 		*limitMGMT,
+		IN GT_BOOL 		*countIFG,
+		IN GT_BOOL 		*countPre
+		);
+
+/*******************************************************************************
+ * grcSetEgressRate
+ *
+ * DESCRIPTION:
+ *       This routine sets the port's egress data limit.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *       rate    - egress data rate limit.
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcSetEgressRate
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_LPORT        port,
+		IN GT_EGRESS_RATE  rate
+		);
+
+/*******************************************************************************
+ * grcGetEgressRate
+ *
+ * DESCRIPTION:
+ *       This routine gets the port's egress data limit.
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *
+ * OUTPUTS:
+ *       rate    - egress data rate limit.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS grcGetEgressRate
+	(
+		IN GT_QD_DEV*       dev,
+		IN  GT_LPORT port,
+		OUT GT_EGRESS_RATE  *rate
+		);
+
+
+/*******************************************************************************
+ * gpavSetPAV
+ *
+ * DESCRIPTION:
+ *       This routine sets the Port Association Vector 
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *       pav 	- Port Association Vector 
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS gpavSetPAV
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_LPORT	port,
+		IN GT_U16	pav
+		);
+
+/*******************************************************************************
+ * gpavGetPAV
+ *
+ * DESCRIPTION:
+ *       This routine gets the Port Association Vector 
+ *
+ * INPUTS:
+ *       port	- logical port number.
+ *
+ * OUTPUTS:
+ *       pav 	- Port Association Vector 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS gpavGetPAV
+	(
+		IN GT_QD_DEV*       dev,
+		IN  GT_LPORT port,
+		OUT GT_U16    *pav
+		);
+
+/*******************************************************************************
+ * gpavSetIngressMonitor
+ *
+ * DESCRIPTION:
+ *       This routine sets the Ingress Monitor bit in the PAV.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       mode - the ingress monitor bit in the PAV
+ *              GT_FALSE: Ingress Monitor enabled 
+ *              GT_TRUE:  Ingress Monitor disabled 
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *******************************************************************************/
+	GT_STATUS gpavSetIngressMonitor
+	(
+		IN GT_QD_DEV*       dev,
+		IN GT_LPORT port,
+		IN GT_BOOL  mode
+		);
+
+/*******************************************************************************
+ * gpavGetIngressMonitor
+ *
+ * DESCRIPTION:
+ *       This routine gets the Ingress Monitor bit in the PAV.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *       
+ * OUTPUTS:
+ *       mode - the ingress monitor bit in the PAV
+ *              GT_FALSE: Ingress Monitor enabled 
+ *              GT_TRUE:  Ingress Monitor disabled 
+ *
+ * RETURNS:
+ *       GT_OK               - on success
+ *       GT_FAIL             - on error
+ *       GT_BAD_PARAM        - on bad parameters
+ *
+ *******************************************************************************/
+	GT_STATUS gpavGetIngressMonitor
+	(
+		IN GT_QD_DEV*       dev,
+		IN  GT_LPORT port,
+		OUT GT_BOOL  *mode
+		);
+
+/*******************************************************************************
+ * gvctGetCableStatus
+ *
+ * DESCRIPTION:
+ *       This routine perform the virtual cable test for the requested port,
+ *       and returns the the status per MDI pair.
+ *
+ * INPUTS:
+ *       port - logical port number.
+ *
+ * OUTPUTS:
+ *       cableStatus - the port copper cable status.
+ *       cableLen    - the port copper cable length.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED- if current device does not support this feature.
+ *
+ *******************************************************************************/
+	GT_STATUS gvctGetCableDiag
+	(
+		IN GT_QD_DEV*       dev,
+		IN  GT_LPORT        port,
+		OUT GT_CABLE_STATUS *cableStatus
+		);
+
+
+/*******************************************************************************
+ * gvctGet1000BTExtendedStatus
+ *
+ * DESCRIPTION:
+ *       This routine retrieves extended cable status, such as Pair Poloarity,
+ *		Pair Swap, and Pair Skew. Note that this routine will be success only
+ *		if 1000Base-T Link is up.
+ *
+ * INPUTS:
+ *       port - logical port number.
+ *
+ * OUTPUTS:
+ *       extendedStatus - the extended cable status.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *       GT_NOT_SUPPORTED- if current device does not support this feature.
+ *
+ *******************************************************************************/
+	GT_STATUS gvctGet1000BTExtendedStatus
+	(
+		IN  GT_QD_DEV 		*dev,
+		IN  GT_LPORT        port,
+		OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+		);
+
+
+/*******************************************************************************
+ * gtMemSet
+ *
+ * DESCRIPTION:
+ *       Set a block of memory
+ *
+ * INPUTS:
+ *       start  - start address of memory block for setting
+ *       simbol - character to store, converted to an unsigned char
+ *       size   - size of block to be set
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       Pointer to set memory block
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	void * gtMemSet
+	(
+		IN void * start,
+		IN int    symbol,
+		IN GT_U32 size
+		);
+
+/*******************************************************************************
+ * gtMemCpy
+ *
+ * DESCRIPTION:
+ *       Copies 'size' characters from the object pointed to by 'source' into
+ *       the object pointed to by 'destination'. If copying takes place between
+ *       objects that overlap, the behavior is undefined.
+ *
+ * INPUTS:
+ *       destination - destination of copy
+ *       source      - source of copy
+ *       size        - size of memory to copy
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       Pointer to destination
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	void * gtMemCpy
+	(
+		IN void *       destination,
+		IN const void * source,
+		IN GT_U32       size
+		);
+
+
+/*******************************************************************************
+ * gtMemCmp
+ *
+ * DESCRIPTION:
+ *       Compares given memories.
+ *
+ * INPUTS:
+ *       src1 - source 1
+ *       src2 - source 2
+ *       size - size of memory to copy
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       0, if equal.
+ *		negative number, if src1 < src2.
+ *		positive number, if src1 > src2.
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	int gtMemCmp
+	(
+		IN char src1[],
+		IN char src2[],
+		IN GT_U32 size
+		);
+
+/*******************************************************************************
+ * gtStrlen
+ *
+ * DESCRIPTION:
+ *       Determine the length of a string
+ * INPUTS:
+ *       source  - string
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       size    - number of characters in string, not including EOS.
+ *
+ * COMMENTS:
+ *       None
+ *
+ *******************************************************************************/
+	GT_U32 gtStrlen
+	(
+		IN const void * source
+		);
+
+/*******************************************************************************
+ * gtVersion
+ *
+ * DESCRIPTION:
+ *       This function returns the version of the QuarterDeck SW suite.
+ *
+ * INPUTS:
+ *       None.
+ *
+ * OUTPUTS:
+ *       version     - QuarterDeck software version.
+ *
+ * RETURNS:
+ *       GT_OK on success,
+ *       GT_BAD_PARAM on bad parameters,
+ *       GT_FAIL otherwise.
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+	GT_STATUS gtVersion
+	(
+		OUT GT_VERSION   *version
+		);
+
+
+/* Prototypes added for Gigabit Ethernet Switch Support */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+ * gfdbMove
+ *
+ * DESCRIPTION:
+ *		This routine moves all or unblocked addresses from a port to another.
+ *
+ * INPUTS:
+ *		moveCmd  - the move operation type.
+ *		moveFrom - port where moving from
+ *		moveTo   - port where moving to
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbMove
+	(
+		IN GT_QD_DEV 	*dev,
+		IN GT_MOVE_CMD	moveCmd,
+		IN GT_U32		moveFrom,
+		IN GT_U32		moveTo
+		);
+
+/*******************************************************************************
+ * gfdbMoveInDB
+ *
+ * DESCRIPTION:
+ * 		This routine move all or unblocked addresses which are in the particular
+ * 		ATU Database (DBNum) from a port to another.
+ *
+ * INPUTS:
+ * 		moveCmd  - the move operation type.
+ *		DBNum	 	- ATU MAC Address Database Number.
+ *		moveFrom - port where moving from
+ *		moveTo   - port where moving to
+ *
+ * OUTPUTS:
+ *     None
+ *
+ * RETURNS:
+ * 		GT_OK           - on success
+ * 		GT_FAIL         - on error
+ * 		GT_NOT_SUPPORTED- if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbMoveInDB
+	(
+		IN GT_QD_DEV   *dev,
+		IN GT_MOVE_CMD moveCmd,
+		IN GT_U8 		DBNum,
+		IN GT_U32		moveFrom,
+		IN GT_U32		moveTo
+		);
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/*******************************************************************************
+ * gatuGetIntStatus
+ *
+ * DESCRIPTION:
+ *		Check to see if a specific type of ATU interrupt occured
+ *
+ * INPUTS:
+ *     intType - the type of interrupt which causes an interrupt.
+ *					GT_MEMEBER_VIOLATION, GT_MISS_VIOLATION, or GT_FULL_VIOLATION 
+ *
+ * OUTPUTS:
+ * 		None.
+ *
+ * RETURNS:
+ * 		GT_OK 	- on success
+ * 		GT_FAIL 	- on error
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+	GT_STATUS gatuGetIntStatus
+	(
+		IN  GT_QD_DEV				*dev,
+		OUT GT_ATU_INT_STATUS	*atuIntStatus
+		);
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+ * gprtSet1000TMasterMode
+ *
+ * DESCRIPTION:
+ *		This routine set the port multicast rate limit.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_1000T_MASTER_SLAVE structure
+ *				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+ *				masterPrefer - GT_TRUE if Master configuration is preferred.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSet1000TMasterMode
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_1000T_MASTER_SLAVE	*mode
+		);
+
+/*******************************************************************************
+ * gprtGet1000TMasterMode
+ *
+ * DESCRIPTION:
+ *		This routine set the port multicast rate limit.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_1000T_MASTER_SLAVE structure
+ *				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+ *				masterPrefer - GT_TRUE if Master configuration is preferred.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGet1000TMasterMode
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_1000T_MASTER_SLAVE	*mode
+		);
+
+/*******************************************************************************
+ * gprtGetPhyReg
+ *
+ * DESCRIPTION:
+ *		This routine reads Phy Registers.
+ *
+ * INPUTS:
+ *		port    - logical port number
+ *		regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *		data    - The read register's data.
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPhyReg
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		IN  GT_U32	 	regAddr,
+		OUT GT_U16	 	*data
+		);
+
+/*******************************************************************************
+ * gprtSetPhyReg
+ *
+ * DESCRIPTION:
+ *		This routine writes Phy Registers.
+ *		
+ * INPUTS:
+ *		port    - logical port number
+ *		regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *		data    - The read register's data.
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetPhyReg
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		IN  GT_U32	 	regAddr,
+		IN  GT_U16	 	data
+		);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+ * gprtSetDropOnLock
+ *
+ * DESCRIPTION:
+ *		This routine set the Drop on Lock. When set to one, Ingress frames will
+ *		be discarded if their SA field is not in the ATU's address database.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetDropOnLock
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetDropOnLock
+ *
+ * DESCRIPTION:
+ *		This routine gets DropOnLock mode.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: DropOnLock enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetDropOnLock
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL		*mode
+		);
+
+/*******************************************************************************
+ * gprtSetDoubleTag
+ *
+ * DESCRIPTION:
+ *		This routine set the Ingress Double Tag Mode. When set to one, 
+ *		ingressing frames are examined to see if they contain an 802.3ac tag.
+ *		If they do, the tag is removed and then the frame is processed from
+ *		there (i.e., removed tag is ignored). Essentially, untagged frames
+ *		remain untagged, single tagged frames become untagged and double tagged
+ *		frames become single tagged.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetDoubleTag
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetDoubleTag
+ *
+ * DESCRIPTION:
+ *		This routine gets DoubleTag mode.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: DoubleTag enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetDoubleTag
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL		*mode
+		);
+
+/*******************************************************************************
+ * gprtSetInterswitchPort
+ *
+ * DESCRIPTION:
+ *		This routine set Interswitch Port. When set to one, 
+ *		it indicates this port is a interswitch port used to communicated with
+ *		CPU or to cascade with another switch device.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetInterswitchPort
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetInterswithPort
+ *
+ * DESCRIPTION:
+ *		This routine gets InterswitchPort.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: This port is interswitch port,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetInterswitchPort
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL		*mode
+		);
+
+/*******************************************************************************
+ * gprtSetLearnDisable
+ *
+ * DESCRIPTION:
+ *		This routine enables/disables automatic learning of new source MAC
+ *		addresses on the given port ingress
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for disable or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetLearnDisable
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		mode
+		);
+
+
+/*******************************************************************************
+ * gprtGetLearnDisable
+ *
+ * DESCRIPTION:
+ *		This routine gets LearnDisable setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: Learning disabled on the given port ingress frames,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetLearnDisable
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL		*mode
+		);
+
+/*******************************************************************************
+ * gprtSetIgnoreFCS
+ *
+ * DESCRIPTION:
+ *		This routine sets FCS Ignore mode. When this bit is set to a one,
+ *		the last four bytes of frames received on this port are overwritten with
+ *		a good CRC and the frames will be accepted by the switch.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetIgnoreFCS
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL 		mode
+		);
+
+/*******************************************************************************
+ * gprtGetIgnoreFCS
+ *
+ * DESCRIPTION:
+ *		This routine gets Ignore FCS setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetIgnoreFCS
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL		*mode
+		);
+
+/*******************************************************************************
+ * gprtSetVTUPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine sets VTU Priority Override. When this bit is set to a one,
+ *		VTU priority overrides can occur on this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for VTU Priority Override or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetVTUPriOverride
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetVTUPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine gets VTU Priority Override setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: VTU Priority Override enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetVTUPriOverride
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL		*mode
+		);
+
+/*******************************************************************************
+ * gprtSetSAPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine sets SA Priority Override. When this bit is set to a one,
+ *		SA priority overrides can occur on this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for SA Priority Override or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetSAPriOverride
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetSAPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine gets SA Priority Override setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: SA Priority Override enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetSAPriOverride
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL 	*mode
+		);
+
+/*******************************************************************************
+ * gprtSetDAPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine sets DA Priority Override. When this bit is set to a one,
+ *		DA priority overrides can occur on this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for DA Priority Override or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetDAPriOverride
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL  	mode
+		);
+
+/*******************************************************************************
+ * gprtGetDAPriOverride
+ *
+ * DESCRIPTION:
+ *		This routine gets DA Priority Override setup
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE: DA Priority Override enabled,
+ *				 GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetDAPriOverride
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*mode
+		);
+
+/*******************************************************************************
+ * gprtSetCPUPort
+ *
+ * DESCRIPTION:
+ *		This routine sets CPU Port number. When Snooping is enabled on this port
+ *		or when this port is configured as an Interswitch Port and it receives a 
+ *		To_CPU frame, the switch needs to know what port on this device the frame 
+ *		should egress.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		cpuPort - CPU Port number or interswitch port where CPU Port is connected
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetCPUPort
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_LPORT 	cpuPort
+		);
+
+/*******************************************************************************
+ * gprtGetCPUPort
+ *
+ * DESCRIPTION:
+ *		This routine gets CPU Logical Port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		cpuPort - CPU Port's logical number
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetCPUPort
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_LPORT 	*cpuLPort
+		);
+
+/*******************************************************************************
+ * gprtSetLockedPort
+ *
+ * DESCRIPTION:
+ *		This routine sets LockedPort. When it's set to one, CPU directed 
+ *		learning for 802.1x MAC authentication is enabled on this port. In this
+ *		mode, an ATU Miss Violation interrupt will occur when a new SA address
+ *		is received in a frame on this port. Automatically SA learning and 
+ *		refreshing is disabled in this mode.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetLockedPort
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetLockedPort
+ *
+ * DESCRIPTION:
+ *		This routine gets Locked Port mode for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetLockedPort
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL  	*mode
+		);
+
+/*******************************************************************************
+ * gprtSetIgnoreWrongData
+ *
+ * DESCRIPTION:
+ *		This routine sets Ignore Wrong Data. If the frame's SA address is found 
+ *		in the database and if the entry is 'static' or if the port is 'locked'
+ *		the source port's bit is checked to insure the SA has been assigned to 
+ *		this port. If the SA is NOT assigned to this port, it is considered an 
+ *		ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+ *		Member Violation interrupt will be generated. If it's set to GT_TRUE,
+ *		the ATU Member Violation error will be masked and ignored.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetIgnoreWrongData
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port,
+		IN GT_BOOL		mode
+		);
+
+
+/*******************************************************************************
+ * gprtGetIgnoreWrongData
+ *
+ * DESCRIPTION:
+ *		This routine gets Ignore Wrong Data mode for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetIgnoreWrongData
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*mode
+		);
+
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+ * gstatsGetPortCounter2
+ *
+ * DESCRIPTION:
+ *		This routine gets a specific counter of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		counter - the counter which will be read
+ *
+ * OUTPUTS:
+ *		statsData - points to 32bit data storage for the MIB counter
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsGetPortCounter2
+	(
+		IN  GT_QD_DEV		*dev,
+		IN  GT_LPORT		port,
+		IN  GT_STATS_COUNTERS2	counter,
+		OUT GT_U32			*statsData
+		);
+
+
+/*******************************************************************************
+ * gstatsGetPortAllCounters2
+ *
+ * DESCRIPTION:
+ *		This routine gets all counters of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsGetPortAllCounters2
+	(
+		IN  GT_QD_DEV		*dev,
+		IN  GT_LPORT		port,
+		OUT GT_STATS_COUNTER_SET2	*statsCounterSet
+		);
+
+/*******************************************************************************
+ * gstatsGetHistogramMode
+ *
+ * DESCRIPTION:
+ *		This routine gets the Histogram Counters Mode.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+ *					and GT_COUNT_RX_TX)
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_BAD_PARAM    - on bad parameter
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsGetHistogramMode
+	(
+		IN  GT_QD_DEV				*dev,
+		OUT GT_HISTOGRAM_MODE	*mode
+		);
+
+/*******************************************************************************
+ * gstatsSetHistogramMode
+ *
+ * DESCRIPTION:
+ *		This routine sets the Histogram Counters Mode.
+ *
+ * INPUTS:
+ *		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+ *					and GT_COUNT_RX_TX)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_BAD_PARAM    - on bad parameter
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsSetHistogramMode
+	(
+		IN GT_QD_DEV 				*dev,
+		IN GT_HISTOGRAM_MODE		mode
+		);
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+ * gprtGetPauseEn
+ *
+ * DESCRIPTION:
+ *		This routine retrives the link pause state.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE for enable or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		If set MAC Pause (for Full Duplex flow control) is implemented in the
+ *		link partner and in MyPause
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPauseEn
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*state
+		);
+
+/*******************************************************************************
+ * gprtGetHdFlow
+ *
+ * DESCRIPTION:
+ *		This routine retrives the half duplex flow control value.
+ *		If set, Half Duplex back pressure will be used on this port if this port
+ *		is in a half duplex mode.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE for enable or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetHdFlow
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL 	*state
+		);
+
+/*******************************************************************************
+ * gprtGetPHYDetect
+ *
+ * DESCRIPTION:
+ *		This routine retrives the information regarding PHY detection.
+ *		If set, An 802.3 PHY is attached to this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if connected or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPHYDetect
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL 	*state
+		);
+
+/*******************************************************************************
+ * gprtSetPHYDetect
+ *
+ * DESCRIPTION:
+ *		This routine sets PHYDetect bit which make PPU change its polling.
+ *		PPU's pool routine uses these bits to determine which port's to poll
+ *		PHYs on for Link, Duplex, Speed, and Flow Control.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE or GT_FALSE
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		This function should not be called if gsysGetPPUState returns 
+ *		PPU_STATE_ACTIVE.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetPHYDetect
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		IN  GT_BOOL  	state
+		);
+
+/*******************************************************************************
+ * gprtGetSpeedMode
+ *
+ * DESCRIPTION:
+ *       This routine retrives the port speed.
+ *
+ * INPUTS:
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       mode - GT_PORT_SPEED_MODE type.
+ *					(PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, or PORT_SPEED_10_MBPS)
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetSpeedMode
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_LPORT  port,
+		OUT GT_PORT_SPEED_MODE   *speed
+		);
+
+/*******************************************************************************
+ * gprtGetHighErrorRate
+ *
+ * DESCRIPTION:
+ *		This routine retrives the PCS High Error Rate.
+ *		This routine returns GT_TRUE if the rate of invalid code groups seen by
+ *		PCS has exceeded 10 to the power of -11.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE or GT_FALSE
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetHighErrorRate
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gprtGetTxPaused
+ *
+ * DESCRIPTION:
+ *		This routine retrives Transmit Pause state.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
+ *				  GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetTxPaused
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+
+/*******************************************************************************
+ * gprtGetFlowCtrl
+ *
+ * DESCRIPTION:
+ *		This routine retrives Flow control state.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if Rx MAC determines that no more data should be 
+ *					entering this port.
+ *				  GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetFlowCtrl
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gprtGetC_Duplex
+ *
+ * DESCRIPTION:
+ *		This routine retrives Port 9's duplex configuration mode determined
+ *		at reset.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if configured as Full duplex operation
+ *				  GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		Return value is valid only if the given port is 9.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetC_Duplex
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gprtGetC_Mode
+ *
+ * DESCRIPTION:
+ *		This routine retrives port's interface type configuration mode 
+ *		determined at reset.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - one of value in GT_PORT_CONFIG_MODE enum type
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		Return value is valid only if the given port is 9.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetC_Mode
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_PORT_CONFIG_MODE   *state
+		);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+ * gsysSetPPUEn
+ *
+ * DESCRIPTION:
+ *		This routine enables/disables Phy Polling Unit.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetPPUEn
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_BOOL 		en
+		);
+
+/*******************************************************************************
+ * gsysGetPPUEn
+ *
+ * DESCRIPTION:
+ *		This routine get the PPU state.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_BAD_PARAM    - on bad parameter
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetPPUEn
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_BOOL  	*en
+		);
+
+/*******************************************************************************
+ * gsysSetCascadePort
+ *
+ * DESCRIPTION:
+ *		This routine sets Cascade Port number.
+ *		In multichip systems frames coming from a CPU need to know when they
+ *		have reached their destination chip.
+ *
+ * INPUTS:
+ *		port - Cascade Port
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetCascadePort
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port
+		);
+
+/*******************************************************************************
+ * gsysGetCascadePort
+ *
+ * DESCRIPTION:
+ *		This routine gets Cascade Port number.
+ *		In multichip systems frames coming from a CPU need to know when they
+ *		have reached their destination chip.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		port - Cascade Port
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetCascadePort
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_LPORT 	*port
+		);
+
+/*******************************************************************************
+ * gsysSetDeviceNumber
+ *
+ * DESCRIPTION:
+ *		This routine sets Device Number.
+ *		In multichip systems frames coming from a CPU need to know when they
+ *		have reached their destination chip. From CPU frames whose Dev_Num
+ *		fieldmatches these bits have reachedtheir destination chip and are sent
+ *		out this chip using the port number indicated in the frame's Trg_Port 
+ *		field.
+ *
+ * INPUTS:
+ *		devNum - Device Number (0 ~ 31)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetDeviceNumber
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_U32  		devNum
+		);
+
+/*******************************************************************************
+ * gsysGetDeviceNumber
+ *
+ * DESCRIPTION:
+ *		This routine gets Device Number.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		devNum - Device Number (0 ~ 31)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetDeviceNumber
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_U32  	*devNum
+		);
+
+
+/* gtPCSCtrl.c */
+
+
+/*******************************************************************************
+ * gpcsGetCommaDet
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Comma Detection status in PCS
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetCommaDet
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsGetSyncOK
+ *
+ * DESCRIPTION:
+ *		This routine retrieves SynOK bit. It is set to a one when the PCS has
+ *		detected a few comma patterns and is synchronized with its peer PCS 
+ *		layer.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if synchronized or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetSyncOK
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsGetSyncFail
+ *
+ * DESCRIPTION:
+ *		This routine retrieves SynFail bit.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetSyncFail
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsGetAnBypassed
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Inband Auto-Negotiation bypass status.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetAnBypassed
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsGetAnBypassMode
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetAnBypassMode
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*mode
+		);
+
+/*******************************************************************************
+ * gpcsSetAnBypassMode
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetAnBypassMode
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL  	mode
+		);
+
+/*******************************************************************************
+ * gpcsGetPCSAnEn
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetPCSAnEn
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*mode
+		);
+
+/*******************************************************************************
+ * gpcsSetPCSAnEn
+ *
+ * DESCRIPTION:
+ *		This routine sets Enable mode of PCS Inband Auto-Negotiation.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetPCSAnEn
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL  	mode
+		);
+
+/*******************************************************************************
+ * gpcsSetRestartPCSAn
+ *
+ * DESCRIPTION:
+ *		This routine restarts PCS Inband Auto-Negotiation.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetRestartPCSAn
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port
+		);
+
+/*******************************************************************************
+ * gpcsGetPCSAnDone
+ *
+ * DESCRIPTION:
+ *		This routine retrieves completion information of PCS Auto-Negotiation.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE if PCS AN is done or never done
+ *			    GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetPCSAnDone
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*mode
+		);
+
+/*******************************************************************************
+ * gpcsSetLinkValue
+ *
+ * DESCRIPTION:
+ *		This routine sets Link's force value
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force link up, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetLinkValue
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN	GT_BOOL		state
+		);
+
+/*******************************************************************************
+ * gpcsGetLinkValue
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Link Value which will be used for Forcing Link 
+ *		up or down.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if Link Force value is one (link up)
+ *			     GT_FALSE otherwise (link down)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetLinkValue
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsSetForcedLink
+ *
+ * DESCRIPTION:
+ *		This routine forces Link. If LinkValue is set to one, calling this 
+ *		routine with GT_TRUE will force Link to be up.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force link (up or down), GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetForcedLink
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN	GT_BOOL		state
+		);
+
+/*******************************************************************************
+ * gpcsGetForcedLink
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Forced Link bit
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if ForcedLink bit is one,
+ *			     GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetForcedLink
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsSetDpxValue
+ *
+ * DESCRIPTION:
+ *		This routine sets Duplex's Forced value. This function needs to be
+ *		called prior to gpcsSetForcedDpx.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force full duplex, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetDpxValue
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN	GT_BOOL		state
+		);
+
+/*******************************************************************************
+ * gpcsGetDpxValue
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Duplex's Forced value
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if Duplex's Forced value is set to Full duplex,
+ *			     GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetDpxValue
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsSetForcedDpx
+ *
+ * DESCRIPTION:
+ *		This routine forces duplex mode. If DpxValue is set to one, calling this 
+ *		routine with GT_TRUE will force duplex mode to be full duplex.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force duplex mode, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetForcedDpx
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN	GT_BOOL		state
+		);
+
+/*******************************************************************************
+ * gpcsGetForcedDpx
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Forced Duplex.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if ForcedDpx bit is one,
+ *			     GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetForcedDpx
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsSetForceSpeed
+ *
+ * DESCRIPTION:
+ *		This routine forces speed. 
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or No Speed Force)
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetForceSpeed
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN	GT_PORT_FORCED_SPEED_MODE  mode
+		);
+
+/*******************************************************************************
+ * gpcsGetForceSpeed
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Force Speed value
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetForceSpeed
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_PORT_FORCED_SPEED_MODE   *mode
+		);
+
+
+
+/* gtQosMap.c */
+
+/*******************************************************************************
+ * gqosGetTagRemap
+ *
+ * DESCRIPTION:
+ *		Gets the remapped priority value for a specific 802.1p priority on a
+ *		given port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *		pri   - 802.1p priority
+ *
+ * OUTPUTS:
+ *		remappedPri - remapped Priority
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gqosGetTagRemap
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		IN  GT_U8    	pri,
+		OUT GT_U8   	*remappedPri
+		);
+
+/*******************************************************************************
+ * gqosSetTagRemap
+ *
+ * DESCRIPTION:
+ *		Sets the remapped priority value for a specific 802.1p priority on a
+ *		given port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *		pri   - 802.1p priority
+ *		remappedPri - remapped Priority
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gqosSetTagRemap
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_U8    	pri,
+		IN GT_U8    	remappedPri
+		);
+
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+/*******************************************************************************
+ * gsysGetPPUState
+ *
+ * DESCRIPTION:
+ *		This routine get the PPU State. These two bits return 
+ *		the current value of the PPU.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		mode - GT_PPU_STATE
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_BAD_PARAM    - on bad parameter
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetPPUState
+	(
+		IN  GT_QD_DEV   	*dev,
+		OUT GT_PPU_STATE	*mode
+		);
+
+
+/* Prototypes added for 88E6093 */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+ * gfdbGetLearn2All
+ *
+ * DESCRIPTION:
+ *		When more than one Marvell device is used to form a single 'switch', it
+ *		may be desirable for all devices in the 'switch' to learn any address this 
+ *		device learns. When this bit is set to a one all other devices in the 
+ *		'switch' learn the same addresses this device learns. When this bit is 
+ *		cleared to a zero, only the devices that actually receive frames will learn
+ *		from those frames. This mode typically supports more active MAC addresses 
+ *		at one time as each device in the switch does not need to learn addresses 
+ *		it may nerver use.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK           - on success
+ *		GT_FAIL         - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbGetLearn2All
+	(
+		IN  GT_QD_DEV    *dev,
+		OUT GT_BOOL 	*mode
+		);
+
+/*******************************************************************************
+ * gfdbSetLearn2All
+ *
+ * DESCRIPTION:
+ *		Enable or disable Learn2All mode.
+ *
+ * INPUTS:
+ *		mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbSetLearn2All
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gfdbRemovePort
+ *
+ * DESCRIPTION:
+ *       This routine deassociages all or unblocked addresses from a port.
+ *
+ * INPUTS:
+ *       moveCmd - the move operation type.
+ *       port - the logical port number.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbRemovePort
+	(
+		IN GT_QD_DEV    *dev,
+		IN GT_MOVE_CMD 	moveCmd,
+		IN GT_LPORT		port
+		);
+
+/*******************************************************************************
+ * gfdbRemovePortInDB
+ *
+ * DESCRIPTION:
+ *       This routine deassociages all or unblocked addresses from a port in the
+ *       particular ATU Database (DBNum).
+ *
+ * INPUTS:
+ *       moveCmd  - the move operation type.
+ *       port - the logical port number.
+ *		DBNum	 - ATU MAC Address Database Number.
+ *
+ * OUTPUTS:
+ *       None
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *       GT_NOT_SUPPORTED- if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gfdbRemovePortInDB
+	(
+		IN GT_QD_DEV    *dev,
+		IN GT_MOVE_CMD 	moveCmd,
+		IN GT_LPORT		port,
+		IN GT_U8 		DBNum
+		);
+
+
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/* gtPCSCtrl.c */
+
+/*******************************************************************************
+ * gpcsGetPCSLink
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Link up status in PCS
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetPCSLink
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsSetFCValue
+ *
+ * DESCRIPTION:
+ *		This routine sets Flow Control's force value
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetFCValue
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN	GT_BOOL		state
+		);
+
+/*******************************************************************************
+ * gpcsGetFCValue
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Flow Control Value which will be used for Forcing 
+ *		Flow Control enabled or disabled.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if FC Force value is one (flow control enabled)
+ *			     GT_FALSE otherwise (flow control disabled)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetFCValue
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gpcsSetForcedFC
+ *
+ * DESCRIPTION:
+ *		This routine forces Flow Control. If FCValue is set to one, calling this 
+ *		routine with GT_TRUE will force Flow Control to be enabled.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsSetForcedFC
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN	GT_BOOL		state
+		);
+
+/*******************************************************************************
+ * gpcsGetForcedFC
+ *
+ * DESCRIPTION:
+ *		This routine retrieves Forced Flow Control bit
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE if ForcedFC bit is one,
+ *			     GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *		
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gpcsGetForcedFC
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+ * gprtGetPagedPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine reads phy register of the given page
+ *
+ * INPUTS:
+ *		port 	- port to be read
+ *		regAddr	- register offset to be read
+ *		page	- page number to be read
+ *
+ * OUTPUTS:
+ *		data	- value of the read register
+ *
+ * RETURNS:
+ *       GT_OK   			- if read successed
+ *       GT_FAIL   			- if read failed
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPagedPhyReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U32  port,
+		IN	GT_U32  regAddr,
+		IN	GT_U32  page,
+		OUT GT_U16* data
+		);
+
+/*******************************************************************************
+ * gprtSetPagedPhyReg
+ *
+ * DESCRIPTION:
+ *       This routine writes a value to phy register of the given page
+ *
+ * INPUTS:
+ *		port 	- port to be read
+ *		regAddr	- register offset to be read
+ *		page	- page number to be read
+ *		data	- value of the read register
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *       GT_OK   			- if read successed
+ *       GT_FAIL   			- if read failed
+ *
+ * COMMENTS:
+ *       None.
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetPagedPhyReg
+	(
+		IN  GT_QD_DEV *dev,
+		IN  GT_U32 port,
+		IN	GT_U32 regAddr,
+		IN	GT_U32 page,
+		IN  GT_U16 data
+		);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+ * gprtSetUseCoreTag
+ *
+ * DESCRIPTION:
+ *       This routine set the UseCoreTag bit in Port Control Register.
+ *			When this bit is cleared to a zero, ingressing frames are considered
+ *			Tagged if the 16-bits following the frame's Source Address is 0x8100.
+ *			When this bit is set to a one, ingressing frames are considered Tagged
+ *			if the 16-bits following the frame's Source Address is equal to the 
+ *			CoreTag register value.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *       None.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetUseCoreTag
+	(
+		IN GT_QD_DEV  *dev,
+		IN GT_LPORT   port,
+		IN GT_BOOL    force
+		);
+
+/*******************************************************************************
+ * gprtGetUseCoreTag
+ *
+ * DESCRIPTION:
+ *       This routine get the Use Core Tag state.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetUseCoreTag
+	(
+		IN  GT_QD_DEV  *dev,
+		IN  GT_LPORT   port,
+		OUT GT_BOOL    *force
+		);
+
+/*******************************************************************************
+ * gprtSetDiscardTagged
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one, all non-MGMT frames that are processed as 
+ *		Tagged will be discarded as they enter this switch port. Priority only 
+ *		tagged frames (with a VID of 0x000) are considered tagged.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetDiscardTagged
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetDiscardTagged
+ *
+ * DESCRIPTION:
+ *		This routine gets DiscardTagged bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetDiscardTagged
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*mode
+		);
+
+/*******************************************************************************
+ * gprtSetDiscardUntagged
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one, all non-MGMT frames that are processed as 
+ *		Untagged will be discarded as they enter this switch port. Priority only 
+ *		tagged frames (with a VID of 0x000) are considered tagged.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetDiscardUntagged
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetDiscardUntagged
+ *
+ * DESCRIPTION:
+ *		This routine gets DiscardUntagged bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetDiscardUntagged
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*mode
+		);
+
+/*******************************************************************************
+ * gprtSetMapDA
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one, normal switch operation will occur where a 
+ *		frame's DA address is used to direct the frame out the correct port.
+ *		When this be is cleared to a zero, the frame will be sent out the port(s) 
+ *		defined by ForwardUnknown bits or the DefaultForward bits even if the DA 
+ *		is ound in the address database.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetMapDA
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetMapDA
+ *
+ * DESCRIPTION:
+ *		This routine gets MapDA bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetMapDA
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*mode
+		);
+
+/*******************************************************************************
+ * gprtSetDefaultForward
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one, normal switch operation will occurs and 
+ *		multicast frames with unknown DA addresses are allowed to egress out this 
+ *		port (assuming the VLAN settings allow the frame to egress this port too).
+ *		When this be is cleared to a zero, multicast frames with unknown DA 
+ *		addresses will not egress out this port.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetDefaultForward
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetDefaultForward
+ *
+ * DESCRIPTION:
+ *		This routine gets DefaultForward bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetDefaultForward
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*mode
+		);
+
+/*******************************************************************************
+ * gprtSetEgressMonitorSource
+ *
+ * DESCRIPTION:
+ *		When this be is cleared to a zero, normal network switching occurs.
+ *		When this bit is set to a one, any frame that egresses out this port will
+ *		also be sent to the EgressMonitorDest Port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetEgressMonitorSource
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetEgressMonitorSource
+ *
+ * DESCRIPTION:
+ *		This routine gets EgressMonitorSource bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetEgressMonitorSource
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*mode
+		);
+
+/*******************************************************************************
+ * gprtSetIngressMonitorSource
+ *
+ * DESCRIPTION:
+ *		When this be is cleared to a zero, normal network switching occurs.
+ *		When this bit is set to a one, any frame that egresses out this port will
+ *		also be sent to the EgressMonitorDest Port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetIngressMonitorSource
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetIngressMonitorSource
+ *
+ * DESCRIPTION:
+ *		This routine gets IngressMonitorSource bit for the given port
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetIngressMonitorSource
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*mode
+		);
+
+
+/* gtPortPAV.c */
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+ * gstatsGetPortCounter3
+ *
+ * DESCRIPTION:
+ *		This routine gets a specific counter of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		counter - the counter which will be read
+ *
+ * OUTPUTS:
+ *		statsData - points to 32bit data storage for the MIB counter
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsGetPortCounter3
+	(
+		IN  GT_QD_DEV		*dev,
+		IN  GT_LPORT		port,
+		IN  GT_STATS_COUNTERS3	counter,
+		OUT GT_U32			*statsData
+		);
+
+/*******************************************************************************
+ * gstatsGetPortAllCounters3
+ *
+ * DESCRIPTION:
+ *		This routine gets all counters of the given port
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+ *
+ * RETURNS:
+ *		GT_OK      - on success
+ *		GT_FAIL    - on error
+ *
+ * COMMENTS:
+ *		This function supports Gigabit Switch only
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gstatsGetPortAllCounters3
+	(
+		IN  GT_QD_DEV		*dev,
+		IN  GT_LPORT		port,
+		OUT GT_STATS_COUNTER_SET3	*statsCounterSet
+		);
+
+
+/* gtPortStat.c */
+
+/*******************************************************************************
+ * gprtGetPortCtr2
+ *
+ * DESCRIPTION:
+ *       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
+ *
+ * INPUTS:
+ *       port  - the logical port number.
+ *
+ * OUTPUTS:
+ *       ctr - the counters value.
+ *
+ * RETURNS:
+ *       GT_OK   - on success
+ *       GT_FAIL - on error
+ *
+ * COMMENTS:
+ *
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetPortCtr2
+	(
+		IN  GT_QD_DEV       *dev,
+		IN  GT_LPORT        port,
+		OUT GT_PORT_STAT2   *ctr
+		);
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+ * gprtGetMGMII
+ *
+ * DESCRIPTION:
+ *		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+ *		detected connected to this port, the SERDES interface between this port
+ *		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+ *		detected connected to this port, the SERDES interface between this port 
+ *		and the PHY will be MGMII. When no PHY is detected on this port and the 
+ *		SERDES interface is being used, it will be configured in 1000Base-X mode.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		state - GT_TRUE or GT_FALSE
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetMGMII
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		OUT GT_BOOL  	*state
+		);
+
+/*******************************************************************************
+ * gprtSetMGMII
+ *
+ * DESCRIPTION:
+ *		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+ *		detected connected to this port, the SERDES interface between this port
+ *		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+ *		detected connected to this port, the SERDES interface between this port 
+ *		and the PHY will be MGMII. When no PHY is detected on this port and the 
+ *		SERDES interface is being used, it will be configured in 1000Base-X mode.
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		state - GT_TRUE or GT_FALSE
+ *
+ * OUTPUTS:
+ *		None
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetMGMII
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT 	port,
+		IN  GT_BOOL  	state
+		);
+
+
+/* gtQosMap.c */
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+ * gsysSetCoreTagType
+ *
+ * DESCRIPTION:
+ *		This routine sets Ether Core Tag Type.
+ *		This Ether Type is added to frames that egress the switch as Double Tagged 
+ *		frames. It is also the Ether Type expected during Ingress to determine if 
+ *		a frame is Tagged or not on ports configured as UseCoreTag mode.
+ *
+ * INPUTS:
+ *		etherType - Core Tag Type (2 bytes)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetCoreTagType
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_U16  		etherType
+		);
+
+/*******************************************************************************
+ * gsysGetCoreTagType
+ *
+ * DESCRIPTION:
+ *		This routine gets CoreTagType
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		etherType - Core Tag Type (2 bytes)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetCoreTagType
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_U16  	*etherType
+		);
+
+/*******************************************************************************
+ * gsysSetIngressMonitorDest
+ *
+ * DESCRIPTION:
+ *		This routine sets Ingress Monitor Destination Port. Frames that are 
+ *		targeted toward an Ingress Monitor Destination go out the port number 
+ *		indicated in these bits. This includes frames received on a Marvell Tag port
+ *		with the Ingress Monitor type, and frames received on a Network port that 
+ *		is enabled to be the Ingress Monitor Source Port.
+ *		If the Ingress Monitor Destination Port resides in this device these bits 
+ *		should point to the Network port where these frames are to egress. If the 
+ *		Ingress Monitor Destination Port resides in another device these bits 
+ *		should point to the Marvell Tag port in this device that is used to get 
+ *		to the device that contains the Ingress Monitor Destination Port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetIngressMonitorDest
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port
+		);
+
+/*******************************************************************************
+ * gsysGetIngressMonitorDest
+ *
+ * DESCRIPTION:
+ *		This routine gets Ingress Monitor Destination Port.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		port  - the logical port number.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetIngressMonitorDest
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_LPORT  	*port
+		);
+
+/*******************************************************************************
+ * gsysSetEgressMonitorDest
+ *
+ * DESCRIPTION:
+ *		This routine sets Egress Monitor Destination Port. Frames that are 
+ *		targeted toward an Egress Monitor Destination go out the port number 
+ *		indicated in these bits. This includes frames received on a Marvell Tag port
+ *		with the Egress Monitor type, and frames transmitted on a Network port that 
+ *		is enabled to be the Egress Monitor Source Port.
+ *		If the Egress Monitor Destination Port resides in this device these bits 
+ *		should point to the Network port where these frames are to egress. If the 
+ *		Egress Monitor Destination Port resides in another device these bits 
+ *		should point to the Marvell Tag port in this device that is used to get 
+ *		to the device that contains the Egress Monitor Destination Port.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetEgressMonitorDest
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port
+		);
+
+/*******************************************************************************
+ * gsysGetEgressMonitorDest
+ *
+ * DESCRIPTION:
+ *		This routine gets Egress Monitor Destination Port.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		port  - the logical port number.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetEgressMonitorDest
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_LPORT  	*port
+		);
+
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+
+/* functions added on rev 2.2 */
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+ * gprtSetMessagePort
+ *
+ * DESCRIPTION:
+ *		When the Learn2All bit is set to one, learning message frames are 
+ *		generated. These frames will be sent out all ports whose Message Port is 
+ *		set to one.
+ * 		If this feature is used, it is recommended that all Marvell Tag ports, 
+ *		except for the CPU's port, have their MessagePort bit set to one. 
+ *		Ports that are not Marvell Tag ports should not have their Message Port
+ *		bit set to one.
+ *		
+ *
+ * INPUTS:
+ *		port - the logical port number.
+ *		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetMessagePort
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL		mode
+		);
+
+/*******************************************************************************
+ * gprtGetMessagePort
+ *
+ * DESCRIPTION:
+ *		When the Learn2All bit is set to one, learning message frames are 
+ *		generated. These frames will be sent out all ports whose Message Port is 
+ *		set to one.
+ * 		If this feature is used, it is recommended that all Marvell Tag ports, 
+ *		except for the CPU's port, have their MessagePort bit set to one. 
+ *		Ports that are not Marvell Tag ports should not have their Message Port
+ *		bit set to one.
+ *
+ *		
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetMessagePort
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_LPORT	port,
+		OUT GT_BOOL 	*mode
+		);
+
+
+/*******************************************************************************
+ * gprtSetTrunkPort
+ *
+ * DESCRIPTION:
+ *		This function enables/disables and sets the trunk ID.
+ *		
+ * INPUTS:
+ *		port - the logical port number.
+ *		en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+ *			 GT_FALSE, otherwise.
+ *		trunkId - valid ID is 0 ~ 15.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetTrunkPort
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		IN GT_BOOL 		en,
+		IN GT_U32		trunkId
+		);
+
+
+/*******************************************************************************
+ * gprtGetTrunkPort
+ *
+ * DESCRIPTION:
+ *		This function returns trunk state of the port.
+ *		When trunk is disabled, trunkId field won't have valid value.
+ *		
+ * INPUTS:
+ *		port - the logical port number.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE, if the port is a member of a trunk,
+ *			 GT_FALSE, otherwise.
+ *		trunkId - 0 ~ 15, valid only if en is GT_TRUE
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS: 
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetTrunkPort
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT 	port,
+		OUT GT_BOOL 	*en,
+		OUT GT_U32		*trunkId
+		);
+
+
+
+
+/*******************************************************************************
+ * gprtGetGlobal2Reg
+ *
+ * DESCRIPTION:
+ *       This routine reads Switch Global 2 Registers.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtGetGlobal2Reg
+	(
+		IN  GT_QD_DEV    *dev,
+		IN  GT_U32	     regAddr,
+		OUT GT_U16	     *data
+		);
+
+/*******************************************************************************
+ * gprtSetGlobal2Reg
+ *
+ * DESCRIPTION:
+ *       This routine writes Switch Global2 Registers.
+ *
+ * INPUTS:
+ *       regAddr - The register's address.
+ *
+ * OUTPUTS:
+ *       data    - The read register's data.
+ *
+ * RETURNS:
+ *       GT_OK           - on success
+ *       GT_FAIL         - on error
+ *
+ * COMMENTS:
+ *       None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gprtSetGlobal2Reg
+	(
+		IN  GT_QD_DEV		*dev,
+		IN  GT_U32			regAddr,
+		IN  GT_U16			data
+		);
+
+/* gtSysCtrl.c */
+/*******************************************************************************
+ * gsysSetARPDest
+ *
+ * DESCRIPTION:
+ *		This routine sets ARP Monitor Destination Port. Tagged or untagged 
+ *		frames that ingress Network ports with the Broadcast Destination Address 
+ *		and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+ *		should point to the port that directs these frames to the switch's CPU 
+ *		that will process ARPs. This target port should be a Marvell Tag port so 
+ *		that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+ *		To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+ *		Tag port will be sent to the port number definded in ARPDest.
+ *
+ *		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP 
+ *		frames will be discarded.
+ *
+ * INPUTS:
+ *		port  - the logical port number.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetARPDest
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_LPORT		port
+		);
+
+/*******************************************************************************
+ * gsysGetARPDest
+ *
+ * DESCRIPTION:
+ *		This routine gets ARP Monitor Destination Port. Tagged or untagged 
+ *		frames that ingress Network ports with the Broadcast Destination Address 
+ *		and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+ *		should point to the port that directs these frames to the switch's CPU 
+ *		that will process ARPs. This target port should be a Marvell Tag port so 
+ *		that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+ *		To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+ *		Tag port will be sent to the port number definded in ARPDest.
+ *
+ *		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP 
+ *		frames will be discarded.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		port  - the logical port number.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetARPDest
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_LPORT  	*port
+		);
+
+/*******************************************************************************
+ * gsysSetRsvd2CpuEnables
+ *
+ * DESCRIPTION:
+ *		Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with 
+ *		en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this 
+ *		enBits(or register) are also set to a one, are treated as MGMT frames. 
+ *		All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0, 
+ *		bit 0 of this register is tested. When x = 0x2, bit 2 of this field is 
+ *		tested and so on.
+ *		If the tested bit in this register is cleared to a zero, the frame will 
+ *		be treated as a normal (non-MGMT) frame.
+ *
+ * INPUTS:
+ *		enBits - bit vector of enabled Reserved Multicast.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetRsvd2CpuEnables
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_U16		enBits
+		);
+
+/*******************************************************************************
+ * gsysGetRsvd2CpuEnables
+ *
+ * DESCRIPTION:
+ *		Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with 
+ *		en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this 
+ *		enBits(or register) are also set to a one, are treated as MGMT frames. 
+ *		All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0, 
+ *		bit 0 of this register is tested. When x = 0x2, bit 2 of this field is 
+ *		tested and so on.
+ *		If the tested bit in this register is cleared to a zero, the frame will 
+ *		be treated as a normal (non-MGMT) frame.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		enBits - bit vector of enabled Reserved Multicast.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetRsvd2CpuEnables
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_U16  	*enBits
+		);
+
+/*******************************************************************************
+ * gsysSetRsvd2Cpu
+ *
+ * DESCRIPTION:
+ *		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+ *		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+ *		membership, will be considered MGMT frames and sent to the port's CPU 
+ *		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+ *		function) for the frames's DA is also set to a one.
+ *
+ * INPUTS:
+ *		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetRsvd2Cpu
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_BOOL		en
+		);
+
+/*******************************************************************************
+ * gsysGetRsvd2Cpu
+ *
+ * DESCRIPTION:
+ *		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+ *		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+ *		membership, will be considered MGMT frames and sent to the port's CPU 
+ *		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+ *		function) for the frames's DA is also set to a one.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetRsvd2Cpu
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_BOOL  	*en
+		);
+
+/*******************************************************************************
+ * gsysSetMGMTPri
+ *
+ * DESCRIPTION:
+ *		These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+ *
+ * INPUTS:
+ *		pri - PRI[2:0] bits (should be less than 8)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - If pri is not less than 8.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetMGMTPri
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_U16		pri
+		);
+
+/*******************************************************************************
+ * gsysGetMGMTPri
+ *
+ * DESCRIPTION:
+ *		These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		pri - PRI[2:0] bits (should be less than 8)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetMGMTPri
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_U16  	*pri
+		);
+
+/*******************************************************************************
+ * gsysSetUseDoubleTagData
+ *
+ * DESCRIPTION:
+ *		This bit is used to determine if Double Tag data that is removed from a 
+ *		Double Tag frame is used or ignored when making switching decisions on 
+ *		the frame.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetUseDoubleTagData
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_BOOL		en
+		);
+
+/*******************************************************************************
+ * gsysGetUseDoubleTagData
+ *
+ * DESCRIPTION:
+ *		This bit is used to determine if Double Tag data that is removed from a 
+ *		Double Tag frame is used or ignored when making switching decisions on 
+ *		the frame.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetUseDoubleTagData
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_BOOL  	*en
+		);
+
+/*******************************************************************************
+ * gsysSetPreventLoops
+ *
+ * DESCRIPTION:
+ *		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+ *		field equals this device's Device Number, the following action will be 
+ *		taken depending upon the value of this bit.
+ *		GT_TRUE (1) - The frame will be discarded.
+ *		GT_FALSE(0) - The frame will be prevented from going out its original 
+ *						source port as defined by the frame's Src_Port field.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetPreventLoops
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_BOOL		en
+		);
+
+/*******************************************************************************
+ * gsysGetPreventLoops
+ *
+ * DESCRIPTION:
+ *		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+ *		field equals this device's Device Number, the following action will be 
+ *		taken depending upon the value of this bit.
+ *		GT_TRUE (1) - The frame will be discarded.
+ *		GT_FALSE(0) - The frame will be prevented from going out its original 
+ *						source port as defined by the frame's Src_Port field.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetPreventLoops
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_BOOL  	*en
+		);
+
+/*******************************************************************************
+ * gsysSetFlowControlMessage
+ *
+ * DESCRIPTION:
+ *		When this bit is set to one, Marvell Tag Flow Control messages will be 
+ *		generated when an output queue becomes congested and received Marvell Tag 
+ *		Flow Control messages will pause MACs inside this device. When this bit 
+ *		is cleared to a zero, Marvell Tag Flow Control messages will not be 
+ *		generated and any received will be ignored at the target MAC.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetFlowControlMessage
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_BOOL		en
+		);
+
+/*******************************************************************************
+ * gsysGetFlowControlMessage
+ *
+ * DESCRIPTION:
+ *		When this bit is set to one, Marvell Tag Flow Control messages will be 
+ *		generated when an output queue becomes congested and received Marvell Tag 
+ *		Flow Control messages will pause MACs inside this device. When this bit 
+ *		is cleared to a zero, Marvell Tag Flow Control messages will not be 
+ *		generated and any received will be ignored at the target MAC.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetFlowControlMessage
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_BOOL  	*en
+		);
+
+/*******************************************************************************
+ * gsysSetForceFlowControlPri
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+ *		Flow Control frames will be set to the value of the FC Pri bits (set by 
+ *		gsysSetFCPri function call). When this bit is cleared to a zero, generated 
+ *		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+ *		frames that caused the congestion. This bit will have no effect if the 
+ *		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+ *		cleared to a zero.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetForceFlowControlPri
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_BOOL		en
+		);
+
+/*******************************************************************************
+ * gsysGetForceFlowControlPri
+ *
+ * DESCRIPTION:
+ *		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+ *		Flow Control frames will be set to the value of the FC Pri bits (set by 
+ *		gsysSetFCPri function call). When this bit is cleared to a zero, generated 
+ *		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+ *		frames that caused the congestion. This bit will have no effect if the 
+ *		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+ *		cleared to a zero.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetForceFlowControlPri
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_BOOL  	*en
+		);
+
+/*******************************************************************************
+ * gsysSetFCPri
+ *
+ * DESCRIPTION:
+ *		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+ *		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+ *		is set to a one.
+ *
+ * INPUTS:
+ *		pri - PRI[2:0] bits (should be less than 8)
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - If pri is not less than 8.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetFCPri
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_U16		pri
+		);
+
+/*******************************************************************************
+ * gsysGetFCPri
+ *
+ * DESCRIPTION:
+ *		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+ *		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+ *		is set to a one.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		pri - PRI[2:0] bits (should be less than 8)
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetFCPri
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_U16  	*pri
+		);
+
+/*******************************************************************************
+ * gsysSetFlowCtrlDelay
+ *
+ * DESCRIPTION:
+ *		This function sets Flow control delay time for 10Mbps, 100Mbps, and 
+ *		1000Mbps. 
+ *
+ * INPUTS:
+ *		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+ *		delayTime - actual delay time will be (this value x 2.048uS).
+ *					the value cannot exceed 0x1FFF (or 8191 in decimal).
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetFlowCtrlDelay
+	(
+		IN GT_QD_DEV			*dev,
+		IN GT_PORT_SPEED_MODE	sp,
+		IN GT_U32				delayTime
+		);
+
+/*******************************************************************************
+ * gsysGetFlowCtrlDelay
+ *
+ * DESCRIPTION:
+ *		This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+ *		1000Mbps. 
+ *
+ * INPUTS:
+ *		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+ *
+ * OUTPUTS:
+ *		delayTime - actual delay time will be (this value x 2.048uS).
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetFlowCtrlDelay
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_PORT_SPEED_MODE	sp,
+		OUT GT_U32		*delayTime
+		);
+
+/*******************************************************************************
+ * gsysSetDevRoutingTable
+ *
+ * DESCRIPTION:
+ *		This function sets Device to Port mapping (which device is connected to 
+ *		which port of this device). 
+ *
+ * INPUTS:
+ *		devNum - target device number.
+ *		portNum - the logical port number.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if devNum >= 32 or port >= total number of ports.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetDevRoutingTable
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_U32  		devNum,
+		IN GT_LPORT 	port
+		);
+
+/*******************************************************************************
+ * gsysGetDevRoutingTable
+ *
+ * DESCRIPTION:
+ *		This function gets Device to Port mapping (which device is connected to 
+ *		which port of this device). 
+ *
+ * INPUTS:
+ *		devNum - target device number.
+ *
+ * OUTPUTS:
+ *		portNum - the logical port number.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if devNum >= 32
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetDevRoutingTable
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_U32 		devNum,
+		OUT GT_LPORT 	*port
+		);
+
+/*******************************************************************************
+ * gsysSetTrunkMaskTable
+ *
+ * DESCRIPTION:
+ *		This function sets Trunk mask vector table for load balancing.
+ *		This vector will be AND'ed with where the frame was originally egressed to.
+ *		To insure all trunks are load balanced correctly, the data in this table
+ *		needs to be correctly configured.
+ *
+ * INPUTS:
+ *		trunkNum - one of the eight Trunk mask vectors.
+ *		trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+ *					bit 1 for port 1 , etc.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkNum > 0x7 or trunMask > 0x7FF (or port vector).
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetTrunkMaskTable
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_U32  		trunkNum,
+		IN GT_U32		trunkMask
+		);
+
+/*******************************************************************************
+ * gsysGetTrunkMaskTable
+ *
+ * DESCRIPTION:
+ *		This function sets Trunk mask vector table for load balancing.
+ *		This vector will be AND'ed with where the frame was originally egressed to.
+ *		To insure all trunks are load balanced correctly, the data in this table
+ *		needs to be correctly configured.
+ *
+ * INPUTS:
+ *		trunkNum - one of the eight Trunk mask vectors.
+ *
+ * OUTPUTS:
+ *		trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+ *					bit 1 for port 1 , etc.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkNum > 0x7.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetTrunkMaskTable
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_U32 		trunkNum,
+		OUT GT_U32		*trunkMask
+		);
+
+/*******************************************************************************
+ * gsysSetHashTrunk
+ *
+ * DESCRIPTION:
+ *		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+ *		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+ *		When this bit is set to a one, the hashed computed for address table 
+ *		lookups is used for the TrunkMask selection. When this bit is cleared to 
+ *		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+ *		select the TrunkMask to use.
+ *
+ * INPUTS:
+ *		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetHashTrunk
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_BOOL		en
+		);
+
+/*******************************************************************************
+ * gsysGetHashTrunk
+ *
+ * DESCRIPTION:
+ *		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+ *		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+ *		When this bit is set to a one, the hashed computed for address table 
+ *		lookups is used for the TrunkMask selection. When this bit is cleared to 
+ *		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+ *		select the TrunkMask to use.
+ *
+ * INPUTS:
+ *		None.
+ *
+ * OUTPUTS:
+ *		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetHashTrunk
+	(
+		IN  GT_QD_DEV	*dev,
+		OUT GT_BOOL  	*en
+		);
+
+/*******************************************************************************
+ * gsysSetTrunkRouting
+ *
+ * DESCRIPTION:
+ *		This function sets routing information for the given Trunk ID.
+ *
+ * INPUTS:
+ *		trunkId - Trunk ID.
+ *		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+ *					bit 1 for port 1 , etc.
+ *
+ * OUTPUTS:
+ *		None.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkId > 0xF or trunkRoute > 0x7FF(or port vector).
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysSetTrunkRouting
+	(
+		IN GT_QD_DEV	*dev,
+		IN GT_U32  		trunkId,
+		IN GT_U32		trunkRoute
+		);
+
+/*******************************************************************************
+ * gsysGetTrunkRouting
+ *
+ * DESCRIPTION:
+ *		This function retrieves routing information for the given Trunk ID.
+ *
+ * INPUTS:
+ *		trunkId - Trunk ID.
+ *
+ * OUTPUTS:
+ *		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+ *					bit 1 for port 1 , etc.
+ *
+ * RETURNS:
+ *		GT_OK   - on success
+ *		GT_FAIL - on error
+ *		GT_BAD_PARAM - if trunkId > 0xF.
+ *		GT_NOT_SUPPORTED - if current device does not support this feature.
+ *
+ * COMMENTS:
+ *		None.
+ *
+ * GalTis:
+ *
+ *******************************************************************************/
+	GT_STATUS gsysGetTrunkRouting
+	(
+		IN  GT_QD_DEV	*dev,
+		IN  GT_U32 		trunkId,
+		OUT GT_U32		*trunkRoute
+		);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApi_h */
Index: linux-2.6.16/include/linux/marvell/msApiTypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/msApiTypes.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,124 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_types.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 12/24/02 5:37p $
+ *
+ * DESCRIPTION:
+ *     This file defines common data types used on Host and NetGX sides.
+ */
+
+
+#ifndef __msApiTypes_h
+#define __msApiTypes_h
+
+
+/* general */
+
+#undef IN
+#define IN
+#undef OUT
+#define OUT
+#undef INOUT
+#define INOUT
+
+
+#ifndef NULL
+#define NULL ((void*)0)
+#endif
+
+typedef void  GT_VOID;
+typedef char  GT_8;
+typedef short GT_16; 
+typedef long  GT_32;
+
+typedef unsigned char  GT_U8;
+typedef unsigned short GT_U16;
+typedef unsigned long  GT_U32;
+typedef unsigned int   GT_UINT; 
+
+typedef union {
+	GT_U8	c[8];
+	GT_U16	s[4];
+	GT_U32	l[2];
+} GT_U64;
+
+
+typedef enum {
+	GT_FALSE = 0,
+	GT_TRUE  = 1
+} GT_BOOL;
+
+typedef void          (*GT_VOIDFUNCPTR) (void); /* ptr to function returning void */
+typedef unsigned int  (*GT_INTFUNCPTR)  (void); /* ptr to function returning int  */
+
+
+/* module state */
+typedef enum {
+	GT_STATE_NONE = 0,	/* Uninitialized */
+	GT_STATE_IDLE,		/* Initialized, but not started (or stopped) */
+	GT_STATE_ACTIVE		/* Started */
+} GT_STATE;
+
+
+#define	GT_ETHERNET_HEADER_SIZE		(6)
+
+typedef struct
+{
+	GT_U8       arEther[GT_ETHERNET_HEADER_SIZE];
+}GT_ETHERADDR;
+
+/* This macro checks for a multicast mac address    */
+#define GT_IS_MULTICAST_MAC(mac)  ((mac.arEther[0] & 0x1) == 1)
+
+
+/* This macro checks for an broadcast mac address     */
+#define GT_IS_BROADCAST_MAC(mac) (((mac).arEther[0] == 0xFF) && ((mac).arEther[1] == 0xFF) && ((mac).arEther[2] == 0xFF) && ((mac).arEther[3] == 0xFF) && ((mac).arEther[4] == 0xFF) && ((mac).arEther[5] == 0xFF))
+
+
+/* status / error codes */
+typedef int GT_STATUS;
+
+#define GT_ERROR		   (-1)
+#define GT_OK			   (0x00)	/* Operation succeeded                   */
+#define GT_FAIL			   (0x01)	/* Operation failed                      */
+#define GT_BAD_VALUE       (0x02)   /* Illegal value (general)               */
+#define GT_OUT_OF_RANGE    (0x03)   /* The value is out of range             */
+#define GT_BAD_PARAM       (0x04)   /* Illegal parameter in function called  */
+#define GT_BAD_PTR         (0x05)   /* Illegal pointer value                 */
+#define GT_BAD_SIZE        (0x06)   /* Illegal size                          */
+#define GT_BAD_STATE       (0x07)   /* Illegal state of state machine        */
+#define GT_SET_ERROR       (0x08)   /* Set operation failed                  */
+#define GT_GET_ERROR       (0x09)   /* Get operation failed                  */
+#define GT_CREATE_ERROR    (0x0A)   /* Fail while creating an item           */
+#define GT_NOT_FOUND       (0x0B)   /* Item not found                        */
+#define GT_NO_MORE         (0x0C)   /* No more items found                   */
+#define GT_NO_SUCH         (0x0D)   /* No such item                          */
+#define GT_TIMEOUT         (0x0E)   /* Time Out                              */
+#define GT_NO_CHANGE       (0x0F)   /* The parameter(s) is already in this value */
+#define GT_NOT_SUPPORTED   (0x10)   /* This request is not support           */
+#define GT_NOT_IMPLEMENTED (0x11)   /* This request is supported but not implemented */
+#define GT_NOT_INITIALIZED (0x12)   /* The item is not initialized           */
+#define GT_NO_RESOURCE     (0x13)   /* Resource not available (memory ...)   */
+#define GT_FULL            (0x14)   /* Item is full (Queue or table etc...)  */
+#define GT_EMPTY           (0x15)   /* Item is empty (Queue or table etc...) */
+#define GT_INIT_ERROR      (0x16)   /* Error occured while INIT process      */
+#define GT_HW_ERROR        (0x17)   /* Hardware error                        */
+#define GT_TX_ERROR        (0x18)   /* Transmit operation not succeeded      */
+#define GT_RCV_ERROR       (0x19)   /* Recieve operation not succeeded       */
+#define GT_NOT_READY	   (0x1A)	/* The other side is not ready yet       */
+#define GT_ALREADY_EXIST   (0x1B)   /* Tried to create existing item         */
+#define GT_OUT_OF_CPU_MEM  (0x1C)   /* Cpu memory allocation failed.         */
+
+
+#endif /* __msApiTypes_h */
Index: linux-2.6.16/include/linux/marvell/msApiWince.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/msApiWince.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,556 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * msApiWince.h
+ *
+ * DESCRIPTION:
+ *       Wince Application need to include only this header file.
+ *
+ * DEPENDENCIES:   None
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#ifndef __msApiFunc_h
+#define __msApiFunc_h
+
+#include <linux/marvell/msApiDefs.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	typedef GT_STATUS (*FGT_PRT_ATUSIZE)(ATU_SIZE);
+	typedef GT_STATUS (*FGT_PRT_U32_U32)(GT_U32*,GT_U32*);
+	typedef GT_STATUS (*FGT_VALUE_U32)(GT_U32);
+	typedef GT_STATUS (*FGT_PTR_U32)(GT_U32*);
+	typedef GT_STATUS (*FGT_PTR_U16)(GT_U16*);
+	typedef GT_STATUS (*FGT_PTR_U32_U32_U32)(GT_U32,GT_U32,GT_U32*);
+	typedef GT_STATUS (*FGT_PTR_ATUENTRY)(GT_ATU_ENTRY*);
+	typedef GT_STATUS (*FGT_PTR_ATUENTRY_BOOL)(GT_ATU_ENTRY*, GT_BOOL*);
+	typedef GT_STATUS (*FGT_VALUE_FLUSHCMD)(GT_FLUSH_CMD);
+	typedef GT_STATUS (*FGT_PTR_ETHERADDR)(GT_ETHERADDR*);
+	typedef GT_STATUS (*FGT_PTR_BOOL)(GT_BOOL*);
+	typedef GT_STATUS (*FGT_VALUE_BOOL)(GT_BOOL);
+	typedef GT_STATUS (*FGT_VALUE_PORT_STPSTATE)(GT_LPORT,GT_PORT_STP_STATE);
+	typedef GT_STATUS (*FGT_PTR_PORT_STPSTATE)(GT_LPORT,GT_PORT_STP_STATE*);
+	typedef GT_STATUS (*FGT_VALUE_PORT_EGRESSMODE)(GT_LPORT,GT_EGRESS_MODE);
+	typedef GT_STATUS (*FGT_PTR_PORT_EGRESSMODE)(GT_LPORT,GT_EGRESS_MODE*);
+	typedef GT_STATUS (*FGT_VALUE_PORT_BOOL)(GT_LPORT,GT_BOOL);
+	typedef GT_STATUS (*FGT_PTR_PORT_BOOL)(GT_LPORT,GT_BOOL*);
+	typedef GT_STATUS (*FGT_VALUE_PORT_PORTS_U8)(GT_LPORT,GT_LPORT*,GT_U8);
+	typedef GT_STATUS (*FGT_PTR_PORT_PORTS_U8)(GT_LPORT,GT_LPORT*,GT_U8*);
+	typedef GT_STATUS (*FGT_VALUE_PORT_U16)(GT_LPORT,GT_U16);
+	typedef GT_STATUS (*FGT_PTR_PORT_U16)(GT_LPORT,GT_U16*);
+	typedef GT_STATUS (*FGT_VALUE_PORT_AUTOMODE)(GT_LPORT,GT_PHY_AUTO_MODE);
+
+	typedef GT_STATUS (*FGT_VALUE_PORT)(GT_LPORT);
+	typedef GT_STATUS (*FGT_VALUE_U8)(GT_U8);
+	typedef GT_STATUS (*FGT_PTR_U8)(GT_U8*);
+	typedef GT_STATUS (*FGT_VALUE_PORT_U8)(GT_LPORT,GT_U8);
+	typedef GT_STATUS (*FGT_PTR_PORT_U8)(GT_LPORT,GT_U8*);
+	typedef GT_STATUS (*FGT_VALUE_PORT_INGRESSMODE)(GT_LPORT,GT_INGRESS_MODE);
+	typedef GT_STATUS (*FGT_PTR_PORT_INGRESSMODE)(GT_LPORT,GT_INGRESS_MODE*);
+	typedef GT_STATUS (*FGT_VALUE_PORT_MCRATE)(GT_LPORT,GT_MC_RATE);
+	typedef GT_STATUS (*FGT_PTR_PORT_MCRATE)(GT_LPORT,GT_MC_RATE*);
+	typedef GT_STATUS (*FGT_VALUE_CTRMODE)(GT_CTR_MODE);
+	typedef GT_STATUS (*FGT_PTR_CTRMODE)(GT_CTR_MODE*);
+	typedef GT_STATUS (*FGT_VOID)(void);
+	typedef GT_STATUS (*FGT_PTR_PORT_PORTSTAT)(GT_LPORT,GT_PORT_STAT*);
+	typedef GT_STATUS (*FGT_VALUE_U8_U8)(GT_U8,GT_U8);
+	typedef GT_STATUS (*FGT_PTR_U8_U8)(GT_U8,GT_U8*);
+	typedef GT_STATUS (*FGT_PTR_CONFIG_INFO)(GT_SYS_CONFIG*,GT_SYS_INFO*);
+	typedef GT_STATUS (*FGT_PTR_VERSION)(GT_VERSION*);
+	typedef GT_STATUS (*FGT_PTR_REGISTER)(BSP_FUNCTIONS*);
+	typedef GT_STATUS (*FGT_PTR_INT_HANDLER)(FGT_INT_HANDLER*);
+
+	typedef GT_STATUS (*FGT_PTR_U32_U32_U16)(GT_U32,GT_U32,GT_U16);
+
+
+	extern FGT_PRT_ATUSIZE 			gfdbSetAtuSize;
+	extern FGT_PRT_U32_U32 			gfdbGetAgingTimeRange;
+	extern FGT_VALUE_U32 			gfdbSetAgingTimeout;
+	extern FGT_PTR_U32 				gfdbGetAtuDynamicCount;
+	extern FGT_PTR_ATUENTRY 		gfdbGetAtuEntryFirst;
+	extern FGT_PTR_ATUENTRY 		gfdbGetAtuEntryNext;
+	extern FGT_PTR_ATUENTRY_BOOL 	gfdbFindAtuMacEntry;
+	extern FGT_VALUE_FLUSHCMD 		gfdbFlush;
+	extern FGT_PTR_ATUENTRY 		gfdbAddMacEntry; //liane
+	extern FGT_PTR_ETHERADDR 		gfdbDelMacEntry;
+	extern FGT_VALUE_BOOL 			gfdbLearnEnable;
+	extern FGT_VALUE_BOOL 				gstpSetMode;
+	extern FGT_VALUE_PORT_STPSTATE 		gstpSetPortState;
+	extern FGT_PTR_PORT_STPSTATE 		gstpGetPortState;
+	extern FGT_VALUE_PORT_EGRESSMODE 	gprtSetEgressMode;
+	extern FGT_PTR_PORT_EGRESSMODE 		gprtGetEgressMode;
+	extern FGT_VALUE_PORT_BOOL 			gprtSetVlanTunnel;
+	extern FGT_PTR_PORT_BOOL 			gprtGetVlanTunnel;
+	extern FGT_VALUE_PORT_PORTS_U8		gvlnSetPortVlanPorts;
+	extern FGT_PTR_PORT_PORTS_U8		gvlnGetPortVlanPorts;
+	extern FGT_VALUE_PORT_BOOL			gvlnSetPortUserPriLsb;
+	extern FGT_PTR_PORT_BOOL			gvlnGetPortUserPriLsb;
+	extern FGT_VALUE_PORT_U16			gvlnSetPortVid;
+	extern FGT_PTR_PORT_U16				gvlnGetPortVid;
+	extern FGT_VALUE_U32				eventSetActive;
+	extern FGT_PTR_U16					eventGetIntStatus;
+	extern FGT_VALUE_PORT				gprtPhyReset;
+	extern FGT_VALUE_PORT_BOOL			gprtSetPortLoopback;
+	extern FGT_VALUE_PORT_BOOL			gprtSetPortSpeed;
+	extern FGT_VALUE_PORT_BOOL			gprtPortAutoNegEnable;
+	extern FGT_VALUE_PORT_BOOL			gprtPortPowerDown;
+	extern FGT_VALUE_PORT				gprtPortRestartAutoNeg;
+	extern FGT_VALUE_PORT_BOOL			gprtSetPortDuplexMode;
+	extern FGT_VALUE_PORT_AUTOMODE		gprtSetPortAutoMode;
+	extern FGT_VALUE_PORT_BOOL			gprtSetPause;
+	extern FGT_VALUE_PORT_U16			gprtPhyIntEnable;
+	extern FGT_PTR_PORT_U16				gprtGetPhyIntStatus;
+	extern FGT_PTR_U16					gprtGetPhyIntPortSummary;
+	extern FGT_VALUE_PORT_BOOL			gprtSetForceFc;
+	extern FGT_PTR_PORT_BOOL			gprtGetForceFc;
+	extern FGT_VALUE_PORT_BOOL			gprtSetTrailerMode;
+	extern FGT_PTR_PORT_BOOL			gprtGetTrailerMode;
+	extern FGT_VALUE_PORT_INGRESSMODE	gprtSetIngressMode;
+	extern FGT_PTR_PORT_INGRESSMODE		gprtGetIngressMode;
+	extern FGT_VALUE_PORT_MCRATE		gprtSetMcRateLimit;
+	extern FGT_PTR_PORT_MCRATE			gprtGetMcRateLimit;
+	extern FGT_VALUE_CTRMODE			gprtSetCtrMode;
+	extern FGT_VOID					gprtClearAllCtr;
+	extern FGT_PTR_PORT_PORTSTAT	gprtGetPortCtr;
+	extern FGT_PTR_PORT_BOOL		gprtGetPartnerLinkPause;
+	extern FGT_PTR_PORT_BOOL		gprtGetSelfLinkPause;
+	extern FGT_PTR_PORT_BOOL		gprtGetResolve;
+	extern FGT_PTR_PORT_BOOL		gprtGetLinkState;
+	extern FGT_PTR_PORT_BOOL		gprtGetPortMode;
+	extern FGT_PTR_PORT_BOOL		gprtGetPhyMode;
+	extern FGT_PTR_PORT_BOOL		gprtGetDuplex;
+	extern FGT_PTR_PORT_BOOL		gprtGetSpeed;
+	extern FGT_VALUE_PORT_U8		gcosSetPortDefaultTc;
+	extern FGT_VALUE_PORT_BOOL		gqosSetPrioMapRule;
+	extern FGT_PTR_PORT_BOOL		gqosGetPrioMapRule;
+	extern FGT_VALUE_PORT_BOOL		gqosIpPrioMapEn;
+	extern FGT_PTR_PORT_BOOL		gqosGetIpPrioMapEn;
+	extern FGT_VALUE_PORT_BOOL		gqosUserPrioMapEn;
+	extern FGT_PTR_PORT_BOOL		gqosGetUserPrioMapEn;
+	extern FGT_PTR_U8_U8			gcosGetUserPrio2Tc;
+	extern FGT_VALUE_U8_U8			gcosSetUserPrio2Tc;
+	extern FGT_PTR_U8_U8			gcosGetDscp2Tc;
+	extern FGT_VALUE_U8_U8			gcosSetDscp2Tc;
+	extern FGT_PTR_CONFIG_INFO		sysConfig;
+	extern FGT_VOID					sysEnable;
+	extern FGT_VOID					gsysSwReset;
+	extern FGT_VALUE_BOOL			gsysSetDiscardExcessive;
+	extern FGT_PTR_BOOL				gsysGetDiscardExcessive;
+	extern FGT_VALUE_BOOL			gsysSetSchedulingMode;
+	extern FGT_PTR_BOOL				gsysGetSchedulingMode;
+	extern FGT_VALUE_BOOL			gsysSetMaxFrameSize;
+	extern FGT_PTR_BOOL				gsysGetMaxFrameSize;
+	extern FGT_VOID					gsysReLoad;
+	extern FGT_VALUE_BOOL			gsysSetWatchDog;
+	extern FGT_PTR_BOOL				gsysGetWatchDog;
+	extern FGT_PTR_ETHERADDR		gsysSetDuplexPauseMac;
+	extern FGT_PTR_ETHERADDR		gsysGetDuplexPauseMac;
+	extern FGT_VALUE_BOOL			gsysSetPerPortDuplexPauseMac;
+	extern FGT_PTR_BOOL				gsysGetPerPortDuplexPauseMac;
+	extern FGT_PTR_U32_U32_U32		gsysReadMiiReg;
+	extern FGT_PTR_VERSION			gtVersion;
+	extern FGT_PTR_REGISTER			gtRegister;
+
+	extern FGT_PTR_U32_U32_U16		gsysWriteMiiReg;
+
+/*
+ * This function will get the all the MS APIs and assign to local function pointers.
+ */
+	int qdGetMSApiFunc();
+
+	GT_U32 gtStrlen
+	(
+		IN const void * source
+		);
+
+//*****************************************************************************
+//  I O C T L S
+//*****************************************************************************
+#include <linux/marvell/windev.h>
+
+	typedef struct _GT_IOCTL_PARAM
+	{
+		union 
+		{
+			GT_LPORT	portList[8];
+			GT_LPORT	port;
+			GT_U8  		u8Data;
+			GT_U16  	u16Data;
+			GT_U32  	u32Data;
+			GT_BOOL 	boolData;
+
+			GT_CTR_MODE	ctrMode;
+			GT_PORT_STP_STATE	stpState;
+			GT_EGRESS_MODE		egressMode;
+			GT_INGRESS_MODE		ingressMode;
+			GT_MC_RATE		mcRate;
+			GT_PORT_STAT	portStat;
+			ATU_SIZE 		atuSize;
+			GT_FLUSH_CMD 	flushCmd;
+
+			GT_ATU_ENTRY 	atuEntry;
+			GT_ETHERADDR 	etherAddr;
+			GT_SYS_CONFIG 	sysConfig;
+			GT_SYS_INFO		sysInfo;
+
+		} FirstParam;
+
+		union 
+		{
+			GT_LPORT	port;
+			GT_LPORT	portList[8];
+			GT_U8		u8Data;
+			GT_U16		u16Data;
+			GT_U32		u32Data;
+			GT_BOOL		boolData;
+			GT_PORT_STP_STATE	stpState;
+			GT_EGRESS_MODE		egressMode;
+			GT_INGRESS_MODE		ingressMode;
+			GT_MC_RATE		mcRate;
+
+			GT_PORT_STAT	portStat;
+
+			GT_PHY_AUTO_MODE	phyAutoMode;
+
+		} SecondParam;
+
+		union
+		{
+			GT_U8	u8Data;
+			GT_U16	u16Data;
+			GT_U32	u32Data;
+
+		} ThirdParam;
+
+	} GT_IOCTL_PARAM, *PGT_IOCTL_PARAM;
+
+#define GET_FUNC_FROM_CTL_CODE(_ioctl) ((_ioctl>>2) & 0xFFF)
+
+/*
+  Microsoft allows for us to use 0x800 ~ 0xFFF
+  So, our program is using 6 bits for function group,
+  and 6 bits for each function.
+*/
+#define SUB_FUNC_MASK		0xFC0
+#define SYS_CFG_FUNC_MASK	(1 << 6) | 0x800
+#define SYS_CTRL_FUNC_MASK	(2 << 6) | 0x800
+#define FDB_FUNC_MASK		(3 << 6) | 0x800
+#define VLAN_FUNC_MASK		(4 << 6) | 0x800
+#define STP_FUNC_MASK		(5 << 6) | 0x800
+#define PORT_CTRL_FUNC_MASK		(6 << 6) | 0x800
+#define PORT_STATUS_FUNC_MASK	(7 << 6) | 0x800
+#define PORT_STATS_FUNC_MASK	(8 << 6) | 0x800
+#define QOS_FUNC_MASK			(9 << 6) | 0x800
+#define PHY_CTRL_FUNC_MASK		(10 << 6) | 0x800
+#define SYS_EVENT_FUNC_MASK		(11 << 6) | 0x800
+#define PHY_INT_FUNC_MASK		(12 << 6) | 0x800
+
+/*
+  Functions for SYS Configuration
+*/
+#define IOCTL_sysConfig    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysReadMiiReg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysWriteMiiReg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gtVersion    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for ATU
+*/
+#define IOCTL_gfdbSetAtuSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAgingTimeRange    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbSetAgingTimeout    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuDynamicCount    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuEntryFirst    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuEntryNext    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFindAtuMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFlush    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbAddMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbDelMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbLearnEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+  Functions for STP
+*/
+#define IOCTL_gstpSetMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstpSetPortState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstpGetPortState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for VLAN
+*/
+#define IOCTL_gprtSetEgressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetEgressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetVlanTunnel    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetVlanTunnel    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVlanPorts    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVlanPorts    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortUserPriLsb    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortUserPriLsb    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVid    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVid    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for System Event
+*/
+#define IOCTL_eventSetActive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_EVENT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_eventGetIntStatus    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_EVENT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for Phy Control
+*/
+#define IOCTL_gprtPhyReset    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortLoopback    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortSpeed    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortAutoNegEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortPowerDown    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortRestartAutoNeg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortDuplexMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortAutoMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/* 
+   Functions for Phy Interrupt
+*/
+#define IOCTL_gprtPhyIntEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyIntStatus    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyIntPortSummary    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for Port Control
+*/
+#define IOCTL_gprtSetForceFc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetForceFc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetTrailerMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetTrailerMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetIngressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetIngressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetMcRateLimit    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetMcRateLimit    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+  Functions for Port Statistics
+*/
+#define IOCTL_gprtSetCtrMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtClearAllCtr    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPortCtr    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for Port Status
+*/
+#define IOCTL_gprtGetPartnerLinkPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetSelfLinkPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetResolve    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetLinkState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPortMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetDuplex    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetSpeed    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for QoS Mapping
+*/
+#define IOCTL_gcosSetPortDefaultTc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosSetPrioMapRule    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetPrioMapRule    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosIpPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetIpPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosUserPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetUserPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetUserPrio2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosSetUserPrio2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetDscp2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosSetDscp2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+  Functions for Sys Control
+*/
+#define IOCTL_gsysSwReset    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetDiscardExcessive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetDiscardExcessive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetSchedulingMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetSchedulingMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetMaxFrameSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetMaxFrameSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysReLoad    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetWatchDog    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetWatchDog    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetPerPortDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetPerPortDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: linux-2.6.16/include/linux/marvell/msIoctl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/msIoctl.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,677 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * msIoctl.h
+ *
+ * DESCRIPTION:
+ *       API definitions for QuarterDeck IOCTL
+ *
+ * DEPENDENCIES:
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#ifndef __MSIOCTL_H
+#define __MSIOCTL_H
+
+#define RG_IO_FILENAME "rgcfgio"
+#define RG_IO_FULLPATH "/proc/rgcfgio"
+
+#include <linux/marvell/mv_platform.h>
+#include <linux/marvell/mv_unimac.h>
+
+bool UNM_IOControl(DWORD  hOpenContext,
+		   DWORD  Ioctl,
+		   UCHAR *pInBuf,
+		   DWORD  InBufLen, 
+		   UCHAR *pOutBuf,
+		   DWORD  OutBufLen,
+		   DWORD *pdwRet
+	);
+
+typedef struct _GT_IOCTL_PARAM
+{
+	union 
+	{
+		GT_LPORT	portList[8];
+		GT_LPORT	port;
+		GT_U8  	u8Data;
+		GT_U16  	u16Data;
+		GT_U32  	u32Data;
+		GT_BOOL 	boolData;
+    
+		GT_CTR_MODE	        ctrMode;
+		GT_PORT_STP_STATE	stpState;
+		GT_EGRESS_MODE	egressMode;
+		GT_INGRESS_MODE	ingressMode;
+		GT_MC_RATE		mcRate;
+		GT_PORT_STAT	portStat;
+		GT_RATE_LIMIT_MODE  rateLimitMode;
+		GT_EGRESS_RATE      egressRate;
+		ATU_SIZE 		atuSize;
+		GT_FLUSH_CMD 	flushCmd;
+		GT_DOT1Q_MODE       dot1QMode;
+		GT_ATU_ENTRY 	atuEntry;
+		GT_ETHERADDR 	etherAddr;
+		GT_SYS_CONFIG 	sysConfig;
+		GT_VTU_INT_STATUS   vtuIntStatus;
+		GT_VTU_ENTRY        vtuEntry;
+		GT_CABLE_STATUS     cableStatus;
+		GT_1000BT_EXTENDED_STATUS extStatus;
+		GT_SW_MODE          swMode;
+		GT_SYS_CONFIG       sysCfg;
+		GT_STATS_COUNTER_SET statsCounterSet;
+		GT_QD_DEV           qd_dev;    
+		MV_UNM_CONFIG       netconf;
+	} FirstParam;
+
+
+	union 
+	{
+		GT_LPORT	        port;
+		GT_LPORT	        portList[8];
+		GT_U8	        u8Data;
+		GT_U16	        u16Data;
+		GT_U32		u32Data;
+		GT_BOOL		boolData;
+		GT_PORT_STP_STATE	stpState;
+		GT_EGRESS_MODE	egressMode;
+		GT_INGRESS_MODE	ingressMode;
+		GT_EGRESS_RATE      egressRate;
+		GT_RATE_LIMIT_MODE  rateLimitMode;
+		GT_MC_RATE		mcRate;
+		GT_PORT_STAT	portStat;
+		GT_DOT1Q_MODE       dot1QMode;
+		GT_PHY_AUTO_MODE	phyAutoMode;
+		GT_STATS_COUNTERS   statsCounter;
+		GT_QD_DEV           dev;
+		char	        szVlanName[20];
+		char       vlan_names[MV_UNM_MAX_VID][MAX_VLAN_NAME];
+    
+	} SecondParam;
+  
+	union
+	{
+		GT_U8	  u8Data;
+		GT_U16	  u16Data;
+		GT_U32	  u32Data;
+		GT_BOOL       boolData;
+		unsigned char macs[MV_UNM_MAX_VID][GT_ETHERNET_HEADER_SIZE];    
+	} ThirdParam;
+
+	union
+	{
+		GT_BOOL       boolData;
+	} FourthParam;
+
+} GT_IOCTL_PARAM, *PGT_IOCTL_PARAM;
+
+
+
+#define FILE_DEVICE_NETWORK (0)
+#define METHOD_BUFFERED     (0)
+#define FILE_ANY_ACCESS     (0)
+
+#define GET_FUNC_FROM_CTL_CODE(_ioctl) (_ioctl) /* ((_ioctl>>2) & 0xFFF) */
+
+#define CTL_CODE(file_device_net, func_mask, method, access) (func_mask)
+
+/*
+  #define CTL_CODE(file_device_net, func_mask, method, access) \
+  ( (file_device_net) | (func_mask) | (method) | (access) )
+*/
+
+
+
+/*
+  We are using 0x800 ~ 0xFFF
+  So, our program is using 6 bits for function group,
+  and 6 bits for each function.
+*/
+#define SUB_FUNC_MASK			(0xFC0)
+#define SYS_CFG_FUNC_MASK		((1 << 6) | 0x800)
+#define SYS_CTRL_FUNC_MASK		((2 << 6) | 0x800)
+#define FDB_FUNC_MASK			((3 << 6) | 0x800)
+#define VLAN_FUNC_MASK			((4 << 6) | 0x800)
+#define STP_FUNC_MASK			((5 << 6) | 0x800)
+#define PORT_CTRL_FUNC_MASK		((6 << 6) | 0x800)
+#define PORT_STATUS_FUNC_MASK	        ((7 << 6) | 0x800)
+#define PORT_STATS_FUNC_MASK	        ((8 << 6) | 0x800)
+#define QOS_FUNC_MASK			((9 << 6) | 0x800)
+#define PHY_CTRL_FUNC_MASK		((10 << 6) | 0x800)
+#define SYS_EVENT_FUNC_MASK		((11 << 6) | 0x800)
+#define PHY_INT_FUNC_MASK		((12 << 6) | 0x800)
+#define PAV_FUNC_MASK		        ((13 << 6) | 0x800)
+#define PRC_FUNC_MASK	                ((14 << 6) | 0x800)
+#define VTU_FUNC_MASK	                ((15 << 6) | 0x800)
+#define STATS_RMON_FUNC_MASK            ((16 << 6) | 0x800)
+#define STATS_SYS_FUNC_MASK             ((17 << 6) | 0x800)
+#define VCT_FUNC_MASK                   ((18 << 6) | 0x800)
+#define UNM_NET_FUNC_MASK		((19 << 6) | 0x800)
+
+
+
+/*
+  Functions for SYS Configuration
+*/
+#define IOCTL_sysConfig    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysReadMiiReg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysWriteMiiReg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gtVersion    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gLoadDriver   \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gUnloadDriver   \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gSysEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+
+/*
+  Functions for ATU
+*/
+#define IOCTL_gfdbSetAtuSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAgingTimeRange    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbSetAgingTimeout    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuDynamicCount    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuEntryFirst    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuEntryNext    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFindAtuMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFlush    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbAddMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbDelMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbLearnEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbDelAtuEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFlushInDB    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+  Functions for STP
+*/
+#define IOCTL_gstpSetMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstpSetPortState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstpGetPortState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+  Functions for VLAN
+*/
+#define IOCTL_gprtSetEgressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetEgressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetVlanTunnel    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetVlanTunnel    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVlanPorts    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVlanPorts    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortUserPriLsb    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortUserPriLsb    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVid    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVid    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVlanDBNum    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVlanDBNum    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVlanDot1qMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVlanDot1qMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVlanForceDefaultVID    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVlanForceDefaultVID    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+
+/*
+  Functions for System Event
+*/
+#define IOCTL_eventSetActive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_EVENT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_eventGetIntStatus    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_EVENT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+  Functions for Phy Control
+*/
+#define IOCTL_gprtPhyReset    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortLoopback    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortSpeed    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortAutoNegEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortPowerDown    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortRestartAutoNeg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortDuplexMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortAutoMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/* 
+   Functions for Phy Interrupt
+*/
+#define IOCTL_gprtPhyIntEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyIntStatus    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyIntPortSummary    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for Port Control
+*/
+#define IOCTL_gprtSetForceFc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetForceFc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetTrailerMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetTrailerMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetIngressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetIngressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetMcRateLimit    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetMcRateLimit    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetHeaderMode   \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetHeaderMode   \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetIGMPSnoop   \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetIGMPSnoop   \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetDuplex   \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+
+/*
+  Functions for Port Statistics
+*/
+#define IOCTL_gprtSetCtrMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtClearAllCtr    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+
+/*
+  Functions for Port Status
+*/
+#define IOCTL_gprtGetPartnerLinkPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetSelfLinkPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetResolve    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetLinkState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPortMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetDuplex    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetSpeed    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPortCtr    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+  Functions for QoS Mapping
+*/
+#define IOCTL_gcosSetPortDefaultTc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosSetPrioMapRule    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetPrioMapRule    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosIpPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetIpPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosUserPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetUserPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetUserPrio2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosSetUserPrio2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetDscp2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosSetDscp2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetPortDefaultTc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  Functions for Sys Control
+*/
+#define IOCTL_gsysSwReset    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetDiscardExcessive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetDiscardExcessive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetSchedulingMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetSchedulingMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetMaxFrameSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetMaxFrameSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysReLoad    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetWatchDog    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetWatchDog    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetPerPortDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetPerPortDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+ * Fuctions to System status
+ */
+#define IOCTL_gsysGetSW_Mode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STATS_SYS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetInitReady    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STATS_SYS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+
+/*
+ *
+ */
+#define IOCTL_UNM_GET_VLAN_NAMES    \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_UNM_GET_VLAN_PARMS    \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_UNM_GET_PORT_VLAN	    \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_UNM_ASSOC_PORT	    \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_UNM_DISASSSOC_PORT    \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_UNM_INIT              \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_UNM_STATUS            \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_UNM_READ_REG          \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_UNM_WRITE_REG          \
+    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+  #define IOCTL_UNM_SAVE_NETCONF    CTL_CODE(FILE_DEVICE_NETWORK , UNM_NET_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+*/
+
+/*  
+ * Functions for Port Association Vector
+ */
+#define IOCTL_gpavSetPAV  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PAV_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gpavGetPAV  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PAV_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gpavSetIngressMonitor  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PAV_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gpavGetIngressMonitor  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PAV_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/* 
+ * Functions for Port Rate Control
+ */
+#define IOCTL_grcSetLimitMode  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcGetLimitMode  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcSetEgressRate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcGetEgressRate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcSetPri3Rate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcGetPri3Rate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcSetPri0Rate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcGetPri0Rate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcSetPri1Rate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcGetPri1Rate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcSetPri2Rate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcGetPri2Rate  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcSetBytesCount  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_grcGetBytesCount  \
+    CTL_CODE(FILE_DEVICE_NETWORK , PRC_FUNC_MASK + 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+ *
+ */
+#define IOCTL_gvtuGetIntStatus \
+    CTL_CODE(FILE_DEVICE_NETWORK , VTU_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvtuGetEntryCount \
+    CTL_CODE(FILE_DEVICE_NETWORK , VTU_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvtuGetEntryFirst \
+    CTL_CODE(FILE_DEVICE_NETWORK , VTU_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvtuGetEntryNext \
+    CTL_CODE(FILE_DEVICE_NETWORK , VTU_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvtuFindVidEntry \
+    CTL_CODE(FILE_DEVICE_NETWORK , VTU_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvtuFlush \
+    CTL_CODE(FILE_DEVICE_NETWORK , VTU_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvtuAddEntry \
+    CTL_CODE(FILE_DEVICE_NETWORK , VTU_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvtuDelEntry \
+    CTL_CODE(FILE_DEVICE_NETWORK , VTU_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+ * Functions for RMON counters
+ */
+#define IOCTL_gstatsFlushAll \
+    CTL_CODE(FILE_DEVICE_NETWORK , STATS_RMON_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstatsFlushPort \
+    CTL_CODE(FILE_DEVICE_NETWORK , STATS_RMON_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstatsGetPortCounter \
+    CTL_CODE(FILE_DEVICE_NETWORK , STATS_RMON_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstatsGetPortAllCounters \
+    CTL_CODE(FILE_DEVICE_NETWORK , STATS_RMON_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+
+/*
+ * Function cable test
+ */
+#define IOCTL_gvctGetCableDiag \
+    CTL_CODE(FILE_DEVICE_NETWORK , VCT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvctGet1000BTExtendedStatus \
+    CTL_CODE(FILE_DEVICE_NETWORK , VCT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/**/
+
+#endif
Index: linux-2.6.16/include/linux/marvell/mv_common.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_common.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,114 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_common.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file defines general-purpose macros.
+ */
+
+
+#ifndef MV_COMMON_H
+#define MV_COMMON_H
+
+
+#include <linux/marvell/mv_types.h>
+
+
+#define GT_ALIGN_UP(num, aln)   (((num)&((aln)-1)) ? (((num)+(aln))&~((aln)-1)) : (num))
+#define GT_ALIGN_DOWN(num, aln) ((num)&~((aln)-1))
+
+#define GT_BYTE0(s) ((s)&0xff)
+#define GT_BYTE1(s) (((s)>>8)&0xff)
+#define GT_BYTE2(s) (((s)>>16)&0xff)
+#define GT_BYTE3(s) (((s)>>24)&0xff)
+#define GT_HWORD0(s) ((s)&0xffff)
+#define GT_HWORD1(s) (((s)>>16)&0xffff)
+
+#define GT_BYTESWAP2(s) ((GT_BYTE0(s)<<8)|GT_BYTE1(s))
+
+#define GT_BYTESWAP4(s) ((GT_BYTE0(s)<<24)|(GT_BYTE1(s)<<16)|(GT_BYTE2(s)<<8)|GT_BYTE3(s))
+
+#define GT_HWORDSWAP(s) ((GT_HWORD0(s)<<16)|GT_HWORD1(s))
+
+#define GT_LOAD_32_BITS(pBuf)                   \
+    (GT_U32)((((pBuf)[0]<<24)&0xff000000) |     \
+             (((pBuf)[1]<<16)&0x00ff0000) |     \
+             (((pBuf)[2]<<8 )&0x0000ff00) |     \
+             (((pBuf)[3])    &0x000000ff))
+
+#define GT_LOAD_32_BITS_WITH_OFFSET(pBuf, offset)   \
+    (GT_U32)( ((pBuf)[0]<<(24+(offset))) |          \
+              ((pBuf)[1]<<(16+(offset))) |          \
+              ((pBuf)[2]<<(8+(offset)))  |          \
+              ((pBuf)[3]<<((offset)))    |          \
+              ((pBuf)[4]>>(8-(offset))) )
+
+#define GT_STORE_32_BITS(pBuf, val32)       \
+do{                                         \
+    (pBuf)[0] = (GT_U8)((val32)>>24);       \
+    (pBuf)[1] = (GT_U8)((val32)>>16);       \
+    (pBuf)[2] = (GT_U8)((val32)>>8);        \
+    (pBuf)[3] = (GT_U8)(val32);             \
+} while (0);
+
+#define GT_LOAD_16_BITS(pBuf)               \
+    (GT_U16)( (((pBuf)[0]<<8)&0xff00) |     \
+              (((pBuf)[1])   &0x00ff))
+
+
+#define GT_STORE_16_BITS(pBuf, val16)       \
+do{                                         \
+    (pBuf)[0] = (GT_U8)((val16)>>8);        \
+    (pBuf)[1] = (GT_U8)(val16);             \
+} while (0);
+
+/*---------------------------------------------------------------------------*/
+/*           BIT FIELDS MANIPULATION MACROS                                  */
+/*---------------------------------------------------------------------------*/
+#define GT_BIT_MASK(x)       (1<<(x))     /* integer which its 'x' bit is set */
+
+/*---------------------------------------------------------------------------*/
+/* checks wheter bit 'x' in 'a' is set and than returns TRUE,                */
+/* otherwise return FALSE.                                                   */
+/*---------------------------------------------------------------------------*/
+#define GT_CHKBIT(a, x)     (((a) & GT_BIT_MASK(x)) >> (x))     
+
+/*---------------------------------------------------------------------------*/
+/* Clear (reset) bit 'x' in integer 'a'                                      */
+/*---------------------------------------------------------------------------*/
+#define GT_CLRBIT(a, x)     ((a) &= ~(GT_BIT_MASK(x)))
+
+/*---------------------------------------------------------------------------*/
+/* SET bit 'x' in integer 'a'                                                */
+/*---------------------------------------------------------------------------*/
+#define GT_SETBIT(a, x)     ((a) |= GT_BIT_MASK(x))
+
+/*---------------------------------------------------------------------------*/
+/*   INVERT bit 'x' in integer 'a'.                                          */
+/*---------------------------------------------------------------------------*/
+#define GT_INVBIT(a, x)   ((a) = (a) ^ GT_BIT_MASK(x))
+
+/*---------------------------------------------------------------------------*/
+/* Get the min between 'a' or 'b'                                             */
+/*---------------------------------------------------------------------------*/
+#define GT_MIN(a,b)    (((a) < (b)) ? (a) : (b)) 
+
+/*---------------------------------------------------------------------------*/
+/* Get the max between 'a' or 'b'                                             */
+/*---------------------------------------------------------------------------*/
+#define GT_MAX(a,b)    (((a) < (b)) ? (b) : (a)) 
+
+
+#endif /* MV_COMMON_H */
Index: linux-2.6.16/include/linux/marvell/mv_debug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_debug.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,74 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_debug.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file defines few types and functions useful for debug purposes.
+ */
+#ifndef MV_DEBUG_H
+#define MV_DEBUG_H
+
+
+#include <linux/marvell/mv_types.h>
+
+
+/*	time measurement structure used to check how much time pass between
+ *  two points
+ */
+typedef struct {
+	char            name[20];	/* name of the entry */
+	unsigned long   begin;		/* time measured on begin point */
+	unsigned long   end;		/* time measured on end point */
+	unsigned long   total;		/* Accumulated time */
+	unsigned long   left;		/* The rest measurement actions */
+	unsigned long   count;		/* Maximum measurement actions */
+	unsigned long   min;		/* Minimum time from begin to end */
+	unsigned long   max;		/* Maximum time from begin to end */
+} MV_DEBUG_TIMES;
+
+/* MACRO to print Debug messages */
+#ifdef MV_DEBUG
+#	define MV_DEBUG_PRINT	gtOsPrintf
+#else
+#       define MV_DEBUG_PRINT
+#endif
+
+
+/****** Error Recording ******/
+
+/* Dump memory in specific format: 
+ * address: X1X1X1X1 X2X2X2X2 ... X8X8X8X8 
+ */
+void      mvDebugMemoryDump(void* addr, int size);
+
+/**** There are three functions deals with MV_DEBUG_TIMES structure ****/
+
+/* Reset MV_DEBUG_TIMES entry */
+void    mvDebugResetTimeEntry(MV_DEBUG_TIMES* pTimeEntry, int count, char* name);
+
+/* Update MV_DEBUG_TIMES entry */
+void    mvDebugUpdateTimeEntry(MV_DEBUG_TIMES* pTimeEntry);
+
+/* Print out MV_DEBUG_TIMES entry */
+void    mvDebugPrintTimeEntry(MV_DEBUG_TIMES* pTimeEntry, GT_BOOL isTitle);
+
+
+/******** General ***********/
+
+/* Change value of mvDebugPrint global variable */
+void      mvDebugPrintEnable(GT_BOOL isEnable);
+
+
+#endif /* MV_DEBUG_H */
Index: linux-2.6.16/include/linux/marvell/mv_eth_addrtbl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_eth_addrtbl.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,114 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ ********************************************************************************
+ * 
+ * FILENAME:    $Workfile: mv_eth_addrtbl.h $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $ 
+ * 
+ * DESCRIPTION:
+ *	        Address Table driver header file for the Marvell ethernet unit.
+ *
+ * DEPENDENCIES:   
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+#ifndef MV_ETH_ADDRTBL_H
+#define MV_ETH_ADDRTBL_H
+
+
+/*
+ * ----------------------------------------------------------------------------
+ * addressTable.h - this file has all the declarations of the address table
+ */
+
+#define _8K_TABLE                           0
+#define ADDRESS_TABLE_ALIGNMENT             8
+#define HASH_DEFAULT_MODE                   14
+#define HASH_MODE                           13
+#define HASH_SIZE                           12
+#define HOP_NUMBER                          12
+#define MAC_ADDRESS_STRING_SIZE             12
+#define MAC_ENTRY_SIZE                      sizeof(addrTblEntry)
+#define MAX_NUMBER_OF_ADDRESSES_TO_STORE    1000
+#define PROMISCUOUS_MODE                    0
+#define SKIP                                1<<1
+#define SKIP_BIT                            1
+#define VALID                               1
+
+
+
+/*
+ * ----------------------------------------------------------------------------
+ * potential sign-extension bugs lurk here...
+ */
+#define NIBBLE_SWAPPING_32_BIT(X) ( (((X) & 0xf0f0f0f0) >> 4) \
+                                  | (((X) & 0x0f0f0f0f) << 4) )
+
+#define NIBBLE_SWAPPING_16_BIT(X) ( (((X) & 0x0000f0f0) >> 4) \
+                                  | (((X) & 0x00000f0f) << 4) )
+
+#define FLIP_4_BITS(X)  ( (((X) & 0x01) << 3) | (((X) & 0x002) << 1) \
+                        | (((X) & 0x04) >> 1) | (((X) & 0x008) >> 3) )
+
+#define FLIP_6_BITS(X)  ( (((X) & 0x01) << 5) | (((X) & 0x020) >> 5) \
+                        | (((X) & 0x02) << 3) | (((X) & 0x010) >> 3) \
+                        | (((X) & 0x04) << 1) | (((X) & 0x008) >> 1) )
+
+#define FLIP_9_BITS(X)  ( (((X) & 0x01) << 8) | (((X) & 0x100) >> 8) \
+                        | (((X) & 0x02) << 6) | (((X) & 0x080) >> 6) \
+                        | (((X) & 0x04) << 4) | (((X) & 0x040) >> 4) \
+         | ((X) & 0x10) | (((X) & 0x08) << 2) | (((X) & 0x020) >> 2) )
+
+/*
+ * V: value we're operating on
+ * O: offset of rightmost bit in field
+ * W: width of field to shift
+ * S: distance to shift left
+ */
+#define MASK( fieldWidth )                            ((1 << (fieldWidth)) - 1)
+#define leftShiftedBitfield( V,O,W,S)        (((V) & (MASK(W) << (O)))  << (S))
+#define rightShiftedBitfield(V,O,W,S)  (((u32)((V) & (MASK(W) << (O)))) >> (S))
+
+/*
+ * ----------------------------------------------------------------------------
+ * This function will initialize the address table and will enableFiltering.
+ * Inputs
+ * hashMode         - hash mode 0 or hash mode 1.
+ * hashSizeSelector - indicates number of hash table entries (0=0x8000,1=0x800)
+ * hashDefaultMode  - 0 = discard addresses not found in the address table,
+ *                    1 = pass addresses not found in the address table.
+ * port - ETHERNET port number.
+ * Outputs
+ * address table is allocated and initialized.
+ * Always returns 1
+ */
+int initAddressTable(u32 port, u32 hashMode, u32 hashSize, u32 hashDefaultMode);
+
+
+/*
+ * ----------------------------------------------------------------------------
+ *  Create an addressTable entry from MAC address info
+ *  found in the specifed net_device struct
+ *
+ *  Input : pointer to ethernet interface network device structure
+ *  Output : N/A
+ */
+void mv_eth_update_mac_address(u8 *byte, u8 port);
+
+/*
+ * clear the address table
+ * port - ETHERNET port number.
+ */
+void addressTableClear(u32 port);
+
+
+#endif /* MV_ETH_ADDRTBL_H */
Index: linux-2.6.16/include/linux/marvell/mv_eth.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_eth.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,364 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ ********************************************************************************
+ * 
+ * FILENAME:    $Workfile: mv_eth.h $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $ 
+ * 
+ * mv_eth.h
+ *
+ * DESCRIPTION:
+ *		Ethernet driver for FireFox
+ *
+ * DEPENDENCIES:   
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+#ifndef MV_ETH_H
+#define MV_ETH_H
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+
+/* #include <asm/88E6318/mv88E6318.h> */
+/* #include <asm/88E6318/mv88E6318int.h> */
+/* #include <asm/88E6318/mv88E6318regs.h> */
+#include <asm/mpc85xx.h>
+
+#include <linux/marvell/mv_os.h>
+#include <linux/marvell/mv_unimac.h>
+
+
+//#undef  ETH_DBG_ECHO
+//#undef  ETH_DBG_INFO
+//#define ETH_DBG_WARN
+//#define ETH_DBG_ERROR
+//#define ETH_DBG_TRACE
+//#undef  ETH_DBG_TX_OUTSTANDING
+
+#undef  ETH_DBG_MC
+#define ENABLE_MC
+
+#define DESCRIPTOR_SIZE            sizeof(gt_dma_desc)
+#define Q_INDEX_LIMIT  64
+
+#define NUM_TX_QUEUES  2
+#define NUM_RX_QUEUES  4
+#define MV_ETH_TX_QUEUE  0
+#define MV_ETH_RX_QUEUE  3
+
+#define FIREFOX_INT_THRE           5
+#define GT_ENET_DESC_OWNERSHIP     (1<<31)
+#define GT_ENET_DESC_INT_ENABLE    (1<<23)
+#define GT_ENET_DESC_ERROR_SUMMARY (1<<15)
+#define MAX_BUFF_SIZE              1536
+
+#define ETH_ADDR_GAP 0x400 /* This is dummy - code must be fixed */
+
+#define HEADER_SIZE        2
+#define TRAILER_SIZE       4
+#define MIN_ETH_PACKET_LEN 60
+
+s32 mv_eth_init(struct net_device *);
+s32 mv_eth_open(struct net_device *);
+s32 mv_eth_start_xmit(struct sk_buff *, struct net_device *);
+s32 mv_eth_stop(struct net_device *);
+void mv_eth_int_handler(s32, void *, struct pt_regs *);
+s32 mv_eth_set_mac_address(struct net_device *, void *);
+struct net_device_stats *mv_eth_get_stats(struct net_device *);
+
+GT_STATUS getNetConfig(OUT MV_UNM_CONFIG* unmConfig);
+GT_STATUS mvDisassociatePort(int qdPort, int fromVlanId, int newPortsBitMask);
+GT_STATUS mvAssociatePort(int qdPort, int toVlanId, int newPortsBitMask, int numOfPorts);
+
+typedef volatile struct gt_dma_desc_struct {
+	volatile u32 command_status;
+	volatile union {
+		volatile struct {
+			u16 reserved;
+			u16 bytes;
+		} tx;
+		volatile struct {
+			u16 bytesReceived;
+			u16 bufferBytes;
+		} rx;
+	} count;
+  
+	volatile void *data;	/* Physical address, only read by the DMA engine. */
+	volatile u32 next;	/* Physical address, only read by the DMA engine. */
+	/*
+	 * Force sizeof(firefoxenetDMAdescriptor) == sizeof(cacheline) 
+	 * Not yet sure exactly why this is necessary but the FIREFOX-B
+	 * part apparently has (yet another) bug that shows itself without
+	 * this padding.  The symptom is that all Enet comms simply stop.
+	 */
+	u32 cachelineSizePadding[4];
+} gt_dma_desc;
+
+typedef enum {
+	HW_UNKNOWN = 0,
+	HW_INIT,
+	HW_READY,
+	HW_ACTIVE
+} HW_STATE;
+
+/* HW SW IF logicall structure */
+/* A single instance           */
+typedef struct mv_eth_HwSwIf {
+	gt_dma_desc *TXqueue[NUM_TX_QUEUES];
+	gt_dma_desc *RXqueue[NUM_RX_QUEUES];
+	struct sk_buff *TXskbuff[NUM_TX_QUEUES][Q_INDEX_LIMIT];
+	struct sk_buff *RXskbuff[NUM_RX_QUEUES][Q_INDEX_LIMIT];
+	u32 TXindex[NUM_TX_QUEUES];
+	u32 RXindex[NUM_RX_QUEUES];
+	u32 TXskbIndex[NUM_TX_QUEUES];
+	HW_STATE hwState;
+  
+	struct tq_struct rx_task;
+} mv_eth_hw;
+
+typedef struct gt_eth_priv_stat {
+	u32 tx_needed_copy;
+	/* more ... */
+} priv_stat;
+
+typedef struct gt_eth_priv_struct {
+	u8 port;
+	struct net_device_stats stat;
+	struct gt_eth_priv_stat privstat; 
+	struct mii_if_info mii_if;
+	bool inited;
+	int vid;       /* the VLAN ID (VID) */
+} gt_eth_priv;
+
+
+/* cache flushing helpers */
+
+#define flush_dcache_addr_size( A, N )     \
+    flush_dcache_range( ((u32)A), ((u32)(A)+(N)) )
+#define flush_dcache(x) flush_dcache_range( ((u32)x) , ((u32)x) + sizeof(*(x)))
+#define invalidate_dcache(x) invalidate_dcache_range( ((u32)x) , ((u32)x) + sizeof(*(x)))
+
+u32 uncachedPages(u32 pages);
+
+
+/* this file has all the ethernet low level definitions */
+
+#define ETHERNET_PORTS_DIFFERENCE_OFFSETS       0x400
+
+#define ETHERNET0_HH_PRIORITY                   11
+#define ETHERNET0_LL_PRIORITY                   2
+#define ETHERNET1_HH_PRIORITY                   12
+
+/* this macros are used to enable access to SMI_REG */
+#define SMI_OP_CODE_BIT_READ                    1
+#define SMI_OP_CODE_BIT_WRITE                   0
+#define SMI_BUSY                                1<<28
+#define READ_VALID                              1<<27
+
+#ifdef CONFIG_ZUMA_V2
+#define PHY_LXT97x
+#define PHY_ADD0                                0
+#define PHY_ADD1  				1
+#elif CONFIG_MOT_MVP
+#define PHY_LXT97x
+#define PHY_ADD0                                4
+#define PHY_ADD1                                5
+#else
+#define PHY_ADD0                                4
+#define PHY_ADD1                                5
+#define PHY_ADD2                                6
+#endif
+
+/* this macros are used to enable access to ETHERNET_PCXR */
+#define OVERRIDE_RX_PRIORITY                    1<<8
+#define MIB_CLEAR_MODE                          1<<16
+
+/* this macros are used to enable access to ETHERNET_SDCMR */
+#define START_TX_HIGH       1<<23
+#define START_TX_LOW        1<<24
+#define ENABLE_RX_DMA       1<<7
+#define ABORT_RECEIVE       1<<15
+#define STOP_TX_HIGH        1<<16
+#define STOP_TX_LOW         1<<17
+#define ABORT_TRANSMIT      1<<31
+
+/* this macros are used to enable access to ETHERNET_SDCR */
+#define ETHERNET_SDMA_BURST_SIZE          3
+
+typedef unsigned int ETHERNET_PCR;
+typedef unsigned int ETHERNET_PCXR;
+typedef unsigned int ETHERNET_PCMR;
+typedef unsigned int ETHERNET_PSR;
+typedef unsigned int ETHERNET_SDCMR;
+typedef unsigned int ETHERNET_SDCR;
+
+typedef unsigned int PHY_ADD_REG;
+typedef unsigned int SMI_REG;
+
+typedef struct mibCounters {
+	unsigned int byteReceived;
+	unsigned int byteSent;
+	unsigned int framesReceived;
+	unsigned int framesSent;
+	unsigned int totalByteReceived;
+	unsigned int totalFramesReceived;
+	unsigned int broadcastFramesReceived;
+	unsigned int multicastFramesReceived;
+	unsigned int cRCError;
+	unsigned int oversizeFrames;
+	unsigned int fragments;
+	unsigned int jabber;
+	unsigned int collision;
+	unsigned int lateCollision;
+	unsigned int frames64;
+	unsigned int frames65_127;
+	unsigned int frames128_255;
+	unsigned int frames256_511;
+	unsigned int frames512_1023;
+	unsigned int frames1024_MaxSize;
+	unsigned int macRxError;
+	unsigned int droppedFrames;
+	unsigned int outMulticastFrames;
+	unsigned int outBroadcastFrames;
+	unsigned int undersizeFrames;
+} STRUCT_MIB_COUNTERS;
+
+/* set port config value */
+inline void
+set_port_config(u32 value, unsigned int port);
+
+/* get port config value */
+inline u32
+get_port_config(unsigned int port);
+
+inline void
+enableFiltering(u32 port);
+
+#ifdef PHY_LXT97x
+#undef THREE_ETHERNET_RMII_PORTS
+#define TWO_ETHERNET_MII_PORTS
+#else
+#define THREE_ETHERNET_RMII_PORTS
+#undef TWO_ETHERNET_MII_PORTS
+#endif
+
+#define ETHERNET_PORT2                      2
+#define ETHERNET_PORT1                      1
+#define ETHERNET_PORT0                      0
+
+#define MAX_NUMBER_OF_MPSC_PORTS                3
+
+
+#ifdef THREE_ETHERNET_RMII_PORTS
+/********/
+/* RMII */
+/********/
+
+#define NUMBER_OF_ETHERNET_PORTS                3
+#define NUMBER_OF_MPSC_PORTS                    2
+#define MRR_REG_VALUE                           0x7ffe38
+
+/* connect MPSC0 + 3 ports of RMII */
+#define SERIAL_PORT_MULTIPLEX_REGISTER_VALUE    0x1102
+/* GALILEO value */
+/* 0000 0000 0001 0001  20 - RMII */
+/*                      16 - clear MIB counters */
+/* 1000 1000 0000 0000  15:14 - 2048 (10) */
+/*#define PORT_CONTROL_EXTEND_VALUE             0x00118000 */
+
+/* PPCBoot value */
+/* 0000 0000 0000 0001  20 - RMII */
+/* 0100 1101 0000 0000  15:14 - 1536 (01) */
+/*                      11 - dont force link pass */
+/*                      10 - disable FC AN */
+/*                       8 - prio override */
+/*#define PORT_CONTROL_EXTEND_VALUE             0x00104d00 */
+
+/* Montavista value */
+/* 0000 0000 0011 0000  21 - DSCP */
+/*                      20 - RMII */
+/* 0100 1100 0010 0010  15:14 - 1536 (01) */
+/*                      11 - dont force link pass */
+/*                      10 - disable fc AN */
+/*                      5:3 - 8pkt high, 1 low (100) */
+/*                      1 - bpdu trap */
+/*#define PORT_CONTROL_EXTEND_VALUE               0x00304c20 */
+#define PORT_CONTROL_EXTEND_VALUE               0x003004420 /* Force Link Pass */
+
+#define ETHERNET_DOWNLOADING_PORT               ETHERNET_PORT2
+
+#else				/* if !THREE_ETHERNET_RMII_PORTS */
+
+#ifdef TWO_ETHERNET_MII_PORTS
+/*******/
+/* MII */
+/*******/
+
+#define NUMBER_OF_ETHERNET_PORTS                2
+#define NUMBER_OF_MPSC_PORTS                    2
+#define MRR_REG_VALUE                           0x7ffe38
+/* connect MPSC0 + 2 ports of MII */
+#define SERIAL_PORT_MULTIPLEX_REGISTER_VALUE    0x1101
+/* GALILEO value */
+/* 0000 0000 0000 0001  16 - clear MIB counters */
+/* 1000 1000 0000 0000  15:14 - 2048 (10) */
+/*#define PORT_CONTROL_EXTEND_VALUE             0x00018000 */
+
+/* PPCBoot (ZUMA) value */
+/* 0000 0000 0000 0000 */
+/* 0100 1101 0000 0000  15:14 - 1536 (01) */
+/*                      11 - dont force link pass */
+/*                      10 - disable FC AN */
+/*                       8 - prio override */
+/*#define PORT_CONTROL_EXTEND_VALUE             0x00004d00 */
+
+/* Montavista (ZUMA) value */
+/* 0000 0000 0010 0000  21 - DSCP */
+/* 0100 1100 0010 0010  15:14 - 1536 (01) */
+/*                      11 - dont force link pass */
+/*                      10 - disable fc AN */
+/*                      5:3 - 8pkt high, 1 low (100) */
+/*                      1 - bpdu trap */
+#ifndef CONFIG_MOT_MVP
+#define PORT_CONTROL_EXTEND_VALUE               0x00204c20
+#else
+/* Hack, don't allow 10mbit for now */
+/* 0000 0000 0010 1100  21 - DSCP */
+/* 0100 1100 0010 0010  18 - Speed (1-> 100mbit) */
+/*                      19 - SpeedEn (1-> disable speed AN) */
+/*                      15:14 - 1536 (01) */
+/*                      11 - dont force link pass */
+/*                      10 - disable fc AN */
+/*                      5:3 - 8pkt high, 1 low (100) */
+/*                      1 - bpdu trap */
+/*  */
+#define PORT_CONTROL_EXTEND_VALUE		0x002c4c20
+#endif
+
+#define ETHERNET_DOWNLOADING_PORT           ETHERNET_PORT1
+
+#endif				/* endif TWO_ETHERNET_MII_PORTS */
+#endif				/* endif !THREE_ETHERNET_RMII_PORTS */
+
+#define LL_QUEUE_PRIORITY                       1
+#define L_QUEUE_PRIORITY                        2
+#define H_QUEUE_PRIORITY                        3
+#define HH_QUEUE_PRIORITY                       4
+
+#define NUMBER_OF_MIB_COUNTERS		25
+
+#define	TIME_OUT			10	/* 1/6 SEC */
+
+
+#endif /* MV_ETH_H */
Index: linux-2.6.16/include/linux/marvell/mv_mvtag.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_mvtag.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,178 @@
+/*
+ * FILENAME:    $Workfile: mv_mvtag.h $
+ * REVISION:    $Revision: 1.3 $
+ *
+ * DESCRIPTION:
+ *     This file defines Marvell Tag structure and support routines
+ */
+
+
+#ifndef MV_MVTAG_H
+#define MV_MVTAG_H
+
+
+#include <linux/marvell/msApiDefs.h>
+
+#define	MV_TAG_LEN	(4)
+
+typedef unsigned long mvtag_t;
+
+#define MT_TYPE(mt)  	((((mvtag_t)(mt)) & 0xc0000000) >> 30)
+#define MT_TAGGED(mt)	((((mvtag_t)(mt)) & 0x20000000) >> 29)
+#define MT_PRI(mt)	((((mvtag_t)(mt)) & 0x0000e000) >> 13)
+#define MT_VID(mt)	((((mvtag_t)(mt)) & 0x00000fff)      )
+
+#define MT_TDEV(mt)	((((mvtag_t)(mt)) & 0x1f000000) >> 24)
+#define MT_TPORT(mt)	((((mvtag_t)(mt)) & 0x00f80000) >> 19)
+#define MT_CFI(mt)	((((mvtag_t)(mt)) & 0x00010000) >> 16)
+
+#define MT_SDEV(mt)	MT_TDEV(mt)
+#define MT_SPORT(mt)	MT_TPORT(mt)
+#define MT_STRK(mt)	MT_SPORT(mt)
+#define MT_STRKED(mt)	((((mvtag_t)(mt)) & 0x00040000) >> 18)
+
+#define MT_CODE(mt)	(((((mvtag_t)(mt)) & 0x00060000) >> 16) | ((((mvtag_t)(mt)) & 0x00001000) >> 12))
+
+/*
+ * 	Marvell Tag's TYPE:
+ * 	
+ * 	Ingress (To Switch)   : FWD or FROM_CPU
+ * 	Egress  (From Switch) : FWD or TO_CPU
+ * 	
+ */
+#define MT_TYPE_TO_CPU		0
+#define MT_TYPE_FROM_CPU	1
+#define MT_TYPE_FWD 		3
+
+#define MT_TYPE_VALID(mt)	(MT_TYPE(mt) != 2)
+
+#define MT_MAX_PRI		0x7
+#define MT_MAX_VID		0xfff
+#define MT_MAX_DEV		0x1f
+#define MT_MAX_PORT		0x1f
+#define MT_MAX_TRK		MT_MAX_PORT
+#define MT_MAX_CODE		0x7
+
+/* FWD type, all other fields are zero */
+#define MT_DEFAULT_FWD_INGRESS 		0xc0000000
+
+/* FROM_CPU type, all other fields are zero */
+#define MT_DEFAULT_FROM_CPU_INGRESS 	0x40000000
+
+/* INVALID type, all other fields are zero */
+#define MT_DEFAULT_INVALID		0x80000000
+
+
+/*
+ * 	The following routines are for contructing Ingress MT that is
+ * 	to be sent to Marvell switches from CPU.
+ *
+ * 	Return 0 on Succ.
+ */
+
+/*
+ * Only allow to set FWD or FROM_CPU type.
+ * 
+ */
+static inline int mt_set_type(mvtag_t * mt, int type)
+{
+	mvtag_t tmp;
+
+	if (!mt)
+		return -1;
+
+	if (type != MT_TYPE_FWD && type != MT_TYPE_FROM_CPU)
+		return -1;
+
+	tmp = *mt & 0x3fffffff;
+	*mt = tmp | (type << 30);
+	return 0;
+}
+
+static inline int mt_set_tagged(mvtag_t *mt, int tagged)
+{
+	if (!mt)
+		return -1;
+
+	if (tagged)
+		*mt |=   0x20000000;
+	else
+		*mt &= ~(0x20000000);
+
+	return 0;
+}
+
+static inline int mt_set_pri(mvtag_t *mt, unsigned int pri)
+{
+	mvtag_t tmp;
+
+	if (!mt)
+		return -1;
+
+	if (pri > MT_MAX_PRI)
+		return -1;
+
+	tmp = *mt & 0xffff1fff;
+	*mt = tmp | (pri << 13);
+	return 0;
+}
+
+static inline int mt_set_vid(mvtag_t *mt, unsigned int vid)
+{
+	mvtag_t tmp;
+
+	if (!mt)
+		return -1;
+
+	if (vid > MT_MAX_VID)
+		return -1;
+
+	tmp = *mt & 0xfffff000;
+	*mt = tmp | vid;
+	return 0;
+}
+
+static inline int mt_set_tdev(mvtag_t *mt, unsigned int tdev)
+{
+	mvtag_t tmp;
+
+	if (!mt)
+		return -1;
+
+	if (tdev > MT_MAX_DEV)
+		return -1;
+
+	tmp = *mt & 0xe0ffffff;
+	*mt = tmp | (tdev << 24);
+	return 0;
+}
+
+static inline int mt_set_tport(mvtag_t *mt, unsigned int tport)
+{
+	mvtag_t tmp;
+
+	if (!mt)
+		return -1;
+
+	if (tport > MT_MAX_PORT)
+		return -1;
+
+	tmp = *mt & 0xfff8ffff;
+	*mt = tmp | (tport << 19);
+	return 0;
+}
+
+static inline int mt_set_cfi(mvtag_t *mt, int cfi)
+{
+	if (!mt)
+		return -1;
+
+	if (cfi)
+		*mt |=   0x00010000;
+	else
+		*mt &= ~(0x00010000);
+
+	return 0;
+}
+
+#endif /* MV_MVTAG_H */
Index: linux-2.6.16/include/linux/marvell/mv_os.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_os.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,317 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_os.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file is the OS Layer header, provided for OS independence.
+ */
+
+#ifndef MV_OS_H
+#define MV_OS_H
+
+
+/*************/
+/* Constants */
+/*************/
+
+#define GT_OS_WAIT_FOREVER				0
+
+
+/*************/
+/* Datatypes */
+/*************/
+
+typedef enum {
+	GT_OS_OK		= 0,
+	GT_OS_FAIL		= 1, 
+	GT_OS_TIMEOUT	= 2
+} GT_OS_STATUS;
+
+
+/*********************/
+/* OS Specific Stuff */
+/*********************/
+
+#include <linux/marvell/mv_os_linux.h>
+
+
+#ifdef HOST_LE /* HOST works in Little Endian mode */
+
+#define gtOsWordHtoN(data)   GT_BYTESWAP4(data)
+#define gtOsShortHtoN(data)  GT_BYTESWAP2(data)
+
+#else   /* HOST_BE - HOST works in Big Endian mode */
+
+#define gtOsWordHtoN(data)   (data)
+#define gtOsShortHtoN(data)  (data)
+
+#endif  /* HOST_LE || HOST_BE */
+
+/*	Useful functions to deal with Physical memory using OS dependent inline
+ *	functions defined in the file mv_os_???.h
+ */
+
+/*  Set physical memory with specified value. Use this function instead of
+ *  memset when physical memory should be set.
+ */
+static INLINE void gtOsSetPhysMem(GT_U32 hpaddr, GT_U8 val, int size)
+{
+	int	i;
+
+	for(i=0; i<size; i++)
+	{
+		gtOsIoMemWriteByte( (hpaddr+i), val);
+	}
+}
+
+/*	Copy data from Physical memory. Use this fuction instead of memcpy,
+ *  when data should be copied from Physical memory to Local (virtual) memory. 
+ */
+static INLINE void gtOsCopyFromPhysMem(GT_U8* localAddr, GT_U32 hpaddr, int size)
+{
+	int		i;
+	GT_U8	byte;
+
+	for(i=0; i<size; i++)
+	{
+		byte = gtOsIoMemReadByte(hpaddr+i);
+		localAddr[i] = byte;
+	}
+}
+
+/*	Copy data to Physical memory. Use this fuction instead of memcpy,
+ *  when data should be copied from Local (virtual) memory to Physical memory. 
+ */
+static INLINE void gtOsCopyToPhysMem(GT_U32 hpaddr, const GT_U8* localAddr, int size)
+{
+	int		i;
+
+	for(i=0; i<size; i++)
+	{
+		gtOsIoMemWriteByte( (hpaddr+i), localAddr[i]);
+	}
+}
+
+
+/***********/
+/* General */
+/***********/
+
+/* gtOsInit
+ *
+ * DESCRIPTION:
+ *     Creates and initializes all the internal components of the OS Layer.
+ *
+ * RETURN VALUES:
+ *     GT_OS_OK -- if succeeds.
+ */
+#ifndef gtOsInit
+long gtOsInit(void);
+#endif
+
+/* gtOsFinish
+ *
+ * DESCRIPTION:
+ *     Clears and deletes all the internal components of the OS Layer.
+ *
+ * RETURN VALUES:
+ *     GT_OS_OK -- if succeeds.
+ */
+#ifndef gtOsFinish 
+long gtOsFinish(void);
+#endif
+
+/* gtOsSleep
+ *
+ * DESCRIPTION:
+ *     Sends the current task to sleep.
+ *
+ * INPUTS:
+ *     mils -- number of miliseconds to sleep.
+ *
+ * RETURN VALUES:
+ *     GT_OS_OK if succeeds.
+ */
+#ifndef gtOsSleep
+void	gtOsSleep(unsigned long mils);
+#endif
+
+
+
+
+/*********/
+/* Misc. */
+/*********/
+
+/* gtOsGetCurrentTime
+ *
+ * DESCRIPTION:
+ *     Returns current system's up-time.
+ *
+ * INPUTS:
+ *     None.
+ *
+ * OUTPUTS:
+ *     None.
+ *
+ * RETURN VALUES:
+ *     current up-time in miliseconds.
+ */
+#ifndef gtOsGetCurrentTime
+unsigned long gtOsGetCurrentTime(void);
+#endif
+
+/* Returns last error number */
+#ifndef gtOsGetErrNo
+unsigned long	gtOsGetErrNo(void);
+#endif
+
+/* Returns random 32-bit number. */
+#ifndef gtOsRand
+unsigned int	gtOsRand(void);
+#endif
+
+/*****************/
+/* File Transfer */
+/*****************/
+
+/* gtOsOpenFile
+ *
+ * DESCRIPTION:
+ *     Opens a file on a remote machine.
+ *
+ * INPUTS:
+ *     machine  -- name or IP-address string of the file server.
+ *     path     -- path on the machine to the directory of the file.
+ *     filename -- name of file to be opened.
+ *
+ * OUTPUTS:
+ *     None.
+ *
+ * RETURN VALUES:
+ *     Handle to the opened file, or NULL on failure.
+ */
+#ifndef gtOsOpenFile
+void* gtOsOpenFile(char* machine, char* path, char* filename);
+#endif
+
+/* gtOsCloseFile
+ *
+ * DESCRIPTION:
+ *     Closes a file opened by gtOsOpenFile.
+ *
+ * INPUTS:
+ *     hfile -- file handle.
+ *
+ * OUTPUTS:
+ *     None.
+ *
+ * RETURN VALUES:
+ *     None.
+ */
+#ifndef gtOsCloseFile
+void gtOsCloseFile(void* hfile);
+#endif
+
+/* gtOsGetFileLine
+ *
+ * DESCRIPTION:
+ *     Reads up to len bytes from the file into the buffer, terminated with zero.
+ *
+ * INPUTS:
+ *     buf   -- buffer pointer.
+ *     len   -- buffer length (in bytes).
+ *     hfile -- file handle.
+ *
+ * RETURN VALUES:
+ *     The given 'buf' pointer.
+ */
+#ifndef gtOsGetFileLine
+char* gtOsGetFileLine(void* hfile, char* buf, int len);
+#endif
+
+/**************/
+/* Semaphores */
+/**************/
+
+/* gtOsSemCreate
+ *
+ * DESCRIPTION:
+ *     Creates a semaphore.
+ *
+ * INPUTS:
+ *     name  -- semaphore name.
+ *     init  -- init value of semaphore counter.
+ *     count -- max counter value (must be positive).
+ *
+ * OUTPUTS:
+ *     smid -- pointer to semaphore ID.
+ *
+ * RETURN VALUES:
+ *     GT_OS_OK if succeeds.
+ */
+#ifndef gtOsSemCreate
+long gtOsSemCreate(char *name,unsigned long init,unsigned long count,
+		   unsigned long *smid);
+#endif
+
+
+/* gtOsSemDelete
+ *
+ * DESCRIPTION:
+ *     Deletes a semaphore.
+ *
+ * INPUTS:
+ *     smid -- semaphore ID.
+ *
+ * RETURN VALUES:
+ *     GT_OS_OK if succeeds.
+ */
+#ifndef gtOsSemDelete
+long gtOsSemDelete(unsigned long smid);
+#endif
+
+/* gtOsSemWait
+ *
+ * DESCRIPTION:
+ *     Waits on a semaphore.
+ *
+ * INPUTS:
+ *     smid     -- semaphore ID.
+ *     time_out -- time out in miliseconds, or 0 to wait forever.
+ *
+ * RETURN VALUES:
+ *     GT_OS_OK if succeeds.
+ */
+#ifndef gtOsSemWait
+long gtOsSemWait(unsigned long smid, unsigned long time_out);
+#endif
+
+/* gtOsSemSignal
+ *
+ * DESCRIPTION:
+ *     Signals a semaphore.
+ *
+ * INPUTS:
+ *     smid -- semaphore ID.
+ *
+ * RETURN VALUES:
+ *     GT_OS_OK if succeeds.
+ */
+#ifndef gtOsSemSignal
+long gtOsSemSignal(unsigned long smid);
+#endif
+
+#endif /* MV_OS_H */
Index: linux-2.6.16/include/linux/marvell/mv_os_linux.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_os_linux.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,111 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_os_linux.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file is the OS Layer header, for uClinux.
+ */
+
+#ifndef _MV_OS_LINUX_H_
+#define _MV_OS_LINUX_H_
+
+/*
+ * LINUX includes
+ */
+#include <linux/kernel.h>
+
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/fcntl.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ip.h>
+#include <linux/mii.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+#include <linux/ctype.h>
+
+/* #include <asm/88E6318/mv88E6318.h> */
+/* #include <asm/88E6318/mv88E6318int.h> */
+/* #include <asm/88E6318/mv88E6318regs.h> */
+#include <asm/mpc85xx.h>
+
+#include <linux/marvell/msApi.h>
+#include <linux/marvell/mv_types.h>
+#include <linux/marvell/mv_common.h>
+#include <linux/marvell/mv_platform.h>
+
+#define INLINE	inline
+
+#ifdef MV_DEBUG
+#define ASSERT(assert) { do { if(!(assert)) { BUG(); } }while(0); }
+#else
+#define ASSERT(assert) 
+#endif 
+
+#define IN
+#define OUT
+
+#define INLINE inline
+
+#define gtOsPrintf				printk
+
+/*
+ *  Physical memory access
+ */
+static INLINE GT_U32 gtOsIoMemReadWord(GT_U32 hpaddr)	
+{
+	return *(volatile GT_U32*)(hpaddr|GT_OS_IOMEM_PREFIX);
+}
+
+static INLINE void gtOsIoMemWriteWord(GT_U32 hpaddr, GT_U32 data) 
+{
+	*(volatile GT_U32*)(hpaddr|GT_OS_IOMEM_PREFIX) = data;
+}
+
+static INLINE GT_U16 gtOsIoMemReadShort(GT_U32 hpaddr)	
+{
+	return *(volatile GT_U16*)(hpaddr|GT_OS_IOMEM_PREFIX);
+}
+
+static INLINE void gtOsIoMemWriteShort(GT_U32 hpaddr, GT_U16 data) 
+{
+	*(volatile GT_U16*)(hpaddr|GT_OS_IOMEM_PREFIX) = data;
+}
+
+static INLINE GT_U8 gtOsIoMemReadByte(GT_U32 hpaddr)	
+{
+	return *(volatile GT_U8*)(hpaddr|GT_OS_IOMEM_PREFIX);
+}
+
+static INLINE void gtOsIoMemWriteByte(GT_U32 hpaddr, GT_U8 data) 
+{
+	*(volatile GT_U8*)(hpaddr|GT_OS_IOMEM_PREFIX) = data;
+}
+
+#endif /* _MV_OS_LINUX_H_ */
Index: linux-2.6.16/include/linux/marvell/mv_platform.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_platform.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,116 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_platform.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file defines the support required for CPU and BSP independence.
+ */
+
+#ifndef _MV_PLATFORM_H_
+#define _MV_PLATFORM_H_
+
+#include <linux/marvell/mv_types.h>
+#include <linux/marvell/mv_common.h>
+#include <linux/marvell/mv_regs.h>
+#include <linux/phy.h>
+
+/*-------------------------------------------------*/
+/* Trailers and Headers settings                   */
+/*-------------------------------------------------*/
+#undef TRAILERS
+/* #define HEADERS */
+#undef HEADERS
+
+#ifdef TRAILERS
+#define QD_TRAILER_MODE
+#endif 
+
+#ifdef HEADERS
+#define QD_HEADER_MODE
+#endif
+
+
+/*-------------------------------------------------*/
+/* Types for IOCTL implementation                  */
+/*-------------------------------------------------*/
+
+#define  STATUS_SUCCESS (0)
+#define  STATUS_UNSUCCESSFUL (-1)
+
+typedef enum {
+	false =0,
+	true
+} bool;
+
+typedef void VOID;
+typedef unsigned int UINT;
+typedef unsigned char UCHAR;
+typedef unsigned int DWORD;
+typedef char WCHAR;
+#define MAX_VLAN_NAME                   (20)
+
+
+
+/*
+ * The CPU port number within the QD switch
+ */
+#define GT_CPU_SWITCH_PORT	(5)
+
+#if defined(MV88E6318) /* MIPS Firehawk */
+#  define PLATFORM_GTREG_BASE 0xb4000000 /* uncached */
+#  define GT_OS_IOMEM_PREFIX  0xa0000000
+#else /* ARM Firefox */ 
+#  define PLATFORM_GTREG_BASE 0x80000000    
+#  define GT_OS_IOMEM_PREFIX  0x00000000
+#endif
+
+/*  Access Device BUS for internal usage only */
+
+#define PLATFORM_DEV_READ_CHAR(offset) *(volatile GT_U8*)((offset)|PLATFORM_DEV_BASE|GT_OS_IOMEM_PREFIX);
+
+#define PLATFORM_DEV_WRITE_CHAR(offset, data) *(volatile GT_U8*)((offset)|PLATFORM_DEV_BASE|GT_OS_IOMEM_PREFIX) = (data);
+
+
+/* Access to FF registers (Read/Write) */
+static inline void gtOsGtRegWrite(GT_U32 gtreg, GT_U32 data)
+{
+	*(volatile GT_U32*)(PLATFORM_GTREG_BASE|GT_OS_IOMEM_PREFIX|gtreg) = data;
+}
+
+static inline GT_U32 gtOsGtRegRead(GT_U32 gtreg)
+{
+	return ( *(volatile GT_U32*)(PLATFORM_GTREG_BASE|GT_OS_IOMEM_PREFIX|gtreg) );
+}
+
+/*
+ * we use TSECs GFAR driver to provide mii operations.
+ *
+ * look at driver/net/gianfar_phy.c
+ * 
+ */
+int gianfar_miiphy_read(unsigned char addr, unsigned char reg, unsigned short *value);
+int gianfar_miiphy_write(unsigned char addr, unsigned char reg, unsigned short value);
+
+static inline int miiphy_read(unsigned char addr, unsigned char reg, unsigned short *value)
+{
+	return gianfar_miiphy_read(addr, reg, value);
+}
+
+static inline int miiphy_write(unsigned char addr, unsigned char reg, unsigned short value)
+{
+	return gianfar_miiphy_write(addr, reg, value);
+}
+
+#endif /* _MV_PLATFORM_H_ */
Index: linux-2.6.16/include/linux/marvell/mv_qd.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_qd.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,32 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_qd.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file is the QD driver header.
+ */
+
+#ifndef __mv_qd_h
+#define __mv_qd_h
+
+
+#include <linux/marvell/msApiDefs.h>
+#include <linux/marvell/msApiPrototype.h>
+
+#define GT_NUM_OF_SWITCH_PORTS  7
+#define GT_QD_VERSION_MAX_LEN   30
+
+
+#endif /* __mv_qd_h */
Index: linux-2.6.16/include/linux/marvell/mv_regs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_regs.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,67 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_regs.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file contains general information about the GT registers.
+ */
+
+
+#ifndef MV_REGS_H
+#define MV_REGS_H
+
+#ifndef MV88E6218
+#define MV88E6218
+#endif
+
+/* This header file contains readable definitions for the GT-96132 System 
+ *  Controller internal register addresses:
+ *   CPU Configuration 
+ *   CPU Address Decode 
+ *   CPU Errors Report 
+ *   Sync Barrier 
+ *   SDRAM_and Device Address Decode 
+ *   SDRAM Configuration 
+ *   SDRAM Parameters 
+ *   ECC 
+ *   Device Parameters
+ *   DMA Record 
+ *   DMA Arbiter 
+ *   Timer/Counter 
+ *   PCI_Internal 
+ *   PCI Configuration 
+ *   PCI Configuration, Function 1 
+ *   Interrupts 
+ *   I2O Support Registers 
+ *   Communication Unit registers
+ */
+
+/****************************************/
+/* General           					*/
+/****************************************/
+
+#define FAST_ETH_MAC_OFFSET  		0x8000
+
+
+/****************************************/
+/* CPU Configuration 					*/
+/****************************************/
+
+
+/* Ethernet Ports */
+#define GT_REG_ETHER_SMI_REG        (FAST_ETH_MAC_OFFSET+0x10) 
+
+
+#endif /* MV_REGS_H */
Index: linux-2.6.16/include/linux/marvell/mv_types.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_types.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,31 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_types.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file defines common data types used on Host and NetGX sides.
+ */
+
+
+#ifndef MV_TYPES_H
+#define MV_TYPES_H
+
+
+#include <linux/marvell/msApiDefs.h>
+
+#define	GT_ETHERNET_HEADER_SIZE		(6)
+
+
+#endif /* MV_TYPES_H */
Index: linux-2.6.16/include/linux/marvell/mv_unimac.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_unimac.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,114 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_unimac.h $
+ * REVISION:    $Revision: 1.3 $
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $
+ *
+ * DESCRIPTION:
+ *     This file is the OS Layer header, provided for OS independence.
+ */
+
+#ifndef MV_UNIMAC_H
+#define MV_UNIMAC_H
+
+
+#include <linux/marvell/mv_platform.h>
+#include <linux/marvell/mv_qd.h>
+
+#define MV_UNM_VID_DISABLED		0
+#define MV_UNM_VID_ISOLATED		(GT_NUM_OF_SWITCH_PORTS+1)
+
+#define	MV_UNM_MAX_VID			(MV_UNM_VID_ISOLATED+1)
+
+typedef int MV_UNM_VID;
+
+typedef struct _MV_UNM_CONFIG 
+{
+	MV_UNM_VID	vidOfPort[GT_NUM_OF_SWITCH_PORTS];     
+} MV_UNM_CONFIG;
+
+
+/*******************************************************************************
+ *Description:
+ *	User application function that supplies configuration to UniMAC Manager
+ *  The function receives a optional pointer to configuration array 
+ *	Parameters:
+ *		unmConfig: pointer to VLAN mapping configuration
+ *					if this parameter is NULL the default parameters
+ * Return value:
+ *		GT_OK	on success
+ *		GT_FAIL otherwise
+ ********************************************************************************/
+
+extern GT_STATUS getNetConfig(OUT MV_UNM_CONFIG* unmConfig);
+
+
+/*******************************************************************************
+ *Description:
+ *	UniMAC manager intialization function
+ *  The function receives a optional pointer to configuration array and also 
+ *	pointers to save and restore configurqation functions
+ *	Parameters:
+ *		None
+ * Return value:
+ *		GT_SUCCESS		on success
+ *		GT_BAD_PARAM	if if getNetConfig() returns invalid configuration
+ *		GT_FAIL			otherwise
+ ********************************************************************************/
+GT_STATUS  mvUnmInitialize(void);
+
+/*******************************************************************************
+ *Description:
+ *	Retrieve current network configuration
+ *  The function receives a pointer to return configuration 
+ *	Parameters:
+ *		config: pointer to VLAN mapping configuration
+ * Return value:
+ *		GT_OK	on success
+ *		GT_FAIL on error
+ ********************************************************************************/
+GT_STATUS	mvUnmGetNetConfig(OUT MV_UNM_CONFIG *config);
+
+
+/*******************************************************************************
+ *Description:
+ *	Move port from isolated VLAN to specific VLAN
+ *	Parameters:
+ *		portId:  port number 
+ *		vlanId:	 VLAN id
+ * Return value:
+ * GT_OK			on success
+ * GT_BAD_PARAM	if a port number is invalid or the port 
+ *						already belongs to some VLAN
+ * GT_FAIL		on other failures
+ *
+ ********************************************************************************/
+ 
+GT_STATUS	mvUnmPortMoveTo(IN int qdPort, IN const MV_UNM_VID vlanId);
+
+/* Create port based VLAN */
+GT_STATUS mvUnmCreateVlan(int vid, GT_U32 vlanPortMask);
+
+/* Return port mask belong this vid */
+GT_U32		mvUnmGetPortMaskOfVid(MV_UNM_VID vid);
+                                   
+
+/* Return vid, that port belong to */
+MV_UNM_VID	mvUnmGetVidOfPort(int port);
+
+/* Return total number of vids, without ISOLATED and DISABLED  */
+int			mvUnmGetNumOfVlans(void);
+
+
+
+#endif /* MV_UNIMAC_H */
Index: linux-2.6.16/include/linux/marvell/mv_unm_netconf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/mv_unm_netconf.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,108 @@
+/*******************************************************************************
+ *                Copyright 2002, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ *********************************************************************************/
+/* 
+ * FILENAME:    $Workfile: mv_unm_netconf.h $ 
+ * REVISION:    $Revision: 1.3 $ 
+ * LAST UPDATE: $Modtime: 6/25/03 7:52p $ 
+ * 
+ */
+#ifndef _FF_NETCNF_H_
+#define _FF_NETCNF_H_
+
+#include <linux/marvell/mv_os.h>
+#include <linux/marvell/mv_unimac.h>
+#include <linux/marvell/mv_eth.h>
+
+/*
+ * This function returns the name of a given VID.
+ *
+ * Inputs:
+ * vid - the vlan id to retirive its name.
+ *
+ * Outputs:
+ * pNameLength - the length of this string's name.
+ * pszVlanName - a const pointer to the name.
+ *
+ * NOTICE: this function returns an unsafe pointer to the string itself
+ *         it doesn't copy nor allocate.
+ */
+VOID           mv_nc_GetVIDName(IN MV_UNM_VID vid,OUT unsigned int *pNameLength,OUT char **pszVlanName);
+
+/*
+ * This function returns the MAC of a given VID.
+ *
+ * Inputs:
+ * vid - the vlan id to retirive its mac.
+ *
+ * Outputs:
+ * A pointer to the mac address (bytes array) of this vlan.
+ *
+ */
+unsigned char* mv_nc_GetMacOfVlan(IN MV_UNM_VID vid);
+
+/*
+ * ----------------------------------------------------------------------------
+ * GT_STATUS  getNetConfig(OUT MV_UNM_CONFIG* unmConfig)
+ *
+ * This function is a part of the unimca manager API.
+ * The unimac manager API (mv_unimac_mgr.c) requires a get function 
+ * in order to init the net-conf data.
+ * While being loaded, the unimac manager request for its init 
+ * configuration data with that function.
+ *
+ * Inputs:
+ *
+ * Outputs:
+ * unmConfig - A pointer to the net config to be filled with the init data.
+ *
+ */
+GT_STATUS      getNetConfig(OUT MV_UNM_CONFIG* unmConfig);
+
+
+/*
+ * ----------------------------------------------------------------------------
+ * GT_STATUS  setNetConfig(OUT MV_UNM_CONFIG* unmConfig, 
+ *						char names[MV_UNM_MAX_VID][MAX_VLAN_NAME],
+ *  					unsigned char macs[MV_UNM_MAX_VID][GT_ETHERNET_HEADER_SIZE])
+ *
+ * The initialization phase calls this set function in order to 
+ * init private fields of this modules.
+ * the private fields holds the net-conf data.
+ * a caller to the 'get' function will retreive this data (see above).
+ *
+ * Inputs:
+ * unmConfig - A pointer to the net config with the init data.
+ * names     - An array of the vlan names in the net-conf.
+ * macs      - An array of mac addresses in the net-conf.
+ *
+ * Outputs:
+ * GT_STATUS - the status of the operation.
+ *
+ */
+GT_STATUS  setNetConfig(OUT MV_UNM_CONFIG* unmConfig, 
+			char names[MV_UNM_MAX_VID][MAX_VLAN_NAME],
+			unsigned char macs[MV_UNM_MAX_VID][GT_ETHERNET_HEADER_SIZE]);
+
+/*
+ * A debug function to print the configuration in the unimac manager.
+ * This function should be used to test that the get config, called by the manager
+ * inited the manager with the correct data. 
+ *
+ * Inputs:
+ *
+ * Outputs:
+ *
+ */
+#ifdef ETH_DBG_INFO
+void           mv_nc_printConf(void);
+#endif
+
+#endif /* _FHNETCNF_H_ */
Index: linux-2.6.16/include/linux/marvell/platformDeps.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/platformDeps.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,31 @@
+#include <linux/marvell/Copyright.h>
+
+/********************************************************************************
+ * platformDeps.h
+ *
+ * DESCRIPTION:
+ *       platform dependent definitions
+ *
+ * DEPENDENCIES:   Platform.
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#ifndef __platformDepsh
+#define __platformDepsh
+
+#include <linux/marvell/msApi.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	GT_BOOL defaultMiiRead (unsigned int portNumber , unsigned int miiReg, unsigned int* value);
+	GT_BOOL defaultMiiWrite (unsigned int portNumber , unsigned int miiReg, unsigned int value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* platformDepsh */
+
Index: linux-2.6.16/include/linux/marvell/qdModule.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16/include/linux/marvell/qdModule.h	2007-05-24 14:47:01.000000000 -0400
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ *                Copyright 2001, Marvell International Ltd.
+ * This code contains confidential information of Marvell semiconductor, inc.
+ * no rights are granted herein under any patent, mask work right or copyright
+ * of Marvell or any third party.
+ * Marvell reserves the right at its sole discretion to request that this code
+ * be immediately returned to Marvell. This code is provided "as is".
+ * Marvell makes no warranties, express, implied or otherwise, regarding its
+ * accuracy, completeness or performance.
+ ********************************************************************************
+ * qdModule.h
+ *
+ * DESCRIPTION:
+ *		Defines the entry point for the QD driver
+ *
+ * DEPENDENCIES:   Platform.
+ *
+ * FILE REVISION NUMBER:
+ *
+ *******************************************************************************/
+
+#ifndef _QD_MODULE_H_
+#define _QD_MODULE_H_
+#include <linux/marvell/mv_qd.h>
+#include <linux/marvell/mv_os.h>
+#include <linux/marvell/mv_unimac.h>
+#include <linux/marvell/msIoctl.h>
+#include <linux/marvell/mv_platform.h>
+
+extern GT_STATUS qdInit(void);
+GT_STATUS qdDisassociatePort(int portNum, int fromVlanId);
+GT_STATUS qdAssociatePort(int portNum, int toVlanId);
+
+#endif /* _QD_MODULE_H_ */
Index: linux-2.6.16/include/net/neighbour.h
===================================================================
--- linux-2.6.16.orig/include/net/neighbour.h	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/include/net/neighbour.h	2007-05-24 14:47:01.000000000 -0400
@@ -139,6 +139,9 @@
 	struct sk_buff_head	arp_queue;
 	struct timer_list	timer;
 	struct neigh_ops	*ops;
+#ifdef CONFIG_MV88E6095	
+	unsigned long		priv; 		/* used by specific neigh_table impl */
+#endif
 	u8			primary_key[0];
 };
 
Index: linux-2.6.16/net/ipv4/arp.c
===================================================================
--- linux-2.6.16.orig/net/ipv4/arp.c	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/net/ipv4/arp.c	2007-05-24 14:48:21.000000000 -0400
@@ -128,6 +128,13 @@
 
 #include <linux/netfilter_arp.h>
 
+#undef TSEC2_ENABLE_MV_TAG
+#if defined(CONFIG_ALTERPATH_ONBOARD) && defined(CONFIG_MV88E6095)
+#define TSEC2_ENABLE_MV_TAG
+#include <linux/marvell/mv_mvtag.h>
+#include <linux/debmax_sw6095.h>
+#endif
+
 /*
  *	Interface to generic neighbour cache.
  */
@@ -574,12 +581,24 @@
 	 *	Allocate a buffer
 	 */
 	
+#ifdef TSEC2_ENABLE_MV_TAG
+	/* Allocate 4 more bytes and reserve them for Marvell Tag, this
+	 * can prevent skb being copied due to lack of headroom */
+	skb = alloc_skb(sizeof(struct arphdr)+ 2*(dev->addr_len+4)
+				+ dev->hard_header_len + 15 + 4, GFP_ATOMIC);
+
+	if (skb == NULL)
+		return;
+
+	skb_reserve(skb, ((dev->hard_header_len+15)&~15)+4);
+#else
 	skb = alloc_skb(sizeof(struct arphdr)+ 2*(dev->addr_len+4)
 				+ LL_RESERVED_SPACE(dev), GFP_ATOMIC);
 	if (skb == NULL)
 		return NULL;
 
 	skb_reserve(skb, LL_RESERVED_SPACE(dev));
+#endif
 	skb->nh.raw = skb->data;
 	arp = (struct arphdr *) skb_put(skb,sizeof(struct arphdr) + 2*(dev->addr_len+4));
 	skb->dev = dev;
@@ -714,7 +733,19 @@
 	u32 sip, tip;
 	u16 dev_type = dev->type;
 	int addr_type;
-	struct neighbour *n;
+	struct neighbour *n = NULL;
+#ifdef TSEC2_ENABLE_MV_TAG
+	mvtag_t mt = MT_DEFAULT_INVALID;
+
+	{
+		mt_pair_t *mp = MT_PAIR_SKB_CB(skb);
+			
+		if (mt_pair_is_valid(mp)) {
+			mt = mp->mvt;
+			mt_pair_init(mp);
+		}
+	}
+#endif
 
 	/* arp_rcv below verifies the ARP header and verifies the device
 	 * is ARP'able.
@@ -850,7 +881,7 @@
 				if (!dont_send)
 					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
 
-				neigh_release(n);
+/* 				neigh_release(n); */
 			}
 			goto out;
 		} else if (IN_DEV_FORWARD(in_dev)) {
@@ -858,14 +889,14 @@
 			    (addr_type == RTN_UNICAST  && rt->u.dst.dev != dev &&
 			     (arp_fwd_proxy(in_dev, rt) || pneigh_lookup(&arp_tbl, &tip, dev, 0)))) {
 				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
-				if (n)
-					neigh_release(n);
 
 				if (NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED || 
 				    skb->pkt_type == PACKET_HOST ||
 				    in_dev->arp_parms->proxy_delay == 0) {
 					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
 				} else {
+					if (n)
+						neigh_release(n);
 					pneigh_enqueue(&arp_tbl, in_dev->arp_parms, skb);
 					in_dev_put(in_dev);
 					return 0;
@@ -908,10 +939,16 @@
 		    skb->pkt_type != PACKET_HOST)
 			state = NUD_STALE;
 		neigh_update(n, sha, state, override ? NEIGH_UPDATE_F_OVERRIDE : 0);
-		neigh_release(n);
 	}
 
 out:
+	if (n) {
+#ifdef TSEC2_ENABLE_MV_TAG
+		if (MT_TYPE_VALID(mt))
+			n->priv = MT_VID(mt);
+#endif
+		neigh_release(n);
+	}
 	if (in_dev)
 		in_dev_put(in_dev);
 	kfree_skb(skb);
@@ -1316,8 +1353,20 @@
 	}
 #endif
 	sprintf(tbuf, "%u.%u.%u.%u", NIPQUAD(*(u32*)n->primary_key));
-	seq_printf(seq, "%-16s 0x%-10x0x%-10x%s     *        %s\n",
-		   tbuf, hatype, arp_state_to_flags(n), hbuffer, dev->name);
+#ifdef TSEC2_ENABLE_MV_TAG
+	if (n->priv) {
+		seq_printf(seq, "%-16s 0x%-10x0x%-10x%s"
+			       "     *        %s@%lu\n",
+			       tbuf,
+			       hatype,
+			       arp_state_to_flags(n), 
+			       hbuffer,
+			       dev->name,
+			       n->priv);
+	} else
+#endif
+		seq_printf(seq, "%-16s 0x%-10x0x%-10x%s     *        %s\n",
+			   tbuf, hatype, arp_state_to_flags(n), hbuffer, dev->name);
 	read_unlock(&n->lock);
 }
 
Index: linux-2.6.16/net/ipv4/ip_input.c
===================================================================
--- linux-2.6.16.orig/net/ipv4/ip_input.c	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/net/ipv4/ip_input.c	2007-05-24 14:47:01.000000000 -0400
@@ -147,6 +147,13 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
+#undef TSEC2_ENABLE_MV_TAG
+#if defined(CONFIG_ALTERPATH_ONBOARD) && defined(CONFIG_MV88E6095)
+#define TSEC2_ENABLE_MV_TAG
+#include <linux/marvell/mv_mvtag.h>
+#include <linux/debmax_sw6095.h>
+#endif
+
 /*
  *	SNMP management statistics
  */
@@ -332,6 +339,22 @@
 static inline int ip_rcv_finish(struct sk_buff *skb)
 {
 	struct iphdr *iph = skb->nh.iph;
+#ifdef TSEC2_ENABLE_MV_TAG
+	u32 sip;
+	struct neighbour *n;
+	mvtag_t mt = MT_DEFAULT_INVALID;
+
+	sip = iph->saddr;
+
+	{
+		mt_pair_t *mp = MT_PAIR_SKB_CB(skb);
+			
+		if (mt_pair_is_valid(mp)) {
+			mt = mp->mvt;
+			mt_pair_init(mp);
+		}
+	}
+#endif
 
 	/*
 	 *	Initialise the virtual path cache for the packet. It describes
@@ -361,6 +384,14 @@
 	if (iph->ihl > 5 && ip_rcv_options(skb))
 		goto drop;
 
+#ifdef TSEC2_ENABLE_MV_TAG
+	if (MT_TYPE_VALID(mt)) {
+		if ((n=__neigh_lookup(&arp_tbl, &sip, skb->dev, 0))) {
+			n->priv = MT_VID(mt);
+			neigh_release(n);
+		}
+	}
+#endif
 	return dst_input(skb);
 
 drop:
Index: linux-2.6.16/drivers/net/phy/phy.c
===================================================================
--- linux-2.6.16.orig/drivers/net/phy/phy.c	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/drivers/net/phy/phy.c	2007-05-24 14:47:01.000000000 -0400
@@ -460,9 +460,11 @@
 	phydev->speed = settings[idx].speed;
 	phydev->duplex = settings[idx].duplex;
 
+    /*
 	pr_info("Trying %d/%s\n", phydev->speed,
 			DUPLEX_FULL == phydev->duplex ?
 			"FULL" : "HALF");
+    */
 }
 
 
@@ -744,11 +746,13 @@
 					phydev->link_timeout =
 						PHY_FORCE_TIMEOUT;
 
+                    /*
 					pr_info("Trying %d/%s\n",
 							phydev->speed,
 							DUPLEX_FULL ==
 							phydev->duplex ?
 							"FULL" : "HALF");
+                    */
 				}
 
 				needs_aneg = 1;
Index: linux-2.6.16/arch/ppc/syslib/mpc85xx_devices.c
===================================================================
--- linux-2.6.16.orig/arch/ppc/syslib/mpc85xx_devices.c	2007-05-24 14:34:46.000000000 -0400
+++ linux-2.6.16/arch/ppc/syslib/mpc85xx_devices.c	2007-05-24 14:47:01.000000000 -0400
@@ -35,9 +35,12 @@
 };
 
 static struct gianfar_platform_data mpc85xx_tsec2_pdata = {
-	.device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT |
-	    FSL_GIANFAR_DEV_HAS_COALESCE | FSL_GIANFAR_DEV_HAS_RMON |
-	    FSL_GIANFAR_DEV_HAS_MULTI_INTR,
+    .device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT |
+        FSL_GIANFAR_DEV_HAS_COALESCE | FSL_GIANFAR_DEV_HAS_RMON |
+#ifdef CONFIG_ALTERPATH_ONBOARD
+        FSL_GIANFAR_DEV_HAS_FAKE_PHY |
+#endif
+        FSL_GIANFAR_DEV_HAS_MULTI_INTR,
 };
 
 static struct gianfar_platform_data mpc85xx_etsec1_pdata = {
