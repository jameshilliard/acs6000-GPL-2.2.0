diff -ruNp linux-2.6.16/arch/ppc/boot/cyc_banner.h.tst kvmmax/arch/ppc/boot/cyc_banner.h.tst
--- linux-2.6.16/arch/ppc/boot/cyc_banner.h.tst	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/arch/ppc/boot/cyc_banner.h.tst	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,71 @@
+static char PROD_LINE0[] = "Cyclades";
+static char PROD_NAME0[] = " TS";
+
+static char PROD_LINE1[] = "AlterPath";
+static char PROD_NAME1[] = " CS";
+
+#define PROD_LINE3			PROD_LINE1
+static char PROD_NAME3[] = " ACS";
+
+#define PROD_LINE2			PROD_LINE1
+static char PROD_NAME2[] = " SM";
+
+#define PROD_LINE4			PROD_LINE1
+static char PROD_NAME4[] = " KVM";
+
+#define PROD_LINE5			PROD_LINE1
+static char PROD_NAME5[] = " KVM/net";
+
+#define PROD_LINE6          PROD_LINE1
+static char PROD_NAME6[] = " ONS";
+
+#define PROD_LINE7			PROD_LINE1
+static char PROD_NAME7[] = " KVM/net Plus";
+
+static char CYCLADES_TXT[] = "Cyclades";
+static char CYCLADES_BANNER[] = "Linux ";
+static char CYCLADES_WHAT[] = "@(#)V_2.0.0a  (May/20/05) #2";
+
+#define CYCLADES_VERSION	(CYCLADES_WHAT+4)
+
+static char machine_txt[38][8] = {
+	"PR3000",
+	"PR+000",
+	"PR=000",
+	"PR1000",
+	"TS1000",
+	"TS2000",
+	"TS400",
+	"TS800",
+	"TS3000",
+	"Tx1000",
+	"Tx2000",
+	"PL1000",
+	"TS100",
+	"NL1000",
+	"ACS16",
+	"ACS32",
+	"SM100",
+	"PR3500",
+	"TS110",
+	"ACS48",
+	"ACS4",
+	"ACS8",
+	"ACS1",
+	"PR3000",
+	"KVM16",
+	"KVM32",
+	"KVMN16",
+	"KVMN32",
+	"ONS441",
+	"ONS481",
+	"ONS841",
+	"ONS881",
+	"ONS442",
+	"ONS482",
+	"ONS842",
+	"ONS882",
+	"KVMP16",
+	"KVMP32",
+};
+
diff -ruNp linux-2.6.16/arch/ppc/boot/images/Makefile kvmmax/arch/ppc/boot/images/Makefile
--- linux-2.6.16/arch/ppc/boot/images/Makefile	2006-03-20 18:07:03.000000000 +1100
+++ kvmmax/arch/ppc/boot/images/Makefile	2006-04-26 11:51:24.000000000 +1000
@@ -30,5 +30,18 @@ $(obj)/uImage: $(obj)/vmlinux.gz
 	@echo -n '  Image: $@ '
 	@if [ -f $@ ]; then echo 'is ready' ; else echo 'not made'; fi
 
+quiet_cmd_uimage.initrd = UIMAGE.INITRD  $@
+      cmd_uimage.initrd = $(CONFIG_SHELL) $(MKIMAGE) -A ppc -O linux \
+                      -T multi -C gzip -a 00000000 -e 00000000 \
+                      -n 'Linux-$(KERNELRELEASE)' \
+                      -d $<:$(obj)/ramdisk.image.gz $@
+
+targets += uImage.initrd
+$(obj)/uImage.initrd: $(obj)/vmlinux.gz $(obj)/ramdisk.image.gz
+	$(Q)rm -f $@
+	$(call if_changed,uimage.initrd)
+	@echo -n '  Image: $@ '
+	@if [ -f $@ ]; then echo 'is ready' ; else echo 'not made'; fi
+
 # Files generated that shall be removed upon make clean
 clean-files	:= sImage vmapus vmlinux* miboot* zImage* uImage
diff -ruNp linux-2.6.16/arch/ppc/Kconfig kvmmax/arch/ppc/Kconfig
--- linux-2.6.16/arch/ppc/Kconfig	2006-03-20 18:07:03.000000000 +1100
+++ kvmmax/arch/ppc/Kconfig	2006-04-24 16:31:10.000000000 +1000
@@ -246,6 +246,36 @@ config PPC601_SYNC_FIX
 	  If in doubt, say Y here.
 
 source arch/ppc/platforms/4xx/Kconfig
+
+config ALTERPATH
+	bool "Cyclades Alterpath options"
+
+choice
+	depends on ALTERPATH
+	prompt "Machine Type"
+	default Alterpath_ACS
+
+config Alterpath_ACS
+	bool "Cyclades Alterpath ACS"
+
+config Alterpath_KVMMAX
+	bool "Cyclades Alterpath KVMMAX version 1"
+
+config Alterpath_KVMMAXV2
+	bool "Cyclades Alterpath KVMMAX version 2"
+
+config ALTERPATH_ONBOARD_V1
+	bool "Cyclades Alterpath OnBoard v1"
+
+config ALTERPATH_ONBOARD_V2
+	bool "Cyclades Alterpath OnBoard v2"
+endchoice
+
+config ALTERPATH_ONBOARD
+	bool
+	depends on ALTERPATH_ONBOARD_V1 || ALTERPATH_ONBOARD_V2
+	default y
+
 source arch/ppc/platforms/85xx/Kconfig
 
 config PPC64BRIDGE
diff -ruNp linux-2.6.16/arch/ppc/kernel/time.c kvmmax/arch/ppc/kernel/time.c
--- linux-2.6.16/arch/ppc/kernel/time.c	2006-03-20 18:07:03.000000000 +1100
+++ kvmmax/arch/ppc/kernel/time.c	2006-04-26 11:51:25.000000000 +1000
@@ -172,7 +172,7 @@ void timer_interrupt(struct pt_regs * re
 		 * We should have an rtc call that only sets the minutes and
 		 * seconds like on Intel to avoid problems with non UTC clocks.
 		 */
-		if ( ppc_md.set_rtc_time && ntp_synced() &&
+		if ( ppc_md.set_rtc_time && /* ntp_synced() && */
 		     xtime.tv_sec - last_rtc_update >= 659 &&
 		     abs((xtime.tv_nsec / 1000) - (1000000-1000000/HZ)) < 500000/HZ &&
 		     jiffies - wall_jiffies == 1) {
diff -ruNp linux-2.6.16/arch/ppc/Makefile kvmmax/arch/ppc/Makefile
--- linux-2.6.16/arch/ppc/Makefile	2006-03-20 18:07:03.000000000 +1100
+++ kvmmax/arch/ppc/Makefile	2006-04-24 16:31:10.000000000 +1000
@@ -99,6 +99,9 @@ $(BOOT_TARGETS): vmlinux
 uImage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot)/images $(boot)/images/$@
 
+uImage.initrd:
+	$(Q)$(MAKE) $(build)=$(boot)/images $(boot)/images/$@
+
 define archhelp
   @echo '* zImage          - Compressed kernel image (arch/$(ARCH)/boot/images/zImage.*)'
   @echo '  uImage          - Create a bootable image for U-Boot / PPCBoot'
@@ -111,7 +114,7 @@ endef
 
 archclean:
 	$(Q)$(MAKE) $(clean)=arch/ppc/boot
-	# Temporary hack until we have migrated to asm-powerpc
+	@# Temporary hack until we have migrated to asm-powerpc
 	$(Q)rm -rf arch/$(ARCH)/include
 
 archprepare: checkbin
@@ -138,12 +141,12 @@ checkbin:
 			false; \
 		fi ; \
 	fi
-	@if ! /bin/echo dssall | $(AS) -many -o $(TOUT) >/dev/null 2>&1 ; then \
-		echo -n '*** ${VERSION}.${PATCHLEVEL} kernels no longer build ' ; \
-		echo 'correctly with old versions of binutils.' ; \
-		echo '*** Please upgrade your binutils to 2.12.1 or newer' ; \
-		false ; \
-	fi
+#	@if ! /bin/echo dssall | $(AS) -many -o $(TOUT) >/dev/null 2>&1 ; then \
+#		echo -n '*** ${VERSION}.${PATCHLEVEL} kernels no longer build ' ; \
+#		echo 'correctly with old versions of binutils.' ; \
+#		echo '*** Please upgrade your binutils to 2.12.1 or newer' ; \
+#		false ; \
+#	fi
 
 CLEAN_FILES += $(TOUT)
 
diff -ruNp linux-2.6.16/arch/ppc/platforms/85xx/kvmmax_osd.c kvmmax/arch/ppc/platforms/85xx/kvmmax_osd.c
--- linux-2.6.16/arch/ppc/platforms/85xx/kvmmax_osd.c	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/arch/ppc/platforms/85xx/kvmmax_osd.c	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,955 @@
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/param.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <asm/immap_cpm2.h>
+#include <platforms/85xx/kvmmax_osd.h>
+#include <platforms/85xx/mpc85xx_cds_common.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+
+#if defined(CONFIG_Alterpath_KVMMAX) && defined(CONFIG_I2C)
+#include <linux/pca9548.h>
+#ifdef CONFIG_SENSORS_DAC5574
+#include <linux/dac5574.h>
+#endif
+#endif
+
+#ifdef CONFIG_SENSORS_M35075
+#include <linux/m35075.h>
+#endif
+
+#define CYOSD_DEBUG
+
+/******************************************************************************
+ * Internal OSD structure
+ *****************************************************************************/
+static struct osd_t {
+	unsigned char idx;		/* number of the OSD */
+	unsigned char signal;		/* signal detected (1) or lost (0) */
+	unsigned char open;		/* number of times the device was 
+					opened */
+	unsigned char color;		/* current foreground color */
+	unsigned char videoon;		/* 1 - video on, 0 - video off */
+	unsigned short htime;		/* FPGA MUX horizontal */
+	unsigned short vtime;		/* FPGA MUX vertical */
+	unsigned short lasthtime;	/* Last horizontal time measured */
+	unsigned short lastvtime;	/* Last vertical time measured */
+	unsigned short hres;		/* horizontal resolution */
+	unsigned short vres;		/* vertical resolution */
+	unsigned short freq;		/* video frequency */
+	unsigned char hpol;		/* horizontal polarity */
+	unsigned char vpol;		/* vertical polarity */
+	unsigned short htotal;		/* total horizontal pixels */
+	unsigned short vtotal;		/* total vertical lines */
+	unsigned short hpos;		/* horizontal visible position */
+	unsigned short vpos;		/* vertical visible position */
+	unsigned short intmask;		/* FPGA interrupt enable mask */
+	unsigned short vidgen;		/* FPGA video generation mask */
+	unsigned short vidlvl;		/* video level status mask */
+	unsigned short vidlock;		/* video lock status mask */
+	volatile unsigned short *hl;	/* FPGA MUX hlo pointer */
+	volatile unsigned short *hh;	/* FPGA MUX hhi pointer */
+	volatile unsigned short *vl;	/* FPGA MUX vlo pointer */
+	volatile unsigned short *vh;	/* FPGA MUX vhi pointer */
+#ifdef CONFIG_Alterpath_KVMMAX
+	volatile unsigned short *ctrl;	/* FPGA video control pointer */
+	volatile unsigned short *ctrlaux;/* FPGA video control aux pointer */
+#else
+	volatile unsigned short *ctrl;	/* FPGA video control pointer */
+	volatile unsigned short *inten; /* FPGA video interrupt enable pointer */
+#endif
+
+	volatile unsigned short *stat;	/* FPGA video status pointer */
+	volatile unsigned short *intr;	/* FPGA video interrupt pointer */
+	unsigned long time;		/* time of last sync stored */
+	struct work_struct queue;	/* OSD schedule queue */
+} osd[NUM_OF_OSDS];
+
+
+static struct video_t {
+	unsigned char idx;		/* number of the OSD */
+	unsigned char open;		/* number of times the device was 
+					opened*/
+	unsigned char muxport;		/* MUX port. MSB forces KM parts */
+	unsigned char muxshift;		/* FPGA MUX channel position */
+#ifdef CONFIG_Alterpath_KVMMAX
+	volatile unsigned short *ctrl;	/* FPGA video control pointer */
+	volatile unsigned short *ctrlaux;/* FPGA video control aux pointer */
+	unsigned short muxenb;		/* FPGA MUX enable mask */
+	unsigned short hpolarity;	/* horizontal polarity mask */
+	unsigned short vpolarity;	/* vertical polarity mask */
+	unsigned char brightness;	/* brightness */
+	unsigned char contrast;		/* contrast */
+	unsigned char red;		/* red level */
+	unsigned char blue;		/* blue level */
+	unsigned char green;		/* green level */
+#else
+	unsigned long muxenb;		/* FPGA MUX enable mask */
+	unsigned long hpolarity;	/* horizontal polarity mask */
+	unsigned long vpolarity;	/* vertical polarity mask */
+#endif
+	struct miscdevice dev;		/* Device structure */
+} video[MAX_VIDEO_CHANNELS];
+
+#ifdef CONFIG_Alterpath_KVMMAX
+
+#define VIDCTRL_OR(posd, val)                  \
+       *(posd->ctrlaux) |= (val);              \
+       *(posd->ctrl) = *(posd->ctrlaux);
+#define VIDCTRL_AND(posd, val)                 \
+       *(posd->ctrlaux) &= ~(val);             \
+       *(posd->ctrl) = *(posd->ctrlaux);
+
+#define VIDINT_ENABLE(posd)	VIDCTRL_OR(posd, posd->intmask)
+#define VIDINT_DISABLE(posd)	VIDCTRL_AND(posd, posd->intmask)
+#define VIDGEN_ENABLE(posd)	VIDCTRL_OR(posd, posd->vidgen)
+#define VIDGEN_DISABLE(posd)	VIDCTRL_AND(posd, posd->vidgen)
+#define VIDMUX_ENABLE(pvideo)	VIDCTRL_OR(pvideo, pvideo->muxenb)
+#define VIDMUX_DISABLE(pvideo)	VIDCTRL_AND(pvideo, pvideo->muxenb | (0x1f << pvideo->muxshift))
+#define VIDMUX_SET(pvideo, mux)  VIDCTRL_OR(pvideo, (mux & 0x1f) << pvideo->muxshift)
+#define VIDHPOL_ENABLE(pvideo)   VIDCTRL_OR(pvideo, pvideo->hpolarity)
+#define VIDHPOL_DISABLE(pvideo)  VIDCTRL_AND(pvideo, pvideo->hpolarity)
+#define VIDVPOL_ENABLE(pvideo)   VIDCTRL_OR(pvideo, pvideo->vpolarity)
+#define VIDVPOL_DISABLE(pvideo)  VIDCTRL_AND(pvideo, pvideo->vpolarity)
+
+#else
+
+#define VIDGPIOC_OR(val)       \
+       cpm2_immr->im_ioport.iop_pdata |= (val);
+#define VIDGPIOC_AND(val)      \
+       cpm2_immr->im_ioport.iop_pdata &= ~(val);
+
+#define VIDINT_ENABLE(posd)    *(posd->inten) |= posd->intmask;
+#define VIDINT_DISABLE(posd)   *(posd->inten) &= ~(posd->intmask);
+#define VIDGEN_ENABLE(posd)    *(posd->ctrl) |= posd->vidgen;
+#define VIDGEN_DISABLE(posd)   *(posd->ctrl) &= ~(posd->vidgen);
+#define VIDMUX_ENABLE(pvideo)    VIDGPIOC_OR(pvideo->muxenb)
+#define VIDMUX_DISABLE(pvideo)   VIDGPIOC_AND(pvideo->muxenb | (0x0f << pvideo->muxshift))
+#define VIDMUX_SET(pvideo, mux)  VIDGPIOC_OR((mux & 0x0f) << pvideo->muxshift)
+#define VIDHPOL_ENABLE(pvideo)   VIDGPIOC_OR(pvideo->hpolarity)
+#define VIDHPOL_DISABLE(pvideo)  VIDGPIOC_AND(pvideo->hpolarity)
+#define VIDVPOL_ENABLE(pvideo)   VIDGPIOC_OR(pvideo->vpolarity)
+#define VIDVPOL_DISABLE(pvideo)  VIDGPIOC_AND(pvideo->vpolarity)
+
+#endif
+
+#define RED_CHANNEL	0
+#define	GREEN_CHANNEL	1
+#define BLUE_CHANNEL	2
+#define EQ_CHANNEL	3
+
+#ifdef CONFIG_Alterpath_KVMMAX
+#define LOCAL_VIDEO_IRQ        SIU_INT_PC1
+#else
+#define LOCAL_VIDEO_IRQ        SIU_INT_PC9
+#endif
+
+#ifdef CONFIG_Alterpath_KVMMAX
+
+/* TODO - support for indices different than 0 */
+static void set_dac (unsigned char video_idx, unsigned char channel, 
+	unsigned short value)
+{
+#ifdef CONFIG_I2C
+	pca_add_channel(5);
+#ifdef CONFIG_SENSORS_DAC5574
+	dac_set_value(channel, value, 1);
+#endif
+	pca_remove_channel(5);
+#endif
+}
+#endif
+
+#define VIDRES_INTERNAL	3
+struct videores_t {
+	unsigned short hres;	/* horizontal resolution */
+	unsigned short vres;	/* vertical resolution */
+	unsigned short freq;	/* video frequency */
+	unsigned char hpol;	/* horizontal polarity */
+	unsigned char vpol;	/* vertical polarity */
+	unsigned short htotal;	/* total horizontal pixels */
+	unsigned short vtotal;	/* total vertical lines */
+	unsigned short hpos;	/* horizontal visible position */
+	unsigned short vpos;	/* vertical visible position */
+} videores_table [] = {
+	{ 640,  350, 85, 0, 1,  832,  445, 64+96+0,   3+60+0},
+	{ 640,  400, 85, 1, 0,  832,  445, 64+96+0,   3+41+0},
+	{ 720,  400, 85, 1, 0,  936,  446, 72+108+0,  3+42+0},
+	{ 640,  480, 60, 1, 1,  800,  525, 96+40+8,   2+25+8},
+	{ 640,  480, 72, 1, 1,  832,  520, 40+120+8,  3+20+8},
+	{ 640,  480, 75, 1, 1,  840,  500, 64+120+0,  3+16+0},
+	{ 640,  480, 85, 1, 1,  832,  509, 56+80+0,   3+25+0},
+	{ 800,  600, 56, 0, 0, 1024,  625, 72+128+0,  2+22+0},
+	{ 800,  600, 60, 0, 0, 1056,  628, 128+88+0,  4+23+0},
+	{ 800,  600, 72, 0, 0, 1040,  666, 120+64+0,  6+23+0},
+	{ 800,  600, 75, 0, 0, 1056,  625, 80+160+0,  3+21+0},
+	{ 800,  600, 85, 0, 0, 1048,  631, 64+152+0,  3+27+0},
+	{1024,  768, 43, 0, 0, 1264,  817, 176+56+0,  4+20+0},
+	{1024,  768, 60, 1, 1, 1344,  806, 136+160+0, 6+29+0},
+	{1024,  768, 70, 1, 1, 1328,  806, 136+144+0, 6+29+0},
+	{1024,  768, 75, 0, 0, 1312,  800, 96+176+0,  3+28+0},
+	{1024,  768, 85, 0, 0, 1376,  808, 96+208+0,  3+36+0},
+	{1152,  864, 75, 0, 0, 1600,  900, 128+256+0, 3+32+0},
+	{1280,  960, 60, 0, 0, 1800, 1000, 112+312+0, 3+36+0},
+	{1280,  960, 85, 0, 0, 1728, 1011, 160+224+0, 3+47+0},
+	{1280, 1024, 60, 0, 0, 1688, 1066, 112+248+0, 3+38+0},
+	{1280, 1024, 75, 0, 0, 1688, 1066, 144+248+0, 3+38+0},
+	{1280, 1024, 85, 0, 0, 1728, 1072, 160+224+0, 3+44+0},
+	{1600, 1200, 60, 0, 0, 2160, 1250, 192+304+0, 3+46+0},
+	{1600, 1200, 65, 0, 0, 2160, 1250, 192+304+0, 3+46+0},
+	{1600, 1200, 70, 0, 0, 2160, 1250, 192+304+0, 3+46+0},
+	{1600, 1200, 75, 0, 0, 2160, 1250, 192+304+0, 3+46+0},
+	{1600, 1200, 85, 0, 0, 2160, 1250, 192+304+0, 3+46+0},
+	{1792, 1344, 60, 1, 0, 2448, 1394, 200+328+0, 3+46+0},
+	{1792, 1344, 75, 1, 0, 2456, 1417, 216+352+0, 3+69+0},
+	{1856, 1392, 60, 1, 0, 2528, 1439, 224+352+0, 3+43+0},
+	{1856, 1392, 75, 1, 0, 2560, 1500, 224+352+0, 3+104+0},
+	{1920, 1440, 60, 1, 0, 2600, 1500, 208+344+0, 3+56+0},
+	{1920, 1440, 75, 1, 0, 2640, 1500, 224+352+0, 3+56+0},
+};
+
+#define VIDEORES_ENTRIES	sizeof(videores_table) / sizeof(struct videores_t)
+#define VIDEO_BASEFREQ		10000000L
+
+static void get_resolution(struct osd_t *posd, unsigned short vltime, 
+	unsigned short vhtime, unsigned short hltime, unsigned short hhtime)
+{
+	unsigned short vtotal = vltime + vhtime;
+	unsigned short htotal = hltime + hhtime;
+	unsigned char hpol = (hltime > hhtime)?1:0;
+	unsigned char vpol = (vltime > vhtime)?1:0;
+	unsigned char freq = (unsigned int)VIDEO_BASEFREQ/vtotal/htotal;
+	int i;
+	for (i = 0; i < VIDEORES_ENTRIES; i++) {
+		if (videores_table[i].vtotal != vtotal) {
+			continue;
+		}
+		//if (videores_table[i].vpol != vpol) {
+		//	continue;
+		//}
+		//if (videores_table[i].hpol != hpol) {
+		//	continue;
+		//}
+		if (videores_table[i].freq > freq + 1) {
+			continue;
+		}
+		if (videores_table[i].freq < freq - 1) {
+			continue;
+		}
+		/* Video resolution found. copy parameters */
+		posd->hres = videores_table[i].hres;
+		posd->vres = videores_table[i].vres;
+		posd->freq = videores_table[i].freq;
+		posd->hpol = hpol;
+		posd->vpol = vpol;
+		posd->htotal = videores_table[i].htotal;
+		posd->vtotal = videores_table[i].vtotal;
+		posd->hpos = videores_table[i].hpos;
+		posd->vpos = videores_table[i].vpos;
+		printk("Detected resolution %dx%d@%d\n", posd->hres, 
+			posd->vres, posd->freq);
+		return;
+	}
+	/* Didn't find. We have to estimate the values */
+	posd->vtotal = vtotal;
+	posd->freq = freq;
+	posd->hpol = hpol;
+	posd->vpol = vpol;
+	/* 93% of the vertical lines will be visible */
+	posd->vres = (int)vtotal * 93 / 100;
+	/* horizontal resolution is 4/3 of the vertical resolution */
+	posd->hres = (int)posd->vres * 4 / 3;
+	/* horizontal visible part occupies 78% of the period */
+	posd->htotal = (int)posd->hres * 100 / 78;
+	/* horizontal visible part starts at 20% of the period from hsync */
+	posd->hpos = (int)posd->htotal * 20 / 100;
+	/* vertical visible part starts at 5.5% from vsync */
+	posd->vpos = (int)posd->vtotal * 11 / 200;
+	printk("Estimated resolution %dx%d@%d\n", posd->hres, posd->vres, 
+		posd->freq);
+	return;
+}
+
+/******************************************************************************
+ * get_video_info - Extracts all the information necessary from the incoming
+ *	video input (polarity, video frequency, vertical resolution).
+ *****************************************************************************/
+static void get_video_info(struct osd_t *posd)
+{
+	unsigned char signal;
+	unsigned short hltime, hhtime, vltime, vhtime;
+	short dhtime, dvtime;
+
+	signal = ((posd->videoon) && (*(posd->stat) & posd->vidlvl));
+
+	if ((signal == 0) && (posd->signal != 0)) { /* video not present */
+		posd->signal = 0;
+		VIDGEN_ENABLE(posd)
+		/* Set up the right color (black, for the time being) */
+		posd->time = jiffies;
+		posd->hres = videores_table[VIDRES_INTERNAL].hres;
+		posd->vres = videores_table[VIDRES_INTERNAL].vres;
+		posd->freq = videores_table[VIDRES_INTERNAL].freq;
+		posd->hpol = videores_table[VIDRES_INTERNAL].hpol;
+		posd->vpol = videores_table[VIDRES_INTERNAL].vpol;
+		posd->htotal = videores_table[VIDRES_INTERNAL].htotal;
+		posd->vtotal = videores_table[VIDRES_INTERNAL].vtotal;
+		posd->hpos = videores_table[VIDRES_INTERNAL].hpos;
+		posd->vpos = videores_table[VIDRES_INTERNAL].vpos;
+		posd->htime = posd->lasthtime = 
+			VIDEO_BASEFREQ / posd->freq / posd->vtotal;
+		posd->vtime = posd->lastvtime = posd->vtotal;
+		schedule_work(&posd->queue);
+
+#ifdef CYOSD_DEBUG
+		printk("get_video_info[%d]: enabling internal video "
+			"generator\n", posd->idx);
+#endif
+	} else if (signal && (*(posd->stat) & posd->vidlock)) { /* video locked */
+		if (! posd->signal) {
+			posd->signal = signal;
+			VIDGEN_DISABLE(posd)
+		}
+
+		/* Acquire display frequency and vertical resolution */
+
+		hltime = *(posd->hl);
+		hhtime = *(posd->hh);
+		vltime = *(posd->vl);
+		vhtime = *(posd->vh);
+
+		dhtime = hltime + hhtime - posd->lasthtime;
+		if (dhtime < 0) dhtime = - dhtime;
+		dvtime = vltime + vhtime - posd->lastvtime;
+		if (dvtime < 0) dvtime = - dvtime;
+		
+		if ((dhtime > 1) || (dvtime > 1)) {
+			posd->time = jiffies;
+			posd->lasthtime = hltime + hhtime;
+			posd->lastvtime = vltime + vhtime;
+		}
+
+		if (jiffies - posd->time >= HZ) {
+			dhtime = posd->htime - (hltime + hhtime);
+			if (dhtime < 0) dhtime = - dhtime;
+			dvtime = posd->vtime - (vltime + vhtime);
+			if (dvtime < 0) dvtime = - dvtime;
+
+			if ((dhtime > 5) || (dvtime > 5)) {
+#ifdef CYOSD_DEBUG
+				printk("get_video_info[%d]: hltime %d "
+					"hhtime %d vltime %d vhtime %d\n", 
+					posd->idx, hltime, hhtime, vltime, 
+					vhtime);
+#endif
+				posd->htime = hltime + hhtime;
+				posd->vtime = vltime + vhtime;
+				get_resolution(posd, vltime, vhtime, hltime, hhtime);
+				schedule_work(&posd->queue);
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ * osd_setup 
+ *****************************************************************************/
+static void osd_setup(void *ptr)
+{
+	struct osd_t *posd = (struct osd_t *)ptr;
+#ifdef CONFIG_SENSORS_M35075
+	m35075_setup(posd->idx, posd->hres, posd->vres, posd->freq,
+		posd->hpol, posd->vpol, posd->htotal, posd->vtotal, 
+		posd->hpos, posd->vpos);
+#endif
+}
+
+/******************************************************************************
+ * osd_interrupt - This is the video interrupt handler
+ *****************************************************************************/
+static irqreturn_t osd_interrupt (int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned short intr;
+	unsigned int i;
+	for (i = 0; i < NUM_OF_OSDS; i++) {
+		intr = *(osd[i].intr);
+		if (video[i].open && intr & osd[i].intmask) {
+			get_video_info(&osd[i]);
+		}
+	}
+	return 0;
+}
+
+/******************************************************************************
+ * osd_select_port - 
+ *****************************************************************************/
+static void osd_select_port(struct video_t *pvideo, unsigned char port)
+{
+	unsigned short mux;
+	VIDMUX_DISABLE(pvideo)
+
+	if ((port & 0x3f) == 0 || (port & 0x3f) > 0x20) {
+		return;
+	}
+	mux = (port & 0x3f) - 1;
+	VIDMUX_SET(pvideo, mux)
+	VIDMUX_ENABLE(pvideo)
+}
+
+#ifdef CONFIG_Alterpath_KVMMAXV2
+/******************************************************************************
+ * osd_set_leds -
+ *****************************************************************************/
+static void osd_set_leds(unsigned char port, unsigned char led)
+{
+	if (port < 9) {
+		cpm2_immr->im_ioport.iop_pdata &=
+			~(3 << ((8 - port) * 2));
+		cpm2_immr->im_ioport.iop_pdata |=
+			(led & 3) << ((8 - port) * 2);
+	} else {
+		cpm2_immr->im_ioport.iop_pdatb &=
+			~(3 << ((15 - port) * 2));
+		cpm2_immr->im_ioport.iop_pdatb |=
+			(led & 3) << ((15 - port) * 2);
+	}
+}
+#endif
+
+/******************************************************************************
+ * osd_llseek - 
+ *****************************************************************************/
+static long long osd_llseek(struct file *file, long long offset, int origin)
+{
+	return -ESPIPE;
+}
+
+/******************************************************************************
+ * osd_write - 
+ *****************************************************************************/
+static ssize_t osd_write(struct file *file, const char *buf, size_t count, 
+	loff_t *ppos)
+{
+	struct osd_t *posd;
+	int idx;
+	int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	if ((minor >= OSDVIDEO_MINOR) && 
+		(minor - OSDVIDEO_MINOR < MAX_VIDEO_CHANNELS)) {
+		idx = minor - OSDVIDEO_MINOR;
+	} else {
+		return -ENODEV;
+	}
+	if (idx < 0 || idx >= NUM_OF_OSDS) {
+		return count;
+	}
+	posd = (struct osd_t *)&osd[idx];
+	VIDINT_DISABLE(posd)
+#ifdef CONFIG_SENSORS_M35075
+	m35075_write_buffer(idx, buf, count);
+#endif
+	VIDINT_ENABLE(posd)
+
+	return count;
+}
+ 
+/******************************************************************************
+ * osd_read - 
+ *****************************************************************************/
+static ssize_t osd_read(struct file *file, char *buf, size_t count, 
+	loff_t *ptr)
+{
+	int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	if ((minor >= OSDVIDEO_MINOR) && 
+		(minor - OSDVIDEO_MINOR < MAX_VIDEO_CHANNELS)) {
+		return 0;
+	}
+	return -ENODEV;
+}
+
+/******************************************************************************
+ * osd_open - 
+ *****************************************************************************/
+static int osd_open(struct inode *inode, struct file *file)
+{
+	struct osd_t *posd;
+	struct video_t *pvideo;
+	int idx;
+	int minor = MINOR(inode->i_rdev);
+
+	if ((minor >= OSDVIDEO_MINOR) && 
+		(minor - OSDVIDEO_MINOR < MAX_VIDEO_CHANNELS)) {
+		idx = minor - OSDVIDEO_MINOR;
+	} else {
+		printk("osd_open: no such device [%d]\n", minor);
+		return -ENODEV;
+	}
+	pvideo = (struct video_t *)&video[idx];
+
+	if (pvideo->open)  {
+		pvideo->open ++;
+		printk("osd_open [%d]: device already open\n", idx);
+		return 0;
+	}
+
+	if (idx >= 0 && idx < NUM_OF_OSDS) {
+		posd = (struct osd_t *)&osd[idx];
+		posd->videoon = 0; /* disable video output */
+		/* Reset the OSD device */
+#ifdef CONFIG_SENSORS_M35075
+		m35075_init(idx);
+#endif
+		/* Check if there is a signal present */
+		posd->signal = 2;
+		get_video_info(posd);
+
+		/* Program the special characters (color = white)*/
+		posd->color = 7; /* white */
+#ifdef CONFIG_SENSORS_M35075
+		program_all_ramchars(idx, posd->color);
+#endif
+	
+		/* Set interrupts */
+		VIDINT_ENABLE(posd)
+	}
+#ifdef CONFIG_Alterpath_KVMMAX
+	set_dac(posd->idx, EQ_CHANNEL, 0x1000); /* Set DAC to a default value */
+#endif
+	pvideo->open = 1;
+	return 0;
+}
+
+/******************************************************************************
+ * osd_release - 
+ *****************************************************************************/
+static int osd_release(struct inode *inode, struct file *file)
+{
+	struct osd_t *posd;
+	struct video_t *pvideo;
+	int idx;
+	int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	if ((minor >= OSDVIDEO_MINOR) && 
+		(minor - OSDVIDEO_MINOR < MAX_VIDEO_CHANNELS)) {
+		idx = minor - OSDVIDEO_MINOR;
+	} else {
+		return -ENODEV;
+	}
+	pvideo = (struct video_t *)&video[idx];
+	if (pvideo->open == 0) {
+		return 0;
+	}
+	pvideo->open --;
+	if (pvideo->open) {
+		return 0;
+	}
+	if (idx >= 0 && idx < NUM_OF_OSDS) {
+		posd = (struct osd_t *)&osd[idx];
+		VIDINT_DISABLE(posd)
+#ifdef CONFIG_SENSORS_M35075
+		m35075_turnoff(idx);
+#endif
+	}
+	return(0);
+}
+
+/******************************************************************************
+ * osd_ioctl - 
+ *****************************************************************************/
+static int osd_ioctl(struct inode * inode, struct file * file,
+          unsigned int cmd, unsigned long arg)
+{
+	struct osd_t *posd;
+	struct video_t *pvideo;
+	unsigned short *p = (unsigned short *)arg;
+	int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	int idx, i, error;
+
+
+	if (minor < OSDVIDEO_MINOR || 
+		minor >= OSDVIDEO_MINOR + MAX_VIDEO_CHANNELS) {
+		return -ENODEV;
+	}
+	idx = minor - OSDVIDEO_MINOR;
+	pvideo = &video[idx];
+
+	if(!pvideo->open) return -EIO;
+	switch (cmd) {
+#ifdef CONFIG_Alterpath_KVMMAX
+	case OSDSETBRIGHTNESS:
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDSETBRIGHTNESS %d\n", 
+			idx, (int)arg);
+#endif
+		pvideo->brightness = arg;
+		set_dac(idx, RED_CHANNEL, pvideo->brightness * pvideo->red);
+		set_dac(idx, GREEN_CHANNEL, pvideo->brightness * pvideo->green);
+		set_dac(idx, BLUE_CHANNEL,pvideo->brightness * pvideo->blue);
+		return 0;
+	case OSDGETBRIGHTNESS:
+		return put_user(pvideo->brightness, p);
+	case OSDSETCONTRAST:
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDSETCONTRAST %d\n", 
+			idx, (int)arg);
+#endif
+		pvideo->contrast = arg;
+		set_dac(idx, EQ_CHANNEL, (unsigned char)arg << 8);
+		return 0;
+	case OSDGETCONTRAST:
+		return put_user(pvideo->contrast, p);
+	case OSDSETRGB:
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDSETRGB %06x\n",
+			idx, (int)arg);
+#endif
+		pvideo->red = arg / 0x10000L;
+		pvideo->green = (arg / 0x100) % 0x100;
+		pvideo->blue = arg % 0x100;
+		set_dac(idx, RED_CHANNEL, pvideo->brightness * pvideo->red);
+		set_dac(idx, GREEN_CHANNEL, pvideo->brightness * pvideo->green);
+		set_dac(idx, BLUE_CHANNEL,pvideo->brightness * pvideo->blue);
+		return 0;
+	case OSDGETRGB:
+		return put_user(pvideo->red * 0x10000L + pvideo->green * 0x100L + pvideo->blue, p);
+
+#endif
+	case OSDSETPORT:
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDSETPORT %02x\n", 
+			idx, (int)arg);
+#endif
+		if (pvideo->muxport != (unsigned char)arg) {
+			osd_select_port(pvideo, (unsigned char)arg);
+			pvideo->muxport = arg;
+		}
+		return 0;
+	case OSDGETPORT:
+		return put_user(pvideo->muxport & 0x1f, p);
+	case OSDSETPOLARITY:
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDSETVPOLARITY %02x\n", 
+			idx, (int)arg);
+#endif
+		/* Vertical Polarity */
+                if (arg & 0x80) {
+			VIDVPOL_ENABLE(pvideo)
+		} else {
+			VIDVPOL_DISABLE(pvideo)
+		}
+		/* Horizontal Polarity */
+                if (arg & 0x40) {
+			VIDHPOL_ENABLE(pvideo)
+		} else {
+			VIDHPOL_DISABLE(pvideo)
+		}
+                return 0;
+	}
+	if (idx < 0 || idx >= NUM_OF_OSDS) {
+		return -ENOTSUPP;
+	}
+	posd = &osd[idx];
+	switch (cmd) {
+	case OSDGETVIDEO:
+		return posd->videoon;
+	case OSDSETVIDEOON:
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDSETVIDEOON\n", 
+			posd->idx);
+#endif
+		posd->videoon = 1;
+		break;
+	case OSDSETVIDEOOFF:
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDSETVIDEOOFF\n", 
+			posd->idx);
+#endif
+		posd->videoon = 0;
+		break;
+	case OSDGETOSD:
+#ifdef CONFIG_SENSORS_M35075
+		return put_user(m35075_status(idx), p);
+#else
+		break;
+#endif
+	case OSDSETOSDON:
+#ifdef CONFIG_SENSORS_M35075
+#ifdef CYOSD_DEBUG
+		printk(KERN_DEBUG "osd_ioctl [%d] - OSDSETOSDON\n", 
+			posd->idx);
+#endif
+		VIDINT_DISABLE(posd)
+		m35075_turnon(idx);
+		VIDINT_ENABLE(posd)
+#endif
+		return 0;
+	case OSDSETOSDOFF:
+#ifdef CONFIG_SENSORS_M35075
+#ifdef CYOSD_DEBUG
+		printk(KERN_DEBUG "osd_ioctl [%d] - OSDSETOSDOFF\n", 
+			posd->idx);
+#endif
+		VIDINT_DISABLE(posd)
+		m35075_turnoff(idx);
+		VIDINT_ENABLE(posd)
+#endif
+		return 0;
+	case OSDSETTRANSPARENTON:
+#ifdef CONFIG_SENSORS_M35075
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDTRANSPARENTON\n", 
+			posd->idx);
+#endif
+		VIDINT_DISABLE(posd)
+		m35075_transparenton(idx);
+		m35075_setalign(idx, 2, 2);
+		VIDINT_ENABLE(posd)
+#endif
+		return 0;
+	case OSDSETTRANSPARENTOFF:
+#ifdef CONFIG_SENSORS_M35075
+#ifdef CYOSD_DEBUG
+		printk (KERN_DEBUG "osd_ioctl [%d] - OSDTRANSPARENTOFF\n", 
+			posd->idx);
+#endif
+		VIDINT_DISABLE(posd)
+		m35075_transparentoff(idx);
+		m35075_setalign(idx, 1, 1);
+		VIDINT_ENABLE(posd)
+#endif
+		return 0;
+	case OSDGETSCREEN:
+#ifdef CONFIG_SENSORS_M35075
+		{
+			unsigned short buffer[OSDBUFSIZE];
+			m35075_getscreen(idx, buffer);
+			error = 0;
+			for (i = 0; i < OSDBUFSIZE; i ++) {
+				error = put_user(buffer[i], p);
+				p ++;
+				if (error) break;
+			}
+			return error;
+		}
+#endif
+		break;
+
+	case OSDSETRAMCHAR:
+#ifdef CONFIG_SENSORS_M35075
+		{
+			struct osdreq_ramchar ramchar;
+
+#ifdef CYOSD_DEBUG
+			printk (KERN_DEBUG "osd_ioctl [%d] - OSDSETRAMCHAR\n", 
+				posd->idx);
+#endif
+			if(copy_from_user(&ramchar, (void*)arg, 
+				sizeof(struct osdreq_ramchar))) {
+				return -EFAULT;
+			}
+			if(ramchar.index >= NUM_RAM_CHARS) {
+				return -EINVAL;
+			}
+			program_ramchar(idx, posd->color, ramchar.index, 
+				ramchar.data);
+		}
+#endif
+		break;
+#ifdef CONFIG_Alterpath_KVMMAXV2
+	case OSDSETLEDS:
+		osd_set_leds(arg / 4, arg % 4);
+		return 0;
+#endif
+
+	default:
+		return -ENOTSUPP;
+        }
+	return 0;
+}
+
+/******************************************************************************
+ * cy_osd_init - 
+ *****************************************************************************/
+static struct file_operations osd_fops = {
+	llseek:osd_llseek,
+	read:osd_read,
+	write:osd_write,
+	ioctl:osd_ioctl,  
+	open:osd_open,
+	release:osd_release
+};
+
+const char *posdvideo_name = "MPC_osd";
+
+void cy_osd_boot_write (unsigned char *buf)
+{
+	struct osd_t *posd;
+	int i, idx;
+	unsigned char *s;
+	unsigned short buffer[1 + 24];
+
+	for (i = 0; i < NUM_OF_OSDS; i ++) {
+		posd = (struct osd_t *)&osd[i];
+		buffer[0] = 6 * 24;
+		for (idx = 1; idx < 1 + 24; ) {
+			buffer[idx ++] = 0x007f;
+		}
+		if (strlen(buf) > 24) {
+			buf[24] = 0;
+		}
+		idx = 1 + (24 - strlen(buf)) / 2;
+		for (s = buf; *s; s ++) {
+			buffer[idx ++] = ((*s==' ')?0x7f:*s) + 0x0F00;
+		}
+#ifdef CONFIG_SENSORS_M35075
+		m35075_write_buffer(i, (char *)buffer, (1 + 24) * 2);
+#endif
+	}
+}
+
+static unsigned char *cycheader1 = "  Cyclades Corporation  ";
+static unsigned char *cycheader2 = " AlterPath-KVM/MAX Boot ";
+void cy_osd_init(void)
+{
+	fpga_regs_t *fpga = (fpga_regs_t *)(cyc_get_fpgaaddr());
+	struct osd_t *posd;
+#ifdef CONFIG_SENSORS_M35075
+	unsigned short buffer[OSDBUFSIZE];
+#endif
+#ifdef CONFIG_Alterpath_KVMMAX
+	int i;
+#endif
+	int idx;
+	unsigned char *s;
+
+#ifdef CONFIG_Alterpath_KVMMAX
+	for (i = 0; i < MAX_VIDEO_CHANNELS; i ++) {
+		struct video_t *pvideo;
+		pvideo = &video[i];
+		pvideo->dev.minor = OSDVIDEO_MINOR + i;
+		pvideo->dev.name = posdvideo_name;
+		pvideo->dev.fops = &osd_fops;
+		misc_register(&pvideo->dev);
+		pvideo->idx = i;
+		pvideo->muxenb = 0x4000;
+		pvideo->muxshift = 2;
+		pvideo->hpolarity = 0x0100;
+		pvideo->vpolarity = 0x0200;
+		pvideo->ctrl = &(fpga->reg1);
+		pvideo->ctrlaux = &(fpga_reg1_value);
+	}
+#else
+	video[0].idx = 0;
+	video[0].muxenb = 0x80000000L;
+	video[0].muxshift = 24;
+	video[0].hpolarity = 0x00200000L;
+	video[0].vpolarity = 0x00100000L;
+	video[0].dev.minor = OSDVIDEO_MINOR;
+	video[0].dev.name = posdvideo_name;
+	video[0].dev.fops = &osd_fops;
+	misc_register(&video[0].dev);
+#endif
+
+	osd[0].idx = 0;
+#ifdef CONFIG_Alterpath_KVMMAX
+	osd[0].hl = &(fpga->hlo);
+	osd[0].hh = &(fpga->hhi);
+	osd[0].vl = &(fpga->vlo);
+	osd[0].vh = &(fpga->vhi);
+	osd[0].intmask = 0x1c00;
+	osd[0].vidgen = 0x0080;
+	osd[0].vidlvl = 0x0002;
+	osd[0].vidlock = 0x0010;
+	osd[0].ctrl = &(fpga->reg1);
+	osd[0].ctrlaux = &(fpga_reg1_value);
+	osd[0].stat = &(fpga->reg3);
+	osd[0].intr = &(fpga->intr);
+#else
+	osd[0].hl = &(fpga->Count_Hsync_0);
+	osd[0].hh = &(fpga->Count_Hsync_1);
+	osd[0].vl = &(fpga->Count_Vsync_0);
+	osd[0].vh = &(fpga->Count_Vsync_1);
+	osd[0].intmask = 0x0700;
+	osd[0].vidgen = 0x0100;
+	osd[0].vidlvl = 0x4000;
+	osd[0].vidlock = 0x2000;
+	osd[0].ctrl = &(fpga->Local_Ctl);
+	osd[0].inten = &(fpga->Int_En_2);
+	osd[0].stat = &(fpga->Local_Ctl);
+	osd[0].intr = &(fpga->Int_Sts_2);
+#endif
+	INIT_WORK(&osd[0].queue, osd_setup, (void *)&osd[0]);
+
+	posd = &osd[0];
+	VIDINT_DISABLE(posd);
+	/* Request an interrupt */
+	request_irq(LOCAL_VIDEO_IRQ, osd_interrupt, SA_SHIRQ, "video", 
+		NULL);
+
+	printk("Initializing OSD for boot messages\n");
+
+	/* Enable video */
+#ifdef CONFIG_Alterpath_KVMMAX
+	cpm2_immr->im_ioport.iop_pdira |=  0x00000080;
+	cpm2_immr->im_ioport.iop_ppara &= ~0x00000080;
+	cpm2_immr->im_ioport.iop_podra &= ~0x00000080;
+	cpm2_immr->im_ioport.iop_pdata |=  0x00000080;
+#else
+	/* Set up video MUX and polarity */
+	cpm2_immr->im_ioport.iop_pdirc |=  0x8f300000;
+	cpm2_immr->im_ioport.iop_pparc &= ~0x8f300000;
+	cpm2_immr->im_ioport.iop_podrc &= ~0x8f300000;
+	cpm2_immr->im_ioport.iop_pdatc &= ~0x8f300000;
+	/* Set up KVM port leds */
+	cpm2_immr->im_ioport.iop_pdira |=  0x0003ffff;
+	cpm2_immr->im_ioport.iop_ppara &= ~0x0003ffff;
+	cpm2_immr->im_ioport.iop_podra &= ~0x0003ffff;
+	cpm2_immr->im_ioport.iop_pdata &= ~0x0003ffff;
+	cpm2_immr->im_ioport.iop_pdirb |=  0x00003fff;
+	cpm2_immr->im_ioport.iop_pparb &= ~0x00003fff;
+	cpm2_immr->im_ioport.iop_podrb &= ~0x00003fff;
+	cpm2_immr->im_ioport.iop_pdatb &= ~0x00003fff;
+#endif
+	/* Reset the OSD device */
+#ifdef CONFIG_SENSORS_M35075
+	m35075_init(0);
+#endif
+
+	/* Activate blank screen generation */
+	VIDGEN_ENABLE(posd)
+#ifdef CONFIG_SENSORS_M35075
+	m35075_setup(0,
+		videores_table[VIDRES_INTERNAL].hres,
+		videores_table[VIDRES_INTERNAL].vres,
+		videores_table[VIDRES_INTERNAL].freq,
+		videores_table[VIDRES_INTERNAL].hpol,
+		videores_table[VIDRES_INTERNAL].vpol,
+		videores_table[VIDRES_INTERNAL].htotal,
+		videores_table[VIDRES_INTERNAL].vtotal,
+		videores_table[VIDRES_INTERNAL].hpos,
+		videores_table[VIDRES_INTERNAL].vpos);
+
+	/* Clean the OSD screen */
+	buffer[0] = 0;
+	for (idx = 1; idx < OSDBUFSIZE; idx ++) {
+		buffer[idx] = 0x007f;
+	}
+	idx = 1 + 4 * 24;
+	for (s = cycheader1; *s; s ++) {
+		buffer[idx ++] = ((*s==' ')?0x7f:*s) + 0x0700;
+	}
+	idx = 1 + 5 * 24;
+	for (s = cycheader2; *s; s ++) {
+		buffer[idx ++] = ((*s==' ')?0x7f:*s) + 0x0700;
+	}
+	m35075_write_buffer(0, (char *)buffer, OSDBUFSIZE * 2);
+	
+	m35075_turnon(0);
+#endif
+	printk("Video Channels/OSD initialized:\n");
+	cy_osd_boot_write("Initializing...");
+}
+
diff -ruNp linux-2.6.16/arch/ppc/platforms/85xx/kvmmax_osd.h kvmmax/arch/ppc/platforms/85xx/kvmmax_osd.h
--- linux-2.6.16/arch/ppc/platforms/85xx/kvmmax_osd.h	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/arch/ppc/platforms/85xx/kvmmax_osd.h	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,37 @@
+#define NUM_OF_OSDS		1
+#define MAX_VIDEO_CHANNELS	1
+
+#define OSDGETVIDEO             0
+#define OSDSETVIDEOON           1
+#define OSDSETVIDEOOFF          2
+#define OSDSETPORT              3
+#define OSDGETPORT              4
+#define OSDGETOSD               5
+#define OSDSETOSDON             6
+#define OSDSETOSDOFF            7
+#define OSDSETPOLARITY          8
+#define OSDSETBRIGHTNESS        9
+#define OSDGETBRIGHTNESS        10
+#define OSDSETCONTRAST          11
+#define OSDGETCONTRAST          12
+#define OSDAGCON                13
+#define OSDAGCOFF               14
+#define OSDGETAGC               15
+#define OSDSETTRANSPARENTON     16
+#define OSDSETTRANSPARENTOFF    17
+#define OSDSETVIDEOCOLOR        18
+#define OSDGETVERSION           19
+#define OSDGETSCREEN            20
+#define OSDSETLOCAL             21
+#define OSDSETREMOTE            22
+#define OSDSETRAMCHAR           23
+#define OSDSETRGB		24
+#define OSDGETRGB		25
+#define OSDSETLEDS		26
+
+struct osdreq_ramchar{
+        __u16 index;
+        __u16 data[18];
+};
+
+extern void cy_osd_init(void);
diff -ruNp linux-2.6.16/arch/ppc/platforms/85xx/Makefile kvmmax/arch/ppc/platforms/85xx/Makefile
--- linux-2.6.16/arch/ppc/platforms/85xx/Makefile	2006-03-20 18:07:03.000000000 +1100
+++ kvmmax/arch/ppc/platforms/85xx/Makefile	2006-04-24 16:31:10.000000000 +1000
@@ -11,3 +11,5 @@ obj-$(CONFIG_TQM8540)		+= tqm85xx.o
 obj-$(CONFIG_TQM8541)		+= tqm85xx.o
 obj-$(CONFIG_TQM8555)		+= tqm85xx.o
 obj-$(CONFIG_TQM8560)		+= tqm85xx.o
+obj-$(CONFIG_Alterpath_KVMMAX)	+= kvmmax_osd.o
+obj-$(CONFIG_Alterpath_KVMMAXV2)+= kvmmax_osd.o
diff -ruNp linux-2.6.16/arch/ppc/platforms/85xx/mpc85xx_cds_common.c kvmmax/arch/ppc/platforms/85xx/mpc85xx_cds_common.c
--- linux-2.6.16/arch/ppc/platforms/85xx/mpc85xx_cds_common.c	2006-03-20 18:07:03.000000000 +1100
+++ kvmmax/arch/ppc/platforms/85xx/mpc85xx_cds_common.c	2006-04-26 11:51:25.000000000 +1000
@@ -32,6 +32,7 @@
 #include <linux/tty.h>
 #include <linux/serial_core.h>
 #include <linux/fsl_devices.h>
+#include <linux/proc_fs.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -63,38 +64,57 @@ unsigned long isa_io_base = 0;
 unsigned long isa_mem_base = 0;
 #endif
 
+static void mpc85xx_alterpath_restart(char *cmd);
+static void mpc85xx_alterpath_halt(void);
+static void mpc85xx_alterpath_power_off(void);
+static void cyc_memory_init(void);
+#ifdef CONFIG_Alterpath_KVMMAXV2
+static void kvmmaxv2_setup_serial(void);
+#endif
+
+static unsigned long fpga_base;
+static unsigned long cf_base;
+unsigned short fpga_reg1_value = 0;
+
 extern unsigned long total_memory;      /* in mm/init */
 
 unsigned char __res[sizeof (bd_t)];
 
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2) \
+			&& !defined(CONFIG_ONBOARD)
 static int cds_pci_slot = 2;
 static volatile u8 * cadmus;
+#endif
 
 /* Internal interrupts are all Level Sensitive, and Positive Polarity */
 static u_char mpc85xx_cds_openpic_initsenses[] __initdata = {
 	MPC85XX_INTERNAL_IRQ_SENSES,
-#if defined(CONFIG_PCI)
-	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 0: PCI1 slot */
-	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 1: PCI1 slot */
-	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 2: PCI1 slot */
-	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 3: PCI1 slot */
-#else
-	0x0,						/* External  0: */
-	0x0,						/* External  1: */
-	0x0,						/* External  2: */
-	0x0,						/* External  3: */
-#endif
-	0x0,						/* External  4: */
-	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External  5: PHY */
-	0x0,						/* External  6: */
-	0x0,						/* External  7: */
-	0x0,						/* External  8: */
-	0x0,						/* External  9: */
-	0x0,						/* External 10: */
-#if defined(CONFIG_85xx_PCI2) && defined(CONFIG_PCI)
-	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 11: PCI2 slot 0 */
-#else
-	0x0,						/* External 11: */
+#if defined(CONFIG_Alterpath_KVMMAX)
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 0: PHY #1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 1: PHY #2 */
+	0x00,                       /* External 2: RTC */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 3: PCI1520*/
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External  4: UART 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External  5: UART 2 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External  6: UART 3 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External  7: UART 4 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 8: PCI */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 9: PCI */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 10: PCI */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 11: PCI */
+#elif defined(CONFIG_Alterpath_KVMMAXV2)
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 0: DSP A */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 1: DSP B */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 2: DSP C */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 3: DSP D */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 4: PCI1520 INTA */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 5: PCI1520 INTB */
+	0,      /* External 6: PCI1520 IRQSER */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 7: USB A */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 8: USB B */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 9: USB C */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 10: Compact Flash */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),      /* External 11: UART */
 #endif
 };
 
@@ -113,8 +133,13 @@ mpc85xx_cds_show_cpuinfo(struct seq_file
 	pvid = mfspr(SPRN_PVR);
 	svid = mfspr(SPRN_SVR);
 
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
 	seq_printf(m, "Vendor\t\t: Freescale Semiconductor\n");
 	seq_printf(m, "Machine\t\t: CDS - MPC%s (%x)\n", cur_ppc_sys_spec->ppc_sys_name, cadmus[CM_VER]);
+#else
+	seq_printf(m, "Vendor\t\t: Cyclades Corporation\n");
+	seq_printf(m, "Machine\t\t: AlterPath-KVM/max - MPC%s\n", cur_ppc_sys_spec->ppc_sys_name);
+#endif
 	seq_printf(m, "clock\t\t: %dMHz\n", freq / 1000000);
 	seq_printf(m, "PVR\t\t: 0x%x\n", pvid);
 	seq_printf(m, "SVR\t\t: 0x%x\n", svid);
@@ -149,7 +174,6 @@ void __init
 mpc85xx_cds_init_IRQ(void)
 {
 	bd_t *binfo = (bd_t *) __res;
-	int i;
 
 	/* Determine the Physical Address of the OpenPIC regs */
 	phys_addr_t OpenPIC_PAddr = binfo->bi_immr_base + MPC85xx_OPENPIC_OFFSET;
@@ -171,7 +195,7 @@ mpc85xx_cds_init_IRQ(void)
 	 */
 	openpic_init(MPC85xx_OPENPIC_IRQ_OFFSET);
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_PCI_NOT
 	openpic_hookup_cascade(PIRQ0A, "82c59 cascade", i8259_irq);
 
 	i8259_init(0, 0);
@@ -196,6 +220,67 @@ mpc85xx_map_irq(struct pci_dev *dev, uns
 {
 	struct pci_controller *hose = pci_bus_to_hose(dev->bus->number);
 
+#ifdef CONFIG_Alterpath_KVMMAX
+	if (!hose->index) {
+		switch (idsel) {
+		case 0x01:
+			return MPC85xx_IRQ_EXT8;
+		case 0x02:
+			return MPC85xx_IRQ_EXT9;
+		case 0x03:
+			return MPC85xx_IRQ_EXT10;
+		case 0x04:
+			return MPC85xx_IRQ_EXT11;
+		}
+	} else {
+		switch (idsel) {
+		case 0x0d:
+			return MPC85xx_IRQ_EXT4;
+		case 0x0e:
+			return MPC85xx_IRQ_EXT5;
+		case 0x0f:
+			return MPC85xx_IRQ_EXT6;
+		case 0x10:
+			return MPC85xx_IRQ_EXT7;
+		case 0x11:
+			return MPC85xx_IRQ_EXT3;
+		}
+	}
+	return 0;
+#elif defined(CONFIG_Alterpath_KVMMAXV2)
+	if (!hose->index) {
+		switch (idsel) {
+		case 0x14:
+			return MPC85xx_IRQ_EXT0;
+		case 0x15:
+			return MPC85xx_IRQ_EXT1;
+		case 0x16:
+			return MPC85xx_IRQ_EXT2;
+		case 0x17:
+			return MPC85xx_IRQ_EXT3;
+		}
+	} else {
+		switch (idsel) {
+		case 0x15:
+			switch (PCI_FUNC(dev->devfn)) {
+			case 0:
+				return MPC85xx_IRQ_EXT4;
+			case 1:
+				return MPC85xx_IRQ_EXT5;
+			}
+		case 0x14:
+			switch (PCI_FUNC(dev->devfn)) {
+			case 0:
+				return MPC85xx_IRQ_EXT7;
+			case 1:
+				return MPC85xx_IRQ_EXT8;
+			case 2:
+				return MPC85xx_IRQ_EXT9;
+			}
+		}
+	}
+	return 0;
+#else
 	if (!hose->index)
 	{
 		/* Handle PCI1 interrupts */
@@ -241,16 +326,20 @@ mpc85xx_map_irq(struct pci_dev *dev, uns
 
 		return PCI_IRQ_TABLE_LOOKUP;
 	}
+#endif
 }
 
-#define ARCADIA_HOST_BRIDGE_IDSEL	17
-#define ARCADIA_2ND_BRIDGE_IDSEL	3
+//#define ARCADIA_HOST_BRIDGE_IDSEL	17
+//#define ARCADIA_2ND_BRIDGE_IDSEL	3
 
 extern int mpc85xx_pci1_last_busno;
 
 int
 mpc85xx_exclude_device(u_char bus, u_char devfn)
 {
+#if defined(CONFIG_Alterpath_KVMMAX) || defined(CONFIG_Alterpath_KVMMAXV2)
+	return PCIBIOS_SUCCESSFUL;
+#else
 	if (bus == 0 && PCI_SLOT(devfn) == 0)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 #ifdef CONFIG_85xx_PCI2
@@ -265,11 +354,13 @@ mpc85xx_exclude_device(u_char bus, u_cha
 		return PCIBIOS_DEVICE_NOT_FOUND;
 	else
 		return PCIBIOS_SUCCESSFUL;
+#endif
 }
 
 void __init
 mpc85xx_cds_enable_via(struct pci_controller *hose)
 {
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
 	u32 pci_class;
 	u16 vid, did;
 
@@ -291,11 +382,13 @@ mpc85xx_cds_enable_via(struct pci_contro
 
 	/* Enable USB and IDE functions */
 	early_write_config_byte(hose, 1, 0x10, 0x48, 0x08);
+#endif
 }
 
 void __init
 mpc85xx_cds_fixup_via(struct pci_controller *hose)
 {
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
 	u32 pci_class;
 	u16 vid, did;
 
@@ -346,8 +439,10 @@ mpc85xx_cds_fixup_via(struct pci_control
 
 	/* Function 6, AC97 Interface */
 	early_write_config_dword(hose, 1, 0x16, PCI_BASE_ADDRESS_0, 0x1c00);
+#endif
 }
 
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
 void __init
 mpc85xx_cds_pcibios_fixup(void)
 {
@@ -391,9 +486,12 @@ mpc85xx_cds_pcibios_fixup(void)
 		pci_dev_put(dev);
         }
 }
+#endif
 #endif /* CONFIG_PCI */
 
+//#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
 TODC_ALLOC();
+//#endif
 
 /* ************************************************************************
  *
@@ -417,6 +515,7 @@ mpc85xx_cds_setup_arch(void)
 	cpm2_reset();
 #endif
 
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
 	cadmus = ioremap(CADMUS_BASE, CADMUS_SIZE);
 	cds_pci_slot = ((cadmus[CM_CSR] >> 6) & 0x3) + 1;
 	printk("CDS Version = %x in PCI slot %d\n", cadmus[CM_VER], cds_pci_slot);
@@ -428,13 +527,16 @@ mpc85xx_cds_setup_arch(void)
 			ioremap(CDS_RTC_ADDR, CDS_RTC_SIZE),
 			8);
 
+#endif
 	/* Set loops_per_jiffy to a half-way reasonable value,
 	   for use until calibrate_delay gets called. */
 	loops_per_jiffy = freq / HZ;
 
 #ifdef CONFIG_PCI
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
 	/* VIA IDE configuration */
         ppc_md.pcibios_fixup = mpc85xx_cds_pcibios_fixup;
+#endif
 
 	/* setup PCI host bridges */
 	mpc85xx_setup_hose();
@@ -453,8 +555,8 @@ mpc85xx_cds_setup_arch(void)
 	/* setup the board related info for the MDIO bus */
 	mdata = (struct gianfar_mdio_data *) ppc_sys_get_pdata(MPC85xx_MDIO);
 
-	mdata->irq[0] = MPC85xx_IRQ_EXT5;
-	mdata->irq[1] = MPC85xx_IRQ_EXT5;
+	mdata->irq[0] = ALTERPATH_TSEC1_PHY_INTERRUPT;
+	mdata->irq[1] = ALTERPATH_TSEC2_PHY_INTERRUPT;
 	mdata->irq[2] = -1;
 	mdata->irq[3] = -1;
 	mdata->irq[31] = -1;
@@ -464,7 +566,7 @@ mpc85xx_cds_setup_arch(void)
 	if (pdata) {
 		pdata->board_flags = FSL_GIANFAR_BRD_HAS_PHY_INTR;
 		pdata->bus_id = 0;
-		pdata->phy_id = 0;
+		pdata->phy_id = ALTERPATH_TSEC1_PHY_ID;
 		memcpy(pdata->mac_addr, binfo->bi_enetaddr, 6);
 	}
 
@@ -505,6 +607,12 @@ mpc85xx_cds_setup_arch(void)
 #else
 	ROOT_DEV = Root_HDA1;
 #endif
+	cyc_memory_init();
+#ifdef CONFIG_Alterpath_KVMMAXV2
+#ifdef CONFIG_SERIAL_8250
+	kvmmaxv2_setup_serial();
+#endif
+#endif
 }
 
 /* ************************************************************************ */
@@ -576,20 +684,22 @@ platform_init(unsigned long r3, unsigned
 	ppc_md.init_IRQ = mpc85xx_cds_init_IRQ;
 	ppc_md.get_irq = openpic_get_irq;
 
-	ppc_md.restart = mpc85xx_restart;
-	ppc_md.power_off = mpc85xx_power_off;
-	ppc_md.halt = mpc85xx_halt;
+	ppc_md.restart = mpc85xx_alterpath_restart;
+	ppc_md.power_off = mpc85xx_alterpath_power_off;
+	ppc_md.halt = mpc85xx_alterpath_halt;
 
 	ppc_md.find_end_of_memory = mpc85xx_find_end_of_memory;
 
 	ppc_md.calibrate_decr = mpc85xx_calibrate_decr;
 
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
 	ppc_md.time_init = todc_time_init;
 	ppc_md.set_rtc_time = todc_set_rtc_time;
 	ppc_md.get_rtc_time = todc_get_rtc_time;
 
 	ppc_md.nvram_read_val = todc_direct_read_val;
 	ppc_md.nvram_write_val = todc_direct_write_val;
+#endif
 
 #if defined(CONFIG_SERIAL_8250) && defined(CONFIG_SERIAL_TEXT_DEBUG)
 	ppc_md.progress = gen550_progress;
@@ -603,3 +713,305 @@ platform_init(unsigned long r3, unsigned
 
 	return;
 }
+
+#ifdef CONFIG_Alterpath_KVMMAX
+#define ALTERPATH_FPGA_BASE_ADDR		0xc0000000
+#define ALTERPATH_FPGA_SIZE				0x200
+#endif
+#ifdef CONFIG_Alterpath_KVMMAXV2
+#define ALTERPATH_FPGA_BASE_ADDR		0xc4000000
+#define ALTERPATH_FPGA_SIZE			0x200
+#define ALTERPATH_CF_BASE_ADDR			0xc4008000
+#define ALTERPATH_CF_SIZE			0x200
+#define ALTERPATH_UART_BASE_ADDR		0xc4010000
+#define ALTERPATH_UART_SIZE			0x200
+#endif
+
+static void cyc_memory_init(void)
+{
+#ifdef CONFIG_Alterpath_KVMMAX
+	fpga_base = cf_base = (unsigned long)ioremap(ALTERPATH_FPGA_BASE_ADDR, ALTERPATH_FPGA_SIZE);
+#endif
+#ifdef CONFIG_Alterpath_KVMMAXV2
+	fpga_base = (unsigned long)ioremap(ALTERPATH_FPGA_BASE_ADDR, ALTERPATH_FPGA_SIZE);
+	cf_base = (unsigned long)ioremap(ALTERPATH_CF_BASE_ADDR, ALTERPATH_CF_SIZE);
+#endif
+}
+
+unsigned long cyc_get_cfaddr(void)
+{
+	return (cf_base);
+}
+
+unsigned long cyc_get_fpgaaddr(void)
+{
+	return (fpga_base);
+}
+
+int cyc_get_ide_CF_irq(void)
+{
+#ifdef CONFIG_Alterpath_KVMMAX
+	return (SIU_INT_PC0);
+#endif
+#ifdef CONFIG_Alterpath_KVMMAXV2
+	return (MPC85xx_IRQ_EXT10);
+#endif
+}
+
+void cyc_reset_ide_CF(void)
+{
+#ifdef CONFIG_Alterpath_KVMMAX
+	fpga_regs_t *fpga = (fpga_regs_t *)fpga_base;
+#endif
+#ifdef CONFIG_Alterpath_KVMMAXV2
+	fpga_regs_t *fpga = (fpga_regs_t *)fpga_base;
+#endif
+
+#ifdef CONFIG_Alterpath_KVMMAX
+	fpga_reg1_value |= 0x0001;
+	fpga->reg1 = fpga_reg1_value;
+	udelay(300000);
+	fpga_reg1_value &= ~0x0001;
+	fpga->reg1 = fpga_reg1_value;
+	udelay(300000);
+	/* Set up CF interrupt */
+	fpga_reg1_value |= 0x0002;
+	fpga->reg1 = fpga_reg1_value;
+	udelay(100000);
+#endif
+#ifdef CONFIG_Alterpath_KVMMAXV2
+	fpga->Reset_Ctl |= 0x0004;
+	udelay(300000);
+	fpga->Reset_Ctl &= ~0x0004;
+	udelay(300000);
+	/* Set up CF interrupt */
+	fpga->Int_En_2 |= 0x2000;
+	udelay(100000);
+#endif
+}
+
+#ifdef CONFIG_BLK_DEV_CYC_IDE
+#define CYC_CF_FS '1'
+#else
+#define CYC_CF_FS '0'
+#endif
+
+static int bdinfo_read_proc(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int len;
+#if 0
+	bd_t *bd = (bd_t *)__res;
+	int clock_freq;
+	int len;
+	unsigned char *pdev, pmac[20];
+	int k26 = LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0);
+                                                                                
+	clock_freq = bd->bi_intfreq / 1000000;
+
+	sprintf(pmac,"%.2x%.2x%.2x%.2x%.2x%.2x",bd->bi_enetaddr[0],
+		bd->bi_enetaddr[1], bd->bi_enetaddr[2],bd->bi_enetaddr[3],
+		bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
+                                                                                
+	if ((bd->hw_info.board_type == BOARD_TS1H) || (bd->hw_info.device_id[0]==0x00)) {
+		pdev = pmac;
+	} else {
+		pdev = bd->hw_info.device_id;
+	}
+
+	if (!*pdev) {
+		pdev = "0";
+	} 
+                                                                               
+	sprintf(page, "%s!%d:%d:%d:%d!%s!%d!%s!%s!%s!%d!%s!%d!%d!%d!%s!%d!%d!%d!%s!%c!%d!\n",
+		bd->board_name,
+		bd->num_portsA, bd->num_portsK, bd->num_portsM, bd->num_portsS,
+		bd->card_name,
+		bd->hw_info.board_type,
+		bd->vendor_name,
+		bd->prod_line,
+		bd->prod_name,
+		(bd->hw_info.pcmcia? 0:1),
+		bd->cyc_version,
+		clock_freq,
+		((bd->hw_info.memory_detected /1024)/1024),
+		(bd->hw_info.storage_size/1000000),
+		pdev,
+		bd->hw_info.fpga_version,
+		bd->hw_info.ipboard1,
+		bd->hw_info.ipboard2,
+		pmac,
+		CYC_CF_FS,
+		k26);
+#endif
+	strcpy(page, "KVMMAX!2:16:0:0!KVMM!33!Cycladess!KVMMAX!KVMMAX!0!V_1.0.0-Dec/01/05!533!256!128!UnKnow!1!0!0!00:60:2e:00:01:02!1!1!\n");
+	len = strlen(page);
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+int bdinfo_proc_init(void)
+{
+	create_proc_read_entry("bdinfo", 0, NULL, bdinfo_read_proc, NULL);
+	return(0);
+}
+
+late_initcall(bdinfo_proc_init);
+
+#if defined(CONFIG_SENSORS_M41T00)
+extern ulong	m41t00_get_rtc_time(void);
+extern int	m41t00_set_rtc_time(ulong);
+
+static int __init
+cyc_rtc_hookup(void)
+{
+	struct timespec	tv;
+
+	ppc_md.get_rtc_time = m41t00_get_rtc_time;
+	ppc_md.set_rtc_time = m41t00_set_rtc_time;
+
+	tv.tv_nsec = 0;
+	tv.tv_sec = (ppc_md.get_rtc_time)();
+	do_settimeofday(&tv);
+
+	return 0;
+}
+late_initcall(cyc_rtc_hookup);
+#endif
+
+char *cyc_get_version(void)
+{
+	return("KVMMAX V_1.0.0 (Dec/07/05) #1\n");
+}
+
+void cyc_reset_osd(void)
+{
+#if defined(CONFIG_Alterpath_KVMMAX)
+	cpm2_immr->im_ioport.iop_pdira |=  0x00000002;
+	cpm2_immr->im_ioport.iop_ppara &= ~0x00000002;
+	cpm2_immr->im_ioport.iop_podra &= ~0x00000002;
+	cpm2_immr->im_ioport.iop_pdata &= ~0x00000002;
+	udelay(200000);
+	cpm2_immr->im_ioport.iop_pdata |=  0x00000002;
+	udelay(200000);
+#endif
+#if defined(CONFIG_Alterpath_KVMMAXV2)
+	fpga_regs_t *fpga = (fpga_regs_t *)fpga_base;
+	fpga->Reset_Ctl |= 0x0020;
+	udelay(200000);
+	fpga->Reset_Ctl &= ~0x0020;
+	udelay(200000);
+#endif
+}
+
+#ifdef CONFIG_Alterpath_KVMMAXV2
+static void kvmmaxv2_setup_serial(void)
+{
+	int i;
+	unsigned long uart_base = (unsigned long)ioremap(ALTERPATH_UART_BASE_ADDR, ALTERPATH_UART_SIZE);
+	struct uart_port p;
+
+	volatile cpm2_map_t *immap = cpm2_immr;
+	volatile iop_cpm2_t *iop = &immap->im_ioport;
+	unsigned long tmp;
+
+	fpga_regs_t *fpga = (fpga_regs_t *)fpga_base;
+
+	memset(&p, 0, sizeof(p));
+	p.line = 0;
+	p.irq = MPC85xx_IRQ_EXT11;
+	p.iotype = UPIO_MEM;
+	p.uartclk = 14745600/2;
+	for (i = 0; i < 20; i ++) {
+		p.line = i + 2;
+		p.membase = 
+			(unsigned char __iomem *)(uart_base + i * 8);
+		if (i < 16) {
+			p.flags = UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ |
+				UPF_LEGACY_RTS;
+		} else {
+			p.flags = UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;
+		}
+		if (early_serial_setup(&p) != 0)
+			printk("Early serial init of port %d failed\n", i + 2);
+	}
+	/* set up DCD/DTR/DSR signals in the UART1 (console) */
+	/* DCD = PA9 */
+	iop->iop_pdira &= ~(CPM_PA_9);
+	iop->iop_ppara &= ~(CPM_PA_9);
+	iop->iop_podra &= ~(CPM_PA_9);
+	iop->iop_pdata |= (CPM_PA_9);
+	/* DTR = PA8 */
+	iop->iop_pdira |= CPM_PA_8;
+	iop->iop_ppara &= ~(CPM_PA_8);
+	iop->iop_podra &= ~(CPM_PA_8);
+	iop->iop_pdata &= ~(CPM_PA_8);
+	/* DSR = PA10 */
+	iop->iop_pdira &= ~(CPM_PA_10);
+	iop->iop_ppara &= ~(CPM_PA_10);
+	iop->iop_podra &= ~(CPM_PA_10);
+	iop->iop_pdata |= (CPM_PA_10);
+	tmp = iop->iop_pdata;
+	asm("sync");
+
+	/* Disable interrupts on all ports */
+	fpga->Int_En_2 &= ~0x000f;
+	fpga->Int_En_1 = 0;
+	/* Reset the chips */
+	fpga->Reset_Ctl |= 0xf800;
+	fpga->Int_En_2 |= 0x000f;
+	fpga->Int_En_1 = 0xffff;
+	mdelay(10);
+	fpga->Reset_Ctl &= ~0xf800;
+}
+#endif
+
+static void mpc85xx_wdt_do_hreset(void)
+{
+	unsigned long val;
+
+	local_irq_disable();
+
+	/*
+	 * set up wdt timeout to be the smallest by making TCR[WP]=11
+	 * and TCR[WPEXT]=1111,
+	 *
+	 * enable processor reset output by making TCR[WRC]=10.
+	 *
+	 * disable all timer interrupts: WIE, DIE, FIE, ARE.
+	 */
+	val = mfspr(SPRN_TCR);
+	val |= (TCR_WP(3) + (15 << 17));
+	val |= TCR_WRC(2);
+	val &= ~(TCR_WIE | TCR_PIE | TCR_FIE | TCR_ARE);
+	mtspr(SPRN_TCR, val);
+
+	/* if above change doesn't work, we need to do more */
+	val = mfspr(SPRN_TSR);
+	val |= TSR_ENW | TSR_WIS;
+	mtspr(SPRN_TSR, val);
+
+	mtspr(SPRN_TBWL, 0);
+	mtspr(SPRN_TBWU, 0);
+	
+	val = mfspr(SPRN_HID0);
+	val |= 0x00004000;
+	val &= ~0x00002000;
+	mtspr(SPRN_HID0, val);
+	
+	for (;;) ;
+}
+static void mpc85xx_alterpath_restart(char *cmd)
+{
+	mpc85xx_wdt_do_hreset();
+}
+
+static void mpc85xx_alterpath_halt(void)
+{
+	mpc85xx_wdt_do_hreset();
+}
+
+static void mpc85xx_alterpath_power_off(void)
+{
+	mpc85xx_wdt_do_hreset();
+}
+
diff -ruNp linux-2.6.16/arch/ppc/platforms/85xx/mpc85xx_cds_common.h kvmmax/arch/ppc/platforms/85xx/mpc85xx_cds_common.h
--- linux-2.6.16/arch/ppc/platforms/85xx/mpc85xx_cds_common.h	2006-03-20 18:07:03.000000000 +1100
+++ kvmmax/arch/ppc/platforms/85xx/mpc85xx_cds_common.h	2006-04-26 11:51:25.000000000 +1000
@@ -26,6 +26,8 @@
 #define BOARD_CCSRBAR           ((uint)0xe0000000)
 #define CCSRBAR_SIZE            ((uint)1024*1024)
 
+#if !defined(CONFIG_Alterpath_KVMMAX) && !defined(CONFIG_Alterpath_KVMMAXV2)
+
 /* CADMUS info */
 #define CADMUS_BASE (0xf8004000)
 #define CADMUS_SIZE (256)
@@ -37,6 +39,8 @@
 #define CDS_RTC_ADDR	(0xf8000000)
 #define CDS_RTC_SIZE	(8 * 1024)
 
+#endif
+
 /* PCI config */
 #define PCI1_CFG_ADDR_OFFSET	(0x8000)
 #define PCI1_CFG_DATA_OFFSET	(0x8004)
@@ -52,32 +56,117 @@
 #define PIRQ1A                   MPC85xx_IRQ_EXT11
 
 /* PCI 1 memory map */
-#define MPC85XX_PCI1_LOWER_IO        0x00000000
-#define MPC85XX_PCI1_UPPER_IO        0x00ffffff
-
 #define MPC85XX_PCI1_LOWER_MEM       0x80000000
 #define MPC85XX_PCI1_UPPER_MEM       0x9fffffff
 
-#define MPC85XX_PCI1_IO_BASE         0xe2000000
 #define MPC85XX_PCI1_MEM_OFFSET      0x00000000
 
-#define MPC85XX_PCI1_IO_SIZE         0x01000000
-
 /* PCI 2 memory map */
-/* Note: the standard PPC fixups will cause IO space to get bumped by
- * hose->io_base_virt - isa_io_base => MPC85XX_PCI1_IO_SIZE */
-#define MPC85XX_PCI2_LOWER_IO        0x00000000
-#define MPC85XX_PCI2_UPPER_IO        0x00ffffff
-
 #define MPC85XX_PCI2_LOWER_MEM       0xa0000000
 #define MPC85XX_PCI2_UPPER_MEM       0xbfffffff
 
-#define MPC85XX_PCI2_IO_BASE         0xe3000000
 #define MPC85XX_PCI2_MEM_OFFSET      0x00000000
 
+
+#ifdef CONFIG_Alterpath_KVMMAXV2
+/* PCI 1 I/O map */
+#define MPC85XX_PCI1_LOWER_IO        0x00000000
+#define MPC85XX_PCI1_UPPER_IO        0x01ffffff
+
+#define MPC85XX_PCI1_IO_BASE         0xc0000000
+#define MPC85XX_PCI1_IO_SIZE         0x02000000
+
+/* PCI 2 I/O map */
+#define MPC85XX_PCI2_LOWER_IO        0x02000000
+#define MPC85XX_PCI2_UPPER_IO        0x03ffffff
+
+#define MPC85XX_PCI2_IO_BASE         0xc2000000
+#define MPC85XX_PCI2_IO_SIZE         0x02000000
+
+#else
+/* PCI 1 I/O map */
+#define MPC85XX_PCI1_LOWER_IO        0x01000000
+#define MPC85XX_PCI1_UPPER_IO        0x01ffffff
+
+#define MPC85XX_PCI1_IO_BASE         0xe2000000
+#define MPC85XX_PCI1_IO_SIZE         0x01000000
+
+/* PCI 2 I/O map */
+#define MPC85XX_PCI2_LOWER_IO        0x00000000
+#define MPC85XX_PCI2_UPPER_IO        0x00ffffff
+
+#define MPC85XX_PCI2_IO_BASE         0xe3000000
 #define MPC85XX_PCI2_IO_SIZE         0x01000000
+#endif
+
+/* PCI 2 memory map */
+/* Note: the standard PPC fixups will cause IO space to get bumped by
+ * hose->io_base_virt - isa_io_base => MPC85XX_PCI1_IO_SIZE */
+#ifdef CONFIG_Alterpath_KVMMAXV2
+#else
+#endif
+
 
-#define NR_8259_INTS		     16
+#define NR_8259_INTS		     0
 #define CPM_IRQ_OFFSET		     NR_8259_INTS
 
+#ifdef CONFIG_ALTERPATH
+unsigned long cyc_get_cfaddr(void);
+unsigned long cyc_get_fpgaaddr(void);
+void cyc_reset_ide_CF(void);
+int cyc_get_ide_CF_irq(void);
+char *cyc_get_version(void);
+void cyc_reset_osd(void);
+
+extern unsigned short fpga_reg1_value;
+
+#ifdef CONFIG_Alterpath_KVMMAX
+typedef struct fpga_regs {
+	unsigned short reserved[0x10];		/* IDE registers */
+	unsigned short reg1;				/* 0x20 */
+	unsigned short reg2;				/* 0x22 */
+	unsigned short reg3;				/* 0x24 */
+	unsigned short hlo;					/* 0x26 */
+	unsigned short hhi;					/* 0x28 */
+	unsigned short vlo;					/* 0x2a */
+	unsigned short vhi;					/* 0x2c */
+	unsigned short intr;				/* 0x2e */
+} fpga_regs_t;
+#endif
+
+#ifdef CONFIG_Alterpath_KVMMAXV2
+typedef struct fpga_regs {
+	unsigned short Reset_Ctl;       /* 0x00 */
+	unsigned short Local_Ctl;       /* 0x02 */
+	unsigned short Int_En_2;        /* 0x04 */
+	unsigned short Int_En_1;        /* 0x06 */
+	unsigned short Int_Sts_2;       /* 0x08 */
+	unsigned short Int_Sts_1;       /* 0x0a */
+	unsigned short Gen_Sts;         /* 0x0c */
+	unsigned short FPGA_ID;         /* 0x0e */
+	unsigned short FPGA_VER;        /* 0x10 */
+	unsigned short Count_Hsync_0;   /* 0x12 */
+	unsigned short Count_Hsync_1;   /* 0x14 */
+	unsigned short Count_Vsync_0;   /* 0x16 */
+	unsigned short Count_Vsync_1;   /* 0x18 */
+} fpga_regs_t;
+#endif
+
+
+/* Ethernet settings */
+#ifdef CONFIG_Alterpath_KVMMAX
+#define ALTERPATH_TSEC1_PHY_INTERRUPT	MPC85xx_IRQ_EXT0
+#define ALTERPATH_TSEC1_PHY_ID		0
+#define ALTERPATH_TSEC2_PHY_INTERRUPT	MPC85xx_IRQ_EXT1
+#define ALTERPATH_TSEC2_PHY_ID		7
+#endif
+#ifdef CONFIG_Alterpath_KVMMAXV2
+#define ALTERPATH_TSEC1_PHY_INTERRUPT	SIU_INT_PC29
+#define ALTERPATH_TSEC1_PHY_ID		1
+#define ALTERPATH_TSEC2_PHY_INTERRUPT	SIU_INT_PC29
+#define ALTERPATH_TSEC2_PHY_ID		3
+#endif
+
+#endif
+
 #endif /* __MACH_MPC85XX_CDS_H__ */
diff -ruNp linux-2.6.16/arch/ppc/syslib/ppc85xx_setup.c kvmmax/arch/ppc/syslib/ppc85xx_setup.c
--- linux-2.6.16/arch/ppc/syslib/ppc85xx_setup.c	2006-03-20 18:07:03.000000000 +1100
+++ kvmmax/arch/ppc/syslib/ppc85xx_setup.c	2006-04-26 11:51:25.000000000 +1000
@@ -159,7 +159,12 @@ mpc85xx_setup_pci1(struct pci_controller
 	early_write_config_word(hose, 0, 0, PCI_COMMAND, temps);
 
 #define PORDEVSR_PCI	(0x00800000)	/* PCI Mode */
-	if (guts->pordevsr & PORDEVSR_PCI) {
+#ifdef CONFIG_ONBOARD
+	if (1)
+#else
+	if (guts->pordevsr & PORDEVSR_PCI)
+#endif
+	{
  		early_write_config_byte(hose, 0, 0, PCI_LATENCY_TIMER, 0x80);
  	} else {
 		/* PCI-X init */
@@ -354,8 +359,8 @@ mpc85xx_setup_hose(void)
 			IORESOURCE_MEM, "PCI2 host bridge");
 
 	pci_init_resource(&hose_b->io_resource,
-			MPC85XX_PCI2_LOWER_IO,
-			MPC85XX_PCI2_UPPER_IO,
+			MPC85XX_PCI1_LOWER_IO,
+			MPC85XX_PCI1_UPPER_IO,
 			IORESOURCE_IO, "PCI2 host bridge");
 
 	hose_b->last_busno = pciauto_bus_scan(hose_b, hose_b->first_busno);
diff -ruNp linux-2.6.16/.config.kvmmax kvmmax/.config.kvmmax
--- linux-2.6.16/.config.kvmmax	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/.config.kvmmax	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,1105 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14
+# Mon Jan 23 19:41:58 2006
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E200 is not set
+CONFIG_E500=y
+CONFIG_BOOKE=y
+CONFIG_FSL_BOOKE=y
+# CONFIG_PHYS_64BIT is not set
+CONFIG_SPE=y
+CONFIG_MATH_EMULATION=y
+# CONFIG_KEXEC is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_WANT_EARLY_SERIAL is not set
+CONFIG_PPC_GEN550=y
+CONFIG_ALTERPATH=y
+# CONFIG_Alterpath_ACS is not set
+CONFIG_Alterpath_KVMMAX=y
+# CONFIG_Alterpath_KVMMAXV2 is not set
+CONFIG_85xx=y
+CONFIG_PPC_INDIRECT_PCI_BE=y
+
+#
+# Freescale 85xx options
+#
+# CONFIG_MPC8540_ADS is not set
+# CONFIG_MPC8548_CDS is not set
+CONFIG_MPC8555_CDS=y
+# CONFIG_MPC8560_ADS is not set
+# CONFIG_SBC8560 is not set
+# CONFIG_STX_GP3 is not set
+CONFIG_MPC8555=y
+CONFIG_85xx_PCI2=y
+
+#
+# Platform options
+#
+CONFIG_CPM2=y
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_HIGHMEM is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+# CONFIG_SOFTWARE_SUSPEND is not set
+# CONFIG_SECCOMP is not set
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_DEBUG=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=m
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_CARDBUS=y
+
+#
+# PC-card bridges
+#
+CONFIG_YENTA=m
+# CONFIG_PD6729 is not set
+# CONFIG_I82092 is not set
+CONFIG_PCCARD_NONSTATIC=m
+
+#
+# Advanced setup
+#
+CONFIG_ADVANCED_OPTIONS=y
+CONFIG_HIGHMEM_START=0xfe000000
+# CONFIG_LOWMEM_SIZE_BOOL is not set
+CONFIG_LOWMEM_SIZE=0x30000000
+# CONFIG_KERNEL_START_BOOL is not set
+CONFIG_KERNEL_START=0xc0000000
+# CONFIG_TASK_SIZE_BOOL is not set
+CONFIG_TASK_SIZE=0x80000000
+# CONFIG_BOOT_LOAD_BOOL is not set
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_DEBUG_DRIVER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_CHAR is not set
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_Alterpath=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=76800
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_CYC_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+CONFIG_BONDING=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+CONFIG_GIANFAR=y
+# CONFIG_GFAR_NAPI is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=m
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+CONFIG_PCMCIA_XIRC2PS=m
+# CONFIG_PCMCIA_AXNET is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPPOE is not set
+CONFIG_SLIP=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+# CONFIG_SLIP_MODE_SLIP6 is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_CS=m
+CONFIG_SERIAL_8250_NR_UARTS=64
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_RSA is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_CPM is not set
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+CONFIG_I2C_MPC=y
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+CONFIG_SENSORS_M41T00=y
+# CONFIG_SENSORS_MAX6875 is not set
+CONFIG_SENSORS_M35075=y
+CONFIG_SENSORS_DAC5574=y
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+CONFIG_HWMON_VID=y
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+CONFIG_SENSORS_LM85=y
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# CPM2 Options
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_KGDB is not set
+# CONFIG_KGDB_CONSOLE is not set
+# CONFIG_XMON is not set
+CONFIG_BDI_SWITCH=y
+CONFIG_SERIAL_TEXT_DEBUG=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -ruNp linux-2.6.16/.config.kvmmaxv2 kvmmax/.config.kvmmaxv2
--- linux-2.6.16/.config.kvmmaxv2	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/.config.kvmmaxv2	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,1109 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14
+# Fri Jan 20 19:41:59 2006
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E200 is not set
+CONFIG_E500=y
+CONFIG_BOOKE=y
+CONFIG_FSL_BOOKE=y
+# CONFIG_PHYS_64BIT is not set
+CONFIG_SPE=y
+CONFIG_MATH_EMULATION=y
+# CONFIG_KEXEC is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_WANT_EARLY_SERIAL is not set
+CONFIG_PPC_GEN550=y
+CONFIG_ALTERPATH=y
+# CONFIG_Alterpath_ACS is not set
+# CONFIG_Alterpath_KVMMAX is not set
+CONFIG_Alterpath_KVMMAXV2=y
+CONFIG_85xx=y
+CONFIG_PPC_INDIRECT_PCI_BE=y
+
+#
+# Freescale 85xx options
+#
+# CONFIG_MPC8540_ADS is not set
+# CONFIG_MPC8548_CDS is not set
+CONFIG_MPC8555_CDS=y
+# CONFIG_MPC8560_ADS is not set
+# CONFIG_SBC8560 is not set
+# CONFIG_STX_GP3 is not set
+CONFIG_MPC8555=y
+CONFIG_85xx_PCI2=y
+
+#
+# Platform options
+#
+CONFIG_CPM2=y
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_HIGHMEM is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+# CONFIG_SOFTWARE_SUSPEND is not set
+# CONFIG_SECCOMP is not set
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_DEBUG=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=m
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_CARDBUS=y
+
+#
+# PC-card bridges
+#
+CONFIG_YENTA=m
+# CONFIG_PD6729 is not set
+# CONFIG_I82092 is not set
+CONFIG_PCCARD_NONSTATIC=m
+
+#
+# Advanced setup
+#
+CONFIG_ADVANCED_OPTIONS=y
+CONFIG_HIGHMEM_START=0xfe000000
+# CONFIG_LOWMEM_SIZE_BOOL is not set
+CONFIG_LOWMEM_SIZE=0x30000000
+# CONFIG_KERNEL_START_BOOL is not set
+CONFIG_KERNEL_START=0xc0000000
+# CONFIG_TASK_SIZE_BOOL is not set
+CONFIG_TASK_SIZE=0x80000000
+# CONFIG_BOOT_LOAD_BOOL is not set
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_Alterpath=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=76800
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_CYC_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+CONFIG_BONDING=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+CONFIG_GIANFAR=y
+# CONFIG_GFAR_NAPI is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+CONFIG_PCMCIA_XIRC2PS=m
+# CONFIG_PCMCIA_AXNET is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPPOE is not set
+CONFIG_SLIP=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+# CONFIG_SLIP_MODE_SLIP6 is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_CS=m
+CONFIG_SERIAL_8250_NR_UARTS=64
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_RSA is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_CPM is not set
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+CONFIG_I2C_MPC=y
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+CONFIG_SENSORS_M41T00=y
+# CONFIG_SENSORS_MAX6875 is not set
+CONFIG_SENSORS_M35075=y
+# CONFIG_SENSORS_DAC5574 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+CONFIG_HWMON_VID=y
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+CONFIG_SENSORS_LM85=y
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# CPM2 Options
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_KGDB is not set
+# CONFIG_KGDB_CONSOLE is not set
+# CONFIG_XMON is not set
+CONFIG_BDI_SWITCH=y
+CONFIG_SERIAL_TEXT_DEBUG=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -ruNp linux-2.6.16/.config.tst kvmmax/.config.tst
--- linux-2.6.16/.config.tst	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/.config.tst	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,728 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14
+# Fri Nov  4 10:14:22 2005
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E200 is not set
+CONFIG_E500=y
+CONFIG_BOOKE=y
+CONFIG_FSL_BOOKE=y
+# CONFIG_PHYS_64BIT is not set
+CONFIG_SPE=y
+CONFIG_MATH_EMULATION=y
+# CONFIG_KEXEC is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_WANT_EARLY_SERIAL is not set
+CONFIG_PPC_GEN550=y
+CONFIG_85xx=y
+CONFIG_PPC_INDIRECT_PCI_BE=y
+
+#
+# Freescale 85xx options
+#
+# CONFIG_MPC8540_ADS is not set
+# CONFIG_MPC8548_CDS is not set
+CONFIG_MPC8555_CDS=y
+# CONFIG_MPC8560_ADS is not set
+# CONFIG_SBC8560 is not set
+# CONFIG_STX_GP3 is not set
+CONFIG_MPC8555=y
+# CONFIG_85xx_PCI2 is not set
+
+#
+# Platform options
+#
+CONFIG_CPM2=y
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_HIGHMEM is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+# CONFIG_SOFTWARE_SUSPEND is not set
+# CONFIG_SECCOMP is not set
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_DEBUG=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Advanced setup
+#
+CONFIG_ADVANCED_OPTIONS=y
+CONFIG_HIGHMEM_START=0xfe000000
+# CONFIG_LOWMEM_SIZE_BOOL is not set
+CONFIG_LOWMEM_SIZE=0x30000000
+# CONFIG_KERNEL_START_BOOL is not set
+CONFIG_KERNEL_START=0xc0000000
+# CONFIG_TASK_SIZE_BOOL is not set
+CONFIG_TASK_SIZE=0x80000000
+# CONFIG_BOOT_LOAD_BOOL is not set
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+CONFIG_DEBUG_DRIVER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=40960
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+CONFIG_BONDING=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+CONFIG_GIANFAR=y
+# CONFIG_GFAR_NAPI is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPPOE is not set
+CONFIG_SLIP=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+# CONFIG_SLIP_MODE_SLIP6 is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_CPM is not set
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# CPM2 Options
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_KGDB is not set
+# CONFIG_KGDB_CONSOLE is not set
+# CONFIG_XMON is not set
+CONFIG_BDI_SWITCH=y
+CONFIG_SERIAL_TEXT_DEBUG=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -ruNp linux-2.6.16/drivers/char/tty_io.c kvmmax/drivers/char/tty_io.c
--- linux-2.6.16/drivers/char/tty_io.c	2006-03-20 18:07:11.000000000 +1100
+++ kvmmax/drivers/char/tty_io.c	2006-04-24 16:31:10.000000000 +1000
@@ -2801,7 +2801,7 @@ out:
  */
 static int baud_table[] = {
 	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
-	9600, 19200, 38400, 57600, 115200, 230400, 460800,
+	9600, 14400, 19200, 28800, 38400, 57600, 76800, 115200, 230400, 460800,
 #ifdef __sparc__
 	76800, 153600, 307200, 614400, 921600
 #else
diff -ruNp linux-2.6.16/drivers/i2c/chips/dac5574.c kvmmax/drivers/i2c/chips/dac5574.c
--- linux-2.6.16/drivers/i2c/chips/dac5574.c	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/drivers/i2c/chips/dac5574.c	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,119 @@
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/param.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+
+/* Routines for the DAC5574 driver */
+
+struct i2c_client *dac_client = NULL;
+static int dac_attach(struct i2c_adapter *adap);
+static int dac_detach(struct i2c_client *client);
+static int dac_command(struct i2c_client *client, unsigned int cmd, void *arg);
+
+static struct i2c_driver dac_driver = {
+	name:		"DAC_I2C",
+	id:		I2C_DRIVERID_DAC5574,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	dac_attach,
+	detach_client:	dac_detach,
+	command:	dac_command
+};
+
+static int dac_attach(struct i2c_adapter *adap)
+{
+	dac_client = (struct i2c_client *)kmalloc(sizeof(*dac_client), 
+		GFP_KERNEL);
+
+	if (!dac_client) {
+		return -ENOMEM;
+	}
+
+	memset(dac_client, 0, sizeof(struct i2c_client));
+	strcpy(dac_client->name, "DAC-I2C");
+	dac_client->flags	= 0;
+	dac_client->addr	= 0x4c;
+	dac_client->adapter	= adap;
+	dac_client->driver	= &dac_driver;
+
+	return i2c_attach_client(dac_client);
+}
+
+static int dac_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+	kfree(client);
+	return 0;
+}
+
+static int dac_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return 0;
+}
+
+int
+dac_set_value(unsigned char channel, unsigned short value, unsigned char offset)
+{
+	unsigned char addr[3];
+	struct i2c_msg msgs[1] = {{ 0, 0, 3, addr }};
+	int ret = -EIO;
+
+	if (dac_client == NULL) {
+		return -EIO;
+	}
+	if (channel >= 4) {
+		return -EIO;
+	}
+	addr[0] = 0x10 + (channel << 1);
+	addr[1] = value / 0x100;
+	addr[2] = value % 0x100;
+	msgs[0].addr = dac_client->addr + offset;
+	ret = i2c_transfer(dac_client->adapter, msgs, 1);
+
+	if (ret == 3) {
+		ret = 0;
+	} else {
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+static __initdata int dac_initialized = 0;
+
+static __init int dac_cleanup(void)
+{
+	int err;
+	if (dac_initialized == 1) {
+		err = i2c_del_driver(&dac_driver);
+		if (err) {
+			printk("dac5574.o: Register I2C driver failed, "
+				"errno is %d\n"	,err);
+			return err;
+		}
+	}
+	dac_initialized --;
+	return 0;
+}
+
+static __init int dac_i2c_init(void)
+{
+	int err;
+
+	printk("dac5574.o: DAC5574 I2C based driver.\n");
+	err = i2c_add_driver(&dac_driver);
+	if (err) {
+		printk("dac5574.o: Register I2C driver failed, errno is %d\n"
+			,err);
+		dac_cleanup();
+		return err;
+	}
+	dac_initialized ++;
+	return 0;
+}
+
+__initcall(dac_i2c_init);
diff -ruNp linux-2.6.16/drivers/i2c/chips/Kconfig kvmmax/drivers/i2c/chips/Kconfig
--- linux-2.6.16/drivers/i2c/chips/Kconfig	2006-03-20 18:07:11.000000000 +1100
+++ kvmmax/drivers/i2c/chips/Kconfig	2006-04-24 16:31:10.000000000 +1000
@@ -135,4 +135,12 @@ config RTC_X1205_I2C
 	  This driver can also be built as a module. If so, the module
 	  will be called x1205.
 
+config SENSORS_M35075
+	tristate "Mitsubishi M35075 OSD chip"
+	depends on I2C
+
+config SENSORS_DAC5574
+	tristate "TI DAC5574 chip"
+	depends on I2C
+
 endmenu
diff -ruNp linux-2.6.16/drivers/i2c/chips/m35075.c kvmmax/drivers/i2c/chips/m35075.c
--- linux-2.6.16/drivers/i2c/chips/m35075.c	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/drivers/i2c/chips/m35075.c	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,580 @@
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/param.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/m35075.h>
+
+#include <asm/irq.h>
+#if defined(CONFIG_Alterpath_KVMMAX) || defined(CONFIG_Alterpath_KVMMAXV2)
+#include <platforms/85xx/kvmmax_osd.h>
+#include <asm/immap_cpm2.h>
+#include <platforms/85xx/mpc85xx_cds_common.h>
+#endif
+
+#ifdef CONFIG_Alterpath_KVMMAXV1
+#include <linux/pca9548.h>
+#endif
+
+#undef CYOSD_DEBUG
+#undef CYOSD_TRACE
+/* Routines for the DAC5574 driver */
+
+#ifndef CONFIG_CYSPI
+struct i2c_client *m35075_client = NULL;
+static int m35075_attach(struct i2c_adapter *adap);
+static int m35075_detach(struct i2c_client *client);
+static int m35075_command(struct i2c_client *client, unsigned int cmd, void *arg);
+
+static struct i2c_driver m35075_driver = {
+	name:		"M35075_I2C",
+	id:		I2C_DRIVERID_M35075,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	m35075_attach,
+	detach_client:	m35075_detach,
+	command:	m35075_command
+};
+
+static int m35075_attach(struct i2c_adapter *adap)
+{
+	m35075_client = (struct i2c_client *)kmalloc(sizeof(*m35075_client), 
+		GFP_KERNEL);
+
+	if (!m35075_client) {
+		return -ENOMEM;
+	}
+
+	memset(m35075_client, 0, sizeof(struct i2c_client));
+	strcpy(m35075_client->name, "M35075-I2C");
+	m35075_client->flags	= 0;
+	m35075_client->addr	= 0x3e;
+	m35075_client->adapter	= adap;
+	m35075_client->driver	= &m35075_driver;
+
+#ifdef CONFIG_Alterpath_KVMMAXV1
+	pca_add_channel(7);
+#endif
+	return i2c_attach_client(m35075_client);
+}
+
+static int m35075_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+#ifdef CONFIG_Alterpath_KVMMAXV1
+	pca_remove_channel(7);
+#endif
+	kfree(client);
+	return 0;
+}
+
+static int m35075_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return 0;
+}
+
+static void select_osdport(int channel)
+{
+}
+
+static int m35075_send_buffer(unsigned short *buffer, short size)
+{
+	struct i2c_msg msgs[1] = {{ 0, 0, 0, NULL }};
+	int ret = -EIO, i;
+
+	if (m35075_client == NULL) {
+		return -EIO;
+	}
+	msgs[0].len = size * 2;
+	msgs[0].buf = kmalloc(size * 2, GFP_ATOMIC);
+	for (i = 0; i < size; i ++) {
+		msgs[0].buf[2 * i] = buffer[i] % 0x0100;
+		msgs[0].buf[2 * i + 1] = buffer[i] / 0x0100;
+	}
+	msgs[0].addr = m35075_client->addr;
+	ret = i2c_transfer(m35075_client->adapter, msgs, 1);
+
+	if (ret == size * 2) {
+		ret = 0;
+	} else {
+		ret = -EIO;
+	}
+	kfree(msgs[0].buf);
+	return ret;
+}
+
+static __initdata int m35075_initialized = 0;
+
+static __init int m35075_cleanup(void)
+{
+	int err;
+	if (m35075_initialized == 1) {
+		err = i2c_del_driver(&m35075_driver);
+		if (err) {
+			printk("m3507.o: Register I2C driver failed, "
+				"errno is %d\n"	,err);
+			return err;
+		}
+	}
+	m35075_initialized --;
+	return 0;
+}
+
+static __init int m35075_i2c_init(void)
+{
+	int err;
+
+	printk("m35075.o: M35075 I2C based driver.\n");
+	err = i2c_add_driver(&m35075_driver);
+	if (err) {
+		printk("m35075.o: Register I2C driver failed, errno is %d\n"
+			,err);
+		m35075_cleanup();
+		return err;
+	}
+	m35075_initialized ++;
+#if defined(CONFIG_Alterpath_KVMMAX) || defined(CONFIG_Alterpath_KVMMAXV2)
+	cy_osd_init();
+#endif
+	return 0;
+}
+
+__initcall(m35075_i2c_init);
+#endif
+
+static struct m35075_t {
+	unsigned char on;		/* 1 = OSD on; 0 = OSD off */
+	unsigned char polv;		/* vertical polarity (1 = invert) */
+	unsigned char polh;		/* horizontal polarity (1 = invert) */
+	unsigned char transparent;	/* 1 -> the background is transparent */
+	unsigned char halign;		/* 0-left;1-center;2-right */
+	unsigned char valign;		/* 0-top;1-center;2-bottom */
+	unsigned short osdhpos[3];
+	unsigned short osdvpos[3];
+	unsigned short buffer[OSDBUFSIZE];	/* buffer of data to be sent 
+						to the OSD */
+} m35075[NUM_OF_OSDS];
+
+/******************************************************************************
+ * List of user-defined characters to be shown in the OSD interface.
+ *****************************************************************************/
+static unsigned short ramchars[] = {
+	/* dollar */
+	0x000, 0x000, 0x060, 0x1f8, 0x3fc, 0x76e, 0x666, 0x760, 0x3f8, 
+	0x1fc, 0x06e, 0x666, 0x76e, 0x3fc, 0x1f8, 0x060, 0x000, 0x000,
+	/* at */
+	0x000, 0x000, 0x1f8, 0x3fc, 0x70e, 0x606, 0x676, 0x6f6, 0x696,
+	0x69e, 0x6fe, 0x66c, 0x600, 0x700, 0x380, 0x1f8, 0x000, 0x000,
+	/* less */
+	0x000, 0x000, 0x000, 0x000, 0x006, 0x01e, 0x078, 0x1e0, 0x780,
+	0x780, 0x1e0, 0x078, 0x01e, 0x006, 0x000, 0x000, 0x000, 0x000,
+	/* greater */
+	0x000, 0x000, 0x000, 0x000, 0x600, 0x780, 0x1e0, 0x078, 0x01e,
+	0x01e, 0x078, 0x1e0, 0x780, 0x600, 0x000, 0x000, 0x000, 0x000,
+	/* backslash */
+	0x000, 0x000, 0x000, 0x000, 0x600, 0x700, 0x380, 0x1c0, 0x0e0,
+	0x070, 0x038, 0x01c, 0x00e, 0x006, 0x000, 0x000, 0x000, 0x000,
+	/* circumflex */
+	0x000, 0x000, 0x000, 0x000, 0x000, 0x060, 0x060, 0x0f0, 0x0f0,
+	0x198, 0x198, 0x30c, 0x30c, 0x000, 0x000, 0x000, 0x000, 0x000,
+	/* bracket left */
+	0x000, 0x000, 0x0f0, 0x0f0, 0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0,
+	0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0c0, 0x0f0, 0x0f0, 0x000, 0x000,
+	/* bracket right */
+	0x000, 0x000, 0x0f0, 0x0f0, 0x030, 0x030, 0x030, 0x030, 0x030,
+	0x030, 0x030, 0x030, 0x030, 0x030, 0x0f0, 0x0f0, 0x000, 0x000,
+};
+
+
+void program_ramchar(int channel, unsigned char color, int index, 
+	unsigned short bitmap[])
+{
+	unsigned short buffer[19];
+	int i;
+
+	buffer[0] = 0x200 + 0x020 * index;
+	for (i = 0; i < 18; i++) {
+		buffer[i + 1] = (color << 12) | (bitmap[i] & 0x0fff);
+	}
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_open(channel + 1);
+	cyc_cpm_spi_osd_write(channel + 1, buffer, 19); 
+	cyc_cpm_spi_close(channel + 1);
+#else
+	select_osdport(channel);
+	m35075_send_buffer(buffer, 19);
+#endif
+}	
+
+void program_all_ramchars(int channel, unsigned char color)
+{
+	int i;
+	for(i = 0; i < 8; i++)
+		program_ramchar(channel, color, i, &(ramchars[i*18]));
+}
+
+/******************************************************************************
+ * m35075_setup - Initialize the OSD
+ *****************************************************************************/
+#define OSD_VSIZE	18 * 12
+#define OSD_HSIZE	12 * 24
+void m35075_setup(int channel, unsigned short hres, unsigned short vres, 
+	unsigned short freq, unsigned char hpol, unsigned char vpol, 
+	unsigned short htotal, unsigned short vtotal, 
+	unsigned short hpos, unsigned short vpos)
+{
+	struct m35075_t *p_m35075 = &m35075[channel];
+	unsigned int hfreq, idx, dotsize;
+	unsigned int hspeed, hdiv;
+	unsigned short buffer[12];
+
+printk("m35075_setup %dx%d@%d\n", hres, vres, freq);
+	p_m35075->polv = vpol;
+	p_m35075->polh = hpol;
+
+	/* the screen should occupy less than 60% of the screen. Based 
+	on that, calculate the dot size */
+	dotsize = (vres * 6) / (OSD_VSIZE * 10);
+	if (dotsize < 1) {
+		dotsize = 1;
+	}
+	if (dotsize > 4) {
+		dotsize = 4;
+	}
+	
+	/* Calculate the horizontal divider */
+	hdiv = htotal / dotsize;
+	
+	/* Calculate the pixel frequency */
+	hfreq = freq * vtotal * hdiv;
+	if (hfreq < 23000000L) {
+		hspeed = 0x04;
+	} else if (hfreq < 24500000L) {
+		hspeed = 0x0c;
+	} else if (hfreq < 30500000L) {
+		hspeed = 0x03;
+	} else if (hfreq < 33500000L) {
+		hspeed = 0x0b;
+	} else if (hfreq < 36500000L) {
+		hspeed = 0x1b;
+	} else if (hfreq < 45500000L) {
+		hspeed = 0x02;
+	} else if (hfreq < 49000000L) {
+		hspeed = 0x0a;
+	} else if (hfreq < 61000000L) {
+		hspeed = 0x01;
+	} else if (hfreq < 66500000L) {
+		hspeed = 0x09;
+	} else if (hfreq < 73000000L) {
+		hspeed = 0x19;
+	} else if (hfreq < 92000000L) {
+		hspeed = 0x00;
+	} else if (hfreq < 100000000L) {
+		hspeed = 0x08;
+	} else if (hfreq < 110000000L) {
+		hspeed = 0x18;
+	}
+
+	/* Calculate the position of the OSD at left, center and right */
+	p_m35075->osdhpos[0] = hpos / dotsize;
+	p_m35075->osdhpos[1] = (hpos + hres/2) / dotsize - OSD_HSIZE/2;
+	p_m35075->osdhpos[2] = (hpos + hres) / dotsize - OSD_HSIZE;
+
+	/* Calculate the position of the OSD at top, center and bottom */
+	p_m35075->osdvpos[0] = vpos;
+	p_m35075->osdvpos[1] = vpos + vres/2 - dotsize * OSD_VSIZE/2;
+	p_m35075->osdvpos[2] = vpos + vres - dotsize * OSD_VSIZE;
+
+	idx = 0;
+
+	/* Address */
+	buffer[idx++] = 0x0120;
+
+	/* Data in 0x120 */
+	buffer[idx++] = hdiv;
+
+	/* Data in 0x121 */
+	buffer[idx++] = 0x2000 + hspeed * 0x100 + 0x002b;
+
+	/* Data in 0x122 */
+	buffer[idx++] = 0x01eb;
+
+	/* Data in 0x123 */
+	buffer[idx++] = p_m35075->osdhpos[p_m35075->halign];
+
+	/* Data in 0x124 */
+	buffer[idx++] = p_m35075->osdvpos[p_m35075->valign];
+
+	/* Data in 0x125 */
+	buffer[idx++] = 0;
+
+	/* Data in 0x126 */
+	buffer[idx++] = (dotsize - 1) * 0x1500;
+
+	/* Data in 0x127 */
+	buffer[idx++] = (dotsize - 1) * 0x1500;
+
+	/* Data in 0x128 */
+	buffer[idx++] = 0;
+
+	/* Data in 0x129 */
+	buffer[idx++] = 0x0008 * p_m35075->polv + 0x0010 * p_m35075->polh;
+#ifdef CYOSD_TRACE
+	{
+		int i;
+		printk("m35075_setup[%d]: buffer", channel);
+		for (i = 0; i < idx; i ++) printk(" %04x", buffer[i]);
+		printk("\n");
+	}
+#endif
+
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_open(channel + 1);
+	cyc_cpm_spi_osd_write(channel + 1, buffer, idx); 
+	cyc_cpm_spi_close(p_m35075->idx + 1);
+	/* wait for 20msec */
+	udelay(20000);
+#else
+	select_osdport(channel);
+	m35075_send_buffer(buffer, idx);
+#endif
+
+	if (p_m35075->on) {
+		p_m35075->on = 0;
+		m35075_turnon(channel);
+	}
+}
+
+/******************************************************************************
+ * m35075_write_buffer 
+ *****************************************************************************/
+void m35075_write_buffer(int channel, const char *buf, size_t count)
+{
+	struct m35075_t *p_m35075 = &m35075[channel];
+	unsigned short *ptr = (unsigned short *)buf;
+	int cnt;
+	/* Store the characters in the screen buffer */
+	cnt = (ptr[0] + count/2 <= OSDBUFSIZE) ? count/2 - 1 : 
+		OSDBUFSIZE - ptr[0] - 1;
+	memcpy(&m35075->buffer[ptr[0] + 1], &ptr[1], cnt * 2);
+
+	if (! p_m35075->on) {
+		return;
+	}
+
+#ifdef CYOSD_TRACE
+	{
+		int i;
+		printk("m35075_write[%d]: buffer", channel);
+		for (i = 0; i < count; i ++) printk(" %02x", buf[i]);
+		printk("\n");
+	}
+#endif
+
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_open(channel + 1);
+	cyc_cpm_spi_osd_write(channel + 1, (unsigned short *)buf, 
+		cnt + 1); 
+	cyc_cpm_spi_close(channel + 1);
+#else
+	select_osdport(channel);
+	m35075_send_buffer(ptr, cnt + 1);
+#endif
+}
+
+/******************************************************************************
+ * osd_turnon - 
+ *****************************************************************************/
+void m35075_turnon(int channel)
+{
+	struct m35075_t *p_m35075 = &m35075[channel];
+	unsigned short buffer[3];
+	if (p_m35075->on) {
+		return;
+	}
+	p_m35075->buffer[0] = 0;
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_open(channel + 1);
+	cyc_cpm_spi_osd_write(channel + 1, p_m35075->buffer, 0x121);
+#else
+	select_osdport(channel);
+	m35075_send_buffer(p_m35075->buffer, 0x121);
+#endif
+	buffer[0] = 0x0123;
+	buffer[1] = p_m35075->osdhpos[p_m35075->halign];
+	buffer[2] = p_m35075->osdvpos[p_m35075->valign];
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_osd_write(channel + 1, buffer, 3);
+	udelay(20000);
+#else
+	m35075_send_buffer(buffer, 3);
+#endif
+	buffer[0] = 0x0129;
+	buffer[1] = 0x1400 + 0x0008 * p_m35075->polv + 0x0010 * 
+		p_m35075->polh + ((p_m35075->transparent)? 0x0020 : 0x0060);
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_osd_write(p_m35075->idx + 1, buffer, 2);
+	cyc_cpm_spi_close(p_m35075->idx + 1);
+#else
+	m35075_send_buffer(buffer, 2);
+#endif
+	p_m35075->on = 1;
+}
+
+/******************************************************************************
+ * m35075_turnoff - 
+ *****************************************************************************/
+void m35075_turnoff(int channel)
+{
+	struct m35075_t *p_m35075 = &m35075[channel];
+	unsigned short buffer[2];
+	if (! p_m35075->on) {
+		return;
+	}
+	buffer[0] = 0x0129;
+	buffer[1] = 0x0008 * p_m35075->polv + 0x0010 * p_m35075->polh;
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_open(p_m35075->idx + 1);
+	cyc_cpm_spi_osd_write(p_m35075->idx + 1, buffer, 2);
+	cyc_cpm_spi_close(p_m35075->idx + 1);
+#else
+	select_osdport(channel);
+	m35075_send_buffer(buffer, 2);
+#endif
+	/* Clean the OSD screen */
+	p_m35075->on = 0;
+}
+
+/******************************************************************************
+ * m35075_setalign - 
+ *****************************************************************************/
+void m35075_setalign(int channel, unsigned char halign, unsigned char valign)
+{
+	struct m35075_t *p_m35075 = &m35075[channel];
+	unsigned short buffer[3];
+	if (halign < 3)	{
+		p_m35075->halign = halign;
+	}
+	if (valign < 3) {
+		p_m35075->valign = valign;
+	}
+	if (! p_m35075->on) {
+		return;
+	}
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_open(channel + 1);
+#else
+	select_osdport(channel);
+#endif
+	buffer[0] = 0x0123;
+	buffer[1] = p_m35075->osdhpos[p_m35075->halign];
+	buffer[2] = p_m35075->osdvpos[p_m35075->valign];
+
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_osd_write(channel + 1, buffer, 3);
+	udelay(20000);
+#else
+	m35075_send_buffer(buffer, 3);
+#endif
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_close(channel + 1);
+#endif
+}
+
+/******************************************************************************
+ * m35075_transparenton - 
+ *****************************************************************************/
+void m35075_transparenton(int channel)
+{
+	struct m35075_t *p_m35075 = &m35075[channel];
+	unsigned short buffer[2];
+	p_m35075->transparent = 1;
+	if (! p_m35075->on) {
+		return;
+	}
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_open(channel + 1);
+#else
+	select_osdport(channel);
+#endif
+	buffer[0] = 0x0129;
+	buffer[1] = 0x1420 + 0x0008 * p_m35075->polv + 0x0010 * p_m35075->polh;
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_osd_write(channel + 1, buffer, 2);
+	udelay(20000);
+#else
+	m35075_send_buffer(buffer, 2);
+#endif
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_close(channel + 1);
+#endif
+}
+
+/******************************************************************************
+ * m35075_transparentoff - 
+ *****************************************************************************/
+void m35075_transparentoff(int channel)
+{
+	struct m35075_t *p_m35075 = &m35075[channel];
+	unsigned short buffer[2];
+	p_m35075->transparent = 0;
+	if (! p_m35075->on) {
+		return;
+	}
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_open(channel + 1);
+#else
+	select_osdport(channel);
+#endif
+	buffer[0] = 0x0129;
+	buffer[1] = 0x1460 + 0x0008 * p_m35075->polv + 0x0010 * p_m35075->polh;
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_osd_write(channel + 1, buffer, 2);
+	udelay(20000);
+#else
+	m35075_send_buffer(buffer, 2);
+#endif
+#ifdef CONFIG_CYCSPI
+	cyc_cpm_spi_close(channel + 1);
+#endif
+}
+
+/******************************************************************************
+ * m35075_init - 
+ *****************************************************************************/
+void m35075_init(int channel)
+{
+	struct m35075_t *p_m35075 = &m35075[channel];
+	int idx;
+	p_m35075->transparent = 0;
+	p_m35075->halign = 1;
+	p_m35075->valign = 1;
+	p_m35075->on = 0;
+	for (idx = 0; idx < OSDBUFSIZE; idx ++) {
+		p_m35075->buffer[idx] = 0;
+	}
+	/* Set up PA30 */
+#ifdef CYOSD_DEBUG
+	printk("osd_open [%d]: resetting the OSD device\n", channel);
+#endif
+#if defined(CONFIG_Alterpath_KVMMAX) || defined(CONFIG_Alterpath_KVMMAXV2)
+	cyc_reset_osd();
+#endif
+}
+
+/******************************************************************************
+ * m35075_getscreen - 
+ *****************************************************************************/
+void m35075_getscreen(int channel, unsigned short *buffer)
+{
+	memcpy(buffer, m35075[channel].buffer, OSDBUFSIZE * 2);
+}
+
+/******************************************************************************
+ * m35075_status - 
+ *****************************************************************************/
+unsigned char m35075_status(int channel)
+{
+	return m35075[channel].on;
+}
diff -ruNp linux-2.6.16/drivers/i2c/chips/m41t00.c kvmmax/drivers/i2c/chips/m41t00.c
--- linux-2.6.16/drivers/i2c/chips/m41t00.c	2006-03-20 18:07:11.000000000 +1100
+++ kvmmax/drivers/i2c/chips/m41t00.c	2006-04-24 16:31:10.000000000 +1000
@@ -21,6 +21,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
+#include <linux/workqueue.h>
 #include <linux/i2c.h>
 #include <linux/rtc.h>
 #include <linux/bcd.h>
@@ -146,7 +147,8 @@ m41t00_set_tlet(ulong arg)
 
 static ulong	new_time;
 
-DECLARE_TASKLET_DISABLED(m41t00_tasklet, m41t00_set_tlet, (ulong)&new_time);
+//DECLARE_TASKLET_DISABLED(m41t00_tasklet, m41t00_set_tlet, (ulong)&new_time);
+DECLARE_WORK(m41t00_work, m41t00_set_tlet, (ulong)&new_time);
 
 int
 m41t00_set_rtc_time(ulong nowtime)
@@ -154,7 +156,7 @@ m41t00_set_rtc_time(ulong nowtime)
 	new_time = nowtime;
 
 	if (in_interrupt())
-		tasklet_schedule(&m41t00_tasklet);
+		schedule_work(&m41t00_work);
 	else
 		m41t00_set_tlet((ulong)&new_time);
 
@@ -205,7 +207,7 @@ m41t00_detach(struct i2c_client *client)
 
 	if ((rc = i2c_detach_client(client)) == 0) {
 		kfree(client);
-		tasklet_kill(&m41t00_tasklet);
+		destroy_workqueue(&m41t00_work);
 	}
 	return rc;
 }
diff -ruNp linux-2.6.16/drivers/i2c/chips/Makefile kvmmax/drivers/i2c/chips/Makefile
--- linux-2.6.16/drivers/i2c/chips/Makefile	2006-03-20 18:07:11.000000000 +1100
+++ kvmmax/drivers/i2c/chips/Makefile	2006-04-24 16:31:10.000000000 +1000
@@ -11,6 +11,9 @@ obj-$(CONFIG_SENSORS_PCA9539)	+= pca9539
 obj-$(CONFIG_SENSORS_PCF8574)	+= pcf8574.o
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_SENSORS_RTC8564)	+= rtc8564.o
+obj-$(CONFIG_SENSORS_DAC5574)	+= dac5574.o
+obj-$(CONFIG_SENSORS_M35075)	+= m35075.o
+obj-$(CONFIG_Alterpath_KVMMAX)	+= pca9548.o
 obj-$(CONFIG_ISP1301_OMAP)	+= isp1301_omap.o
 obj-$(CONFIG_TPS65010)		+= tps65010.o
 obj-$(CONFIG_RTC_X1205_I2C)	+= x1205.o
diff -ruNp linux-2.6.16/drivers/i2c/chips/pca9548.c kvmmax/drivers/i2c/chips/pca9548.c
--- linux-2.6.16/drivers/i2c/chips/pca9548.c	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/drivers/i2c/chips/pca9548.c	2006-04-24 16:31:10.000000000 +1000
@@ -0,0 +1,169 @@
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/param.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+
+/* Routines for the DAC5574 driver */
+
+struct i2c_client *pca_client = NULL;
+static int pca_attach(struct i2c_adapter *adap);
+static int pca_detach(struct i2c_client *client);
+static int pca_command(struct i2c_client *client, unsigned int cmd, void *arg);
+
+static struct i2c_driver pca_driver = {
+	name:		"PCA9548_I2C",
+	id:		I2C_DRIVERID_PCA9548,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	pca_attach,
+	detach_client:	pca_detach,
+	command:	pca_command
+};
+
+static int pca_attach(struct i2c_adapter *adap)
+{
+	pca_client = (struct i2c_client *)kmalloc(sizeof(*pca_client), 
+		GFP_KERNEL);
+
+	if (!pca_client) {
+		return -ENOMEM;
+	}
+
+	memset(pca_client, 0, sizeof(struct i2c_client));
+	strcpy(pca_client->name, "PCA-I2C");
+	pca_client->flags	= 0;
+	pca_client->addr	= 0x70;
+	pca_client->adapter	= adap;
+	pca_client->driver	= &pca_driver;
+
+	return i2c_attach_client(pca_client);
+}
+
+static int pca_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+	kfree(client);
+	return 0;
+}
+
+static int pca_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return 0;
+}
+static unsigned char pca_channel_mask = 0;
+
+int pca_add_channel(unsigned char channel)
+{
+	unsigned char addr[1];
+	struct i2c_msg msgs[1] = {{ 0, 0, 1, addr }};
+	int ret = -EIO;
+
+	if (pca_client == NULL) {
+		return -EIO;
+	}
+	if (channel >= 8) {
+		return -EIO;
+	}
+	pca_channel_mask |= (1 << channel);
+	addr[0] = pca_channel_mask;
+	msgs[0].addr = pca_client->addr;
+	ret = i2c_transfer(pca_client->adapter, msgs, 1);
+
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		ret = -EIO;
+	}
+	return ret;
+}
+
+int pca_remove_channel(unsigned char channel)
+{
+	unsigned char addr[1];
+	struct i2c_msg msgs[1] = {{ 0, 0, 1, addr }};
+	int ret = -EIO;
+
+	if (pca_client == NULL) {
+		return -EIO;
+	}
+	if (channel >= 4) {
+		return -EIO;
+	}
+	pca_channel_mask &= (~(1 << channel));
+	addr[0] = pca_channel_mask;
+	msgs[0].addr = pca_client->addr;
+	ret = i2c_transfer(pca_client->adapter, msgs, 1);
+
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		ret = -EIO;
+	}
+	return ret;
+}
+
+unsigned char pca_get_channels(void)
+{
+	return pca_channel_mask;
+}
+
+int pca_set_channels(unsigned char channels)
+{
+	unsigned char addr[1];
+	struct i2c_msg msgs[1] = {{ 0, 0, 1, addr }};
+	int ret = -EIO;
+
+	if (pca_client == NULL) {
+		return -EIO;
+	}
+	pca_channel_mask = channels;
+	addr[0] = pca_channel_mask;
+	msgs[0].addr = pca_client->addr;
+	ret = i2c_transfer(pca_client->adapter, msgs, 1);
+
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		ret = -EIO;
+	}
+	return ret;
+}
+
+static __initdata int pca_initialized = 0;
+
+static __init int pca_cleanup(void)
+{
+	int err;
+	if (pca_initialized == 1) {
+		err = i2c_del_driver(&pca_driver);
+		if (err) {
+			printk("pca9598.o: Register I2C driver failed, "
+				"errno is %d\n"	,err);
+			return err;
+		}
+	}
+	pca_initialized --;
+	return 0;
+}
+
+static __init int pca_i2c_init(void)
+{
+	int err;
+
+	printk("pca9598.o: PCA9598 I2C based driver.\n");
+	err = i2c_add_driver(&pca_driver);
+	if (err) {
+		printk("pca9598.o: Register I2C driver failed, errno is %d\n"
+			,err);
+		pca_cleanup();
+		return err;
+	}
+	pca_initialized ++;
+	return 0;
+}
+
+__initcall(pca_i2c_init);
diff -ruNp linux-2.6.16/drivers/ide/cyc-ide.c kvmmax/drivers/ide/cyc-ide.c
--- linux-2.6.16/drivers/ide/cyc-ide.c	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/drivers/ide/cyc-ide.c	2006-04-24 16:31:12.000000000 +1000
@@ -0,0 +1,92 @@
+/* -*- linux-c -*- */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/ioport.h>
+#include <linux/hdreg.h>
+#include <linux/major.h>
+#include <linux/ide.h>
+ 
+#include <asm/pgtable.h>
+#include <asm/io.h>
+#include <linux/blkdev.h>
+#include <asm/system.h>
+
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <asm/mpc85xx.h>
+ 
+MODULE_LICENSE("GPL");
+
+static
+void cyc_ide_init_hwif_ports(hw_regs_t *hw,
+			     unsigned long data_port,
+			     unsigned long ctrl_port, int *irq)
+{
+	unsigned long reg = data_port;
+	int     i;
+
+	/* Access to the CF is endian reverted, moreover
+	   every second byte is omitted. That's why we
+           have this weird order. The data register gets
+	   special treatment by calling ide_fix_driveid
+	   a 2nd time, and with setting bswap. */
+
+	hw->io_ports[IDE_DATA_OFFSET] = reg;
+	reg += 3;	
+	for (i = IDE_DATA_OFFSET+1; i <= IDE_STATUS_OFFSET; i++){
+		hw->io_ports[i] = reg;
+		reg += 2;
+	}
+	hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+
+	if (irq != NULL)
+		*irq = 0;
+}
+
+int init_cyc_ide(void)
+{
+	unsigned long addr = cyc_get_cfaddr() - _IO_BASE;
+	hw_regs_t hw;
+	int ret;
+	ide_hwif_t *hwif;
+
+	memset(&hw, 0, sizeof(hw));
+	hw.irq = cyc_get_ide_CF_irq();
+	hw.dma = NO_DMA;
+
+	/* Reset CF */
+	cyc_reset_ide_CF();
+
+	cyc_ide_init_hwif_ports(&hw, addr, addr+0x1e, NULL);
+	ret = ide_register_hw(&hw, &hwif);
+
+	if(ret >= 0){
+		/* ide_fix_driveid has been done in ide-probe. Unfortunately,
+		   that was wrong - so we have to revert that here.
+		   This is a waste of CPU cycles - but it's done only once. */
+		/* internal CF needs this, although PCMCIA CF does not. */
+		hwif->drives[0].bswap = 1;
+	}
+
+	printk(KERN_INFO "cyc-ide: addr: %8x IRQ: %d ret: %d\n", addr, hw.irq, ret);
+	return ret;
+}
+
+void exit_cyc_ide(void)
+{
+
+}
+
+#ifdef MODULE
+module_init(init_cyc_ide);
+module_exit(exit_cyc_ide);
+#endif
+ 
diff -ruNp linux-2.6.16/drivers/ide/ide.c kvmmax/drivers/ide/ide.c
--- linux-2.6.16/drivers/ide/ide.c	2006-03-20 18:07:11.000000000 +1100
+++ kvmmax/drivers/ide/ide.c	2006-04-24 16:31:10.000000000 +1000
@@ -1776,6 +1776,7 @@ done:
 
 extern void pnpide_init(void);
 extern void h8300_ide_init(void);
+extern void init_cyc_ide(void);
 
 /*
  * probe_for_hwifs() finds/initializes "known" IDE interfaces
@@ -1840,6 +1841,9 @@ static void __init probe_for_hwifs (void
 #ifdef CONFIG_H8300
 	h8300_ide_init();
 #endif
+#if defined CONFIG_BLK_DEV_CYC_IDE
+	init_cyc_ide();
+#endif /* CONFIG_BLK_DEV_CYC_IDE */
 }
 
 void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
diff -ruNp linux-2.6.16/drivers/ide/ide-probe.c kvmmax/drivers/ide/ide-probe.c
--- linux-2.6.16/drivers/ide/ide-probe.c	2006-03-20 18:07:11.000000000 +1100
+++ kvmmax/drivers/ide/ide-probe.c	2006-04-24 16:31:11.000000000 +1000
@@ -146,7 +146,7 @@ static inline void do_identify (ide_driv
 
 	drive->id_read = 1;
 	local_irq_enable();
-	ide_fix_driveid(id);
+	//ide_fix_driveid(id);
 
 #if defined (CONFIG_SCSI_EATA_DMA) || defined (CONFIG_SCSI_EATA_PIO) || defined (CONFIG_SCSI_EATA)
 	/*
diff -ruNp linux-2.6.16/drivers/ide/Kconfig kvmmax/drivers/ide/Kconfig
--- linux-2.6.16/drivers/ide/Kconfig	2006-03-20 18:07:11.000000000 +1100
+++ kvmmax/drivers/ide/Kconfig	2006-04-24 16:31:11.000000000 +1000
@@ -61,6 +61,14 @@ config IDE_MAX_HWIFS
 	  be supported by the driver. Make sure it is at least as high as
 	  the number of IDE interfaces in your system.
 
+config BLK_DEV_CYC_IDE
+	tristate "Cyclades ACS IDE support"
+	depends on ALTERPATH
+	default n
+	help
+	  This option enable support for File System in builtin IDE CF.
+	  It requires u-boot.
+
 config BLK_DEV_IDE
 	tristate "Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support"
 	---help---
diff -ruNp linux-2.6.16/drivers/ide/Makefile kvmmax/drivers/ide/Makefile
--- linux-2.6.16/drivers/ide/Makefile	2006-03-20 18:07:11.000000000 +1100
+++ kvmmax/drivers/ide/Makefile	2006-04-24 16:31:11.000000000 +1000
@@ -26,6 +26,8 @@ ide-core-$(CONFIG_BLK_DEV_IDEPNP)	+= ide
 # built-in only drivers from arm/
 ide-core-$(CONFIG_IDE_ARM)		+= arm/ide_arm.o
 
+ide-core-$(CONFIG_BLK_DEV_CYC_IDE) += cyc-ide.o
+
 # built-in only drivers from legacy/
 ide-core-$(CONFIG_BLK_DEV_BUDDHA)	+= legacy/buddha.o
 ide-core-$(CONFIG_BLK_DEV_FALCON_IDE)	+= legacy/falconide.o
diff -ruNp linux-2.6.16/drivers/mtd/maps/cyclades.c kvmmax/drivers/mtd/maps/cyclades.c
--- linux-2.6.16/drivers/mtd/maps/cyclades.c	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/drivers/mtd/maps/cyclades.c	2006-04-26 11:51:25.000000000 +1000
@@ -0,0 +1,104 @@
+/*
+ * drivers/mtd/maps/debmax.c
+ * 
+ * Mapping for Cyclades OnSite and KVM/netMAX user flash
+ *
+ * Author: source@mvista.com
+ *
+ * 2004 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_Alterpath_KVMMAXV2
+#define FLASH_BASE_ADDR		0xffc00000
+#define FLASH_SIZE		0x00400000
+#else
+#define FLASH_BASE_ADDR		0xff800000
+#define FLASH_SIZE		0x00800000
+#endif
+
+static struct mtd_info *flash;
+
+static struct map_info debmax_map = {
+	.name =		"OnSite/KVMMAX flash",
+	.size =		FLASH_SIZE,
+	.bankwidth =	2,
+	.phys = 	FLASH_BASE_ADDR,
+};
+
+static struct mtd_partition debmax_partitions[] = {
+	{
+		.name =   "misc",
+		.offset = 0,
+		.size =   FLASH_SIZE - 0x000a0000,
+		.mask_flags = MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+		.name =   "env",
+		.offset = FLASH_SIZE - 0x000a0000,
+		.size =   0x00020000,
+//		.mask_flags = MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+		.name =   "uboot",
+		.offset = FLASH_SIZE - 0x00080000,
+		.size =   0x00080000,
+//		.mask_flags = MTD_WRITEABLE,  /* force read-only */
+	}
+};
+
+int __init init_debmax(void)
+{
+	debmax_map.virt =
+		(void __iomem *)ioremap(FLASH_BASE_ADDR, debmax_map.size);
+
+	if (!debmax_map.virt) {
+		printk(KERN_NOTICE "Failed to ioremap flash\n");
+		return -EIO;
+	}
+
+	simple_map_init(&debmax_map);
+
+	flash = do_map_probe("cfi_probe", &debmax_map);
+	if (flash) {
+		flash->owner = THIS_MODULE;
+		add_mtd_partitions(flash, debmax_partitions,
+					ARRAY_SIZE(debmax_partitions));
+	} else {
+		printk(KERN_NOTICE "map probe failed for flash\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_debmax(void)
+{
+	if (flash) {
+		del_mtd_partitions(flash);
+		map_destroy(flash);
+	}
+
+	if (debmax_map.virt) {
+		iounmap((void *)debmax_map.virt);
+		debmax_map.virt = 0;
+	}
+}
+
+module_init(init_debmax);
+module_exit(cleanup_debmax);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("<source@mvista.com>");
+MODULE_DESCRIPTION("MTD map and partitions for the Cyclades OnBoard and KVM/netMAX");
diff -ruNp linux-2.6.16/drivers/mtd/maps/Kconfig kvmmax/drivers/mtd/maps/Kconfig
--- linux-2.6.16/drivers/mtd/maps/Kconfig	2006-03-20 18:07:15.000000000 +1100
+++ kvmmax/drivers/mtd/maps/Kconfig	2006-04-26 11:51:25.000000000 +1000
@@ -631,5 +631,8 @@ config MTD_PLATRAM
 
 	  This selection automatically selects the map_ram driver.
 
+config MTD_Alterpath
+	bool "Flash mapped for the Alterpath KVM MAX product line"
+	depends on MTD && ( Alterpath_KVMMAX || Alterpath_KVMMAXV2 )
 endmenu
 
diff -ruNp linux-2.6.16/drivers/mtd/maps/Makefile kvmmax/drivers/mtd/maps/Makefile
--- linux-2.6.16/drivers/mtd/maps/Makefile	2006-03-20 18:07:15.000000000 +1100
+++ kvmmax/drivers/mtd/maps/Makefile	2006-04-24 16:31:11.000000000 +1000
@@ -71,3 +71,4 @@ obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
 obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
+obj-$(CONFIG_MTD_Alterpath)	+= cyclades.o
diff -ruNp linux-2.6.16/drivers/serial/8250.c kvmmax/drivers/serial/8250.c
--- linux-2.6.16/drivers/serial/8250.c	2006-03-20 18:07:21.000000000 +1100
+++ kvmmax/drivers/serial/8250.c	2006-04-26 11:51:25.000000000 +1000
@@ -1075,6 +1075,12 @@ static void serial8250_stop_tx(struct ua
 
 	__stop_tx(up);
 
+	if (port->flags & UPF_LEGACY_RTS) {
+		/* Turn off RTS to stop transmission */
+		up->mcr &= ~UART_MCR_RTS;
+		serial_out(up, UART_MCR, up->mcr);
+	}
+
 	/*
 	 * We really want to stop the transmitter from sending.
 	 */
@@ -1091,6 +1097,11 @@ static void serial8250_start_tx(struct u
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
 	if (!(up->ier & UART_IER_THRI)) {
+		if (port->flags & UPF_LEGACY_RTS) {
+			/* Turn on RTS to start transmission */
+			up->mcr |= UART_MCR_RTS;
+                        serial_out(up, UART_MCR, up->mcr);
+		}
 		up->ier |= UART_IER_THRI;
 		serial_out(up, UART_IER, up->ier);
 
@@ -1222,7 +1233,21 @@ static void transmit_chars(struct uart_8
 		return;
 	}
 	if (uart_circ_empty(xmit)) {
+		if (up->port.flags & UPF_LEGACY_RTS) {
+			/* Enable interrupt when transmission has not 
+			finished yet */
+			if (! (serial_inp(up, UART_LSR) &  UART_LSR_TEMT)) {
+				up->ier |= UART_IER_THRI;
+				serial_out(up, UART_IER, up->ier);
+				return;
+			}
+		}
 		__stop_tx(up);
+		if (up->port.flags & UPF_LEGACY_RTS) {
+			/* Turn off RTS when transmission was finished */
+			up->mcr &= ~UART_MCR_RTS;
+			serial_out(up, UART_MCR, up->mcr);
+		}
 		return;
 	}
 
@@ -1240,8 +1265,23 @@ static void transmit_chars(struct uart_8
 
 	DEBUG_INTR("THRE...");
 
-	if (uart_circ_empty(xmit))
+	if (uart_circ_empty(xmit)) {
+		if (up->port.flags & UPF_LEGACY_RTS) {
+			/* Enable interrupt when transmission has not 
+			finished yet */
+			if (! (serial_inp(up, UART_LSR) &  UART_LSR_TEMT)) {
+				up->ier |= UART_IER_THRI;
+				serial_out(up, UART_IER, up->ier);
+				return;
+			}
+		}
+		if (up->port.flags & UPF_LEGACY_RTS) {
+			/* Turn off RTS when transmission was finished */
+			up->mcr &= ~UART_MCR_RTS;
+			serial_out(up, UART_MCR, up->mcr);
+		}
 		__stop_tx(up);
+	}
 }
 
 static unsigned int check_modem_status(struct uart_8250_port *up)
@@ -1463,22 +1503,39 @@ static unsigned int serial8250_get_mctrl
 static void serial8250_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
-	unsigned char mcr = 0;
+	unsigned char mcr = up->mcr;
 
-	if (mctrl & TIOCM_RTS)
-		mcr |= UART_MCR_RTS;
-	if (mctrl & TIOCM_DTR)
+	if (!(port->flags & UPF_LEGACY_RTS)) {
+		if (mctrl & TIOCM_RTS) {
+			mcr |= UART_MCR_RTS;
+		} else {
+			mcr &= ~UART_MCR_RTS;
+		}
+	}
+	if (mctrl & TIOCM_DTR) {
 		mcr |= UART_MCR_DTR;
-	if (mctrl & TIOCM_OUT1)
+	} else {
+		mcr &= ~UART_MCR_DTR;
+	}
+	if (mctrl & TIOCM_OUT1) {
 		mcr |= UART_MCR_OUT1;
-	if (mctrl & TIOCM_OUT2)
+	} else {
+		mcr &= ~UART_MCR_OUT1;
+	}
+	if (mctrl & TIOCM_OUT2) {
 		mcr |= UART_MCR_OUT2;
-	if (mctrl & TIOCM_LOOP)
+	} else {
+		mcr &= ~UART_MCR_OUT2;
+	}
+	if (mctrl & TIOCM_LOOP) {
 		mcr |= UART_MCR_LOOP;
+	} else {
+		mcr &= ~UART_MCR_LOOP;
+	}
 
-	mcr = (mcr & up->mcr_mask) | up->mcr_force | up->mcr;
+	up->mcr = (mcr & up->mcr_mask) | up->mcr_force;
 
-	serial_out(up, UART_MCR, mcr);
+	serial_out(up, UART_MCR, up->mcr);
 }
 
 static void serial8250_break_ctl(struct uart_port *port, int break_state)
diff -ruNp linux-2.6.16/fs/proc/proc_misc.c kvmmax/fs/proc/proc_misc.c
--- linux-2.6.16/fs/proc/proc_misc.c	2006-03-20 18:07:26.000000000 +1100
+++ kvmmax/fs/proc/proc_misc.c	2006-04-26 11:51:25.000000000 +1000
@@ -68,7 +68,7 @@ extern int get_exec_domain_list(char *);
 extern int get_dma_list(char *);
 extern int get_locks_status (char *, char **, off_t, int);
 
-static int proc_calc_metrics(char *page, char **start, off_t off,
+int proc_calc_metrics(char *page, char **start, off_t off,
 				 int count, int *eof, int len)
 {
 	if (len <= off+count) *eof = 1;
@@ -239,6 +239,9 @@ static int version_read_proc(char *page,
 	int len;
 
 	strcpy(page, linux_banner);
+#ifdef CONFIG_ALTERPATH
+	strcat(page, cyc_get_version());
+#endif
 	len = strlen(page);
 	return proc_calc_metrics(page, start, off, count, eof, len);
 }
diff -ruNp linux-2.6.16/include/asm-powerpc/irq.h kvmmax/include/asm-powerpc/irq.h
--- linux-2.6.16/include/asm-powerpc/irq.h	2006-03-20 18:07:36.000000000 +1100
+++ kvmmax/include/asm-powerpc/irq.h	2006-04-24 16:31:11.000000000 +1000
@@ -324,20 +324,20 @@ extern u64 ppc64_interrupt_controller;
 #define	SIU_INT_SCC2		((uint)0x29+CPM_IRQ_OFFSET)
 #define	SIU_INT_SCC3		((uint)0x2a+CPM_IRQ_OFFSET)
 #define	SIU_INT_SCC4		((uint)0x2b+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC15		((uint)0x30+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC14		((uint)0x31+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC13		((uint)0x32+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC12		((uint)0x33+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC11		((uint)0x34+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC10		((uint)0x35+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC9		((uint)0x36+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC8		((uint)0x37+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC7		((uint)0x38+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC6		((uint)0x39+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC5		((uint)0x3a+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC4		((uint)0x3b+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC3		((uint)0x3c+CPM_IRQ_OFFSET)
-#define	SIU_INT_PC2		((uint)0x3d+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC29		((uint)0x30+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC23		((uint)0x31+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC15		((uint)0x32+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC14		((uint)0x33+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC13		((uint)0x34+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC12		((uint)0x35+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC11		((uint)0x36+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC10		((uint)0x37+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC9		((uint)0x38+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC8		((uint)0x39+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC7		((uint)0x3a+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC6		((uint)0x3b+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC5		((uint)0x3c+CPM_IRQ_OFFSET)
+#define	SIU_INT_PC4		((uint)0x3d+CPM_IRQ_OFFSET)
 #define	SIU_INT_PC1		((uint)0x3e+CPM_IRQ_OFFSET)
 #define	SIU_INT_PC0		((uint)0x3f+CPM_IRQ_OFFSET)
 
diff -ruNp linux-2.6.16/include/asm-powerpc/reg.h kvmmax/include/asm-powerpc/reg.h
--- linux-2.6.16/include/asm-powerpc/reg.h	2006-03-20 18:07:37.000000000 +1100
+++ kvmmax/include/asm-powerpc/reg.h	2006-04-24 16:31:11.000000000 +1000
@@ -102,12 +102,16 @@
 #else /* 32-bit */
 /* Default MSR for kernel mode. */
 #ifndef MSR_KERNEL	/* reg_booke.h also defines this */
-#ifdef CONFIG_APUS_FAST_EXCEPT
+#ifdef CONFIG_BDI_SWITCH
+#define MSR_KERNEL	(MSR_DE|MSR_ME|MSR_RI|MSR_IR|MSR_DR)
+#else
+#if defined(CONFIG_APUS_FAST_EXCEPT)
 #define MSR_KERNEL	(MSR_ME|MSR_IP|MSR_RI|MSR_IR|MSR_DR)
 #else
 #define MSR_KERNEL	(MSR_ME|MSR_RI|MSR_IR|MSR_DR)
 #endif
 #endif
+#endif
 
 #define MSR_USER	(MSR_KERNEL|MSR_PR|MSR_EE)
 #endif
diff -ruNp linux-2.6.16/include/asm-powerpc/termbits.h kvmmax/include/asm-powerpc/termbits.h
--- linux-2.6.16/include/asm-powerpc/termbits.h	2006-03-20 18:07:37.000000000 +1100
+++ kvmmax/include/asm-powerpc/termbits.h	2006-04-24 16:31:11.000000000 +1000
@@ -119,26 +119,29 @@ struct termios {
 #define  B2400	0000013
 #define  B4800	0000014
 #define  B9600	0000015
-#define  B19200	0000016
-#define  B38400	0000017
+#define  b14400 0000016
+#define  B19200	0000017
+#define  B28800	0000020
+#define  B38400	0000021
 #define  EXTA   B19200
 #define  EXTB   B38400
 #define  CBAUDEX 0000000
-#define  B57600   00020
-#define  B115200  00021
-#define  B230400  00022
-#define  B460800  00023
-#define  B500000  00024
-#define  B576000  00025
-#define  B921600  00026
-#define B1000000  00027
-#define B1152000  00030
-#define B1500000  00031
-#define B2000000  00032
-#define B2500000  00033
-#define B3000000  00034
-#define B3500000  00035
-#define B4000000  00036
+#define  B57600   00022
+#define  B76800   00023
+#define  B115200  00024
+#define  B230400  00025
+#define  B460800  00026
+#define  B500000  00027
+#define  B576000  00030
+#define  B921600  00031
+#define B1000000  00032
+#define B1152000  00033
+#define B1500000  00034
+#define B2000000  00035
+#define B2500000  00036
+#define B3000000  00037
+#define B3500000  00040
+#define B4000000  00041
 
 #define CSIZE	00001400
 #define   CS5	00000000
diff -ruNp linux-2.6.16/include/asm-ppc/cpm2.h kvmmax/include/asm-ppc/cpm2.h
--- linux-2.6.16/include/asm-ppc/cpm2.h	2006-03-20 18:07:37.000000000 +1100
+++ kvmmax/include/asm-ppc/cpm2.h	2006-04-24 16:31:11.000000000 +1000
@@ -603,6 +603,100 @@ typedef struct fcc_param {
 	uint	fcc_tcrc;	/* Tx temp CRC */
 } fccp_t;
 
+/* CPM Parallel IO Ports:
+ *   PA: 24 bits [8:31]
+ *   PB: 14 bits [18:31]
+ *   PC: 28 bits [0:31, NO: 2, 3, 30, 31]
+ *   PD: 16 bits [7, 14:25, 29:31]
+ *
+ * 16 bits in PC can be used for interrupt input pins:
+ *   PC[0:1, 4:15, 23, 29]
+ */
+#define CPM_PA_8           0x00800000
+#define CPM_PA_9           0x00400000
+#define CPM_PA_10          0x00200000
+#define CPM_PA_11          0x00100000
+#define CPM_PA_12          0x00080000
+#define CPM_PA_13          0x00040000
+#define CPM_PA_14          0x00020000
+#define CPM_PA_15          0x00010000
+#define CPM_PA_16          0x00008000
+#define CPM_PA_17          0x00004000
+#define CPM_PA_18          0x00002000
+#define CPM_PA_19          0x00001000
+#define CPM_PA_20          0x00000800
+#define CPM_PA_21          0x00000400
+#define CPM_PA_22          0x00000200
+#define CPM_PA_23          0x00000100
+#define CPM_PA_24          0x00000080
+#define CPM_PA_25          0x00000040
+#define CPM_PA_26          0x00000020
+#define CPM_PA_27          0x00000010
+#define CPM_PA_28          0x00000008
+#define CPM_PA_29          0x00000004
+#define CPM_PA_30          0x00000002
+#define CPM_PA_31          0x00000001
+
+#define CPM_PB_18          0x00002000
+#define CPM_PB_19          0x00001000
+#define CPM_PB_20          0x00000800
+#define CPM_PB_21          0x00000400
+#define CPM_PB_22          0x00000200
+#define CPM_PB_23          0x00000100
+#define CPM_PB_24          0x00000080
+#define CPM_PB_25          0x00000040
+#define CPM_PB_26          0x00000020
+#define CPM_PB_27          0x00000010
+#define CPM_PB_28          0x00000008
+#define CPM_PB_29          0x00000004
+#define CPM_PB_30          0x00000002
+#define CPM_PB_31          0x00000001
+
+#define CPM_PC_0           0x80000000
+#define CPM_PC_1           0x40000000
+#define CPM_PC_4           0x08000000
+#define CPM_PC_5           0x04000000
+#define CPM_PC_6           0x02000000
+#define CPM_PC_7           0x01000000
+#define CPM_PC_8           0x00800000
+#define CPM_PC_9           0x00400000
+#define CPM_PC_10          0x00200000
+#define CPM_PC_11          0x00100000
+#define CPM_PC_12          0x00080000
+#define CPM_PC_13          0x00040000
+#define CPM_PC_14          0x00020000
+#define CPM_PC_15          0x00010000
+#define CPM_PC_16          0x00008000
+#define CPM_PC_17          0x00004000
+#define CPM_PC_18          0x00002000
+#define CPM_PC_19          0x00001000
+#define CPM_PC_20          0x00000800
+#define CPM_PC_21          0x00000400
+#define CPM_PC_22          0x00000200
+#define CPM_PC_23          0x00000100
+#define CPM_PC_24          0x00000080
+#define CPM_PC_25          0x00000040
+#define CPM_PC_26          0x00000020
+#define CPM_PC_27          0x00000010
+#define CPM_PC_28          0x00000008
+#define CPM_PC_29          0x00000004
+
+#define CPM_PD_7           0x01000000
+#define CPM_PD_14          0x00020000
+#define CPM_PD_15          0x00010000
+#define CPM_PD_16          0x00008000
+#define CPM_PD_17          0x00004000
+#define CPM_PD_18          0x00002000
+#define CPM_PD_19          0x00001000
+#define CPM_PD_20          0x00000800
+#define CPM_PD_21          0x00000400
+#define CPM_PD_22          0x00000200
+#define CPM_PD_23          0x00000100
+#define CPM_PD_24          0x00000080
+#define CPM_PD_25          0x00000040
+#define CPM_PD_29          0x00000004
+#define CPM_PD_30          0x00000002
+#define CPM_PD_31          0x00000001
 
 /* Ethernet controller through FCC.
 */
diff -ruNp linux-2.6.16/include/asm-ppc/ppcboot.h kvmmax/include/asm-ppc/ppcboot.h
--- linux-2.6.16/include/asm-ppc/ppcboot.h	2006-03-20 18:07:37.000000000 +1100
+++ kvmmax/include/asm-ppc/ppcboot.h	2006-04-24 16:31:11.000000000 +1000
@@ -70,6 +70,11 @@ typedef struct bd_info {
 	unsigned int	bi_pci_busfreq;	/* PCI Bus speed, in Hz */
 	unsigned char	bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
 #endif
+#if defined(CONFIG_ALTERPATH)
+	unsigned int    bi_pci1_busfreq; /* PCI1 freq */
+	unsigned int    bi_pci2_busfreq; /* PCI2 freq */
+#endif
+#
 #if defined(CONFIG_HYMOD)
 	hymod_conf_t	bi_hymod_conf;	/* hymod configuration information */
 #endif
@@ -94,6 +99,16 @@ typedef struct bd_info {
 	int		bi_phynum[4];		/* phy mapping */
 	int		bi_phymode[4];		/* phy mode */
 #endif
+#ifdef CONFIG_ALTERPATH
+    unsigned char   wdt;
+    unsigned char   mii_operation[2];
+    unsigned char   board_type;
+    unsigned char   board_model;
+    unsigned char   pci;
+    unsigned char   fpga_version;
+    unsigned char   device_id[16];
+    unsigned char   board_ver_rev;
+#endif
 } bd_t;
 
 #define bi_tbfreq	bi_intfreq
diff -ruNp linux-2.6.16/include/linux/dac5574.h kvmmax/include/linux/dac5574.h
--- linux-2.6.16/include/linux/dac5574.h	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/include/linux/dac5574.h	2006-04-24 16:31:11.000000000 +1000
@@ -0,0 +1 @@
+int dac_set_value(unsigned char, unsigned short, unsigned char);
diff -ruNp linux-2.6.16/include/linux/i2c-id.h kvmmax/include/linux/i2c-id.h
--- linux-2.6.16/include/linux/i2c-id.h	2006-03-20 18:07:39.000000000 +1100
+++ kvmmax/include/linux/i2c-id.h	2006-04-24 16:31:11.000000000 +1000
@@ -108,6 +108,8 @@
 #define I2C_DRIVERID_UPD64083	78	/* upd64083 video processor	*/
 #define I2C_DRIVERID_UPD64031A	79	/* upd64031a video processor	*/
 #define I2C_DRIVERID_SAA717X	80	/* saa717x video encoder	*/
+#define I2C_DRIVERID_M35075	81	/* M35075 on-screen display	*/
+#define I2C_DRIVERID_DAC5574	82	/* DAC5574 D/A converter	*/
 
 #define I2C_DRIVERID_I2CDEV	900
 #define I2C_DRIVERID_ARP        902    /* SMBus ARP Client              */
diff -ruNp linux-2.6.16/include/linux/m35075.h kvmmax/include/linux/m35075.h
--- linux-2.6.16/include/linux/m35075.h	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/include/linux/m35075.h	2006-04-24 16:31:11.000000000 +1000
@@ -0,0 +1,23 @@
+#define OSDBUFSIZE	0x121
+#define NUM_RAM_CHARS   8
+
+
+/* External functions */
+extern void program_all_ramchars(int channel, unsigned char color);
+extern void program_ramchar(int channel, unsigned char color, int index, 
+	unsigned short bitmap[]);
+extern void m35075_setup(int channel, unsigned short hres, unsigned short vres, 
+	unsigned short freq, unsigned char hpol, unsigned char vpol, 
+	unsigned short htotal, unsigned short vtotal, 
+	unsigned short hpos, unsigned short vpos);
+extern void m35075_write_buffer(int channel, const char *buf, size_t count);
+extern void m35075_turnon(int channel);
+extern void m35075_turnoff(int channel);
+extern void m35075_setalign(int channel, unsigned char halign, 
+	unsigned char valign);
+extern void m35075_transparenton(int channel);
+extern void m35075_transparentoff(int channel);
+extern void m35075_init(int channel);
+extern void m35075_getscreen(int channel, unsigned short *buffer);
+extern unsigned char m35075_status(int channel);
+
diff -ruNp linux-2.6.16/include/linux/miscdevice.h kvmmax/include/linux/miscdevice.h
--- linux-2.6.16/include/linux/miscdevice.h	2006-03-20 18:07:39.000000000 +1100
+++ kvmmax/include/linux/miscdevice.h	2006-04-24 16:31:11.000000000 +1000
@@ -30,6 +30,8 @@
 #define TUN_MINOR	     200
 #define	HPET_MINOR	     228
 
+#define OSDVIDEO_MINOR		190
+
 struct device;
 struct class_device;
 
diff -ruNp linux-2.6.16/include/linux/pca9548.h kvmmax/include/linux/pca9548.h
--- linux-2.6.16/include/linux/pca9548.h	1970-01-01 10:00:00.000000000 +1000
+++ kvmmax/include/linux/pca9548.h	2006-04-24 16:31:11.000000000 +1000
@@ -0,0 +1,4 @@
+int pca_add_channel(unsigned char);
+int pca_remove_channel(unsigned char);
+unsigned char pca_get_channels();
+int pca_set_channels(unsigned char);
diff -ruNp linux-2.6.16/include/linux/serial_core.h kvmmax/include/linux/serial_core.h
--- linux-2.6.16/include/linux/serial_core.h	2006-03-20 18:07:41.000000000 +1100
+++ kvmmax/include/linux/serial_core.h	2006-04-24 16:31:11.000000000 +1000
@@ -248,6 +248,7 @@ struct uart_port {
 #define UPF_LOW_LATENCY		((__force upf_t) (1 << 13))
 #define UPF_BUGGY_UART		((__force upf_t) (1 << 14))
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
+#define UPF_LEGACY_RTS		((__force upf_t) (1 << 20))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
diff -ruNp linux-2.6.16/init/version.c kvmmax/init/version.c
--- linux-2.6.16/init/version.c	2006-03-20 18:07:42.000000000 +1100
+++ kvmmax/init/version.c	2006-04-24 16:31:11.000000000 +1000
@@ -26,8 +26,14 @@ struct new_utsname system_utsname = {
 	.domainname	= UTS_DOMAINNAME,
 };
 
+#ifdef CONFIG_ALTERPATH
+#define WHAT_STR "@(#)"
+#else
+#define WHAT_STR
+#endif
+
 EXPORT_SYMBOL(system_utsname);
 
-const char linux_banner[] =
+const char linux_banner[] = WHAT_STR
 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
 	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
diff -ruNp linux-2.6.16/Makefile kvmmax/Makefile
--- linux-2.6.16/Makefile	2006-03-20 18:06:54.000000000 +1100
+++ kvmmax/Makefile	2006-04-24 16:31:11.000000000 +1000
@@ -968,8 +968,9 @@ depmod_opts	:= -b $(INSTALL_MOD_PATH) -r
 endif
 .PHONY: _modinst_post
 _modinst_post: _modinst_
+ifeq ($(CROSS_COMPILE),)
 	if [ -r System.map -a -x $(DEPMOD) ]; then $(DEPMOD) -ae -F System.map $(depmod_opts) $(KERNELRELEASE); fi
-
+endif
 else # CONFIG_MODULES
 
 # Modules not configured
