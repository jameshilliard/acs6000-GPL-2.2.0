Index: u-boot-1.2.0/Makefile
===================================================================
--- u-boot-1.2.0.orig/Makefile
+++ u-boot-1.2.0/Makefile
@@ -1181,6 +1181,12 @@ rainier_nand_config:	unconfig
 sbc405_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc ppc4xx sbc405
 
+golden_gate_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx golden_gate avocent
+
+shasta_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx golden_gate avocent
+
 sequoia_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc ppc4xx sequoia amcc
 
Index: u-boot-1.2.0/include/configs/shasta.h
===================================================================
--- /dev/null
+++ u-boot-1.2.0/include/configs/shasta.h
@@ -0,0 +1,2 @@
+#define CONFIG_SHASTA
+#include "golden_gate.h"
Index: u-boot-1.2.0/board/avocent/golden_gate/Makefile
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/Makefile
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2002-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	= $(BOARD).o sdram.o flash.o ../gsp/gsp-config.o
+SOBJS	= init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
Index: u-boot-1.2.0/board/avocent/golden_gate/config.mk
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/config.mk
@@ -0,0 +1,41 @@
+#
+# (C) Copyright 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Avocent Golden Gate (ACS 6000)
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+TEXT_BASE = 0xFFF83000
+endif
+
+PLATFORM_CPPFLAGS += -DCONFIG_440=1
+
+ifeq ($(debug),1)
+PLATFORM_CPPFLAGS += -DDEBUG
+endif
+
+ifeq ($(dbcr),1)
+PLATFORM_CPPFLAGS += -DCFG_INIT_DBCR=0x8cff0000
+endif
Index: u-boot-1.2.0/board/avocent/golden_gate/flash.c
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/flash.c
@@ -0,0 +1,1157 @@
+/*
+ * (C) Copyright 2004-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002 Jun Gu <jung@artesyncp.com>
+ * Add support for Am29F016D and dynamic switch setting.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Modified 4/5/2001
+ * Wait for completion of each sector erase command issued
+ * 4/5/2001
+ * Chris Hallinan - DS4.COM, Inc. - clh@net1plus.com
+ */
+
+#include <common.h>
+#include <ppc4xx.h>
+#include <asm/processor.h>
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static int write_word (flash_info_t * info, ulong dest, ulong data);
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+static int write_word_1 (flash_info_t * info, ulong dest, ulong data);
+static int write_word_2 (flash_info_t * info, ulong dest, ulong data);
+static int flash_erase_1 (flash_info_t * info, int s_first, int s_last);
+static int flash_erase_2 (flash_info_t * info, int s_first, int s_last);
+static ulong flash_get_size_1 (vu_long * addr, int banknum);
+static ulong flash_get_size_2 (vu_long * addr, int banknum);
+#endif
+
+void
+flash_print_info (flash_info_t * info)
+{
+  int i;
+  int k;
+  int size;
+  int erased;
+  volatile unsigned long *flash;
+
+  if (info->flash_id == FLASH_UNKNOWN)
+	{
+	  printf ("missing or unknown FLASH type\n");
+	  return;
+	}
+
+  switch (info->flash_id & FLASH_VENDMASK)
+	{
+	case FLASH_MAN_AMD:
+	  printf ("AMD ");
+	  break;
+	case FLASH_MAN_STM:
+	  printf ("STM ");
+	  break;
+	case FLASH_MAN_FUJ:
+	  printf ("FUJITSU ");
+	  break;
+	case FLASH_MAN_SST:
+	  printf ("SST ");
+	  break;
+	case FLASH_MAN_MX:
+	  printf ("MACRONIX ");
+	  break;
+	default:
+	  printf ("Unknown Vendor ");
+	  break;
+	}
+
+  switch (info->flash_id & FLASH_TYPEMASK)
+	{
+	case FLASH_AM040:
+	  printf ("AM29F040 (512 Kbit, uniform sector size)\n");
+	  break;
+	case FLASH_AM400B:
+	  printf ("AM29LV400B (4 Mbit, bottom boot sect)\n");
+	  break;
+	case FLASH_AM400T:
+	  printf ("AM29LV400T (4 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_AM800B:
+	  printf ("AM29LV800B (8 Mbit, bottom boot sect)\n");
+	  break;
+	case FLASH_AM800T:
+	  printf ("AM29LV800T (8 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_AMD016:
+	  printf ("AM29F016D (16 Mbit, uniform sector size)\n");
+	  break;
+	case FLASH_AM160B:
+	  printf ("AM29LV160B (16 Mbit, bottom boot sect)\n");
+	  break;
+	case FLASH_AM160T:
+	  printf ("AM29LV160T (16 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_AM320B:
+	  printf ("AM29LV320B (32 Mbit, bottom boot sect)\n");
+	  break;
+	case FLASH_AM320T:
+	  printf ("AM29LV320T (32 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_AM033C:
+	  printf ("AM29LV033C (32 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_SST800A:
+	  printf ("SST39LF/VF800 (8 Mbit, uniform sector size)\n");
+	  break;
+	case FLASH_SST160A:
+	  printf ("SST39LF/VF160 (16 Mbit, uniform sector size)\n");
+	  break;
+	case FLASH_SST040:
+	  printf ("SST39VF040 (4 Mbit, uniform sector size)\n");
+	  break;
+	case FLASH_STMW320DT:
+	  printf ("M29W320DT (32 M, top sector)\n");
+	  break;
+	case FLASH_MXLV320T:
+	  printf ("MXLV320T (32 Mbit, top sector)\n");
+	  break;
+	default:
+	  printf ("Unknown Chip Type\n");
+	  break;
+	}
+
+  printf ("  Size: %ld KB in %d Sectors\n",
+		  info->size >> 10, info->sector_count);
+
+for (i = 0; i < info->sector_count; i++) printf("info %p info->start[%d]=%08x\n", info, i, info->start[i]);
+  printf ("  Sector Start Addresses:");
+  for (i = 0; i < info->sector_count; ++i)
+	{
+	  /*
+	   * Check if whole sector is erased
+	   */
+	  if (i != (info->sector_count - 1))
+		size = info->start[i + 1] - info->start[i];
+	  else
+		size = info->start[0] + info->size - info->start[i];
+	  erased = 1;
+	  flash = (volatile unsigned long *) info->start[i];
+	  size = size >> 2;			/* divide by 4 for longword access */
+	  for (k = 0; k < size; k++)
+		{
+		  if (*flash++ != 0xffffffff)
+			{
+			  erased = 0;
+			  break;
+			}
+		}
+
+	  if ((i % 5) == 0)
+		printf ("\n   ");
+	  printf (" %08lX%s%s",
+			  info->start[i],
+			  erased ? " E" : "  ", info->protect[i] ? "RO " : "   ");
+	}
+  printf ("\n");
+  return;
+}
+
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+static ulong flash_get_size (vu_long * addr, int banknum)
+{
+	/* bit 0 used for big flash marking */
+	if ((ulong) addr & 0x1) {
+  		return flash_get_size_2 ((vu_long *) ((ulong) addr & 0xfffffffe), banknum);
+	}
+  	else {
+	  	return flash_get_size_1 (addr, banknum);
+	}
+}
+
+static ulong flash_get_size_1 (vu_long * addr, int banknum)
+#else
+ulong flash_get_size (vu_long * addr, int banknum)
+#endif
+{
+  short i;
+  CFG_FLASH_WORD_SIZE value;
+  ulong base = (ulong) addr;
+  volatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *) addr;
+  flash_info_t *info = &flash_info[banknum];
+
+  debug ("FLASH ADDR: %08x\n", (unsigned) addr);
+
+  /* Write auto select command: read Manufacturer ID */
+  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00900090;
+  udelay (1000);
+
+  value = addr2[0];
+  debug ("FLASH MANUFACT: %x\n", value);
+
+  switch (value)
+	{
+	case (CFG_FLASH_WORD_SIZE) AMD_MANUFACT:
+	  info->flash_id = FLASH_MAN_AMD;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) FUJ_MANUFACT:
+	  info->flash_id = FLASH_MAN_FUJ;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) SST_MANUFACT:
+	  info->flash_id = FLASH_MAN_SST;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) STM_MANUFACT:
+	  info->flash_id = FLASH_MAN_STM;
+	  break;
+	default:
+	  info->flash_id = FLASH_UNKNOWN;
+	  info->sector_count = 0;
+	  info->size = 0;
+	  return (0);				/* no or unknown flash  */
+	}
+
+  value = addr2[1];				/* device ID */
+  debug ("\nFLASH DEVICEID: %x\n", value);
+
+  switch (value)
+	{
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV040B:
+	  info->flash_id += FLASH_AM040;
+	  info->sector_count = 8;
+	  info->size = 0x0080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_F040B:
+	  info->flash_id += FLASH_AM040;
+	  info->sector_count = 8;
+	  info->size = 0x0080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) STM_ID_M29W040B:
+	  info->flash_id += FLASH_AM040;
+	  info->sector_count = 8;
+	  info->size = 0x0080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_F016D:
+	  info->flash_id += FLASH_AMD016;
+	  info->sector_count = 32;
+	  info->size = 0x00200000;	/* => 2 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV033C:
+	  info->flash_id += FLASH_AMDLV033C;
+	  info->sector_count = 64;
+	  info->size = 0x00400000;	/* => 4 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV400T:
+	  info->flash_id += FLASH_AM400T;
+	  info->sector_count = 11;
+	  info->size = 0x00080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV400B:
+	  info->flash_id += FLASH_AM400B;
+	  info->sector_count = 11;
+	  info->size = 0x00080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV800T:
+	  info->flash_id += FLASH_AM800T;
+	  info->sector_count = 19;
+	  info->size = 0x00100000;	/* => 1 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV800B:
+	  info->flash_id += FLASH_AM800B;
+	  info->sector_count = 19;
+	  info->size = 0x00100000;	/* => 1 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV160T:
+	  info->flash_id += FLASH_AM160T;
+	  info->sector_count = 35;
+	  info->size = 0x00200000;	/* => 2 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV160B:
+	  info->flash_id += FLASH_AM160B;
+	  info->sector_count = 35;
+	  info->size = 0x00200000;	/* => 2 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) SST_ID_xF040:
+	  info->flash_id += FLASH_SST040;
+	  info->sector_count = 128;
+	  info->size = 0x00080000;	/* => 512kB */
+	  break;
+
+	default:
+	  info->flash_id = FLASH_UNKNOWN;
+	  return (0);				/* => no or unknown flash */
+	}
+
+  /* set up sector start address table */
+  if (((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM040) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AMD016))
+	{
+	  for (i = 0; i < info->sector_count; i++)
+		info->start[i] = base + (i * (info->size/info->sector_count));
+	}
+  else
+	{
+	  if (info->flash_id & FLASH_BTYPE)
+		{
+		  /* set sector offsets for bottom boot block type */
+		  info->start[0] = base + 0x00000000;
+		  info->start[1] = base + 0x00004000;
+		  info->start[2] = base + 0x00006000;
+		  info->start[3] = base + 0x00008000;
+		  for (i = 4; i < info->sector_count; i++)
+			{
+			  info->start[i] = base + (i * 0x00010000) - 0x00030000;
+			}
+		}
+	  else
+		{
+		  /* set sector offsets for top boot block type */
+		  i = info->sector_count - 1;
+		  info->start[i--] = base + info->size - 0x00004000;
+		  info->start[i--] = base + info->size - 0x00006000;
+		  info->start[i--] = base + info->size - 0x00008000;
+		  for (; i >= 0; i--)
+			{
+			  info->start[i] = base + i * 0x00010000;
+			}
+		}
+	}
+
+  /* check for protected sectors */
+  for (i = 0; i < info->sector_count; i++)
+	{
+	  /* read sector protection at sector address, (A7 .. A0) = 0x02 */
+	  /* D0 = 1 if protected */
+	  addr2 = (volatile CFG_FLASH_WORD_SIZE *) (info->start[i]);
+
+	  /* For AMD29033C flash we need to resend the command of *
+	   * reading flash protection for upper 8 Mb of flash     */
+	  if (i == 32)
+		{
+		  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0xAAAAAAAA;
+		  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x55555555;
+		  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x90909090;
+		}
+
+	  if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)
+		info->protect[i] = 0;
+	  else
+		info->protect[i] = addr2[2] & 1;
+	}
+
+  /* issue bank reset to return to read mode */
+  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;
+
+  return (info->size);
+}
+
+static int
+wait_for_DQ7_1 (flash_info_t * info, int sect)
+{
+  ulong start, now, last;
+  volatile CFG_FLASH_WORD_SIZE *addr =
+	(CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+  start = get_timer (0);
+  last = start;
+  while ((addr[0] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+		 (CFG_FLASH_WORD_SIZE) 0x00800080)
+	{
+	  if ((now = get_timer (start)) > CFG_FLASH_ERASE_TOUT)
+		{
+		  printf ("Timeout\n");
+		  return -1;
+		}
+	  /* show that we're waiting */
+	  if ((now - last) > 1000)
+		{						/* every second */
+		  putc ('.');
+		  last = now;
+		}
+	}
+  return 0;
+}
+
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+int
+flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+  if (((info->flash_id & FLASH_TYPEMASK) == FLASH_AM320B) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM320T) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_MXLV320T) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_STMW320DT))
+	{
+	  return flash_erase_2 (info, s_first, s_last);
+	}
+  else
+	{
+	  return flash_erase_1 (info, s_first, s_last);
+	}
+}
+
+static int
+flash_erase_1 (flash_info_t * info, int s_first, int s_last)
+#else
+int
+flash_erase (flash_info_t * info, int s_first, int s_last)
+#endif
+{
+  volatile CFG_FLASH_WORD_SIZE *addr =
+	(CFG_FLASH_WORD_SIZE *) (info->start[0]);
+  volatile CFG_FLASH_WORD_SIZE *addr2;
+  int flag, prot, sect, l_sect;
+  int i;
+
+
+  if ((s_first < 0) || (s_first > s_last))
+	{
+	  if (info->flash_id == FLASH_UNKNOWN)
+		{
+		  printf ("- missing\n");
+		}
+	  else
+		{
+		  printf ("- no sectors to erase\n");
+		}
+	  return 1;
+	}
+
+  if (info->flash_id == FLASH_UNKNOWN)
+	{
+	  printf ("Can't erase unknown flash type - aborted\n");
+	  return 1;
+	}
+
+  prot = 0;
+  for (sect = s_first; sect <= s_last; ++sect)
+	{
+	  if (info->protect[sect])
+		{
+		  prot++;
+		}
+	}
+
+  if (prot)
+	{
+	  printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	}
+  else
+	{
+	  printf ("\n");
+	}
+
+  l_sect = -1;
+
+  /* Disable interrupts which might cause a timeout here */
+  flag = disable_interrupts ();
+
+  /* Start erase on unprotected sectors */
+  for (sect = s_first; sect <= s_last; sect++)
+	{
+	  if (info->protect[sect] == 0)
+		{						/* not protected */
+		  addr2 = (CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+		  if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST && info->flash_id & FLASH_TYPEMASK != FLASH_SST040)
+			{
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00500050;	/* block erase */
+			  for (i = 0; i < 50; i++)
+				udelay (1000);	/* wait 1 ms */
+			}
+		  else
+			{
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00300030;	/* sector erase */
+			}
+		  l_sect = sect;
+		  /*
+		   * Wait for each sector to complete, it's more
+		   * reliable.  According to AMD Spec, you must
+		   * issue all erase commands within a specified
+		   * timeout.  This has been seen to fail, especially
+		   * if printf()s are included (for debug)!!
+		   */
+		  wait_for_DQ7_1 (info, sect);
+		}
+	}
+
+  /* re-enable interrupts if necessary */
+  if (flag)
+	enable_interrupts ();
+
+  /* wait at least 80us - let's wait 1 ms */
+  udelay (1000);
+
+  /* reset to read mode */
+  addr = (CFG_FLASH_WORD_SIZE *) info->start[0];
+  addr[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;	/* reset bank */
+
+  printf (" done\n");
+  return 0;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int
+write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+  ulong cp, wp, data;
+  int i, l, rc;
+
+  wp = (addr & ~3);				/* get lower word aligned address */
+
+  /*
+   * handle unaligned start bytes
+   */
+  if ((l = addr - wp) != 0)
+	{
+	  data = 0;
+	  for (i = 0, cp = wp; i < l; ++i, ++cp)
+		{
+		  data = (data << 8) | (*(uchar *) cp);
+		}
+	  for (; i < 4 && cnt > 0; ++i)
+		{
+		  data = (data << 8) | *src++;
+		  --cnt;
+		  ++cp;
+		}
+	  for (; cnt == 0 && i < 4; ++i, ++cp)
+		{
+		  data = (data << 8) | (*(uchar *) cp);
+		}
+
+	  if ((rc = write_word (info, wp, data)) != 0)
+		{
+		  return (rc);
+		}
+	  wp += 4;
+	}
+
+  /*
+   * handle word aligned part
+   */
+  while (cnt >= 4)
+	{
+	  data = 0;
+	  for (i = 0; i < 4; ++i)
+		{
+		  data = (data << 8) | *src++;
+		}
+	  if ((rc = write_word (info, wp, data)) != 0)
+		{
+		  return (rc);
+		}
+	  wp += 4;
+	  cnt -= 4;
+	}
+
+  if (cnt == 0)
+	{
+	  return (0);
+	}
+
+  /*
+   * handle unaligned tail bytes
+   */
+  data = 0;
+  for (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp)
+	{
+	  data = (data << 8) | *src++;
+	  --cnt;
+	}
+  for (; i < 4; ++i, ++cp)
+	{
+	  data = (data << 8) | (*(uchar *) cp);
+	}
+
+  return (write_word (info, wp, data));
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+static int
+write_word (flash_info_t * info, ulong dest, ulong data)
+{
+  if (((info->flash_id & FLASH_TYPEMASK) == FLASH_AM320B) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM320T) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_MXLV320T) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_STMW320DT))
+	{
+	  return write_word_2 (info, dest, data);
+	}
+  else
+	{
+	  return write_word_1 (info, dest, data);
+	}
+}
+
+static int
+write_word_1 (flash_info_t * info, ulong dest, ulong data)
+#else
+static int
+write_word (flash_info_t * info, ulong dest, ulong data)
+#endif
+{
+  volatile CFG_FLASH_WORD_SIZE *addr2 =
+	(CFG_FLASH_WORD_SIZE *) (info->start[0]);
+  volatile CFG_FLASH_WORD_SIZE *dest2 = (CFG_FLASH_WORD_SIZE *) dest;
+  volatile CFG_FLASH_WORD_SIZE *data2 = (CFG_FLASH_WORD_SIZE *) & data;
+  ulong start;
+  int i;
+
+  /* Check if Flash is (sufficiently) erased */
+  if ((*((vu_long *) dest) & data) != data)
+	{
+	  return (2);
+	}
+
+  for (i = 0; i < 4 / sizeof (CFG_FLASH_WORD_SIZE); i++)
+	{
+	  int flag;
+
+	  /* Disable interrupts which might cause a timeout here */
+	  flag = disable_interrupts ();
+
+	  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+	  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+	  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00A000A0;
+
+	  dest2[i] = data2[i];
+
+	  /* re-enable interrupts if necessary */
+	  if (flag)
+		enable_interrupts ();
+
+	  /* data polling for D7 */
+	  start = get_timer (0);
+	  while ((dest2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+			 (data2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080))
+		{
+
+		  if (get_timer (start) > CFG_FLASH_WRITE_TOUT)
+			{
+			  return (1);
+			}
+		}
+	}
+
+  return (0);
+}
+
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+
+#undef  CFG_FLASH_WORD_SIZE
+#define CFG_FLASH_WORD_SIZE unsigned short
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong
+flash_get_size_2 (vu_long * addr, flash_info_t * info)
+{
+  short i;
+  int n;
+  CFG_FLASH_WORD_SIZE value;
+  ulong base = (ulong) addr;
+  volatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *) addr;
+
+  debug ("FLASH ADDR: %08x\n", (unsigned) addr);
+
+  /* Write auto select command: read Manufacturer ID */
+  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00900090;
+  udelay (1000);
+
+  value = addr2[0];
+  debug ("FLASH MANUFACT: %x\n", value);
+
+  switch (value)
+	{
+	case (CFG_FLASH_WORD_SIZE) AMD_MANUFACT:
+	  info->flash_id = FLASH_MAN_AMD;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) FUJ_MANUFACT:
+	  info->flash_id = FLASH_MAN_FUJ;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) SST_MANUFACT:
+	  info->flash_id = FLASH_MAN_SST;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) STM_MANUFACT:
+	  info->flash_id = FLASH_MAN_STM;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) MX_MANUFACT:
+	  info->flash_id = FLASH_MAN_MX;
+	  break;
+	default:
+	  info->flash_id = FLASH_UNKNOWN;
+	  info->sector_count = 0;
+	  info->size = 0;
+	  return (0);				/* no or unknown flash  */
+	}
+
+  value = addr2[1];				/* device ID */
+
+  debug ("\nFLASH DEVICEID: %x\n", value);
+
+  switch (value)
+	{
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV320T:
+	  info->flash_id += FLASH_AM320T;
+	  info->sector_count = 71;
+	  info->size = 0x00400000;
+	  break;					/* => 4 MiB     */
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV320B:
+	  info->flash_id += FLASH_AM320B;
+	  info->sector_count = 71;
+	  info->size = 0x00400000;
+	  break;					/* => 4 MiB     */
+
+	case (CFG_FLASH_WORD_SIZE) STM_ID_29W320DT:
+	  info->flash_id += FLASH_STMW320DT;
+	  info->sector_count = 67;
+	  info->size = 0x00400000;
+	  break;					/* => 4 MiB     */
+
+	case (CFG_FLASH_WORD_SIZE) MX_ID_LV320T:
+	  info->flash_id += FLASH_MXLV320T;
+	  info->sector_count = 71;
+	  info->size = 0x00400000;
+	  break;					/* => 4 MB      */
+
+	default:
+	  info->flash_id = FLASH_UNKNOWN;
+	  return (0);				/* => no or unknown flash */
+	}
+
+  /* set up sector start address table */
+  if (((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM040) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AMD016))
+	{
+	  for (i = 0; i < info->sector_count; i++)
+		info->start[i] = base + (i * 0x00010000);
+	}
+  else if ((info->flash_id & FLASH_TYPEMASK) == FLASH_STMW320DT)
+	{
+	  /* set sector offsets for top boot block type           */
+	  base += info->size;
+	  i = info->sector_count;
+	  /*  1 x 16k boot sector */
+	  base -= 16 << 10;
+	  --i;
+	  info->start[i] = base;
+	  /*  2 x 8k  boot sectors */
+	  for (n = 0; n < 2; ++n)
+		{
+		  base -= 8 << 10;
+		  --i;
+		  info->start[i] = base;
+		}
+	  /*  1 x 32k boot sector */
+	  base -= 32 << 10;
+	  --i;
+	  info->start[i] = base;
+
+	  while (i > 0)
+		{						/* 64k regular sectors  */
+		  base -= 64 << 10;
+		  --i;
+		  info->start[i] = base;
+		}
+	}
+  else if ((info->flash_id & FLASH_TYPEMASK) == FLASH_MXLV320T)
+	{
+	  i = info->sector_count - 1;
+	  info->start[i--] = base + info->size - 0x00002000;
+	  info->start[i--] = base + info->size - 0x00004000;
+	  info->start[i--] = base + info->size - 0x00006000;
+	  info->start[i--] = base + info->size - 0x00008000;
+	  info->start[i--] = base + info->size - 0x0000a000;
+	  info->start[i--] = base + info->size - 0x0000c000;
+	  info->start[i--] = base + info->size - 0x0000e000;
+	  info->start[i--] = base + info->size - 0x00010000;
+
+	  for (; i >= 0; i--)
+		info->start[i] = base + i * 0x00010000;
+	}
+  else
+	{
+	  if (info->flash_id & FLASH_BTYPE)
+		{
+		  /* set sector offsets for bottom boot block type */
+		  info->start[0] = base + 0x00000000;
+		  info->start[1] = base + 0x00004000;
+		  info->start[2] = base + 0x00006000;
+		  info->start[3] = base + 0x00008000;
+		  for (i = 4; i < info->sector_count; i++)
+			{
+			  info->start[i] = base + (i * 0x00010000) - 0x00030000;
+			}
+		}
+	  else
+		{
+		  /* set sector offsets for top boot block type */
+		  i = info->sector_count - 1;
+		  info->start[i--] = base + info->size - 0x00004000;
+		  info->start[i--] = base + info->size - 0x00006000;
+		  info->start[i--] = base + info->size - 0x00008000;
+		  for (; i >= 0; i--)
+			{
+			  info->start[i] = base + i * 0x00010000;
+			}
+		}
+	}
+
+  /* check for protected sectors */
+  for (i = 0; i < info->sector_count; i++)
+	{
+	  /* read sector protection at sector address, (A7 .. A0) = 0x02 */
+	  /* D0 = 1 if protected */
+	  addr2 = (volatile CFG_FLASH_WORD_SIZE *) (info->start[i]);
+
+	  /* For AMD29033C flash we need to resend the command of *
+	   * reading flash protection for upper 8 Mb of flash     */
+	  if (i == 32)
+		{
+		  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0xAAAAAAAA;
+		  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x55555555;
+		  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x90909090;
+		}
+
+	  if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)
+		info->protect[i] = 0;
+	  else
+		info->protect[i] = addr2[2] & 1;
+	}
+
+  /* issue bank reset to return to read mode */
+  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;
+
+  return (info->size);
+}
+
+static int
+wait_for_DQ7_2 (flash_info_t * info, int sect)
+{
+  ulong start, now, last;
+  volatile CFG_FLASH_WORD_SIZE *addr =
+	(CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+  start = get_timer (0);
+  last = start;
+  while ((addr[0] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+		 (CFG_FLASH_WORD_SIZE) 0x00800080)
+	{
+	  if ((now = get_timer (start)) > CFG_FLASH_ERASE_TOUT)
+		{
+		  printf ("Timeout\n");
+		  return -1;
+		}
+	  /* show that we're waiting */
+	  if ((now - last) > 1000)
+		{						/* every second */
+		  putc ('.');
+		  last = now;
+		}
+	}
+  return 0;
+}
+
+static int
+flash_erase_2 (flash_info_t * info, int s_first, int s_last)
+{
+  volatile CFG_FLASH_WORD_SIZE *addr =
+	(CFG_FLASH_WORD_SIZE *) (info->start[0]);
+  volatile CFG_FLASH_WORD_SIZE *addr2;
+  int flag, prot, sect, l_sect;
+  int i;
+
+  if ((s_first < 0) || (s_first > s_last))
+	{
+	  if (info->flash_id == FLASH_UNKNOWN)
+		{
+		  printf ("- missing\n");
+		}
+	  else
+		{
+		  printf ("- no sectors to erase\n");
+		}
+	  return 1;
+	}
+
+  if (info->flash_id == FLASH_UNKNOWN)
+	{
+	  printf ("Can't erase unknown flash type - aborted\n");
+	  return 1;
+	}
+
+  prot = 0;
+  for (sect = s_first; sect <= s_last; ++sect)
+	{
+	  if (info->protect[sect])
+		{
+		  prot++;
+		}
+	}
+
+  if (prot)
+	{
+	  printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	}
+  else
+	{
+	  printf ("\n");
+	}
+
+  l_sect = -1;
+
+  /* Disable interrupts which might cause a timeout here */
+  flag = disable_interrupts ();
+
+  /* Start erase on unprotected sectors */
+  for (sect = s_first; sect <= s_last; sect++)
+	{
+	  if (info->protect[sect] == 0)
+		{						/* not protected */
+		  addr2 = (CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+		  if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)
+			{
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00500050;	/* block erase */
+			  for (i = 0; i < 50; i++)
+				udelay (1000);	/* wait 1 ms */
+			}
+		  else
+			{
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00300030;	/* sector erase */
+			}
+		  l_sect = sect;
+		  /*
+		   * Wait for each sector to complete, it's more
+		   * reliable.  According to AMD Spec, you must
+		   * issue all erase commands within a specified
+		   * timeout.  This has been seen to fail, especially
+		   * if printf()s are included (for debug)!!
+		   */
+		  wait_for_DQ7_2 (info, sect);
+		}
+	}
+
+  /* re-enable interrupts if necessary */
+  if (flag)
+	enable_interrupts ();
+
+  /* wait at least 80us - let's wait 1 ms */
+  udelay (1000);
+
+  /* reset to read mode */
+  addr = (CFG_FLASH_WORD_SIZE *) info->start[0];
+  addr[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;	/* reset bank */
+
+  printf (" done\n");
+  return 0;
+}
+
+static int
+write_word_2 (flash_info_t * info, ulong dest, ulong data)
+{
+  volatile CFG_FLASH_WORD_SIZE *addr2 =
+	(CFG_FLASH_WORD_SIZE *) (info->start[0]);
+  volatile CFG_FLASH_WORD_SIZE *dest2 = (CFG_FLASH_WORD_SIZE *) dest;
+  volatile CFG_FLASH_WORD_SIZE *data2 = (CFG_FLASH_WORD_SIZE *) & data;
+  ulong start;
+  int i;
+
+  /* Check if Flash is (sufficiently) erased */
+  if ((*((vu_long *) dest) & data) != data)
+	{
+	  return (2);
+	}
+
+  for (i = 0; i < 4 / sizeof (CFG_FLASH_WORD_SIZE); i++)
+	{
+	  int flag;
+
+	  /* Disable interrupts which might cause a timeout here */
+	  flag = disable_interrupts ();
+
+	  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+	  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+	  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00A000A0;
+
+	  dest2[i] = data2[i];
+
+	  /* re-enable interrupts if necessary */
+	  if (flag)
+		enable_interrupts ();
+
+	  /* data polling for D7 */
+	  start = get_timer (0);
+	  while ((dest2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+			 (data2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080))
+		{
+
+		  if (get_timer (start) > CFG_FLASH_WRITE_TOUT)
+			{
+			  return (1);
+			}
+		}
+	}
+
+  return (0);
+}
+#endif /* CFG_FLASH_2ND_16BIT_DEV */
+
+unsigned long flash_init (void)
+{
+  	unsigned long total_size;
+  	unsigned long size_b0, size_b1;
+  	int i;
+
+  	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+  	total_size = 0;
+  	size_b0 = 0xffffffff;
+
+  	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		size_b1 = flash_get_size ((vu_long *) (CFG_FLASH_BASE +
+								   total_size), i);
+
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+				  i, size_b1, size_b1 >> 20);
+		}
+
+	  	/* Is this really needed ? - LP */
+	  	if (size_b1 > size_b0) {
+		  	printf ("## ERROR: Bank %d (0x%08lx = %ld MB) > Bank %d (0x%08lx = %ld MB)\n",
+			 	i, size_b1, size_b1 >> 20, i - 1, size_b0, size_b0 >>20);
+		  	goto out_error;
+		}
+
+	  	size_b0 = size_b1;
+	  	total_size += size_b1;
+	}
+
+  	/* Compute the Address Mask */
+  	for (i = 0; (total_size >> i) != 0; ++i) {
+
+	}
+  	i--;
+  	if (total_size != (1 << i)) {
+		printf ("## WARNING: Total FLASH size (0x%08lx = %ld MB) is not a power of 2\n",
+		 total_size, total_size >> 20);
+	}
+
+  	total_size = 0;
+
+  	for (i = 0; i < CFG_MAX_FLASH_BANKS && flash_info[i].size != 0; ++i) {
+		/* Re-do sizing to get full correct info */
+	  	/* Why ? - LP */
+	  	size_b1 = flash_get_size ((vu_long *) (CFG_FLASH_BASE +
+								   total_size), i);
+
+	  	/* This is done by flash_get_size - LP */
+	  	/* flash_get_offsets (CFG_FLASH_BASE + total_size, &flash_info[i]); */
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	  /* monitor protection ON by default */
+	  flash_protect (FLAG_PROTECT_SET,
+					 CFG_MONITOR_BASE,
+					 CFG_MONITOR_BASE + monitor_flash_len - 1,
+					 &flash_info[i]);
+#endif
+
+#ifdef  CFG_ENV_IS_IN_FLASH
+	  /* ENV protection ON by default */
+	  flash_protect (FLAG_PROTECT_SET,
+					 CFG_ENV_ADDR,
+					 CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[i]);
+#endif
+
+	  total_size += size_b1;
+	}
+
+  return (total_size);
+
+out_error:
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	  	flash_info[i].sector_count = -1;
+	  	flash_info[i].size = 0;
+	}
+  	return (0);
+}
Index: u-boot-1.2.0/board/avocent/golden_gate/gg_fpga.h
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/gg_fpga.h
@@ -0,0 +1,102 @@
+#ifndef _FPGA_H_
+#define _FPGA_H_
+
+/* Structure for FPGA */
+typedef struct {
+	unsigned char config_sts;
+	unsigned char res_uart;
+	unsigned char misc;
+	unsigned char board_sw_id;
+} fpga_t;
+
+/* Map for CS0 and CFG Selector Status */
+#define CS0_SEL_0	0
+#define CS0_SEL_1	1
+#define CFG_0	    5
+#define CFG_1	    6
+#define CFG_2	    7
+
+/* Map for UART Reset */
+#define OCTAL_UART_0_RESET	0
+#define OCTAL_UART_1_RESET  1
+#define OCTAL_UART_2_RESET  2
+#define OCTAL_UART_3_RESET  3
+#define OCTAL_UART_4_RESET  4
+#define OCTAL_UART_5_RESET  5
+
+/* Map for Misc Reset/Control */
+#define PWR_PCCARD_RESET	0
+#define MODEM_RESET			1
+#define ETH_PHY_RESET		2
+#define CISCO_RJ45_RESET	4
+#define BLUE_LED_0_RESET	6
+#define BLUE_LED_1_RESET	7
+
+/* Map for Board & Switch ID Status */
+#define BOARD_ID_0      7
+#define BOARD_ID_1      6
+#define BOARD_ID_2      5
+#define SWITCH_ID_0     4
+#define SWITCH_ID_1     3
+#define SWITCH_ID_2     2
+#define SWITCH_ID_3     1
+#define SWITCH_ID_4     0
+
+#define BOARD_ID          BOARD_ID_2
+#define BOARD_TYPE_MASK   0x07
+
+/* Board type definitions */
+#define BOARD_ACS6000       0x00
+
+/* FPGA register address */
+#define CONFIG_STS		0x00
+#define RES_UART		0x01
+#define MISC			0x02
+#define BRD_SW_ID		0x03
+
+/* Boot options */
+#define CFG_BOOT_OPTION_A	0
+#define CFG_BOOT_OPTION_E   1
+#define CFG_BOOT_OPTION_C   2
+#define CFG_BOOT_OPTION_F   3
+#define CFG_BOOT_OPTION_B   4
+#define CFG_BOOT_OPTION_G   5
+#define CFG_BOOT_OPTION_D   6
+#define CFG_BOOT_OPTION_H   7
+
+/* Chip Select 0 */
+#define CFG_SMALL_NOR_FLASH		0
+#define CFG_LARGE_NOR_FLASH	    1
+#define CFG_NAND_FLASH		    2
+
+/* Blue Led */
+#define	BLUE_LED_ON	   		0
+#define BLUE_LED_BLINK1	    1   /* Blink Type 1 */
+#define BLUE_LED_BLINK2	    2   /* Blink Type 2 */
+#define BLUE_LED_BLINK3	    3   /* Blink Type 3 */
+
+/* SW_ID (0) */
+#define	LOW_PORT_COUNT			0
+#define	HIGH_PORT_COUNT			1
+//Obsoleted...
+#define	SHASTA_VERSION			0
+#define	GOLDEN_GOLD_VERSION		1
+
+/* SW_ID (1) */
+#define	AUX_PORT_VERSION		0
+#define	MODEM_PORT_VERSION		1
+
+/* SW_ID (2) */
+#define	SINGLE_PWR_SUPPLY_VERSION	0
+#define	DUAL_PWR_SUPPLY_VERSION		1
+
+/* SW_ID (3..4), SW_ID(0)=1 */
+#define	SERIAL_16_PORTS_VERSION		0
+#define	SERIAL_32_PORTS_VERSION		1
+#define	SERIAL_48_PORTS_VERSION		2
+/* SW_ID (3..4), SW_ID(0)=0 */
+#define	SERIAL_1_PORTS_VERSION		0
+#define	SERIAL_4_PORTS_VERSION		1
+#define	SERIAL_8_PORTS_VERSION		2
+
+#endif  /* _FPGA_H_ */
Index: u-boot-1.2.0/board/avocent/golden_gate/golden_gate.c
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/golden_gate.c
@@ -0,0 +1,682 @@
+/*
+ * (C) Copyright 2007
+ * Roger Yung, Avocent Corp., roger.yung@avocent.com
+ *
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * (C) Copyright 2006
+ * Jacqueline Pira-Ferriol, AMCC/IBM, jpira-ferriol@fr.ibm.com
+ * Alain Saurel,	    AMCC/IBM, alain.saurel@fr.ibm.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/processor.h>
+#include <ppc440.h>
+#include "golden_gate.h"
+#include "gg_fpga.h"
+#include "../gsp/gsp-config.h"
+#include <avocent/flashhdr.h>
+
+#include <gsp-serialnb.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern flash_info_t flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+
+ulong flash_get_size (ulong base, int banknum);
+
+int board_early_init_f(void)
+{
+	u32 sdr0_cust0;
+	u32 sdr0_pfc0, sdr0_pfc1, sdr0_pfc2;
+	u32 reg;
+	fpga_t* fpgaPtr;
+
+	/* Blink the blue LED */
+	fpgaPtr = (fpga_t*)CFG_FPGA_ADDR;
+	fpgaPtr->misc &= 0xfc; /* Reset led bits to zero */
+
+	fpgaPtr->misc |= BLUE_LED_BLINK1;
+
+	mtdcr(ebccfga, xbcfg);
+	mtdcr(ebccfgd, 0xb8400000);
+
+	/*--------------------------------------------------------------------
+	 * Setup the GPIO pins
+	 *-------------------------------------------------------------------*/
+	out32(GPIO0_OR, 	0x00000000);
+	out32(GPIO0_TCR, 	0x0000f0c0);
+	out32(GPIO0_OSRL, 	0x54055400);
+	out32(GPIO0_OSRH, 	0x55005000);
+	out32(GPIO0_TSRL, 	0x54055500);
+	out32(GPIO0_TSRH, 	0x55005000);
+	out32(GPIO0_ISR1L, 	0x54000100);
+	out32(GPIO0_ISR1H, 	0x00000000);
+	out32(GPIO0_ISR2L, 	0x00000000);
+	out32(GPIO0_ISR2H, 	0x00000100);
+	out32(GPIO0_ISR3L, 	0x00000000);
+	out32(GPIO0_ISR3H, 	0x00000000);
+
+	out32(GPIO1_OR, 	0x00000000);
+	out32(GPIO1_TCR, 	0x16000000);
+	out32(GPIO1_OSRL, 	0x02180000);
+	out32(GPIO1_OSRH, 	0x00000000);
+	out32(GPIO1_TSRL, 	0x00000000);
+	out32(GPIO1_TSRH, 	0x00000000);
+	out32(GPIO1_ISR1L, 	0x00405555);
+	out32(GPIO1_ISR1H, 	0x40000000);
+	out32(GPIO1_ISR2L, 	0x04010000);
+	out32(GPIO1_ISR2H, 	0x00000000);
+	out32(GPIO1_ISR3L, 	0x00000000);
+	out32(GPIO1_ISR3H, 	0x00000000);
+
+	/*--------------------------------------------------------------------
+	 * Setup the interrupt controller polarities, triggers, etc.
+	 *-------------------------------------------------------------------*/
+	mtdcr(uic0sr, 0xffffffff);	/* clear all */
+	mtdcr(uic0er, 0x00000000);	/* disable all */
+	mtdcr(uic0cr, 0x00000005);	/* ATI & UIC1 crit are critical */
+	mtdcr(uic0pr, 0xfffff7ff);	/* per ref-board manual */
+	mtdcr(uic0tr, 0x00000000);	/* per ref-board manual */
+	mtdcr(uic0vr, 0x00000000);	/* int31 highest, base=0x000 */
+	mtdcr(uic0sr, 0xffffffff);	/* clear all */
+
+	mtdcr(uic1sr, 0xffffffff);	/* clear all */
+	mtdcr(uic1er, 0x00000000);	/* disable all */
+	mtdcr(uic1cr, 0x00000000);	/* all non-critical */
+	mtdcr(uic1pr, 0xffffffff);	/* per ref-board manual */
+	mtdcr(uic1tr, 0x00000000);	/* per ref-board manual */
+	mtdcr(uic1vr, 0x00000000);	/* int31 highest, base=0x000 */
+	mtdcr(uic1sr, 0xffffffff);	/* clear all */
+
+	mtdcr(uic2sr, 0xffffffff);	/* clear all */
+	mtdcr(uic2er, 0x00000000);	/* disable all */
+	mtdcr(uic2cr, 0x00000000);	/* all non-critical */
+	mtdcr(uic2pr, 0xffffffff);	/* per ref-board manual */
+	mtdcr(uic2tr, 0x00000000);	/* per ref-board manual */
+	mtdcr(uic2vr, 0x00000000);	/* int31 highest, base=0x000 */
+	mtdcr(uic2sr, 0xffffffff);	/* clear all */
+
+	/* 50MHz tmrclk */
+	/* *(unsigned char *)(CFG_BCSR_BASE | 0x04) = 0x00; */
+
+	/* clear write protects */
+	/* *(unsigned char *)(CFG_BCSR_BASE | 0x07) = 0x00; */
+
+	/* reset Ethernet */
+	/* *(unsigned char *)(CFG_BCSR_BASE | 0x08) = 0x00; */
+	fpgaPtr->misc |= (0x80 >> ETH_PHY_RESET);
+	udelay(100000);
+	fpgaPtr->misc &= ~(0x80 >> ETH_PHY_RESET);
+	udelay(100000);
+
+	/* enable USB device */
+	/* *(unsigned char *)(CFG_BCSR_BASE | 0x09) = 0x20; */
+
+    	/* enable trace signals */
+	mfsdr(SDR0_PFC0, sdr0_pfc0); /* Get sdr0_pfc0 */
+	sdr0_pfc0 = (sdr0_pfc0 & ~SDR0_PFC0_TRE_MASK) | SDR0_PFC0_TRE_ENABLE;
+	mtsdr(SDR0_PFC0, sdr0_pfc0); /* Set sdr0_pfc0 */
+
+	/* select Ethernet pins */
+	mfsdr(SDR0_PFC1, sdr0_pfc1); /* Get sdr0_pfc1 */
+	sdr0_pfc1 = (sdr0_pfc1 & ~SDR0_PFC1_SELECT_MASK) | SDR0_PFC1_SELECT_CONFIG_4;
+	sdr0_pfc1 |= SDR0_PFC1_SIS_IIC1_SEL; /* set second I2C bus */
+	sdr0_pfc1 |= SDR0_PFC1_U1ME_CTS_RTS | SDR0_PFC1_U0ME_CTS_RTS | SDR0_PFC1_U0IM_4PINS; /* set 4-wire, CTS/RTS UART interfaces */
+
+	mfsdr(SDR0_PFC2, sdr0_pfc2);
+	sdr0_pfc2 = (sdr0_pfc2 & ~SDR0_PFC2_SELECT_MASK) | SDR0_PFC2_SELECT_CONFIG_4;
+
+	mtsdr(SDR0_PFC2, sdr0_pfc2); /* Set sdr0_pfc2 */
+	mtsdr(SDR0_PFC1, sdr0_pfc1);
+
+	/* PCI arbiter enabled */
+	mfsdr(sdr_pci0, reg);
+	mtsdr(sdr_pci0, 0x80000000 | reg);
+
+	/* setup NAND FLASH */
+	mfsdr(SDR0_CUST0, sdr0_cust0);
+	sdr0_cust0 = SDR0_CUST0_MUX_NDFC_SEL	|
+		SDR0_CUST0_NDFC_ENABLE		|
+		SDR0_CUST0_NDFC_BW_8_BIT	|
+		SDR0_CUST0_NDFC_ARE_MASK	|
+		(0x80000000 >> (28 + CFG_NAND_CS));
+	mtsdr(SDR0_CUST0, sdr0_cust0);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------+
+  | misc_init_r.
+  +---------------------------------------------------------------------------*/
+int misc_init_r(void)
+{
+	uint pbcr;
+	int size_val = 0;
+	u32 reg;
+	int set = 0;
+#ifdef CONFIG_440EPX
+	unsigned long usb2d0cr = 0;
+	unsigned long usb2phy0cr, usb2h0cr = 0;
+	unsigned long sdr0_pfc0, sdr0_pfc1;
+	char *act = getenv("usbact");
+#endif
+
+#ifdef CONFIG_AVOCENT_GSP
+	memset(gd->bd->serialnb, 0, 5);
+#endif
+	/*
+	 * FLASH stuff...
+	 */
+
+	/* Re-do sizing to get full correct info */
+
+	/* adjust flash start and offset */
+	gd->bd->bi_flashstart = 0 - gd->bd->bi_flashsize;
+	gd->bd->bi_flashoffset = 0;
+
+#if defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+	mtdcr(ebccfga, pb3cr);
+#else
+	mtdcr(ebccfga, pb0cr);
+#endif
+	pbcr = mfdcr(ebccfgd);
+	switch (gd->bd->bi_flashsize) {
+	case 256 << 10:
+	case 512 << 10:
+	case 1 << 20:
+		size_val = 0;
+		break;
+	case 2 << 20:
+		size_val = 1;
+		break;
+	case 4 << 20:
+		size_val = 2;
+		break;
+	case 8 << 20:
+		size_val = 3;
+		break;
+	case 16 << 20:
+		size_val = 4;
+		break;
+	case 32 << 20:
+		size_val = 5;
+		break;
+	case 64 << 20:
+		size_val = 6;
+		break;
+	case 128 << 20:
+		size_val = 7;
+		break;
+	}
+	pbcr = (pbcr & 0x0001ffff) | (gd->bd->bi_flashstart & 0xfff00000) | (size_val << 17);
+#if defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+	mtdcr(ebccfga, pb3cr);
+#else
+	mtdcr(ebccfga, pb0cr);
+#endif
+	mtdcr(ebccfgd, pbcr);
+
+	/*
+	 * Re-check to get correct base address
+	 */
+	flash_get_size(gd->bd->bi_flashstart, 0);
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	{
+		/* Check for serial number and MAC address in first sector */
+		struct bdserial *bds = (struct bdserial *)gd->bd->bi_flashstart;
+		char aux[20], *s;
+		if (bds->magic == BDS_MAGIC) {
+			sprintf(aux, "%02x%02x%02x%02x%02x",
+				bds->serialnb[0], bds->serialnb[1],
+				bds->serialnb[2], bds->serialnb[3],
+				bds->serialnb[4]);
+#ifdef CONFIG_AVOCENT_GSP
+			memcpy(gd->bd->serialnb, bds->serialnb, 5);
+#endif
+			s = getenv("serial#");
+			if (s == NULL || strcmp(s, aux)) {
+				printf("Setting serial number: %s\n", aux);
+				setenv("serial#", aux);
+				set = 1;
+			}
+			sprintf(aux, "%02x:%02x:%02x:%02x:%02x:%02x",
+				bds->ethaddr[0], bds->ethaddr[1],
+				bds->ethaddr[2], bds->ethaddr[3],
+				bds->ethaddr[4], bds->ethaddr[5]);
+			s = getenv("ethaddr");
+			if (s == NULL || strcmp(s, aux)) {
+				printf("Setting first MAC address: %s\n", aux);
+				setenv("ethaddr", aux);
+				set = 1;
+			}
+			sprintf(aux, "%02x:%02x:%02x:%02x:%02x:%02x",
+				bds->eth1addr[0], bds->eth1addr[1],
+				bds->eth1addr[2], bds->eth1addr[3],
+				bds->eth1addr[4], bds->eth1addr[5]);
+			s = getenv("eth1addr");
+			if (s == NULL || strcmp(s, aux)) {
+				printf("Setting second MAC address: %s\n", aux);
+				setenv("eth1addr", aux);
+				set = 1;
+			}
+		} else {
+			if (getenv("serial#") == NULL) {
+				/* production mode - network boot + maintenance mode */
+				setenv("bootcmd", "net_boot single");
+			}
+		}
+	}
+
+	/* Monitor protection ON by default */
+	(void)flash_protect(FLAG_PROTECT_SET,
+			    -CFG_MONITOR_LEN,
+			    0xffffffff,
+			    &flash_info[0]);
+	/* Environment protection ON by default */
+	(void)flash_protect(FLAG_PROTECT_SET,
+			    CFG_ENV_ADDR,
+			    CFG_ENV_ADDR + CFG_ENV_SIZE - 1,
+			    &flash_info[0]);
+	/* Serial Number protection ON by default */
+	(void)flash_protect(FLAG_PROTECT_SET,
+			    gd->bd->bi_flashstart,
+			    gd->bd->bi_flashstart + CFG_ENV_SECT_SIZE - 1,
+			    &flash_info[0]);
+#endif
+
+	/*
+	 * USB suff...
+	 */
+#ifdef CONFIG_440EPX
+	if (act == NULL || strcmp(act, "hostdev") == 0)	{
+		/* SDR Setting */
+		mfsdr(SDR0_PFC1, sdr0_pfc1);
+		mfsdr(SDR0_USB0, usb2d0cr);
+		mfsdr(SDR0_USB2PHY0CR, usb2phy0cr);
+		mfsdr(SDR0_USB2H0CR, usb2h0cr);
+
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_XOCLK_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_XOCLK_EXTERNAL;	/*0*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_WDINT_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_WDINT_16BIT_30MHZ;	/*1*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_DVBUS_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_DVBUS_PURDIS;		/*0*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_DWNSTR_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_DWNSTR_HOST;		/*1*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_UTMICN_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_UTMICN_HOST;		/*1*/
+
+		/* An 8-bit/60MHz interface is the only possible alternative
+		   when connecting the Device to the PHY */
+		usb2h0cr   = usb2h0cr &~SDR0_USB2H0CR_WDINT_MASK;
+		usb2h0cr   = usb2h0cr | SDR0_USB2H0CR_WDINT_16BIT_30MHZ;	/*1*/
+
+		/* To enable the USB 2.0 Device function through the UTMI interface */
+		usb2d0cr = usb2d0cr &~SDR0_USB2D0CR_USB2DEV_EBC_SEL_MASK;
+		usb2d0cr = usb2d0cr | SDR0_USB2D0CR_USB2DEV_SELECTION;		/*1*/
+
+		sdr0_pfc1 = sdr0_pfc1 &~SDR0_PFC1_UES_MASK;
+		sdr0_pfc1 = sdr0_pfc1 | SDR0_PFC1_UES_USB2D_SEL;		/*0*/
+
+		mtsdr(SDR0_PFC1, sdr0_pfc1);
+		mtsdr(SDR0_USB0, usb2d0cr);
+		mtsdr(SDR0_USB2PHY0CR, usb2phy0cr);
+		mtsdr(SDR0_USB2H0CR, usb2h0cr);
+
+		/*clear resets*/
+		udelay (1000);
+		mtsdr(SDR0_SRST1, 0x00000000);
+		udelay (1000);
+		mtsdr(SDR0_SRST0, 0x00000000);
+
+		printf("USB:   Host(int phy) Device(ext phy)\n");
+
+	} else if (strcmp(act, "dev") == 0) {
+		/*-------------------PATCH-------------------------------*/
+		mfsdr(SDR0_USB2PHY0CR, usb2phy0cr);
+
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_XOCLK_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_XOCLK_EXTERNAL;	/*0*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_DVBUS_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_DVBUS_PURDIS;		/*0*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_DWNSTR_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_DWNSTR_HOST;		/*1*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_UTMICN_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_UTMICN_HOST;		/*1*/
+		mtsdr(SDR0_USB2PHY0CR, usb2phy0cr);
+
+		udelay (1000);
+		mtsdr(SDR0_SRST1, 0x672c6000);
+
+		udelay (1000);
+		mtsdr(SDR0_SRST0, 0x00000080);
+
+		udelay (1000);
+		mtsdr(SDR0_SRST1, 0x60206000);
+
+		*(unsigned int *)(0xe0000350) = 0x00000001;
+
+		udelay (1000);
+		mtsdr(SDR0_SRST1, 0x60306000);
+		/*-------------------PATCH-------------------------------*/
+
+		/* SDR Setting */
+		mfsdr(SDR0_USB2PHY0CR, usb2phy0cr);
+		mfsdr(SDR0_USB2H0CR, usb2h0cr);
+		mfsdr(SDR0_USB0, usb2d0cr);
+		mfsdr(SDR0_PFC1, sdr0_pfc1);
+
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_XOCLK_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_XOCLK_EXTERNAL;	/*0*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_WDINT_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_WDINT_8BIT_60MHZ;	/*0*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_DVBUS_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_DVBUS_PUREN;		/*1*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_DWNSTR_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_DWNSTR_DEV;		/*0*/
+		usb2phy0cr = usb2phy0cr &~SDR0_USB2PHY0CR_UTMICN_MASK;
+		usb2phy0cr = usb2phy0cr | SDR0_USB2PHY0CR_UTMICN_DEV;		/*0*/
+
+		usb2h0cr   = usb2h0cr &~SDR0_USB2H0CR_WDINT_MASK;
+		usb2h0cr   = usb2h0cr | SDR0_USB2H0CR_WDINT_8BIT_60MHZ;		/*0*/
+
+		usb2d0cr = usb2d0cr &~SDR0_USB2D0CR_USB2DEV_EBC_SEL_MASK;
+		usb2d0cr = usb2d0cr | SDR0_USB2D0CR_EBC_SELECTION;		/*0*/
+
+		sdr0_pfc1 = sdr0_pfc1 &~SDR0_PFC1_UES_MASK;
+		sdr0_pfc1 = sdr0_pfc1 | SDR0_PFC1_UES_EBCHR_SEL;		/*1*/
+
+		mtsdr(SDR0_USB2H0CR, usb2h0cr);
+		mtsdr(SDR0_USB2PHY0CR, usb2phy0cr);
+		mtsdr(SDR0_USB0, usb2d0cr);
+		mtsdr(SDR0_PFC1, sdr0_pfc1);
+
+		/*clear resets*/
+		udelay (1000);
+		mtsdr(SDR0_SRST1, 0x00000000);
+		udelay (1000);
+		mtsdr(SDR0_SRST0, 0x00000000);
+
+		printf("USB:   Device(int phy)\n");
+	}
+#endif /* CONFIG_440EPX */
+
+	/*
+	 * Clear PLB4A0_ACR[WRP]
+	 * This fix will make the MAL burst disabling patch for the Linux
+	 * EMAC driver obsolete.
+	 */
+	reg = mfdcr(plb4_acr) & ~PLB4_ACR_WRP;
+	mtdcr(plb4_acr, reg);
+
+#ifdef CONFIG_AVOCENT_GSP //mp: shouldn't this be more specific about ACS6000?
+	set |= gsp_config_wdt();
+	set |= gsp_config_fecmode(0, 1);
+	set |= gsp_config_fecmode(1, 1);
+	gd->bd->family = OPTREC_PRODUCT_TYPE_ACS6000;
+#endif
+	if (set) {
+		saveenv();
+	}
+	return 0;
+}
+
+int checkboard(void)
+{
+	char *s = getenv("serial#");
+	fpga_t* fpgaPtr = (fpga_t*)CFG_FPGA_ADDR;
+	int board_id = fpgaPtr->board_sw_id >> BOARD_ID;
+
+#ifdef CONFIG_440EPX //mp: shouldn't this be more specific about ACS6000?
+	if ((board_id & BOARD_TYPE_MASK) != BOARD_ACS6000) {
+		int i;
+		putc('\n');
+		for (i=0; i<3; i++) {
+			printf("WARNING : U-Boot is NOT running on expected ACS6000 board : WARNING\n");
+			udelay(5 * 1000 * 1000);
+		}
+		putc('\n');
+		printf("Unknown Board");
+	} else {
+		printf("ACS6000 Board");
+	}
+#else
+	printf("AMCC - Evaluation Board");
+#endif
+
+	if (s != NULL) {
+		puts(", serial# ");
+		puts(s);
+	}
+	putc('\n');
+
+	return (0);
+}
+
+#if defined(CFG_DRAM_TEST)
+int testdram(void)
+{
+	unsigned long *mem = (unsigned long *)0;
+	const unsigned long kend = (1024 / sizeof(unsigned long));
+	unsigned long k, n;
+
+	mtmsr(0);
+
+	for (k = 0; k < CFG_MBYTES_SDRAM;
+	     ++k, mem += (1024 / sizeof(unsigned long))) {
+		if ((k & 1023) == 0) {
+			printf("%3d MB\r", k / 1024);
+		}
+
+		memset(mem, 0xaaaaaaaa, 1024);
+		for (n = 0; n < kend; ++n) {
+			if (mem[n] != 0xaaaaaaaa) {
+				printf("SDRAM test fails at: %08x\n",
+				       (uint) & mem[n]);
+				return 1;
+			}
+		}
+
+		memset(mem, 0x55555555, 1024);
+		for (n = 0; n < kend; ++n) {
+			if (mem[n] != 0x55555555) {
+				printf("SDRAM test fails at: %08x\n",
+				       (uint) & mem[n]);
+				return 1;
+			}
+		}
+	}
+	printf("SDRAM test passes\n");
+	return 0;
+}
+#endif
+
+/*************************************************************************
+ *  pci_pre_init
+ *
+ *  This routine is called just prior to registering the hose and gives
+ *  the board the opportunity to check things. Returning a value of zero
+ *  indicates that things are bad & PCI initialization should be aborted.
+ *
+ *	Different boards may wish to customize the pci controller structure
+ *	(add regions, override default access routines, etc) or perform
+ *	certain pre-initialization actions.
+ *
+ ************************************************************************/
+#if defined(CONFIG_PCI) && defined(CFG_PCI_PRE_INIT)
+int pci_pre_init(struct pci_controller *hose)
+{
+	unsigned long addr;
+#if 0
+	/*--------------------------------------------------------------------------+
+	 *	Cactus is always configured as the host & requires the
+	 *	PCI arbiter to be enabled ???
+	 *--------------------------------------------------------------------------*/
+	unsigned long strap;
+	mfsdr(sdr_sdstp1, strap);
+	if ((strap & SDR0_SDSTP1_PAE_MASK) == 0) {
+		printf("PCI: SDR0_STRP1[PAE] not set.\n");
+		printf("PCI: Configuration aborted.\n");
+		return 0;
+	}
+#endif
+
+	/*-------------------------------------------------------------------------+
+	  | Set priority for all PLB3 devices to 0.
+	  | Set PLB3 arbiter to fair mode.
+	  +-------------------------------------------------------------------------*/
+	mfsdr(sdr_amp1, addr);
+	mtsdr(sdr_amp1, (addr & 0x000000FF) | 0x0000FF00);
+	addr = mfdcr(plb3_acr);
+	mtdcr(plb3_acr, addr | 0x80000000);
+
+	/*-------------------------------------------------------------------------+
+	  | Set priority for all PLB4 devices to 0.
+	  +-------------------------------------------------------------------------*/
+	mfsdr(sdr_amp0, addr);
+	mtsdr(sdr_amp0, (addr & 0x000000FF) | 0x0000FF00);
+	addr = mfdcr(plb4_acr) | 0xa0000000;	/* Was 0x8---- */
+	mtdcr(plb4_acr, addr);
+
+	/*-------------------------------------------------------------------------+
+	  | Set Nebula PLB4 arbiter to fair mode.
+	  +-------------------------------------------------------------------------*/
+	/* Segment0 */
+	addr = (mfdcr(plb0_acr) & ~plb0_acr_ppm_mask) | plb0_acr_ppm_fair;
+	addr = (addr & ~plb0_acr_hbu_mask) | plb0_acr_hbu_enabled;
+	addr = (addr & ~plb0_acr_rdp_mask) | plb0_acr_rdp_4deep;
+	addr = (addr & ~plb0_acr_wrp_mask) | plb0_acr_wrp_2deep;
+	mtdcr(plb0_acr, addr);
+
+	/* Segment1 */
+	addr = (mfdcr(plb1_acr) & ~plb1_acr_ppm_mask) | plb1_acr_ppm_fair;
+	addr = (addr & ~plb1_acr_hbu_mask) | plb1_acr_hbu_enabled;
+	addr = (addr & ~plb1_acr_rdp_mask) | plb1_acr_rdp_4deep;
+	addr = (addr & ~plb1_acr_wrp_mask) | plb1_acr_wrp_2deep;
+	mtdcr(plb1_acr, addr);
+
+	return 1;
+}
+#endif				/* defined(CONFIG_PCI) && defined(CFG_PCI_PRE_INIT) */
+
+/*************************************************************************
+ *  pci_target_init
+ *
+ *	The bootstrap configuration provides default settings for the pci
+ *	inbound map (PIM). But the bootstrap config choices are limited and
+ *	may not be sufficient for a given board.
+ *
+ ************************************************************************/
+#if defined(CONFIG_PCI) && defined(CFG_PCI_TARGET_INIT)
+void pci_target_init(struct pci_controller *hose)
+{
+	/*--------------------------------------------------------------------------+
+	 * Set up Direct MMIO registers
+	 *--------------------------------------------------------------------------*/
+	/*--------------------------------------------------------------------------+
+	  | PowerPC440EPX PCI Master configuration.
+	  | Map one 1Gig range of PLB/processor addresses to PCI memory space.
+	  |   PLB address 0xA0000000-0xDFFFFFFF ==> PCI address 0xA0000000-0xDFFFFFFF
+	  |   Use byte reversed out routines to handle endianess.
+	  | Make this region non-prefetchable.
+	  +--------------------------------------------------------------------------*/
+	out32r(PCIX0_PMM0MA, 0x00000000);	/* PMM0 Mask/Attribute - disabled b4 setting */
+	out32r(PCIX0_PMM0LA, CFG_PCI_MEMBASE);	/* PMM0 Local Address */
+	out32r(PCIX0_PMM0PCILA, CFG_PCI_MEMBASE);	/* PMM0 PCI Low Address */
+	out32r(PCIX0_PMM0PCIHA, 0x00000000);	/* PMM0 PCI High Address */
+	out32r(PCIX0_PMM0MA, 0xE0000001);	/* 512M + No prefetching, and enable region */
+
+	out32r(PCIX0_PMM1MA, 0x00000000);	/* PMM0 Mask/Attribute - disabled b4 setting */
+	out32r(PCIX0_PMM1LA, CFG_PCI_MEMBASE2); /* PMM0 Local Address */
+	out32r(PCIX0_PMM1PCILA, CFG_PCI_MEMBASE2);	/* PMM0 PCI Low Address */
+	out32r(PCIX0_PMM1PCIHA, 0x00000000);	/* PMM0 PCI High Address */
+	out32r(PCIX0_PMM1MA, 0xE0000001);	/* 512M + No prefetching, and enable region */
+
+	out32r(PCIX0_PTM1MS, 0x00000001);	/* Memory Size/Attribute */
+	out32r(PCIX0_PTM1LA, 0);	/* Local Addr. Reg */
+	out32r(PCIX0_PTM2MS, 0);	/* Memory Size/Attribute */
+	out32r(PCIX0_PTM2LA, 0);	/* Local Addr. Reg */
+
+	/*--------------------------------------------------------------------------+
+	 * Set up Configuration registers
+	 *--------------------------------------------------------------------------*/
+
+	/* Program the board's subsystem id/vendor id */
+	pci_write_config_word(0, PCI_SUBSYSTEM_VENDOR_ID, CFG_PCI_SUBSYS_VENDORID);
+	pci_write_config_word(0, PCI_SUBSYSTEM_ID, CFG_PCI_SUBSYS_ID);
+
+	/* Configure command register as bus master */
+	pci_write_config_word(0, PCI_COMMAND, PCI_COMMAND_MASTER);
+
+	/* 240nS PCI clock */
+	pci_write_config_word(0, PCI_LATENCY_TIMER, 1);
+
+	/* No error reporting */
+	pci_write_config_word(0, PCI_ERREN, 0);
+
+	pci_write_config_dword(0, PCI_BRDGOPT2, 0x00000101);
+
+}
+#endif				/* defined(CONFIG_PCI) && defined(CFG_PCI_TARGET_INIT) */
+
+/*************************************************************************
+ *  pci_master_init
+ *
+ ************************************************************************/
+#if defined(CONFIG_PCI) && defined(CFG_PCI_MASTER_INIT)
+void pci_master_init(struct pci_controller *hose)
+{
+	unsigned short temp_short;
+
+	/*--------------------------------------------------------------------------+
+	  | Write the PowerPC440 EP PCI Configuration regs.
+	  |   Enable PowerPC440 EP to be a master on the PCI bus (PMM).
+	  |   Enable PowerPC440 EP to act as a PCI memory target (PTM).
+	  +--------------------------------------------------------------------------*/
+	pci_read_config_word(0, PCI_COMMAND, &temp_short);
+	pci_write_config_word(0, PCI_COMMAND,
+			      temp_short | PCI_COMMAND_MASTER |
+			      PCI_COMMAND_MEMORY);
+}
+#endif				/* defined(CONFIG_PCI) && defined(CFG_PCI_MASTER_INIT) */
+
+/*************************************************************************
+ *  is_pci_host
+ *
+ *	This routine is called to determine if a pci scan should be
+ *	performed. With various hardware environments (especially cPCI and
+ *	PPMC) it's insufficient to depend on the state of the arbiter enable
+ *	bit in the strap register, or generic host/adapter assumptions.
+ *
+ *	Rather than hard-code a bad assumption in the general 440 code, the
+ *	440 pci code requires the board to decide at runtime.
+ *
+ *	Return 0 for adapter mode, non-zero for host (monarch) mode.
+ *
+ *
+ ************************************************************************/
+#if defined(CONFIG_PCI)
+int is_pci_host(struct pci_controller *hose)
+{
+	/* Cactus is always configured as host. */
+	return (1);
+}
+#endif				/* defined(CONFIG_PCI) */
Index: u-boot-1.2.0/board/avocent/golden_gate/golden_gate.h
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/golden_gate.h
@@ -0,0 +1,67 @@
+/*
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * (C) Copyright 2006
+ * Jacqueline Pira-Ferriol, AMCC/IBM, jpira-ferriol@fr.ibm.com
+ * Alain Saurel,            AMCC/IBM, alain.saurel@fr.ibm.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+/*----------------------------------------------------------------------------+
+  | EBC Configuration Register - EBC0_CFG
+  +----------------------------------------------------------------------------*/
+/* External Bus Three-State Control */
+#define EBC0_CFG_EBTC_DRIVEN	    0x80000000
+/* Device-Paced Time-out Disable */
+#define EBC0_CFG_PTD_ENABLED	    0x00000000
+/* Ready Timeout Count */
+#define EBC0_CFG_RTC_MASK	    0x38000000
+#define EBC0_CFG_RTC_16PERCLK	    0x00000000
+#define EBC0_CFG_RTC_32PERCLK	    0x08000000
+#define EBC0_CFG_RTC_64PERCLK	    0x10000000
+#define EBC0_CFG_RTC_128PERCLK	    0x18000000
+#define EBC0_CFG_RTC_256PERCLK	    0x20000000
+#define EBC0_CFG_RTC_512PERCLK	    0x28000000
+#define EBC0_CFG_RTC_1024PERCLK	    0x30000000
+#define EBC0_CFG_RTC_2048PERCLK	    0x38000000
+/* External Master Priority Low */
+#define EBC0_CFG_EMPL_LOW	    0x00000000
+#define EBC0_CFG_EMPL_MEDIUM_LOW    0x02000000
+#define EBC0_CFG_EMPL_MEDIUM_HIGH   0x04000000
+#define EBC0_CFG_EMPL_HIGH	    0x06000000
+/* External Master Priority High */
+#define EBC0_CFG_EMPH_LOW	    0x00000000
+#define EBC0_CFG_EMPH_MEDIUM_LOW    0x00800000
+#define EBC0_CFG_EMPH_MEDIUM_HIGH   0x01000000
+#define EBC0_CFG_EMPH_HIGH	    0x01800000
+/* Chip Select Three-State Control */
+#define EBC0_CFG_CSTC_DRIVEN	    0x00400000
+/* Burst Prefetch */
+#define EBC0_CFG_BPF_ONEDW	    0x00000000
+#define EBC0_CFG_BPF_TWODW	    0x00100000
+#define EBC0_CFG_BPF_FOURDW	    0x00200000
+/* External Master Size */
+#define EBC0_CFG_EMS_8BIT	    0x00000000
+/* Power Management Enable */
+#define EBC0_CFG_PME_DISABLED	    0x00000000
+#define EBC0_CFG_PME_ENABLED	    0x00020000
+/* Power Management Timer */
+#define EBC0_CFG_PMT_ENCODE(n)		((((unsigned long)(n))&0x1F)<<12)
+
+#define SDR0_USB0                    0x0320     /* USB Control Register */
Index: u-boot-1.2.0/board/avocent/golden_gate/init.S
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/init.S
@@ -0,0 +1,160 @@
+/*
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <ppc_asm.tmpl>
+#include <config.h>
+
+/* General */
+#define TLB_VALID   0x00000200
+#define _256M       0x10000000
+
+/* Supported page sizes */
+
+#define SZ_1K	    0x00000000
+#define SZ_4K	    0x00000010
+#define SZ_16K	    0x00000020
+#define SZ_64K	    0x00000030
+#define SZ_256K	    0x00000040
+#define SZ_1M	    0x00000050
+#define SZ_8M       0x00000060
+#define SZ_16M	    0x00000070
+#define SZ_256M	    0x00000090
+
+/* Storage attributes */
+#define SA_W	    0x00000800	    /* Write-through */
+#define SA_I	    0x00000400	    /* Caching inhibited */
+#define SA_M	    0x00000200	    /* Memory coherence */
+#define SA_G	    0x00000100	    /* Guarded */
+#define SA_E	    0x00000080	    /* Endian */
+
+/* Access control */
+#define AC_X	    0x00000024	    /* Execute */
+#define AC_W	    0x00000012	    /* Write */
+#define AC_R	    0x00000009	    /* Read */
+
+/* Some handy macros */
+
+#define EPN(e)		((e) & 0xfffffc00)
+#define TLB0(epn,sz)	( (EPN((epn)) | (sz) | TLB_VALID ) )
+#define TLB1(rpn,erpn)	( ((rpn)&0xfffffc00) | (erpn) )
+#define TLB2(a)		( (a)&0x00000fbf )
+
+#define tlbtab_start\
+	mflr    r1  ;\
+	bl 0f	    ;
+
+#define tlbtab_end\
+	.long 0, 0, 0	;   \
+0:	mflr    r0	;   \
+	mtlr    r1	;   \
+	blr		;
+
+#define tlbentry(epn,sz,rpn,erpn,attr)\
+	.long TLB0(epn,sz),TLB1(rpn,erpn),TLB2(attr)
+
+
+/**************************************************************************
+ * TLB TABLE
+ *
+ * This table is used by the cpu boot code to setup the initial tlb
+ * entries. Rather than make broad assumptions in the cpu source tree,
+ * this table lets each board set things up however they like.
+ *
+ *  Pointer to the table is returned in r1
+ *
+ *************************************************************************/
+    .section .bootpg,"ax"
+    .globl tlbtab
+
+tlbtab:
+	tlbtab_start
+
+	/*
+	 * BOOT_CS (FLASH) must be first. Before relocation SA_I can be off to use the
+	 * speed up boot process. It is patched after relocation to enable SA_I
+	 */
+#ifndef CONFIG_NAND_SPL
+	tlbentry( CFG_BOOT_BASE_ADDR, SZ_256M, CFG_BOOT_BASE_ADDR, 1, AC_R|AC_W|AC_X|SA_G )
+#else
+	tlbentry( CFG_NAND_BOOT_SPL_SRC, SZ_4K, CFG_NAND_BOOT_SPL_SRC, 1, AC_R|AC_W|AC_X|SA_G )
+#endif
+
+	/* TLB-entry for DDR SDRAM (Up to 2GB) */
+	tlbentry( CFG_SDRAM_BASE, SZ_256M, CFG_SDRAM_BASE, 0, AC_R|AC_W|AC_X|SA_G|SA_I )
+
+#ifdef CFG_INIT_RAM_DCACHE
+	/* TLB-entry for init-ram in dcache (SA_I must be turned off!) */
+	tlbentry( CFG_INIT_RAM_ADDR, SZ_64K, CFG_INIT_RAM_ADDR, 0, AC_R|AC_W|AC_X|SA_G )
+#endif
+
+	/* TLB-entry for PCI Memory */
+	tlbentry( CFG_PCI_MEMBASE, SZ_256M, CFG_PCI_MEMBASE, 1, AC_R|AC_W|SA_G|SA_I )
+	tlbentry( CFG_PCI_MEMBASE1, SZ_256M, CFG_PCI_MEMBASE1, 1, AC_R|AC_W|SA_G|SA_I )
+	tlbentry( CFG_PCI_MEMBASE2, SZ_256M, CFG_PCI_MEMBASE2, 1, AC_R|AC_W|SA_G|SA_I )
+	tlbentry( CFG_PCI_MEMBASE3, SZ_256M, CFG_PCI_MEMBASE3, 1, AC_R|AC_W|SA_G|SA_I )
+
+	/* TLB-entry for FPGA */
+	tlbentry( CFG_FPGA_ADDR, SZ_1K, CFG_FPGA_ADDR, 1, AC_R|AC_W|AC_X|SA_G|SA_I )
+
+    /* TLB-entry for UART */
+	tlbentry( CFG_UART_ADDR, SZ_4K, CFG_UART_ADDR, 1, AC_R|AC_W|AC_X|SA_G|SA_I )
+
+	/* TLB-entry for NAND */
+	tlbentry( CFG_NAND_ADDR, SZ_1K, CFG_NAND_ADDR, 1, AC_R|AC_W|AC_X|SA_G|SA_I )
+
+	/* TLB-entry for Internal Registers & OCM */
+	tlbentry( 0xe0000000, SZ_16M, 0xe0000000, 0,  AC_R|AC_W|AC_X|SA_I )
+
+	/*TLB-entry PCI registers*/
+	tlbentry( 0xEEC00000, SZ_1K, 0xEEC00000, 1,  AC_R|AC_W|AC_X|SA_G|SA_I )
+
+	/* TLB-entry for peripherals */
+	tlbentry( 0xEF000000, SZ_16M, 0xEF000000, 1, AC_R|AC_W|AC_X|SA_G|SA_I)
+
+	tlbtab_end
+
+#if defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+	/*
+	 * For NAND booting the first TLB has to be reconfigured to full size
+	 * and with caching disabled after running from RAM!
+	 */
+#define TLB00	TLB0(CFG_BOOT_BASE_ADDR, SZ_256M)
+#define TLB01	TLB1(CFG_BOOT_BASE_ADDR, 1)
+#define TLB02	TLB2(AC_R|AC_W|AC_X|SA_G|SA_I)
+
+	.globl	reconfig_tlb0
+reconfig_tlb0:
+	sync
+	isync
+	addi	r4,r0,0x0000		/* TLB entry #0 */
+	lis	r5,TLB00@h
+	ori	r5,r5,TLB00@l
+	tlbwe	r5,r4,0x0000		/* Save it out */
+	lis	r5,TLB01@h
+	ori	r5,r5,TLB01@l
+	tlbwe	r5,r4,0x0001		/* Save it out */
+	lis	r5,TLB02@h
+	ori	r5,r5,TLB02@l
+	tlbwe	r5,r4,0x0002		/* Save it out */
+	sync
+	isync
+	blr
+#endif
Index: u-boot-1.2.0/board/avocent/golden_gate/sdram.c
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/sdram.c
@@ -0,0 +1,431 @@
+/*
+ * (C) Copyright 2006
+ * Sylvie Gohl,             AMCC/IBM, gohl.sylvie@fr.ibm.com
+ * Jacqueline Pira-Ferriol, AMCC/IBM, jpira-ferriol@fr.ibm.com
+ * Thierry Roman,           AMCC/IBM, thierry_roman@fr.ibm.com
+ * Alain Saurel,            AMCC/IBM, alain.saurel@fr.ibm.com
+ * Robert Snyder,           AMCC/IBM, rob.snyder@fr.ibm.com
+ *
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* define DEBUG for debug output */
+#undef DEBUG
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+#include <ppc440.h>
+
+#include "sdram.h"
+
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL) || \
+	defined(CONFIG_DDR_DATA_EYE)
+/*-----------------------------------------------------------------------------+
+ * wait_for_dlllock.
+ +----------------------------------------------------------------------------*/
+static int wait_for_dlllock(void)
+{
+	unsigned long val;
+	int wait = 0;
+
+	/* -----------------------------------------------------------+
+	 * Wait for the DCC master delay line to finish calibration
+	 * ----------------------------------------------------------*/
+	mtdcr(ddrcfga, DDR0_17);
+	val = DDR0_17_DLLLOCKREG_UNLOCKED;
+
+	while (wait != 0xffff) {
+		val = mfdcr(ddrcfgd);
+		if ((val & DDR0_17_DLLLOCKREG_MASK) == DDR0_17_DLLLOCKREG_LOCKED)
+			/* dlllockreg bit on */
+			return 0;
+		else
+			wait++;
+	}
+	debug("0x%04x: DDR0_17 Value (dlllockreg bit): 0x%08x\n", wait, val);
+	debug("Waiting for dlllockreg bit to raise\n");
+
+	return -1;
+}
+#endif
+
+#if defined(CONFIG_DDR_DATA_EYE)
+/*-----------------------------------------------------------------------------+
+ * wait_for_dram_init_complete.
+ +----------------------------------------------------------------------------*/
+int wait_for_dram_init_complete(void)
+{
+	unsigned long val;
+	int wait = 0;
+
+	/* --------------------------------------------------------------+
+	 * Wait for 'DRAM initialization complete' bit in status register
+	 * -------------------------------------------------------------*/
+	mtdcr(ddrcfga, DDR0_00);
+
+	while (wait != 0xffff) {
+		val = mfdcr(ddrcfgd);
+		if ((val & DDR0_00_INT_STATUS_BIT6) == DDR0_00_INT_STATUS_BIT6)
+			/* 'DRAM initialization complete' bit */
+			return 0;
+		else
+			wait++;
+	}
+
+	debug("DRAM initialization complete bit in status register did not rise\n");
+
+	return -1;
+}
+
+#define NUM_TRIES 64
+#define NUM_READS 10
+
+/*-----------------------------------------------------------------------------+
+ * denali_core_search_data_eye.
+ +----------------------------------------------------------------------------*/
+void denali_core_search_data_eye(unsigned long memory_size)
+{
+	int k, j;
+	u32 val;
+	u32 wr_dqs_shift, dqs_out_shift, dll_dqs_delay_X;
+	u32 max_passing_cases = 0, wr_dqs_shift_with_max_passing_cases = 0;
+	u32 passing_cases = 0, dll_dqs_delay_X_sw_val = 0;
+	u32 dll_dqs_delay_X_start_window = 0, dll_dqs_delay_X_end_window = 0;
+	volatile u32 *ram_pointer;
+	u32 test[NUM_TRIES] = {
+		0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF,
+		0x00000000, 0x00000000, 0xFFFFFFFF, 0xFFFFFFFF,
+		0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000000,
+		0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000000,
+		0xAAAAAAAA, 0xAAAAAAAA, 0x55555555, 0x55555555,
+		0xAAAAAAAA, 0xAAAAAAAA, 0x55555555, 0x55555555,
+		0x55555555, 0x55555555, 0xAAAAAAAA, 0xAAAAAAAA,
+		0x55555555, 0x55555555, 0xAAAAAAAA, 0xAAAAAAAA,
+		0xA5A5A5A5, 0xA5A5A5A5, 0x5A5A5A5A, 0x5A5A5A5A,
+		0xA5A5A5A5, 0xA5A5A5A5, 0x5A5A5A5A, 0x5A5A5A5A,
+		0x5A5A5A5A, 0x5A5A5A5A, 0xA5A5A5A5, 0xA5A5A5A5,
+		0x5A5A5A5A, 0x5A5A5A5A, 0xA5A5A5A5, 0xA5A5A5A5,
+		0xAA55AA55, 0xAA55AA55, 0x55AA55AA, 0x55AA55AA,
+		0xAA55AA55, 0xAA55AA55, 0x55AA55AA, 0x55AA55AA,
+		0x55AA55AA, 0x55AA55AA, 0xAA55AA55, 0xAA55AA55,
+		0x55AA55AA, 0x55AA55AA, 0xAA55AA55, 0xAA55AA55 };
+
+	ram_pointer = (volatile u32 *)(CFG_SDRAM_BASE);
+
+	for (wr_dqs_shift = 64; wr_dqs_shift < 96; wr_dqs_shift++) {
+		/*for (wr_dqs_shift=1; wr_dqs_shift<96; wr_dqs_shift++) {*/
+
+		/* -----------------------------------------------------------+
+		 * De-assert 'start' parameter.
+		 * ----------------------------------------------------------*/
+		mtdcr(ddrcfga, DDR0_02);
+		val = (mfdcr(ddrcfgd) & ~DDR0_02_START_MASK) | DDR0_02_START_OFF;
+		mtdcr(ddrcfgd, val);
+
+		/* -----------------------------------------------------------+
+		 * Set 'wr_dqs_shift'
+		 * ----------------------------------------------------------*/
+		mtdcr(ddrcfga, DDR0_09);
+		val = (mfdcr(ddrcfgd) & ~DDR0_09_WR_DQS_SHIFT_MASK)
+			| DDR0_09_WR_DQS_SHIFT_ENCODE(wr_dqs_shift);
+		mtdcr(ddrcfgd, val);
+
+		/* -----------------------------------------------------------+
+		 * Set 'dqs_out_shift' = wr_dqs_shift + 32
+		 * ----------------------------------------------------------*/
+		dqs_out_shift = wr_dqs_shift + 32;
+		mtdcr(ddrcfga, DDR0_22);
+		val = (mfdcr(ddrcfgd) & ~DDR0_22_DQS_OUT_SHIFT_MASK)
+			| DDR0_22_DQS_OUT_SHIFT_ENCODE(dqs_out_shift);
+		mtdcr(ddrcfgd, val);
+
+		passing_cases = 0;
+
+		for (dll_dqs_delay_X = 1; dll_dqs_delay_X < 64; dll_dqs_delay_X++) {
+			/*for (dll_dqs_delay_X=1; dll_dqs_delay_X<128; dll_dqs_delay_X++) {*/
+			/* -----------------------------------------------------------+
+			 * Set 'dll_dqs_delay_X'.
+			 * ----------------------------------------------------------*/
+			/* dll_dqs_delay_0 */
+			mtdcr(ddrcfga, DDR0_17);
+			val = (mfdcr(ddrcfgd) & ~DDR0_17_DLL_DQS_DELAY_0_MASK)
+				| DDR0_17_DLL_DQS_DELAY_0_ENCODE(dll_dqs_delay_X);
+			mtdcr(ddrcfgd, val);
+			/* dll_dqs_delay_1 to dll_dqs_delay_4 */
+			mtdcr(ddrcfga, DDR0_18);
+			val = (mfdcr(ddrcfgd) & ~DDR0_18_DLL_DQS_DELAY_X_MASK)
+				| DDR0_18_DLL_DQS_DELAY_4_ENCODE(dll_dqs_delay_X)
+				| DDR0_18_DLL_DQS_DELAY_3_ENCODE(dll_dqs_delay_X)
+				| DDR0_18_DLL_DQS_DELAY_2_ENCODE(dll_dqs_delay_X)
+				| DDR0_18_DLL_DQS_DELAY_1_ENCODE(dll_dqs_delay_X);
+			mtdcr(ddrcfgd, val);
+			/* dll_dqs_delay_5 to dll_dqs_delay_8 */
+			mtdcr(ddrcfga, DDR0_19);
+			val = (mfdcr(ddrcfgd) & ~DDR0_19_DLL_DQS_DELAY_X_MASK)
+				| DDR0_19_DLL_DQS_DELAY_8_ENCODE(dll_dqs_delay_X)
+				| DDR0_19_DLL_DQS_DELAY_7_ENCODE(dll_dqs_delay_X)
+				| DDR0_19_DLL_DQS_DELAY_6_ENCODE(dll_dqs_delay_X)
+				| DDR0_19_DLL_DQS_DELAY_5_ENCODE(dll_dqs_delay_X);
+			mtdcr(ddrcfgd, val);
+
+			ppcMsync();
+			ppcMbar();
+
+			/* -----------------------------------------------------------+
+			 * Assert 'start' parameter.
+			 * ----------------------------------------------------------*/
+			mtdcr(ddrcfga, DDR0_02);
+			val = (mfdcr(ddrcfgd) & ~DDR0_02_START_MASK) | DDR0_02_START_ON;
+			mtdcr(ddrcfgd, val);
+
+			ppcMsync();
+			ppcMbar();
+
+			/* -----------------------------------------------------------+
+			 * Wait for the DCC master delay line to finish calibration
+			 * ----------------------------------------------------------*/
+			if (wait_for_dlllock() != 0) {
+				printf("dlllock did not occur !!!\n");
+				printf("denali_core_search_data_eye!!!\n");
+				printf("wr_dqs_shift = %d - dll_dqs_delay_X = %d\n",
+				       wr_dqs_shift, dll_dqs_delay_X);
+				hang();
+			}
+			ppcMsync();
+			ppcMbar();
+
+			if (wait_for_dram_init_complete() != 0) {
+				printf("dram init complete did not occur !!!\n");
+				printf("denali_core_search_data_eye!!!\n");
+				printf("wr_dqs_shift = %d - dll_dqs_delay_X = %d\n",
+				       wr_dqs_shift, dll_dqs_delay_X);
+				hang();
+			}
+			udelay(100);  /* wait 100us to ensure init is really completed !!! */
+
+			/* write values */
+			for (j=0; j<NUM_TRIES; j++) {
+				ram_pointer[j] = test[j];
+
+				/* clear any cache at ram location */
+				__asm__("dcbf 0,%0": :"r" (&ram_pointer[j]));
+			}
+
+			/* read values back */
+			for (j=0; j<NUM_TRIES; j++) {
+				for (k=0; k<NUM_READS; k++) {
+					/* clear any cache at ram location */
+					__asm__("dcbf 0,%0": :"r" (&ram_pointer[j]));
+
+					if (ram_pointer[j] != test[j])
+						break;
+				}
+
+				/* read error */
+				if (k != NUM_READS)
+					break;
+			}
+
+			/* See if the dll_dqs_delay_X value passed.*/
+			if (j < NUM_TRIES) {
+				/* Failed */
+				passing_cases = 0;
+				/* break; */
+			} else {
+				/* Passed */
+				if (passing_cases == 0)
+					dll_dqs_delay_X_sw_val = dll_dqs_delay_X;
+				passing_cases++;
+				if (passing_cases >= max_passing_cases) {
+					max_passing_cases = passing_cases;
+					wr_dqs_shift_with_max_passing_cases = wr_dqs_shift;
+					dll_dqs_delay_X_start_window = dll_dqs_delay_X_sw_val;
+					dll_dqs_delay_X_end_window = dll_dqs_delay_X;
+				}
+			}
+
+			/* -----------------------------------------------------------+
+			 * De-assert 'start' parameter.
+			 * ----------------------------------------------------------*/
+			mtdcr(ddrcfga, DDR0_02);
+			val = (mfdcr(ddrcfgd) & ~DDR0_02_START_MASK) | DDR0_02_START_OFF;
+			mtdcr(ddrcfgd, val);
+
+		} /* for (dll_dqs_delay_X=0; dll_dqs_delay_X<128; dll_dqs_delay_X++) */
+
+	} /* for (wr_dqs_shift=0; wr_dqs_shift<96; wr_dqs_shift++) */
+
+	/* -----------------------------------------------------------+
+	 * Largest passing window is now detected.
+	 * ----------------------------------------------------------*/
+
+	/* Compute dll_dqs_delay_X value */
+	dll_dqs_delay_X = (dll_dqs_delay_X_end_window + dll_dqs_delay_X_start_window) / 2;
+	wr_dqs_shift = wr_dqs_shift_with_max_passing_cases;
+
+	debug("DQS calibration - Window detected:\n");
+	debug("max_passing_cases = %d\n", max_passing_cases);
+	debug("wr_dqs_shift      = %d\n", wr_dqs_shift);
+	debug("dll_dqs_delay_X   = %d\n", dll_dqs_delay_X);
+	debug("dll_dqs_delay_X window = %d - %d\n",
+	       dll_dqs_delay_X_start_window, dll_dqs_delay_X_end_window);
+
+	/* -----------------------------------------------------------+
+	 * De-assert 'start' parameter.
+	 * ----------------------------------------------------------*/
+	mtdcr(ddrcfga, DDR0_02);
+	val = (mfdcr(ddrcfgd) & ~DDR0_02_START_MASK) | DDR0_02_START_OFF;
+	mtdcr(ddrcfgd, val);
+
+	/* -----------------------------------------------------------+
+	 * Set 'wr_dqs_shift'
+	 * ----------------------------------------------------------*/
+	mtdcr(ddrcfga, DDR0_09);
+	val = (mfdcr(ddrcfgd) & ~DDR0_09_WR_DQS_SHIFT_MASK)
+		| DDR0_09_WR_DQS_SHIFT_ENCODE(wr_dqs_shift);
+	mtdcr(ddrcfgd, val);
+	debug("DDR0_09=0x%08lx\n", val);
+
+	/* -----------------------------------------------------------+
+	 * Set 'dqs_out_shift' = wr_dqs_shift + 32
+	 * ----------------------------------------------------------*/
+	dqs_out_shift = wr_dqs_shift + 32;
+	mtdcr(ddrcfga, DDR0_22);
+	val = (mfdcr(ddrcfgd) & ~DDR0_22_DQS_OUT_SHIFT_MASK)
+		| DDR0_22_DQS_OUT_SHIFT_ENCODE(dqs_out_shift);
+	mtdcr(ddrcfgd, val);
+	debug("DDR0_22=0x%08lx\n", val);
+
+	/* -----------------------------------------------------------+
+	 * Set 'dll_dqs_delay_X'.
+	 * ----------------------------------------------------------*/
+	/* dll_dqs_delay_0 */
+	mtdcr(ddrcfga, DDR0_17);
+	val = (mfdcr(ddrcfgd) & ~DDR0_17_DLL_DQS_DELAY_0_MASK)
+		| DDR0_17_DLL_DQS_DELAY_0_ENCODE(dll_dqs_delay_X);
+	mtdcr(ddrcfgd, val);
+	debug("DDR0_17=0x%08lx\n", val);
+
+	/* dll_dqs_delay_1 to dll_dqs_delay_4 */
+	mtdcr(ddrcfga, DDR0_18);
+	val = (mfdcr(ddrcfgd) & ~DDR0_18_DLL_DQS_DELAY_X_MASK)
+		| DDR0_18_DLL_DQS_DELAY_4_ENCODE(dll_dqs_delay_X)
+		| DDR0_18_DLL_DQS_DELAY_3_ENCODE(dll_dqs_delay_X)
+		| DDR0_18_DLL_DQS_DELAY_2_ENCODE(dll_dqs_delay_X)
+		| DDR0_18_DLL_DQS_DELAY_1_ENCODE(dll_dqs_delay_X);
+	mtdcr(ddrcfgd, val);
+	debug("DDR0_18=0x%08lx\n", val);
+
+	/* dll_dqs_delay_5 to dll_dqs_delay_8 */
+	mtdcr(ddrcfga, DDR0_19);
+	val = (mfdcr(ddrcfgd) & ~DDR0_19_DLL_DQS_DELAY_X_MASK)
+		| DDR0_19_DLL_DQS_DELAY_8_ENCODE(dll_dqs_delay_X)
+		| DDR0_19_DLL_DQS_DELAY_7_ENCODE(dll_dqs_delay_X)
+		| DDR0_19_DLL_DQS_DELAY_6_ENCODE(dll_dqs_delay_X)
+		| DDR0_19_DLL_DQS_DELAY_5_ENCODE(dll_dqs_delay_X);
+	mtdcr(ddrcfgd, val);
+	debug("DDR0_19=0x%08lx\n", val);
+
+	/* -----------------------------------------------------------+
+	 * Assert 'start' parameter.
+	 * ----------------------------------------------------------*/
+	mtdcr(ddrcfga, DDR0_02);
+	val = (mfdcr(ddrcfgd) & ~DDR0_02_START_MASK) | DDR0_02_START_ON;
+	mtdcr(ddrcfgd, val);
+
+	ppcMsync();
+	ppcMbar();
+
+	/* -----------------------------------------------------------+
+	 * Wait for the DCC master delay line to finish calibration
+	 * ----------------------------------------------------------*/
+	if (wait_for_dlllock() != 0) {
+		printf("dlllock did not occur !!!\n");
+		hang();
+	}
+	ppcMsync();
+	ppcMbar();
+
+	if (wait_for_dram_init_complete() != 0) {
+		printf("dram init complete did not occur !!!\n");
+		hang();
+	}
+	udelay(100);  /* wait 100us to ensure init is really completed !!! */
+}
+#endif /* CONFIG_DDR_DATA_EYE */
+
+/*************************************************************************
+ *
+ * initdram -- 440EPx's DDR controller is a DENALI Core
+ *
+ ************************************************************************/
+long int initdram (int board_type)
+{
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+	mtsdram(DDR0_02, 0x00000000);
+
+	mtsdram(DDR0_00, 0x0000190A);
+	mtsdram(DDR0_01, 0x01000000);
+	mtsdram(DDR0_03, 0x02030602);
+	mtsdram(DDR0_04, 0x13030300);
+	mtsdram(DDR0_05, 0x0202050E);
+	mtsdram(DDR0_06, 0x0104C823);
+	mtsdram(DDR0_07, 0x000D0100);
+	mtsdram(DDR0_08, 0x02360001);
+	mtsdram(DDR0_09, 0x00011D5F);
+	mtsdram(DDR0_10, 0x00000300);
+	mtsdram(DDR0_11, 0x0027C800);
+	mtsdram(DDR0_12, 0x00000003);
+#ifdef CONFIG_SHASTA
+	// 32-bit addressing
+	mtsdram(DDR0_14, 0x00010000);
+#else
+	// 64-bit addressing
+	mtsdram(DDR0_14, 0x00000000);
+#endif
+	mtsdram(DDR0_17, 0x19000000);
+	mtsdram(DDR0_18, 0x19191919);
+	mtsdram(DDR0_19, 0x19191919);
+	mtsdram(DDR0_20, 0x0B0B0B0B);
+	mtsdram(DDR0_21, 0x0B0B0B0B);
+	mtsdram(DDR0_22, 0x00267F0B);
+	mtsdram(DDR0_23, 0x00000000);
+	mtsdram(DDR0_24, 0x01010002);
+	mtsdram(DDR0_26, 0x5B260181);
+	mtsdram(DDR0_27, 0x0000682B);
+	mtsdram(DDR0_28, 0x00000000);
+	mtsdram(DDR0_31, 0x00000000);
+	mtsdram(DDR0_42, 0x01000006);
+	mtsdram(DDR0_43, 0x050A0200);
+	mtsdram(DDR0_44, 0x00000005);
+	mtsdram(DDR0_02, 0x00000001);
+
+	wait_for_dlllock();
+#endif /* #ifndef CONFIG_NAND_U_BOOT */
+
+#ifdef CONFIG_DDR_DATA_EYE
+	/* -----------------------------------------------------------+
+	 * Perform data eye search if requested.
+	 * ----------------------------------------------------------*/
+	denali_core_search_data_eye(CFG_MBYTES_SDRAM << 20);
+#endif
+
+	return (CFG_MBYTES_SDRAM << 20);
+}
Index: u-boot-1.2.0/board/avocent/golden_gate/sdram.h
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/sdram.h
@@ -0,0 +1,508 @@
+/*
+ * (C) Copyright 2006
+ * Sylvie Gohl,             AMCC/IBM, gohl.sylvie@fr.ibm.com
+ * Jacqueline Pira-Ferriol, AMCC/IBM, jpira-ferriol@fr.ibm.com
+ * Thierry Roman,           AMCC/IBM, thierry_roman@fr.ibm.com
+ * Alain Saurel,            AMCC/IBM, alain.saurel@fr.ibm.com
+ * Robert Snyder,           AMCC/IBM, rob.snyder@fr.ibm.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SPD_SDRAM_DENALI_H_
+#define _SPD_SDRAM_DENALI_H_
+
+#define ppcMsync	sync
+#define ppcMbar		eieio
+
+/* General definitions */
+#define MAX_SPD_BYTE        128         /* highest SPD byte # to read */
+#define DENALI_REG_NUMBER   45          /* 45 Regs in PPC440EPx Denali Core */
+#define SUPPORTED_DIMMS_NB  7           /* Number of supported DIMM modules types */
+#define SDRAM_NONE          0           /* No DIMM detected in Slot */
+#define MAXRANKS            2           /* 2 ranks maximum */
+
+/* Supported PLB Frequencies */
+#define PLB_FREQ_133MHZ     133333333
+#define PLB_FREQ_152MHZ     152000000
+#define PLB_FREQ_160MHZ     160000000
+#define PLB_FREQ_166MHZ     166666666
+
+/* Denali Core Registers */
+#define SDRAM_DCR_BASE 0x10
+
+#define DDR_DCR_BASE 0x10
+#define ddrcfga  (DDR_DCR_BASE+0x0)   /* DDR configuration address reg */
+#define ddrcfgd  (DDR_DCR_BASE+0x1)   /* DDR configuration data reg    */
+
+/*-----------------------------------------------------------------------------+
+  | Values for ddrcfga register - indirect addressing of these regs
+  +-----------------------------------------------------------------------------*/
+
+#define DDR0_00                         0x00
+#define DDR0_00_INT_ACK_MASK              0x7F000000 /* Write only */
+#define DDR0_00_INT_ACK_ALL               0x7F000000
+#define DDR0_00_INT_ACK_ENCODE(n)           ((((unsigned long)(n))&0x7F)<<24)
+#define DDR0_00_INT_ACK_DECODE(n)           ((((unsigned long)(n))>>24)&0x7F)
+/* Status */
+#define DDR0_00_INT_STATUS_MASK           0x00FF0000 /* Read only */
+/* Bit0. A single access outside the defined PHYSICAL memory space detected. */
+#define DDR0_00_INT_STATUS_BIT0           0x00010000
+/* Bit1. Multiple accesses outside the defined PHYSICAL memory space detected. */
+#define DDR0_00_INT_STATUS_BIT1           0x00020000
+/* Bit2. Single correctable ECC event detected */
+#define DDR0_00_INT_STATUS_BIT2           0x00040000
+/* Bit3. Multiple correctable ECC events detected. */
+#define DDR0_00_INT_STATUS_BIT3           0x00080000
+/* Bit4. Single uncorrectable ECC event detected. */
+#define DDR0_00_INT_STATUS_BIT4           0x00100000
+/* Bit5. Multiple uncorrectable ECC events detected. */
+#define DDR0_00_INT_STATUS_BIT5           0x00200000
+/* Bit6. DRAM initialization complete. */
+#define DDR0_00_INT_STATUS_BIT6           0x00400000
+/* Bit7. Logical OR of all lower bits. */
+#define DDR0_00_INT_STATUS_BIT7           0x00800000
+
+#define DDR0_00_INT_STATUS_ENCODE(n)        ((((unsigned long)(n))&0xFF)<<16)
+#define DDR0_00_INT_STATUS_DECODE(n)        ((((unsigned long)(n))>>16)&0xFF)
+#define DDR0_00_DLL_INCREMENT_MASK        0x00007F00
+#define DDR0_00_DLL_INCREMENT_ENCODE(n)     ((((unsigned long)(n))&0x7F)<<8)
+#define DDR0_00_DLL_INCREMENT_DECODE(n)     ((((unsigned long)(n))>>8)&0x7F)
+#define DDR0_00_DLL_START_POINT_MASK      0x0000007F
+#define DDR0_00_DLL_START_POINT_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<0)
+#define DDR0_00_DLL_START_POINT_DECODE(n)   ((((unsigned long)(n))>>0)&0x7F)
+
+
+
+#define DDR0_01                         0x01
+#define DDR0_01_PLB0_DB_CS_LOWER_MASK     0x1F000000
+#define DDR0_01_PLB0_DB_CS_LOWER_ENCODE(n)  ((((unsigned long)(n))&0x1F)<<24)
+#define DDR0_01_PLB0_DB_CS_LOWER_DECODE(n)  ((((unsigned long)(n))>>24)&0x1F)
+#define DDR0_01_PLB0_DB_CS_UPPER_MASK     0x001F0000
+#define DDR0_01_PLB0_DB_CS_UPPER_ENCODE(n)  ((((unsigned long)(n))&0x1F)<<16)
+#define DDR0_01_PLB0_DB_CS_UPPER_DECODE(n)  ((((unsigned long)(n))>>16)&0x1F)
+#define DDR0_01_OUT_OF_RANGE_TYPE_MASK    0x00000700 /* Read only */
+#define DDR0_01_OUT_OF_RANGE_TYPE_ENCODE(n)               ((((unsigned long)(n))&0x7)<<8)
+#define DDR0_01_OUT_OF_RANGE_TYPE_DECODE(n)               ((((unsigned long)(n))>>8)&0x7)
+#define DDR0_01_INT_MASK_MASK             0x000000FF
+#define DDR0_01_INT_MASK_ENCODE(n)          ((((unsigned long)(n))&0xFF)<<0)
+#define DDR0_01_INT_MASK_DECODE(n)          ((((unsigned long)(n))>>0)&0xFF)
+#define DDR0_01_INT_MASK_ALL_ON           0x000000FF
+#define DDR0_01_INT_MASK_ALL_OFF          0x00000000
+
+#define DDR0_02                         0x02
+#define DDR0_02_MAX_CS_REG_MASK           0x02000000 /* Read only */
+#define DDR0_02_MAX_CS_REG_ENCODE(n)        ((((unsigned long)(n))&0x2)<<24)
+#define DDR0_02_MAX_CS_REG_DECODE(n)        ((((unsigned long)(n))>>24)&0x2)
+#define DDR0_02_MAX_COL_REG_MASK          0x000F0000 /* Read only */
+#define DDR0_02_MAX_COL_REG_ENCODE(n)       ((((unsigned long)(n))&0xF)<<16)
+#define DDR0_02_MAX_COL_REG_DECODE(n)       ((((unsigned long)(n))>>16)&0xF)
+#define DDR0_02_MAX_ROW_REG_MASK          0x00000F00 /* Read only */
+#define DDR0_02_MAX_ROW_REG_ENCODE(n)       ((((unsigned long)(n))&0xF)<<8)
+#define DDR0_02_MAX_ROW_REG_DECODE(n)       ((((unsigned long)(n))>>8)&0xF)
+#define DDR0_02_START_MASK                0x00000001
+#define DDR0_02_START_ENCODE(n)             ((((unsigned long)(n))&0x1)<<0)
+#define DDR0_02_START_DECODE(n)             ((((unsigned long)(n))>>0)&0x1)
+#define DDR0_02_START_OFF                 0x00000000
+#define DDR0_02_START_ON                  0x00000001
+
+#define DDR0_03                         0x03
+#define DDR0_03_BSTLEN_MASK               0x07000000
+#define DDR0_03_BSTLEN_ENCODE(n)            ((((unsigned long)(n))&0x7)<<24)
+#define DDR0_03_BSTLEN_DECODE(n)            ((((unsigned long)(n))>>24)&0x7)
+#define DDR0_03_CASLAT_MASK               0x00070000
+#define DDR0_03_CASLAT_ENCODE(n)            ((((unsigned long)(n))&0x7)<<16)
+#define DDR0_03_CASLAT_DECODE(n)            ((((unsigned long)(n))>>16)&0x7)
+#define DDR0_03_CASLAT_LIN_MASK           0x00000F00
+#define DDR0_03_CASLAT_LIN_ENCODE(n)        ((((unsigned long)(n))&0xF)<<8)
+#define DDR0_03_CASLAT_LIN_DECODE(n)        ((((unsigned long)(n))>>8)&0xF)
+#define DDR0_03_INITAREF_MASK             0x0000000F
+#define DDR0_03_INITAREF_ENCODE(n)          ((((unsigned long)(n))&0xF)<<0)
+#define DDR0_03_INITAREF_DECODE(n)          ((((unsigned long)(n))>>0)&0xF)
+
+#define DDR0_04                         0x04
+#define DDR0_04_TRC_MASK                  0x1F000000
+#define DDR0_04_TRC_ENCODE(n)               ((((unsigned long)(n))&0x1F)<<24)
+#define DDR0_04_TRC_DECODE(n)               ((((unsigned long)(n))>>24)&0x1F)
+#define DDR0_04_TRRD_MASK                 0x00070000
+#define DDR0_04_TRRD_ENCODE(n)              ((((unsigned long)(n))&0x7)<<16)
+#define DDR0_04_TRRD_DECODE(n)              ((((unsigned long)(n))>>16)&0x7)
+#define DDR0_04_TRTP_MASK                 0x00000700
+#define DDR0_04_TRTP_ENCODE(n)              ((((unsigned long)(n))&0x7)<<8)
+#define DDR0_04_TRTP_DECODE(n)              ((((unsigned long)(n))>>8)&0x7)
+
+#define DDR0_05                         0x05
+#define DDR0_05_TMRD_MASK                 0x1F000000
+#define DDR0_05_TMRD_ENCODE(n)              ((((unsigned long)(n))&0x1F)<<24)
+#define DDR0_05_TMRD_DECODE(n)              ((((unsigned long)(n))>>24)&0x1F)
+#define DDR0_05_TEMRS_MASK                0x00070000
+#define DDR0_05_TEMRS_ENCODE(n)             ((((unsigned long)(n))&0x7)<<16)
+#define DDR0_05_TEMRS_DECODE(n)             ((((unsigned long)(n))>>16)&0x7)
+#define DDR0_05_TRP_MASK                  0x00000F00
+#define DDR0_05_TRP_ENCODE(n)               ((((unsigned long)(n))&0xF)<<8)
+#define DDR0_05_TRP_DECODE(n)               ((((unsigned long)(n))>>8)&0xF)
+#define DDR0_05_TRAS_MIN_MASK             0x000000FF
+#define DDR0_05_TRAS_MIN_ENCODE(n)          ((((unsigned long)(n))&0xFF)<<0)
+#define DDR0_05_TRAS_MIN_DECODE(n)          ((((unsigned long)(n))>>0)&0xFF)
+
+#define DDR0_06                         0x06
+#define DDR0_06_WRITEINTERP_MASK          0x01000000
+#define DDR0_06_WRITEINTERP_ENCODE(n)       ((((unsigned long)(n))&0x1)<<24)
+#define DDR0_06_WRITEINTERP_DECODE(n)       ((((unsigned long)(n))>>24)&0x1)
+#define DDR0_06_TWTR_MASK                 0x00070000
+#define DDR0_06_TWTR_ENCODE(n)              ((((unsigned long)(n))&0x7)<<16)
+#define DDR0_06_TWTR_DECODE(n)              ((((unsigned long)(n))>>16)&0x7)
+#define DDR0_06_TDLL_MASK                 0x0000FF00
+#define DDR0_06_TDLL_ENCODE(n)              ((((unsigned long)(n))&0xFF)<<8)
+#define DDR0_06_TDLL_DECODE(n)              ((((unsigned long)(n))>>8)&0xFF)
+#define DDR0_06_TRFC_MASK                 0x0000007F
+#define DDR0_06_TRFC_ENCODE(n)              ((((unsigned long)(n))&0x7F)<<0)
+#define DDR0_06_TRFC_DECODE(n)              ((((unsigned long)(n))>>0)&0x7F)
+
+#define DDR0_07                         0x07
+#define DDR0_07_NO_CMD_INIT_MASK          0x01000000
+#define DDR0_07_NO_CMD_INIT_ENCODE(n)       ((((unsigned long)(n))&0x1)<<24)
+#define DDR0_07_NO_CMD_INIT_DECODE(n)       ((((unsigned long)(n))>>24)&0x1)
+#define DDR0_07_TFAW_MASK                 0x001F0000
+#define DDR0_07_TFAW_ENCODE(n)              ((((unsigned long)(n))&0x1F)<<16)
+#define DDR0_07_TFAW_DECODE(n)              ((((unsigned long)(n))>>16)&0x1F)
+#define DDR0_07_AUTO_REFRESH_MODE_MASK    0x00000100
+#define DDR0_07_AUTO_REFRESH_MODE_ENCODE(n) ((((unsigned long)(n))&0x1)<<8)
+#define DDR0_07_AUTO_REFRESH_MODE_DECODE(n) ((((unsigned long)(n))>>8)&0x1)
+#define DDR0_07_AREFRESH_MASK             0x00000001
+#define DDR0_07_AREFRESH_ENCODE(n)          ((((unsigned long)(n))&0x1)<<0)
+#define DDR0_07_AREFRESH_DECODE(n)          ((((unsigned long)(n))>>0)&0x1)
+
+#define DDR0_08                         0x08
+#define DDR0_08_WRLAT_MASK                0x07000000
+#define DDR0_08_WRLAT_ENCODE(n)             ((((unsigned long)(n))&0x7)<<24)
+#define DDR0_08_WRLAT_DECODE(n)             ((((unsigned long)(n))>>24)&0x7)
+#define DDR0_08_TCPD_MASK                 0x00FF0000
+#define DDR0_08_TCPD_ENCODE(n)              ((((unsigned long)(n))&0xFF)<<16)
+#define DDR0_08_TCPD_DECODE(n)              ((((unsigned long)(n))>>16)&0xFF)
+#define DDR0_08_DQS_N_EN_MASK             0x00000100
+#define DDR0_08_DQS_N_EN_ENCODE(n)          ((((unsigned long)(n))&0x1)<<8)
+#define DDR0_08_DQS_N_EN_DECODE(n)          ((((unsigned long)(n))>>8)&0x1)
+#define DDR0_08_DDRII_SDRAM_MODE_MASK     0x00000001
+#define DDR0_08_DDRII_ENCODE(n)             ((((unsigned long)(n))&0x1)<<0)
+#define DDR0_08_DDRII_DECODE(n)             ((((unsigned long)(n))>>0)&0x1)
+
+#define DDR0_09                         0x09
+#define DDR0_09_OCD_ADJUST_PDN_CS_0_MASK  0x1F000000
+#define DDR0_09_OCD_ADJUST_PDN_CS_0_ENCODE(n) ((((unsigned long)(n))&0x1F)<<24)
+#define DDR0_09_OCD_ADJUST_PDN_CS_0_DECODE(n) ((((unsigned long)(n))>>24)&0x1F)
+#define DDR0_09_RTT_0_MASK                0x00030000
+#define DDR0_09_RTT_0_ENCODE(n)             ((((unsigned long)(n))&0x3)<<16)
+#define DDR0_09_RTT_0_DECODE(n)             ((((unsigned long)(n))>>16)&0x3)
+#define DDR0_09_WR_DQS_SHIFT_BYPASS_MASK  0x00007F00
+#define DDR0_09_WR_DQS_SHIFT_BYPASS_ENCODE(n) ((((unsigned long)(n))&0x7F)<<8)
+#define DDR0_09_WR_DQS_SHIFT_BYPASS_DECODE(n) ((((unsigned long)(n))>>8)&0x7F)
+#define DDR0_09_WR_DQS_SHIFT_MASK         0x0000007F
+#define DDR0_09_WR_DQS_SHIFT_ENCODE(n)      ((((unsigned long)(n))&0x7F)<<0)
+#define DDR0_09_WR_DQS_SHIFT_DECODE(n)      ((((unsigned long)(n))>>0)&0x7F)
+
+#define DDR0_10                         0x0A
+#define DDR0_10_WRITE_MODEREG_MASK        0x00010000 /* Write only */
+#define DDR0_10_WRITE_MODEREG_ENCODE(n)     ((((unsigned long)(n))&0x1)<<16)
+#define DDR0_10_WRITE_MODEREG_DECODE(n)     ((((unsigned long)(n))>>16)&0x1)
+#define DDR0_10_CS_MAP_MASK               0x00000300
+#define DDR0_10_CS_MAP_NO_MEM             0x00000000
+#define DDR0_10_CS_MAP_RANK0_INSTALLED    0x00000100
+#define DDR0_10_CS_MAP_RANK1_INSTALLED    0x00000200
+#define DDR0_10_CS_MAP_ENCODE(n)            ((((unsigned long)(n))&0x3)<<8)
+#define DDR0_10_CS_MAP_DECODE(n)            ((((unsigned long)(n))>>8)&0x3)
+#define DDR0_10_OCD_ADJUST_PUP_CS_0_MASK  0x0000001F
+#define DDR0_10_OCD_ADJUST_PUP_CS_0_ENCODE(n) ((((unsigned long)(n))&0x1F)<<0)
+#define DDR0_10_OCD_ADJUST_PUP_CS_0_DECODE(n) ((((unsigned long)(n))>>0)&0x1F)
+
+#define DDR0_11                         0x0B
+#define DDR0_11_SREFRESH_MASK             0x01000000
+#define DDR0_11_SREFRESH_ENCODE(n)          ((((unsigned long)(n))&0x1)<<24)
+#define DDR0_11_SREFRESH_DECODE(n)          ((((unsigned long)(n))>>24)&0x1F)
+#define DDR0_11_TXSNR_MASK                0x00FF0000
+#define DDR0_11_TXSNR_ENCODE(n)             ((((unsigned long)(n))&0xFF)<<16)
+#define DDR0_11_TXSNR_DECODE(n)             ((((unsigned long)(n))>>16)&0xFF)
+#define DDR0_11_TXSR_MASK                 0x0000FF00
+#define DDR0_11_TXSR_ENCODE(n)              ((((unsigned long)(n))&0xFF)<<8)
+#define DDR0_11_TXSR_DECODE(n)              ((((unsigned long)(n))>>8)&0xFF)
+
+#define DDR0_12                         0x0C
+#define DDR0_12_TCKE_MASK                 0x0000007
+#define DDR0_12_TCKE_ENCODE(n)              ((((unsigned long)(n))&0x7)<<0)
+#define DDR0_12_TCKE_DECODE(n)              ((((unsigned long)(n))>>0)&0x7)
+
+#define DDR0_13                         0x0D
+
+#define DDR0_14                         0x0E
+#define DDR0_14_DLL_BYPASS_MODE_MASK      0x01000000
+#define DDR0_14_DLL_BYPASS_MODE_ENCODE(n)   ((((unsigned long)(n))&0x1)<<24)
+#define DDR0_14_DLL_BYPASS_MODE_DECODE(n)   ((((unsigned long)(n))>>24)&0x1)
+#define DDR0_14_REDUC_MASK                0x00010000
+#define DDR0_14_REDUC_64BITS              0x00000000
+#define DDR0_14_REDUC_32BITS              0x00010000
+#define DDR0_14_REDUC_ENCODE(n)             ((((unsigned long)(n))&0x1)<<16)
+#define DDR0_14_REDUC_DECODE(n)             ((((unsigned long)(n))>>16)&0x1)
+#define DDR0_14_REG_DIMM_ENABLE_MASK      0x00000100
+#define DDR0_14_REG_DIMM_ENABLE_ENCODE(n)   ((((unsigned long)(n))&0x1)<<8)
+#define DDR0_14_REG_DIMM_ENABLE_DECODE(n)   ((((unsigned long)(n))>>8)&0x1)
+
+#define DDR0_15                         0x0F
+
+#define DDR0_16                         0x10
+
+#define DDR0_17                         0x11
+#define DDR0_17_DLL_DQS_DELAY_0_MASK      0x7F000000
+#define DDR0_17_DLL_DQS_DELAY_0_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<24)
+#define DDR0_17_DLL_DQS_DELAY_0_DECODE(n)   ((((unsigned long)(n))>>24)&0x7F)
+#define DDR0_17_DLLLOCKREG_MASK           0x00010000 /* Read only */
+#define DDR0_17_DLLLOCKREG_LOCKED         0x00010000
+#define DDR0_17_DLLLOCKREG_UNLOCKED       0x00000000
+#define DDR0_17_DLLLOCKREG_ENCODE(n)        ((((unsigned long)(n))&0x1)<<16)
+#define DDR0_17_DLLLOCKREG_DECODE(n)        ((((unsigned long)(n))>>16)&0x1)
+#define DDR0_17_DLL_LOCK_MASK             0x00007F00 /* Read only */
+#define DDR0_17_DLL_LOCK_ENCODE(n)          ((((unsigned long)(n))&0x7F)<<8)
+#define DDR0_17_DLL_LOCK_DECODE(n)          ((((unsigned long)(n))>>8)&0x7F)
+
+#define DDR0_18                         0x12
+#define DDR0_18_DLL_DQS_DELAY_X_MASK      0x7F7F7F7F
+#define DDR0_18_DLL_DQS_DELAY_4_MASK      0x7F000000
+#define DDR0_18_DLL_DQS_DELAY_4_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<24)
+#define DDR0_18_DLL_DQS_DELAY_4_DECODE(n)   ((((unsigned long)(n))>>24)&0x7F)
+#define DDR0_18_DLL_DQS_DELAY_3_MASK      0x007F0000
+#define DDR0_18_DLL_DQS_DELAY_3_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<16)
+#define DDR0_18_DLL_DQS_DELAY_3_DECODE(n)   ((((unsigned long)(n))>>16)&0x7F)
+#define DDR0_18_DLL_DQS_DELAY_2_MASK      0x00007F00
+#define DDR0_18_DLL_DQS_DELAY_2_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<8)
+#define DDR0_18_DLL_DQS_DELAY_2_DECODE(n)   ((((unsigned long)(n))>>8)&0x7F)
+#define DDR0_18_DLL_DQS_DELAY_1_MASK      0x0000007F
+#define DDR0_18_DLL_DQS_DELAY_1_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<0)
+#define DDR0_18_DLL_DQS_DELAY_1_DECODE(n)   ((((unsigned long)(n))>>0)&0x7F)
+
+#define DDR0_19                         0x13
+#define DDR0_19_DLL_DQS_DELAY_X_MASK      0x7F7F7F7F
+#define DDR0_19_DLL_DQS_DELAY_8_MASK      0x7F000000
+#define DDR0_19_DLL_DQS_DELAY_8_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<24)
+#define DDR0_19_DLL_DQS_DELAY_8_DECODE(n)   ((((unsigned long)(n))>>24)&0x7F)
+#define DDR0_19_DLL_DQS_DELAY_7_MASK      0x007F0000
+#define DDR0_19_DLL_DQS_DELAY_7_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<16)
+#define DDR0_19_DLL_DQS_DELAY_7_DECODE(n)   ((((unsigned long)(n))>>16)&0x7F)
+#define DDR0_19_DLL_DQS_DELAY_6_MASK      0x00007F00
+#define DDR0_19_DLL_DQS_DELAY_6_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<8)
+#define DDR0_19_DLL_DQS_DELAY_6_DECODE(n)   ((((unsigned long)(n))>>8)&0x7F)
+#define DDR0_19_DLL_DQS_DELAY_5_MASK      0x0000007F
+#define DDR0_19_DLL_DQS_DELAY_5_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<0)
+#define DDR0_19_DLL_DQS_DELAY_5_DECODE(n)   ((((unsigned long)(n))>>0)&0x7F)
+
+#define DDR0_20                         0x14
+#define DDR0_20_DLL_DQS_BYPASS_3_MASK      0x7F000000
+#define DDR0_20_DLL_DQS_BYPASS_3_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<24)
+#define DDR0_20_DLL_DQS_BYPASS_3_DECODE(n)   ((((unsigned long)(n))>>24)&0x7F)
+#define DDR0_20_DLL_DQS_BYPASS_2_MASK      0x007F0000
+#define DDR0_20_DLL_DQS_BYPASS_2_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<16)
+#define DDR0_20_DLL_DQS_BYPASS_2_DECODE(n)   ((((unsigned long)(n))>>16)&0x7F)
+#define DDR0_20_DLL_DQS_BYPASS_1_MASK      0x00007F00
+#define DDR0_20_DLL_DQS_BYPASS_1_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<8)
+#define DDR0_20_DLL_DQS_BYPASS_1_DECODE(n)   ((((unsigned long)(n))>>8)&0x7F)
+#define DDR0_20_DLL_DQS_BYPASS_0_MASK      0x0000007F
+#define DDR0_20_DLL_DQS_BYPASS_0_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<0)
+#define DDR0_20_DLL_DQS_BYPASS_0_DECODE(n)   ((((unsigned long)(n))>>0)&0x7F)
+
+#define DDR0_21                         0x15
+#define DDR0_21_DLL_DQS_BYPASS_7_MASK      0x7F000000
+#define DDR0_21_DLL_DQS_BYPASS_7_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<24)
+#define DDR0_21_DLL_DQS_BYPASS_7_DECODE(n)   ((((unsigned long)(n))>>24)&0x7F)
+#define DDR0_21_DLL_DQS_BYPASS_6_MASK      0x007F0000
+#define DDR0_21_DLL_DQS_BYPASS_6_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<16)
+#define DDR0_21_DLL_DQS_BYPASS_6_DECODE(n)   ((((unsigned long)(n))>>16)&0x7F)
+#define DDR0_21_DLL_DQS_BYPASS_5_MASK      0x00007F00
+#define DDR0_21_DLL_DQS_BYPASS_5_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<8)
+#define DDR0_21_DLL_DQS_BYPASS_5_DECODE(n)   ((((unsigned long)(n))>>8)&0x7F)
+#define DDR0_21_DLL_DQS_BYPASS_4_MASK      0x0000007F
+#define DDR0_21_DLL_DQS_BYPASS_4_ENCODE(n)   ((((unsigned long)(n))&0x7F)<<0)
+#define DDR0_21_DLL_DQS_BYPASS_4_DECODE(n)   ((((unsigned long)(n))>>0)&0x7F)
+
+#define DDR0_22                         0x16
+/* ECC */
+#define DDR0_22_CTRL_RAW_MASK             0x03000000
+#define DDR0_22_CTRL_RAW_ECC_DISABLE      0x00000000 /* ECC not being used */
+#define DDR0_22_CTRL_RAW_ECC_CHECK_ONLY   0x01000000 /* ECC checking is on, but no attempts to correct*/
+#define DDR0_22_CTRL_RAW_NO_ECC_RAM       0x02000000 /* No ECC RAM storage available */
+#define DDR0_22_CTRL_RAW_ECC_ENABLE       0x03000000 /* ECC checking and correcting on */
+#define DDR0_22_CTRL_RAW_ENCODE(n)          ((((unsigned long)(n))&0x3)<<24)
+#define DDR0_22_CTRL_RAW_DECODE(n)          ((((unsigned long)(n))>>24)&0x3)
+
+#define DDR0_22_DQS_OUT_SHIFT_BYPASS_MASK 0x007F0000
+#define DDR0_22_DQS_OUT_SHIFT_BYPASS_ENCODE(n) ((((unsigned long)(n))&0x7F)<<16)
+#define DDR0_22_DQS_OUT_SHIFT_BYPASS_DECODE(n) ((((unsigned long)(n))>>16)&0x7F)
+#define DDR0_22_DQS_OUT_SHIFT_MASK        0x00007F00
+#define DDR0_22_DQS_OUT_SHIFT_ENCODE(n)     ((((unsigned long)(n))&0x7F)<<8)
+#define DDR0_22_DQS_OUT_SHIFT_DECODE(n)     ((((unsigned long)(n))>>8)&0x7F)
+#define DDR0_22_DLL_DQS_BYPASS_8_MASK     0x0000007F
+#define DDR0_22_DLL_DQS_BYPASS_8_ENCODE(n)  ((((unsigned long)(n))&0x7F)<<0)
+#define DDR0_22_DLL_DQS_BYPASS_8_DECODE(n)  ((((unsigned long)(n))>>0)&0x7F)
+
+
+
+
+#define DDR0_23                         0x17
+#define DDR0_23_ODT_RD_MAP_CS0_MASK       0x03000000
+#define DDR0_23_ODT_RD_MAP_CS0_ENCODE(n)   ((((unsigned long)(n))&0x3)<<24)
+#define DDR0_23_ODT_RD_MAP_CS0_DECODE(n)   ((((unsigned long)(n))>>24)&0x3)
+#define DDR0_23_ECC_C_SYND_MASK           0x00FF0000 /* Read only */
+#define DDR0_23_ECC_C_SYND_ENCODE(n)        ((((unsigned long)(n))&0xFF)<<16)
+#define DDR0_23_ECC_C_SYND_DECODE(n)        ((((unsigned long)(n))>>16)&0xFF)
+#define DDR0_23_ECC_U_SYND_MASK           0x0000FF00 /* Read only */
+#define DDR0_23_ECC_U_SYND_ENCODE(n)        ((((unsigned long)(n))&0xFF)<<8)
+#define DDR0_23_ECC_U_SYND_DECODE(n)        ((((unsigned long)(n))>>8)&0xFF)
+#define DDR0_23_FWC_MASK                  0x00000001 /* Write only */
+#define DDR0_23_FWC_ENCODE(n)               ((((unsigned long)(n))&0x1)<<0)
+#define DDR0_23_FWC_DECODE(n)               ((((unsigned long)(n))>>0)&0x1)
+
+#define DDR0_24                         0x18
+#define DDR0_24_RTT_PAD_TERMINATION_MASK  0x03000000
+#define DDR0_24_RTT_PAD_TERMINATION_ENCODE(n) ((((unsigned long)(n))&0x3)<<24)
+#define DDR0_24_RTT_PAD_TERMINATION_DECODE(n) ((((unsigned long)(n))>>24)&0x3)
+#define DDR0_24_ODT_WR_MAP_CS1_MASK       0x00030000
+#define DDR0_24_ODT_WR_MAP_CS1_ENCODE(n)    ((((unsigned long)(n))&0x3)<<16)
+#define DDR0_24_ODT_WR_MAP_CS1_DECODE(n)    ((((unsigned long)(n))>>16)&0x3)
+#define DDR0_24_ODT_RD_MAP_CS1_MASK       0x00000300
+#define DDR0_24_ODT_RD_MAP_CS1_ENCODE(n)    ((((unsigned long)(n))&0x3)<<8)
+#define DDR0_24_ODT_RD_MAP_CS1_DECODE(n)    ((((unsigned long)(n))>>8)&0x3)
+#define DDR0_24_ODT_WR_MAP_CS0_MASK       0x00000003
+#define DDR0_24_ODT_WR_MAP_CS0_ENCODE(n)    ((((unsigned long)(n))&0x3)<<0)
+#define DDR0_24_ODT_WR_MAP_CS0_DECODE(n)    ((((unsigned long)(n))>>0)&0x3)
+
+#define DDR0_25                         0x19
+#define DDR0_25_VERSION_MASK              0xFFFF0000 /* Read only */
+#define DDR0_25_VERSION_ENCODE(n)           ((((unsigned long)(n))&0xFFFF)<<16)
+#define DDR0_25_VERSION_DECODE(n)           ((((unsigned long)(n))>>16)&0xFFFF)
+#define DDR0_25_OUT_OF_RANGE_LENGTH_MASK  0x000003FF /* Read only */
+#define DDR0_25_OUT_OF_RANGE_LENGTH_ENCODE(n) ((((unsigned long)(n))&0x3FF)<<0)
+#define DDR0_25_OUT_OF_RANGE_LENGTH_DECODE(n) ((((unsigned long)(n))>>0)&0x3FF)
+
+#define DDR0_26                         0x1A
+#define DDR0_26_TRAS_MAX_MASK             0xFFFF0000
+#define DDR0_26_TRAS_MAX_ENCODE(n)          ((((unsigned long)(n))&0xFFFF)<<16)
+#define DDR0_26_TRAS_MAX_DECODE(n)          ((((unsigned long)(n))>>16)&0xFFFF)
+#define DDR0_26_TREF_MASK                 0x00003FFF
+#define DDR0_26_TREF_ENCODE(n)              ((((unsigned long)(n))&0x3FF)<<0)
+#define DDR0_26_TREF_DECODE(n)              ((((unsigned long)(n))>>0)&0x3FF)
+
+#define DDR0_27                         0x1B
+#define DDR0_27_EMRS_DATA_MASK            0x3FFF0000
+#define DDR0_27_EMRS_DATA_ENCODE(n)         ((((unsigned long)(n))&0x3FFF)<<16)
+#define DDR0_27_EMRS_DATA_DECODE(n)         ((((unsigned long)(n))>>16)&0x3FFF)
+#define DDR0_27_TINIT_MASK                0x0000FFFF
+#define DDR0_27_TINIT_ENCODE(n)             ((((unsigned long)(n))&0xFFFF)<<0)
+#define DDR0_27_TINIT_DECODE(n)             ((((unsigned long)(n))>>0)&0xFFFF)
+
+#define DDR0_28                         0x1C
+#define DDR0_28_EMRS3_DATA_MASK           0x3FFF0000
+#define DDR0_28_EMRS3_DATA_ENCODE(n)        ((((unsigned long)(n))&0x3FFF)<<16)
+#define DDR0_28_EMRS3_DATA_DECODE(n)        ((((unsigned long)(n))>>16)&0x3FFF)
+#define DDR0_28_EMRS2_DATA_MASK           0x00003FFF
+#define DDR0_28_EMRS2_DATA_ENCODE(n)        ((((unsigned long)(n))&0x3FFF)<<0)
+#define DDR0_28_EMRS2_DATA_DECODE(n)        ((((unsigned long)(n))>>0)&0x3FFF)
+
+#define DDR0_29                         0x1D
+
+#define DDR0_30                         0x1E
+
+#define DDR0_31                         0x1F
+#define DDR0_31_XOR_CHECK_BITS_MASK       0x0000FFFF
+#define DDR0_31_XOR_CHECK_BITS_ENCODE(n)    ((((unsigned long)(n))&0xFFFF)<<0)
+#define DDR0_31_XOR_CHECK_BITS_DECODE(n)    ((((unsigned long)(n))>>0)&0xFFFF)
+
+#define DDR0_32                         0x20
+#define DDR0_32_OUT_OF_RANGE_ADDR_MASK    0xFFFFFFFF /* Read only */
+#define DDR0_32_OUT_OF_RANGE_ADDR_ENCODE(n) ((((unsigned long)(n))&0xFFFFFFFF)<<0)
+#define DDR0_32_OUT_OF_RANGE_ADDR_DECODE(n) ((((unsigned long)(n))>>0)&0xFFFFFFFF)
+
+#define DDR0_33                         0x21
+#define DDR0_33_OUT_OF_RANGE_ADDR_MASK    0x00000001 /* Read only */
+#define DDR0_33_OUT_OF_RANGE_ADDR_ENCODE(n) ((((unsigned long)(n))&0x1)<<0)
+#define DDR0_33_OUT_OF_RANGE_ADDR_DECODE(n)               ((((unsigned long)(n))>>0)&0x1)
+
+#define DDR0_34                         0x22
+#define DDR0_34_ECC_U_ADDR_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_34_ECC_U_ADDR_ENCODE(n)        ((((unsigned long)(n))&0xFFFFFFFF)<<0)
+#define DDR0_34_ECC_U_ADDR_DECODE(n)        ((((unsigned long)(n))>>0)&0xFFFFFFFF)
+
+#define DDR0_35                         0x23
+#define DDR0_35_ECC_U_ADDR_MASK           0x00000001 /* Read only */
+#define DDR0_35_ECC_U_ADDR_ENCODE(n)        ((((unsigned long)(n))&0x1)<<0)
+#define DDR0_35_ECC_U_ADDR_DECODE(n)        ((((unsigned long)(n))>>0)&0x1)
+
+#define DDR0_36                         0x24
+#define DDR0_36_ECC_U_DATA_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_36_ECC_U_DATA_ENCODE(n)        ((((unsigned long)(n))&0xFFFFFFFF)<<0)
+#define DDR0_36_ECC_U_DATA_DECODE(n)        ((((unsigned long)(n))>>0)&0xFFFFFFFF)
+
+#define DDR0_37                         0x25
+#define DDR0_37_ECC_U_DATA_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_37_ECC_U_DATA_ENCODE(n)        ((((unsigned long)(n))&0xFFFFFFFF)<<0)
+#define DDR0_37_ECC_U_DATA_DECODE(n)        ((((unsigned long)(n))>>0)&0xFFFFFFFF)
+
+#define DDR0_38                         0x26
+#define DDR0_38_ECC_C_ADDR_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_38_ECC_C_ADDR_ENCODE(n)        ((((unsigned long)(n))&0xFFFFFFFF)<<0)
+#define DDR0_38_ECC_C_ADDR_DECODE(n)        ((((unsigned long)(n))>>0)&0xFFFFFFFF)
+
+#define DDR0_39                         0x27
+#define DDR0_39_ECC_C_ADDR_MASK           0x00000001 /* Read only */
+#define DDR0_39_ECC_C_ADDR_ENCODE(n)        ((((unsigned long)(n))&0x1)<<0)
+#define DDR0_39_ECC_C_ADDR_DECODE(n)        ((((unsigned long)(n))>>0)&0x1)
+
+#define DDR0_40                         0x28
+#define DDR0_40_ECC_C_DATA_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_40_ECC_C_DATA_ENCODE(n)        ((((unsigned long)(n))&0xFFFFFFFF)<<0)
+#define DDR0_40_ECC_C_DATA_DECODE(n)        ((((unsigned long)(n))>>0)&0xFFFFFFFF)
+
+#define DDR0_41                         0x29
+#define DDR0_41_ECC_C_DATA_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_41_ECC_C_DATA_ENCODE(n)        ((((unsigned long)(n))&0xFFFFFFFF)<<0)
+#define DDR0_41_ECC_C_DATA_DECODE(n)        ((((unsigned long)(n))>>0)&0xFFFFFFFF)
+
+#define DDR0_42                         0x2A
+#define DDR0_42_ADDR_PINS_MASK            0x07000000
+#define DDR0_42_ADDR_PINS_ENCODE(n)         ((((unsigned long)(n))&0x7)<<24)
+#define DDR0_42_ADDR_PINS_DECODE(n)         ((((unsigned long)(n))>>24)&0x7)
+#define DDR0_42_CASLAT_LIN_GATE_MASK      0x0000000F
+#define DDR0_42_CASLAT_LIN_GATE_ENCODE(n)   ((((unsigned long)(n))&0xF)<<0)
+#define DDR0_42_CASLAT_LIN_GATE_DECODE(n)   ((((unsigned long)(n))>>0)&0xF)
+
+#define DDR0_43                         0x2B
+#define DDR0_43_TWR_MASK                  0x07000000
+#define DDR0_43_TWR_ENCODE(n)               ((((unsigned long)(n))&0x7)<<24)
+#define DDR0_43_TWR_DECODE(n)               ((((unsigned long)(n))>>24)&0x7)
+#define DDR0_43_APREBIT_MASK              0x000F0000
+#define DDR0_43_APREBIT_ENCODE(n)           ((((unsigned long)(n))&0xF)<<16)
+#define DDR0_43_APREBIT_DECODE(n)           ((((unsigned long)(n))>>16)&0xF)
+#define DDR0_43_COLUMN_SIZE_MASK          0x00000700
+#define DDR0_43_COLUMN_SIZE_ENCODE(n)       ((((unsigned long)(n))&0x7)<<8)
+#define DDR0_43_COLUMN_SIZE_DECODE(n)       ((((unsigned long)(n))>>8)&0x7)
+#define DDR0_43_EIGHT_BANK_MODE_MASK      0x00000001
+#define DDR0_43_EIGHT_BANK_MODE_8_BANKS     0x00000001
+#define DDR0_43_EIGHT_BANK_MODE_4_BANKS     0x00000000
+#define DDR0_43_EIGHT_BANK_MODE_ENCODE(n)   ((((unsigned long)(n))&0x1)<<0)
+#define DDR0_43_EIGHT_BANK_MODE_DECODE(n)   ((((unsigned long)(n))>>0)&0x1)
+
+#define DDR0_44                         0x2C
+#define DDR0_44_TRCD_MASK                 0x000000FF
+#define DDR0_44_TRCD_ENCODE(n)              ((((unsigned long)(n))&0xFF)<<0)
+#define DDR0_44_TRCD_DECODE(n)              ((((unsigned long)(n))>>0)&0xFF)
+
+#endif /* _SPD_SDRAM_DENALI_H_ */
Index: u-boot-1.2.0/board/avocent/golden_gate/u-boot-nand.lds
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/u-boot-nand.lds
@@ -0,0 +1,137 @@
+/*
+ * (C) Copyright 2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    /* WARNING - the following is hand-optimized to fit within	*/
+    /* the sector layout of our flash chips!	XXX FIXME XXX	*/
+
+    cpu/ppc4xx/start.o	(.text)
+
+    /* Align to next NAND block */
+    . = ALIGN(0x4000);
+    common/environment.o  (.ppcenv)
+    /* Keep some space here for redundant env and potential bad env blocks */
+    . = ALIGN(0x10000);
+
+    *(.text)
+    *(.fixup)
+    *(.got1)
+  }
+  _etext = .;
+  PROVIDE (etext = .);
+  .rodata    :
+  {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >>2;
+  __fixup_entries = (. - _FIXUP_TABLE_)>>2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+
+  . = .;
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+
+  _end = . ;
+  PROVIDE (end = .);
+}
Index: u-boot-1.2.0/board/avocent/golden_gate/u-boot.lds
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/avocent/golden_gate/u-boot.lds
@@ -0,0 +1,145 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  .resetvec 0xFFFFFFFC :
+  {
+    *(.resetvec)
+  } = 0xffff
+
+  .bootpg 0xFFFFF000 :
+  {
+    cpu/ppc4xx/start.o	(.bootpg)
+  } = 0xffff
+
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    /* WARNING - the following is hand-optimized to fit within	*/
+    /* the sector layout of our flash chips!	XXX FIXME XXX	*/
+
+    cpu/ppc4xx/start.o	(.text)
+
+    *(.text)
+    *(.fixup)
+    *(.got1)
+  }
+  _etext = .;
+  PROVIDE (etext = .);
+  .rodata    :
+  {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >>2;
+  __fixup_entries = (. - _FIXUP_TABLE_)>>2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+
+  . = .;
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+
+  ppcenv_assert = ASSERT(. < 0xFFFF8000, ".bss section too big, overlaps .ppcenv section. Please update your confguration: CFG_MONITOR_BASE, CFG_MONITOR_LEN and TEXT_BASE may need to be modified.");
+
+  _end = . ;
+  PROVIDE (end = .);
+}
Index: u-boot-1.2.0/include/configs/golden_gate.h
===================================================================
--- /dev/null
+++ u-boot-1.2.0/include/configs/golden_gate.h
@@ -0,0 +1,431 @@
+/*
+ * (C) Copyright 2007
+ * Roger Yung, Avcoent Corp., roger.yung@avocent.com
+ *
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * (C) Copyright 2006
+ * Jacqueline Pira-Ferriol, AMCC/IBM, jpira-ferriol@fr.ibm.com
+ * Alain Saurel,            AMCC/IBM, alain.saurel@fr.ibm.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/************************************************************************
+ * golden_gate.h - configuration for Golden Gate ACS 6000 (PowerPC440EPx)
+ ***********************************************************************/
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*-----------------------------------------------------------------------
+ * High Level Configuration Options
+ *----------------------------------------------------------------------*/
+/* This config file is used for Golden Gate (440EPx)  */
+#ifndef CONFIG_SHASTA
+#define CONFIG_GOLDENGATE	1		/* Board is Golden Gate	*/
+#define CONFIG_440EPX		1		/* Specific PPC440EPx	*/
+#else
+#define CONFIG_440GRX		1		/* Specific PPC440GRx	*/
+#endif
+#define CONFIG_4xx		1		/* ... PPC4xx family	*/
+#define CONFIG_SYS_CLK_FREQ	33333333	/* external freq to pll	*/
+#define CONFIG_BOOKE		1
+
+#define CONFIG_BOARD_EARLY_INIT_F 1		/* Call board_early_init_f */
+#define CONFIG_MISC_INIT_R	1		/* Call misc_init_r	*/
+#define CONFIG_WATCHDOG		1
+#define CONFIG_AVOCENT_GSP	1
+
+/*-----------------------------------------------------------------------
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ *----------------------------------------------------------------------*/
+#define CFG_MONITOR_LEN		(500 * 1024)	/* Reserve 500 kB for Monitor	*/
+#define CFG_MALLOC_LEN		(256 * 1024)	/* Reserve 256 kB for malloc()	*/
+
+#define CFG_BOOT_BASE_ADDR	0xf0000000
+#define CFG_SDRAM_BASE		0x00000000	/* _must_ be 0		*/
+#define CFG_FLASH_BASE		0xfc000000	/* start of FLASH	*/
+#define CFG_MONITOR_BASE	TEXT_BASE
+#define CFG_NAND_ADDR		0xd0000000      /* NAND Flash		*/
+#define CFG_FPGA_ADDR		0xc0000000		/* FPGA */
+#define CFG_UART_ADDR		0xc8000000		/* UART */
+#define CFG_OCM_BASE		0xe0010000      /* ocm			*/
+#define CFG_PCI_BASE		0xe0000000      /* Internal PCI regs	*/
+#define CFG_PCI_MEMBASE		0x80000000	/* mapped pci memory	*/
+#define CFG_PCI_MEMBASE1	CFG_PCI_MEMBASE  + 0x10000000
+#define CFG_PCI_MEMBASE2	CFG_PCI_MEMBASE1 + 0x10000000
+#define CFG_PCI_MEMBASE3	CFG_PCI_MEMBASE2 + 0x10000000
+
+/* Don't change either of these */
+#define CFG_PERIPHERAL_BASE	0xef600000	/* internal peripherals	*/
+
+#define CFG_USB2D0_BASE		0xe0000100
+#define CFG_USB_DEVICE		0xe0000000
+#define CFG_USB_HOST		0xe0000400
+/* #define CFG_BCSR_BASE		0xc0000000 */
+
+/*-----------------------------------------------------------------------
+ * Initial RAM & stack pointer
+ *----------------------------------------------------------------------*/
+/* 440EPx/440GRx have 16KB of internal SRAM, so no need for D-Cache	*/
+#define CFG_INIT_RAM_OCM	1		/* OCM as init ram	*/
+#define CFG_INIT_RAM_ADDR	CFG_OCM_BASE	/* OCM			*/
+
+#define CFG_INIT_RAM_END	(4 << 10)
+#define CFG_GBL_DATA_SIZE	256		/* num bytes initial data */
+#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+/*-----------------------------------------------------------------------
+ * Serial Port
+ *----------------------------------------------------------------------*/
+#define CFG_EXT_SERIAL_CLOCK  24000000	/* ext. 24MHz clk	*/
+#define CONFIG_BAUDRATE		9600
+#define CONFIG_SERIAL_MULTI     1
+/* define this if you want console on UART1 */
+#undef CONFIG_UART1_CONSOLE
+
+#define CFG_BAUDRATE_TABLE						\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#define CFG_ENV_IS_EMBEDDED	1	/* use embedded environment */
+#endif
+
+/*-----------------------------------------------------------------------
+ * FLASH related
+ *----------------------------------------------------------------------*/
+#define CFG_MAX_FLASH_BANKS	1	/* number of banks		*/
+#define CFG_MAX_FLASH_SECT	128	/* sectors per device		*/
+
+#undef	CFG_FLASH_CHECKSUM
+#define CFG_FLASH_ERASE_TOUT	120000	/* Timeout for Flash Erase (in ms) */
+#define CFG_FLASH_WRITE_TOUT	500	/* Timeout for Flash Write (in ms) */
+
+#define CFG_FLASH_ADDR0		0x5555
+#define CFG_FLASH_ADDR1		0x2aaa
+#define CFG_FLASH_WORD_SIZE	unsigned char
+
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x1000 	/* size of one complete sector	*/
+#define	CFG_ENV_SIZE		0x2000	/* Total Size of Environment Sector	*/
+#define CFG_ENV_ADDR		(TEXT_BASE - CFG_ENV_SIZE)
+#define CFG_ENV_FILE            "/dev/mtdblock9"
+
+///* Address and size of Redundant Environment Sector	*/
+//#define CFG_ENV_ADDR_REDUND	(CFG_ENV_ADDR-CFG_ENV_SECT_SIZE)
+//#define CFG_ENV_SIZE_REDUND	(CFG_ENV_SIZE)
+#endif
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 4k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 4kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ * On 440EPx the SPL is copied to SDRAM before the NAND controller is
+ * set up. While still running from cache, I experienced problems accessing
+ * the NAND controller.	sr - 2006-08-25
+ */
+#define CFG_NAND_BOOT_SPL_SRC	0xfffff000	/* SPL location			*/
+#define CFG_NAND_BOOT_SPL_SIZE	(4 << 10)	/* SPL size			*/
+#define CFG_NAND_BOOT_SPL_DST	(CFG_OCM_BASE + (12 << 10)) /* Copy SPL here	*/
+#define CFG_NAND_U_BOOT_DST	0x01000000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+#define CFG_NAND_BOOT_SPL_DELTA	(CFG_NAND_BOOT_SPL_SRC - CFG_NAND_BOOT_SPL_DST)
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(16 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(384 << 10)	/* Size of RAM U-Boot image	*/
+
+/*
+ * Now the NAND chip has to be defined (no autodetection used!)
+ */
+#define CFG_NAND_PAGE_SIZE	(512)		/* NAND chip page size		*/
+#define CFG_NAND_BLOCK_SIZE	(16 << 10)	/* NAND chip block size		*/
+#define CFG_NAND_PAGE_COUNT	(32)		/* NAND chip page count		*/
+#define CFG_NAND_BAD_BLOCK_POS	(5)		/* Location of bad block marker	*/
+#undef CFG_NAND_4_ADDR_CYCLE			/* No fourth addr used (<=32MB)	*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+/*
+ * For NAND booting the environment is embedded in the U-Boot image. Please take
+ * look at the file board/amcc/sequoia/u-boot-nand.lds for details.
+ */
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_U_BOOT_OFFS + CFG_ENV_SIZE)
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*-----------------------------------------------------------------------
+ * DDR SDRAM
+ *----------------------------------------------------------------------*/
+#ifdef CONFIG_SHASTA
+#define CFG_MBYTES_SDRAM        (128)		/* 128MB */
+#else
+#define CFG_MBYTES_SDRAM        (256)		/* 256MB */
+#endif
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CONFIG_DDR_DATA_EYE			/* use DDR2 optimization	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * I2C
+ *----------------------------------------------------------------------*/
+#define CONFIG_HARD_I2C		1		/* I2C with hardware support	*/
+#undef	CONFIG_SOFT_I2C				/* I2C bit-banged		*/
+#define CFG_I2C_SPEED		400000		/* I2C speed and slave address	*/
+#define CFG_I2C_SLAVE		0x7F
+
+#define CFG_I2C_MULTI_EEPROMS
+#define CFG_I2C_EEPROM_ADDR	(0xa8>>1)
+#define CFG_I2C_EEPROM_ADDR_LEN 1
+#define CFG_EEPROM_PAGE_WRITE_ENABLE
+#define CFG_EEPROM_PAGE_WRITE_BITS 3
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS 10
+
+/* I2C SYSMON (LM75, AD7414 is almost compatible)			*/
+#define CONFIG_DTT_LM75		1		/* ON Semi's LM75	*/
+#define CONFIG_DTT_AD7414	1		/* use AD7414		*/
+#define CONFIG_DTT_SENSORS	{0}		/* Sensor addresses	*/
+#define CFG_DTT_MAX_TEMP	70
+#define CFG_DTT_LOW_TEMP	-30
+#define CFG_DTT_HYSTERESIS	3
+
+#undef	CONFIG_BOOTARGS
+
+#define CONFIG_ETHADDR	00:e0:86:00:00:01
+#define CONFIG_OVERWRITE_ETHADDR_ONCE	1
+#define CONFIG_IPADDR	192.168.0.1
+#define CONFIG_SERVERIP	192.168.0.2
+#define CONFIG_BOOTFILE zvmppcacs6k.bin
+
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"currentimage=1\0" \
+	"fallback=yes\0" \
+	"netretry=once\0"
+
+#define CONFIG_BOOTCOMMAND	"hw_boot"
+
+#define CONFIG_BOOT_FROM_NAND   1
+#define CFG_KERNEL_SIZE         0x00200000
+#define CONFIG_TWO_IMAGES       1
+
+#if 0
+#define CONFIG_BOOTDELAY	-1	/* autoboot disabled		*/
+#else
+#define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds	*/
+#endif
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+#define CONFIG_M88E1121_PHY	1
+
+#define	CONFIG_IBM_EMAC4_V4	1
+#define CONFIG_MII		1	/* MII PHY management		*/
+#define CONFIG_PHY_ADDR		1	/* PHY address, See schematics	*/
+
+#define CONFIG_PHY_RESET        1	/* reset phy upon startup         */
+#define CONFIG_PHY_GIGE		1	/* Include GbE speed/duplex detection */
+
+#define CONFIG_HAS_ETH0     1
+#define CFG_RX_ETH_BUFFER	32	/* Number of ethernet rx buffers & descriptors */
+
+#define CONFIG_NET_MULTI	1
+#define CONFIG_HAS_ETH1		1	/* add support for "eth1addr"	*/
+#define CONFIG_ETH1ADDR		00:e0:86:00:00:02
+#define CONFIG_PHY1_ADDR	0
+
+/* USB */
+#ifdef CONFIG_440EPX
+#define CONFIG_USB_OHCI
+#define CONFIG_USB_STORAGE
+
+/* Comment this out to enable USB 1.1 device */
+#define USB_2_0_DEVICE
+
+#define CMD_USB			CFG_CMD_USB
+#else
+#define CMD_USB			0	/* no USB on 440GRx		*/
+#endif /* CONFIG_440EPX */
+
+/* Partitions */
+#define CONFIG_MAC_PARTITION
+#define CONFIG_DOS_PARTITION
+#define CONFIG_ISO_PARTITION
+
+#define CONFIG_COMMANDS 	(CONFIG_CMD_DFL | CFG_CMD_NET | CFG_CMD_NAND | CFG_CMD_DHCP | CFG_CMD_DIAG | CFG_CMD_PING | CFG_CMD_MII | CFG_CMD_I2C)
+/*#define CONFIG_COMMANDS       (CONFIG_CMD_DFL	|	\
+			       CFG_CMD_ASKENV	|	\
+			       CFG_CMD_DHCP	|	\
+			       CFG_CMD_DTT	|	\
+			       CFG_CMD_DIAG	|	\
+			       CFG_CMD_EEPROM	|	\
+			       CFG_CMD_ELF	|	\
+			       CFG_CMD_FAT	|	\
+			       CFG_CMD_I2C	|	\
+			       CFG_CMD_IRQ	|	\
+			       CFG_CMD_MII	|	\
+			       CFG_CMD_NAND	|	\
+			       CFG_CMD_NET	|	\
+			       CFG_CMD_NFS	|	\
+			       CFG_CMD_PCI	|	\
+			       CFG_CMD_PING	|	\
+			       CFG_CMD_REGINFO	|	\
+			       CFG_CMD_SDRAM	|	\
+			       CMD_USB)
+*/
+#define CONFIG_SUPPORT_VFAT
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ *----------------------------------------------------------------------*/
+#define CFG_LONGHELP			/* undef to save memory		*/
+#define CFG_PROMPT	        "=> "	/* Monitor Command Prompt	*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CBSIZE	        1024	/* Console I/O Buffer Size	*/
+#else
+#define CFG_CBSIZE	        256	/* Console I/O Buffer Size	*/
+#endif
+#define CFG_PBSIZE              (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS	        16	/* max number of command args	*/
+#define CFG_BARGSIZE	        CFG_CBSIZE /* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x0400000 /* memtest works on		*/
+#define CFG_MEMTEST_END		0x0C00000 /* 4 ... 12 MB in DRAM	*/
+#define CFG_ALT_MEMTEST		1
+
+#define CFG_LOAD_ADDR		0x1000000 /* default load address	*/
+#define CFG_EXTBDINFO		1	/* To use extended board_into (bd_t) */
+
+#define CFG_HZ		        1000	/* decrementer freq: 1 ms ticks	*/
+
+#define CONFIG_CMDLINE_EDITING	1	/* add command line history	*/
+#define CONFIG_LOOPW            1       /* enable loopw command         */
+#define CONFIG_MX_CYCLIC        1       /* enable mdc/mwc commands      */
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+#define CONFIG_VERSION_VARIABLE 1	/* include version env variable */
+
+/*-----------------------------------------------------------------------
+ * PCI stuff
+ *----------------------------------------------------------------------*/
+#ifndef CONFIG_SHASTA
+/* General PCI */
+#define CONFIG_PCI			/* include pci support	        */
+#define CONFIG_PCI_PNP			/* do (not) pci plug-and-play   */
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup  */
+#define CFG_PCI_TARGBASE        0x80000000 /* PCIaddr mapped to CFG_PCI_MEMBASE*/
+
+/* Board-specific PCI */
+#define CFG_PCI_PRE_INIT		/* enable board pci_pre_init()	*/
+#define CFG_PCI_TARGET_INIT
+#define CFG_PCI_MASTER_INIT
+
+#define CFG_PCI_SUBSYS_VENDORID 0x10e8	/* AMCC				*/
+#define CFG_PCI_SUBSYS_ID       0xcafe	/* Whatever			*/
+#endif
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ		(8 << 20)	/* Initial Memory map for Linux */
+
+/*-----------------------------------------------------------------------
+ * External Bus Controller (EBC) Setup
+ *----------------------------------------------------------------------*/
+#define CFG_FLASH		CFG_FLASH_BASE
+#define CFG_NAND		0xD0000000
+#define CFG_FPGA		0xC0000000
+#define CFG_UART		0xC8000000
+
+#define CFG_NAND_CS		3
+/* Memory Bank 0 (NOR Flash) initialization */
+#define CFG_EBC_PB0AP		0x02859200
+#define CFG_EBC_PB0CR		(CFG_FLASH | 0xD8000)
+
+/* Memory Bank 1 initialization	*/
+/* Memory Bank 2 initialization */
+
+/* Memory Bank 3 (NAND) initialization */
+#define CFG_EBC_PB3AP		0x018003c0
+#define CFG_EBC_PB3CR		(CFG_NAND | 0x1c000)
+
+/* Memory Bank 4 (UART) initialization */
+#define CFG_EBC_PB4AP		0x01050200
+#define CFG_EBC_PB4CR		(CFG_UART | 0x18000)
+
+/* Memory Bank 5 (FPGA) initialization */
+#define CFG_EBC_PB5AP		0x02898400
+#define CFG_EBC_PB5CR		(CFG_FPGA | 0x18000)
+
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH
+ *----------------------------------------------------------------------*/
+#define CFG_MAX_NAND_DEVICE	1
+#define NAND_MAX_CHIPS		1
+#define CFG_NAND_BASE		(CFG_NAND_ADDR + CFG_NAND_CS)
+#define CFG_NAND_SELECT_DEVICE  1	/* nand driver supports mutipl. chips	*/
+#define CONFIG_MTD_NAND_ECC_SMC
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ *----------------------------------------------------------------------*/
+#define CFG_DCACHE_SIZE		(32<<10)  /* For AMCC 440 CPUs			*/
+#define CFG_CACHELINE_SIZE	32	      /* ...			            */
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CACHELINE_SHIFT	5	      /* log base 2 of the above value	*/
+#endif
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH	*/
+#define BOOTFLAG_WARM	0x02		/* Software reboot			*/
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	    /* which serial port to use */
+#endif
+
+#endif	/* __CONFIG_H */
+
Index: u-boot-1.2.0/include/gsp-serialnb.h
===================================================================
--- /dev/null
+++ u-boot-1.2.0/include/gsp-serialnb.h
@@ -0,0 +1,10 @@
+#define BDS_MAGIC	0x2E437ABD
+#define CFG_SERIALNB_FILE	"/dev/mtdblock8"
+
+struct bdserial {
+	int magic;
+	unsigned char serialnb[6];
+	unsigned char ethaddr[6];
+	unsigned char eth1addr[6];
+};
+
Index: u-boot-1.2.0/cpu/ppc4xx/serial.c
===================================================================
--- u-boot-1.2.0.orig/cpu/ppc4xx/serial.c
+++ u-boot-1.2.0/cpu/ppc4xx/serial.c
@@ -494,7 +494,7 @@ int serial_init(void)
 	out8(UART_BASE + UART_DLM, bdiv >> 8);	/* set baudrate divisor */
 	out8(UART_BASE + UART_LCR, 0x03);	/* clear DLAB; set 8 bits, no parity */
 	out8(UART_BASE + UART_FCR, 0x00);	/* disable FIFO */
-	out8(UART_BASE + UART_MCR, 0x00);	/* no modem control DTR RTS */
+	out8(UART_BASE + UART_MCR, 0x02);	/* no modem control DTR; RTS on */
 	val = in8(UART_BASE + UART_LSR);	/* clear line status */
 	val = in8(UART_BASE + UART_RBR);	/* read receive buffer */
 	out8(UART_BASE + UART_SCR, 0x00);	/* set scratchpad */
Index: u-boot-1.2.0/cpu/ppc4xx/cpu_init.c
===================================================================
--- u-boot-1.2.0.orig/cpu/ppc4xx/cpu_init.c
+++ u-boot-1.2.0/cpu/ppc4xx/cpu_init.c
@@ -219,6 +219,28 @@ void set_chip_gpio_configuration(gpio_pa
 void
 cpu_init_f (void)
 {
+#if defined(CONFIG_GOLDENGATE) || defined(CONFIG_SHASTA)
+	unsigned long reg;
+	/* rewrite clock configuration */
+	mfclk(clk_plld, reg);
+	if (CPR0_PLLD_FBDV_DECODE(reg) != 16) {
+		reg = (reg & ~PLLD_FBDV_MASK) | CPR0_PLLD_FBDV_ENCODE(16);
+		reg = (reg & ~PLLD_FWDVA_MASK) | CPR0_PLLD_FWDVA_ENCODE(2);
+		reg = (reg & ~PLLD_FWDVB_MASK) | CPR0_PLLD_FWDVB_ENCODE(8);
+		reg = (reg & ~PLLD_LFBDV_MASK) | CPR0_PLLD_LFBDV_ENCODE(1);
+		mtclk(clk_plld, reg);
+
+		mfclk(clk_primbd, reg);
+		reg = (reg & ~PRBDV_MASK) | (1 << 24);
+		mtclk(clk_primbd, reg);
+
+		mfclk(clk_icfg, reg);
+		reg |= CPR0_ICFG_RLI_PRESERVECPR;
+		mtclk(clk_icfg, reg);
+ 
+		mtspr (dbcr0, 0x20000000);	/* Reset the chip */
+	}
+#endif
 #if defined(CONFIG_405EP)
 	/*
 	 * GPIO0 setup (select GPIO or alternate function)
Index: u-boot-1.2.0/common/cmd_mii.c
===================================================================
--- u-boot-1.2.0.orig/common/cmd_mii.c
+++ u-boot-1.2.0/common/cmd_mii.c
@@ -40,6 +40,7 @@ uint last_addr;
 uint last_data;
 uint last_reg;
 
+extern void miiphy_dump (char *devname, unsigned char addr);
 /*
  * MII device/info/read/write
  *
@@ -560,6 +561,10 @@ int do_mii (cmd_tbl_t * cmdtp, int flag,
 			miiphy_listdev ();
 		else
 			miiphy_set_current_dev (argv[2]);
+	} else if (op[0] == 'l') {
+		for (addr = addrlo; addr <= addrhi; addr++) {
+			miiphy_dump (devname, addr);
+		}
 	} else {
 		printf("Usage:\n%s\n", cmdtp->usage);
 		return 1;
@@ -590,6 +595,7 @@ U_BOOT_CMD(
 	"mii read   <addr> <reg>        - read  MII PHY <addr> register <reg>\n"
 	"mii write  <addr> <reg> <data> - write MII PHY <addr> register <reg>\n"
 	"mii dump   <addr> <reg>        - pretty-print <addr> <reg> (0-5 only)\n"
+	"mii list   <addr>              - list registers in PHY <addr>\n"
 	"Addr and/or reg may be ranges, e.g. 2-7.\n"
 );
 
Index: u-boot-1.2.0/common/cmd_gsp-bootcmd.c
===================================================================
--- u-boot-1.2.0.orig/common/cmd_gsp-bootcmd.c
+++ u-boot-1.2.0/common/cmd_gsp-bootcmd.c
@@ -38,10 +38,10 @@ static int hw_boot (cmd_tbl_t *cmdtp, in
 #endif
 	sprintf(arg + strlen(arg), " console=ttyS0,%s", baud);
 	for (i = 1; i < argc; i ++) {
+		if (strstr(argv[i], "OEM"))
+			continue;
 		sprintf(arg + strlen(arg), " %s", argv[i]);
-        }
-
-
+	}
 	setenv("bootargs", arg);
 	load_addr = CFG_LOAD_ADDR;
 #ifdef CONFIG_BOOT_FROM_NAND
@@ -90,8 +90,10 @@ static int net_boot (cmd_tbl_t *cmdtp, i
 	printf("Booting from network ...\n");
 	sprintf(arg, "root=/dev/ram0 rw console=ttyS0,%s", baud);
 	for (i = 1; i < argc; i ++) {
+		if (strstr(argv[i], "OEM"))
+			continue;
 		sprintf(arg + strlen(arg), " %s", argv[i]);
-        }
+	}
 	setenv("bootargs", arg);
 	load_addr = CFG_LOAD_ADDR;
 	if ((size = NetLoop(TFTP)) <= 0) {
