Index: u-boot-1.3.1/Makefile
===================================================================
--- u-boot-1.3.1.orig/Makefile
+++ u-boot-1.3.1/Makefile
@@ -1814,6 +1814,9 @@ MPC8313ERDB_66_config: unconfig
 	fi ;
 	@$(MKCONFIG) -a MPC8313ERDB ppc mpc83xx mpc8313erdb freescale
 
+avocent-pmhd_config: unconfig
+	@$(MKCONFIG) -a avocent-pmhd ppc mpc83xx avocent-pmhd avocent
+
 MPC8323ERDB_config:	unconfig
 	@$(MKCONFIG) -a MPC8323ERDB ppc mpc83xx mpc8323erdb freescale
 
Index: u-boot-1.3.1/board/avocent/avocent-pmhd/Makefile
===================================================================
--- /dev/null
+++ u-boot-1.3.1/board/avocent/avocent-pmhd/Makefile
@@ -0,0 +1,50 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= $(BOARD).o sdram.o flash.o nand.o ../gsp/gsp-config-wdt.o ../gsp/gsp-config-fecmode.o ../gsp/gsp-config-serialnb.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
Index: u-boot-1.3.1/board/avocent/avocent-pmhd/avocent-pmhd.c
===================================================================
--- /dev/null
+++ u-boot-1.3.1/board/avocent/avocent-pmhd/avocent-pmhd.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006-2007
+ *
+ * Author: Scott Wood <scottwood@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#if defined(CONFIG_OF_LIBFDT)
+#include <libfdt.h>
+#endif
+#include <pci.h>
+#include <mpc83xx.h>
+
+#include "../gsp/gsp-config-wdt.h"
+#include "../gsp/gsp-config-fecmode.h"
+#include "../gsp/gsp-config-serialnb.h"
+#include <avocent/flashhdr.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_early_init_f(void)
+{
+	volatile immap_t *im = (immap_t *)CFG_IMMR;
+
+	if (im->pmc.pmccr1 & PMCCR1_POWER_OFF)
+		gd->flags |= GD_FLG_SILENT;
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: Avocent PMHD\n");
+	return 0;
+}
+
+static struct pci_region pci_regions[] = {
+	{
+		bus_start: CFG_PCI1_MEM_BASE,
+		phys_start: CFG_PCI1_MEM_PHYS,
+		size: CFG_PCI1_MEM_SIZE,
+		flags: PCI_REGION_MEM | PCI_REGION_PREFETCH
+	},
+	{
+		bus_start: CFG_PCI1_MMIO_BASE,
+		phys_start: CFG_PCI1_MMIO_PHYS,
+		size: CFG_PCI1_MMIO_SIZE,
+		flags: PCI_REGION_MEM
+	},
+	{
+		bus_start: CFG_PCI1_IO_BASE,
+		phys_start: CFG_PCI1_IO_PHYS,
+		size: CFG_PCI1_IO_SIZE,
+		flags: PCI_REGION_IO
+	}
+};
+
+void pci_init_board(void)
+{
+	volatile immap_t *immr = (volatile immap_t *)CFG_IMMR;
+	volatile clk83xx_t *clk = (volatile clk83xx_t *)&immr->clk;
+	volatile law83xx_t *pci_law = immr->sysconf.pcilaw;
+	struct pci_region *reg[] = { pci_regions };
+	int warmboot;
+
+	/* Enable all 3 PCI_CLK_OUTPUTs. */
+	clk->occr |= 0xe0000000;
+
+	/*
+	 * Configure PCI Local Access Windows
+	 */
+	pci_law[0].bar = CFG_PCI1_MEM_PHYS & LAWBAR_BAR;
+	pci_law[0].ar = LBLAWAR_EN | LBLAWAR_512MB;
+
+	pci_law[1].bar = CFG_PCI1_IO_PHYS & LAWBAR_BAR;
+	pci_law[1].ar = LBLAWAR_EN | LBLAWAR_1MB;
+
+	warmboot = gd->bd->bi_bootflags & BOOTFLAG_WARM;
+	warmboot |= immr->pmc.pmccr1 & PMCCR1_POWER_OFF;
+
+	mpc83xx_pci_init(1, reg, warmboot);
+}
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	ft_cpu_setup(blob, bd);
+#ifdef CONFIG_PCI
+	ft_pci_setup(blob, bd);
+#endif
+}
+#endif
+int gsp_reset_type_identification(void)
+{
+        DECLARE_GLOBAL_DATA_PTR;
+        bd_t *bd = gd->bd;
+        int set = 0;
+        char *tmp;
+        char str[64];
+
+        gd = (gd_t *) (CFG_INIT_RAM_ADDR + CFG_GBL_DATA_OFFSET);
+        ulong rsr = gd->reset_status;
+
+        tmp = getenv("reboottype");
+
+        if( rsr == 0 ) {
+                if((tmp == NULL)|| (tmp != "normal")){
+                        setenv("reboottype","normal");
+                        set = 1;
+                }
+        }
+        else{
+
+                static struct {
+                        ulong mask;
+                        char *desc;
+                } bits[] = {
+                        {
+                        RSR_SWSR, "SW Soft"}, {
+                        RSR_SWHR, "SW Hard"}, {
+                        RSR_JSRS, "JTAG Soft"}, {
+                        RSR_CSHR, "Chk Stop"}, {
+                        RSR_SWRS, "SW Wdog"}, {
+                        RSR_BMRS, "Bus Monitor"}, {
+                        RSR_SRS,  "Ex/Int Soft"}, {
+                        RSR_HRS,  "Ext/Int Hard"}
+                };
+
+
+                static int n = sizeof bits / sizeof bits[0];
+                ulong rsr = gd->reset_status;
+                int i;
+		int flag = 0;
+                char *sep;
+		sep = " ,";
+	
+                for (i = 0; i < n; i++){
+                        if (rsr & bits[i].mask) {
+				if( flag ) {
+                                	strcat(str, sep);
+                                	strcat(str, bits[i].desc);
+				}
+				else {
+                                	strcpy(str, bits[i].desc);
+					flag = 1;
+				}	
+                        }
+                }
+
+                if(( tmp == NULL)|| (strcmp(tmp,str) != 0 )) {
+                        setenv("reboottype",str);
+                        set = 1;
+                }
+        }
+
+        return set;
+}
+
+
+int misc_init_r(void)
+{
+	int set = 0;
+#ifdef CONFIG_AVOCENT_GSP
+#ifdef CONFIG_GSP_SERIALNB
+	set |= gsp_config_serialnb((void *)CFG_SERIALNB_ADDR);
+#endif
+        set |= gsp_config_wdt();
+        set |= gsp_config_fecmode(0, 1);
+#ifdef CONFIG_HAS_ETH1
+        set |= gsp_config_fecmode(1, 1);
+#endif
+	gd->bd->family = OPTREC_PRODUCT_TYPE_PMHD;
+	set |= gsp_reset_type_identification();
+
+	if (set) {
+		saveenv();
+	}
+#endif
+	return 0;
+}
+
Index: u-boot-1.3.1/board/avocent/avocent-pmhd/config.mk
===================================================================
--- /dev/null
+++ u-boot-1.3.1/board/avocent/avocent-pmhd/config.mk
@@ -0,0 +1 @@
+TEXT_BASE = 0xFFF00000
Index: u-boot-1.3.1/board/avocent/avocent-pmhd/sdram.c
===================================================================
--- /dev/null
+++ u-boot-1.3.1/board/avocent/avocent-pmhd/sdram.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006-2007
+ *
+ * Authors: Nick.Spence@freescale.com
+ *          Wilson.Lo@freescale.com
+ *          scottwood@freescale.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <mpc83xx.h>
+#include <spd_sdram.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+
+#include <asm/processor.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static void resume_from_sleep(void)
+{
+	u32 magic = *(u32 *)0;
+
+	typedef void (*func_t)(void);
+	func_t resume = *(func_t *)4;
+
+	if (magic == 0xf5153ae5)
+		resume();
+
+	gd->flags &= ~GD_FLG_SILENT;
+	puts("\nResume from sleep failed: bad magic word\n");
+}
+
+/* Fixed sdram init -- doesn't use serial presence detect.
+ *
+ * This is useful for faster booting in configs where the RAM is unlikely
+ * to be changed, or for things like NAND booting where space is tight.
+ */
+static long fixed_sdram(void)
+{
+	volatile immap_t *im = (volatile immap_t *)CFG_IMMR;
+	u32 msize = CFG_DDR_SIZE * 1024 * 1024;
+	u32 msize_log2 = __ilog2(msize);
+
+	im->sysconf.ddrlaw[0].bar = CFG_DDR_SDRAM_BASE >> 12;
+	im->sysconf.ddrlaw[0].ar = LBLAWAR_EN | (msize_log2 - 1);
+	im->sysconf.ddrcdr = CFG_DDRCDR_VALUE;
+
+	/*
+	 * Erratum DDR3 requires a 50ms delay after clearing DDRCDR[DDR_cfg],
+	 * or the DDR2 controller may fail to initialize correctly.
+	 */
+	udelay(50000);
+
+	im->ddr.csbnds[0].csbnds = (msize - 1) >> 24;
+	im->ddr.cs_config[0] = CFG_DDR_CONFIG;
+
+	im->ddr.cs_config[1] = 0;
+
+	im->ddr.sdram_clk_cntl = CFG_DDR_CLK_CNTL;
+	im->ddr.timing_cfg_3 = CFG_DDR_TIMING_3;
+	im->ddr.timing_cfg_1 = CFG_DDR_TIMING_1;
+	im->ddr.timing_cfg_2 = CFG_DDR_TIMING_2;
+	im->ddr.timing_cfg_0 = CFG_DDR_TIMING_0;
+
+	if (im->pmc.pmccr1 & PMCCR1_POWER_OFF)
+		im->ddr.sdram_cfg = CFG_SDRAM_CFG | SDRAM_CFG_BI;
+	else
+		im->ddr.sdram_cfg = CFG_SDRAM_CFG;
+
+	im->ddr.sdram_cfg2 = CFG_SDRAM_CFG2;
+	im->ddr.sdram_mode = CFG_DDR_MODE;
+	im->ddr.sdram_mode2 = CFG_DDR_MODE_2;
+
+	im->ddr.sdram_interval = CFG_DDR_INTERVAL;
+	sync();
+
+	/* enable DDR controller */
+	im->ddr.sdram_cfg |= SDRAM_CFG_MEM_EN;
+
+	return msize;
+}
+
+long int initdram(int board_type)
+{
+	volatile immap_t *im = (volatile immap_t *)CFG_IMMR;
+	volatile lbus83xx_t *lbc = &im->lbus;
+	u32 msize;
+
+	if ((im->sysconf.immrbar & IMMRBAR_BASE_ADDR) != (u32)im)
+		return -1;
+
+	/* DDR SDRAM - Main SODIMM */
+	msize = fixed_sdram();
+
+	/* Local Bus setup lbcr and mrtpr */
+	lbc->lbcr = CFG_LBC_LBCR;
+	lbc->mrtpr = CFG_LBC_MRTPR;
+	sync();
+
+	if (im->pmc.pmccr1 & PMCCR1_POWER_OFF)
+		resume_from_sleep();
+
+	/* return total bus SDRAM size(bytes)  -- DDR */
+	return msize;
+}
Index: u-boot-1.3.1/include/configs/avocent-pmhd.h
===================================================================
--- /dev/null
+++ u-boot-1.3.1/include/configs/avocent-pmhd.h
@@ -0,0 +1,514 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * mpc8313epb board configuration file
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_E300		1
+#define CONFIG_MPC83XX		1
+#define CONFIG_MPC831X		1
+#define CONFIG_MPC8313		1
+#define CONFIG_AVOCENT_PMHD	1
+
+#define CONFIG_PCI
+#define CONFIG_83XX_GENERIC_PCI
+
+#define CONFIG_83XX_CLKIN	32849739 /* clock is being programmed 98.54% of 33333333 Hz Compensate clocl spread */
+
+#define CONFIG_SYS_CLK_FREQ	CONFIG_83XX_CLKIN
+
+#define CONFIG_BOARD_EARLY_INIT_F		/* call board_pre_init */
+#define CONFIG_MISC_INIT_R      1
+#define CONFIG_WATCHDOG         1
+#define CONFIG_AVOCENT_GSP	1
+
+#define CFG_WATCHDOG_VALUE	0x8000
+
+#define CFG_IMMR		0xE0000000
+
+#define CFG_MEMTEST_START	0x00001000
+#define CFG_MEMTEST_END		0x0ff00000
+#define CFG_ALT_MEMTEST
+
+/* Early revs of this board will lock up hard when attempting
+ * to access the PMC registers, unless a JTAG debugger is
+ * connected, or some resistor modifications are made.
+ */
+#define CFG_ACR_PIPE_DEP	3	/* Arbiter pipeline depth (0-3) */
+#define CFG_ACR_RPTCNT		3	/* Arbiter repeat count (0-7) */
+
+/*
+ * DDR Setup
+ */
+#define CFG_DDR_BASE		0x00000000	/* DDR is system memory*/
+#define CFG_SDRAM_BASE		CFG_DDR_BASE
+#define CFG_DDR_SDRAM_BASE	CFG_DDR_BASE
+
+/*
+ * Manually set up DDR parameters, as this board does not
+ * seem to have the SPD connected to I2C.
+ */
+#define CFG_DDR_SIZE		256		/* MB */
+#define CFG_DDR_CONFIG		( CSCONFIG_EN | CSCONFIG_AP \
+				| 0x00440000 /* Terminating Read and Write */ \
+				| 0x00004000 /* 8 banks */ \
+				| CSCONFIG_ROW_BIT_13 | CSCONFIG_COL_BIT_10 )
+				/* 0x80840102 */
+
+#define CFG_DDR_TIMING_3	0x00000000
+#define CFG_DDR_TIMING_0	( ( 0 << TIMING_CFG0_RWT_SHIFT ) \
+				| ( 0 << TIMING_CFG0_WRT_SHIFT ) \
+				| ( 0 << TIMING_CFG0_RRT_SHIFT ) \
+				| ( 0 << TIMING_CFG0_WWT_SHIFT ) \
+				| ( 2 << TIMING_CFG0_ACT_PD_EXIT_SHIFT ) \
+				| ( 2 << TIMING_CFG0_PRE_PD_EXIT_SHIFT ) \
+				| ( 8 << TIMING_CFG0_ODT_PD_EXIT_SHIFT ) \
+				| ( 2 << TIMING_CFG0_MRS_CYC_SHIFT ) )
+				/* 0x00220802 */
+#define CFG_DDR_TIMING_1	( ( 3 << TIMING_CFG1_PRETOACT_SHIFT ) \
+				| ( 9 << TIMING_CFG1_ACTTOPRE_SHIFT ) \
+				| ( 3 << TIMING_CFG1_ACTTORW_SHIFT ) \
+				| ( 5 << TIMING_CFG1_CASLAT_SHIFT ) \
+				| (13 << TIMING_CFG1_REFREC_SHIFT ) \
+				| ( 3 << TIMING_CFG1_WRREC_SHIFT ) \
+				| ( 2 << TIMING_CFG1_ACTTOACT_SHIFT ) \
+				| ( 2 << TIMING_CFG1_WRTORD_SHIFT ) )
+				/* 0x3935d322 */
+#define CFG_DDR_TIMING_2	( ( 0 << TIMING_CFG2_ADD_LAT_SHIFT ) \
+				| (31 << TIMING_CFG2_CPO_SHIFT ) \
+				| ( 2 << TIMING_CFG2_WR_LAT_DELAY_SHIFT ) \
+				| ( 2 << TIMING_CFG2_RD_TO_PRE_SHIFT ) \
+				| ( 2 << TIMING_CFG2_WR_DATA_DELAY_SHIFT ) \
+				| ( 3 << TIMING_CFG2_CKE_PLS_SHIFT ) \
+				| (10 << TIMING_CFG2_FOUR_ACT_SHIFT) )
+				/* 0x0f9048ca */ /* P9-45,may need tuning */
+#define CFG_DDR_INTERVAL	( ( 400 << SDRAM_INTERVAL_REFINT_SHIFT ) \
+				| ( 100 << SDRAM_INTERVAL_BSTOPRE_SHIFT ) )
+				/* 0x03200064 */
+#if defined(CONFIG_DDR_2T_TIMING)
+#define CFG_SDRAM_CFG		( SDRAM_CFG_SREN \
+				| SDRAM_CFG_SDRAM_TYPE_DDR2 \
+				| SDRAM_CFG_2T_EN \
+				| SDRAM_CFG_DBW_32 )
+#else
+#define CFG_SDRAM_CFG		( SDRAM_CFG_SREN \
+				| SDRAM_CFG_SDRAM_TYPE_DDR2 \
+				| SDRAM_CFG_32_BE )
+				/* 0x43080000 */
+#endif
+#define CFG_SDRAM_CFG2		0x00401000;
+/* set burst length to 8 for 32-bit data path */
+#define CFG_DDR_MODE		( ( 0x4440 << SDRAM_MODE_ESD_SHIFT ) \
+				| ( 0x0232 << SDRAM_MODE_SD_SHIFT ) )
+				/* 0x44400232 */
+#define CFG_DDR_MODE_2		0x8000C000;
+
+#define CFG_DDR_CLK_CNTL	DDR_SDRAM_CLK_CNTL_CLK_ADJUST_05
+				/*0x02000000*/
+#define CFG_DDRCDR_VALUE	( DDRCDR_EN \
+				| DDRCDR_PZ_NOMZ \
+				| DDRCDR_NZ_NOMZ \
+				| DDRCDR_M_ODR )
+
+/*
+ * FLASH on the Local Bus
+ */
+#define CFG_FLASH_BASE		0xFFF00000	/* start of FLASH   */
+#define CFG_FLASH_SIZE		1		/* flash size in MB */
+#define CFG_FLASH_EMPTY_INFO			/* display empty sectors */
+#define CFG_FLASH_USE_BUFFER_WRITE		/* buffer up multiple bytes */
+
+#define CFG_FLASH_ADDR0		0x5555
+#define CFG_FLASH_ADDR1		0x2aaa
+#define CFG_FLASH_WORD_SIZE	unsigned char
+
+#define CFG_BR0_PRELIM		(CFG_FLASH_BASE |	/* flash Base address */ \
+				(1 << BR_PS_SHIFT) |	/* 8 bit port size */ \
+				BR_V)			/* valid */
+#define CFG_OR0_PRELIM		( 0xFFF00000		/* 1 MByte */ \
+				| OR_GPCM_XACS \
+				| OR_GPCM_SCY_9 \
+				| OR_GPCM_EHTR \
+				| OR_GPCM_EAD )
+				/* 0xFF006FF7	TODO SLOW 16 MB flash size */
+#define CFG_LBLAWBAR0_PRELIM	CFG_FLASH_BASE	/* window base at flash base */
+#define CFG_LBLAWAR0_PRELIM	0x80000017	/* 16 MB window size */
+
+#define CFG_MAX_FLASH_BANKS	1		/* number of banks */
+#define CFG_MAX_FLASH_SECT	135		/* sectors per device */
+
+#define CFG_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CFG_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CFG_MONITOR_BASE	TEXT_BASE	/* start of monitor */
+
+#if (CFG_MONITOR_BASE < CFG_FLASH_BASE)
+#define CFG_RAMBOOT
+#endif
+
+#define CFG_INIT_RAM_LOCK	1
+#define CFG_INIT_RAM_ADDR	0xFD000000	/* Initial RAM address */
+#define CFG_INIT_RAM_END	0x1000		/* End of used area in RAM*/
+
+#define CFG_GBL_DATA_SIZE	0x100		/* num bytes initial data */
+#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+#define CFG_MONITOR_LEN		(500 * 1024)	/* Reserve 500 kB for Mon */
+#define CFG_MALLOC_LEN		(512 * 1024)	/* Reserved for malloc */
+
+/*
+ * Local Bus LCRR and LBCR regs
+ */
+#define CFG_LCRR	LCRR_EADC_1 | LCRR_CLKDIV_2	/* 0x00010002 */
+#define CFG_LBC_LBCR	( 0x00040000 /* TODO */ \
+			| (0xFF << LBCR_BMT_SHIFT) \
+			| 0xF )	/* 0x0004ff0f */
+
+#define CFG_LBC_MRTPR	0x20000000  /*TODO */ 	/* LB refresh timer prescal, 266MHz/32 */
+
+/* drivers/nand/nand.c */
+#define CFG_NAND_BASE		0xE2800000	/* 0xF0000000 */
+#define CFG_MAX_NAND_DEVICE	1
+#define NAND_MAX_CHIPS		1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+
+#define CFG_BR1_PRELIM		( CFG_NAND_BASE \
+				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
+				| BR_PS_8		/* Port Size = 8 bit */ \
+				| BR_MS_FCM		/* MSEL = FCM */ \
+				| BR_V )		/* valid */
+#define CFG_OR1_PRELIM		( 0xFFFF8000		/* length 32K */ \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_2 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR )
+				/* 0xFFFF8396 */
+#define CFG_LBLAWBAR1_PRELIM	CFG_NAND_BASE
+#define CFG_LBLAWAR1_PRELIM	0x8000000E	/* 32KB  */
+
+#define CFG_UART_BASE	0xF0000000
+
+#define CFG_BR2_PRELIM		0xf0000801	/* UART Base address */
+#define CFG_OR2_PRELIM		0xfff80193	/* UART, 128K bytes*/
+#define CFG_LBLAWBAR2_PRELIM	CFG_UART_BASE   /* Access window base at UART base */
+#define CFG_LBLAWAR2_PRELIM	0x80000010	/* Access window size 128K */
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT	1
+#define CONFIG_OF_BOARD_SETUP	1
+
+#define OF_CPU			"PowerPC,8313@0"
+#define OF_SOC			"soc8313@e0000000"
+#define OF_TBCLK		(bd->bi_busfreq / 4)
+#define OF_STDOUT_PATH		"/soc8313@e0000000/serial@4500"
+
+/*
+ * Serial Port
+ */
+#define CONFIG_CONS_INDEX	1
+#define CFG_NS16550
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE	1
+#define CFG_NS16550_CLK		get_bus_freq(0)
+
+#define CFG_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 115200}
+
+#define CFG_NS16550_COM1	(CFG_IMMR+0x4500)
+#define CFG_NS16550_COM2	(CFG_IMMR+0x4600)
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "> "
+
+/* I2C */
+#define CONFIG_HARD_I2C			/* I2C with hardware support*/
+#define CONFIG_FSL_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CFG_I2C_SPEED		50000	/* I2C speed and slave address */
+#define CFG_I2C_SLAVE		0x7F
+#define CFG_I2C_NOPROBES	{{0,0x69}} /* Don't probe these addrs */
+#define CFG_I2C_OFFSET		0x3000
+#define CFG_I2C2_OFFSET		0x3100
+
+/* TSEC */
+#define CFG_TSEC1_OFFSET	0x24000
+#define CFG_TSEC1		(CFG_IMMR+CFG_TSEC1_OFFSET)
+#define CFG_TSEC2_OFFSET	0x25000
+#define CFG_TSEC2		(CFG_IMMR+CFG_TSEC2_OFFSET)
+
+/*
+ * General PCI
+ * Addresses are mapped 1-1.
+ */
+#define CFG_PCI1_MEM_BASE	0x80000000
+#define CFG_PCI1_MEM_PHYS	CFG_PCI1_MEM_BASE
+#define CFG_PCI1_MEM_SIZE	0x10000000	/* 256M */
+#define CFG_PCI1_MMIO_BASE	0x90000000
+#define CFG_PCI1_MMIO_PHYS	CFG_PCI1_MMIO_BASE
+#define CFG_PCI1_MMIO_SIZE	0x10000000	/* 256M */
+#define CFG_PCI1_IO_BASE	0x00000000
+#define CFG_PCI1_IO_PHYS	0xE2000000
+#define CFG_PCI1_IO_SIZE	0x00100000	/* 1M */
+
+#define CONFIG_PCI_PNP		/* do pci plug-and-play */
+#define CFG_PCI_SUBSYS_VENDORID 0x1057	/* Motorola */
+
+/*
+ * TSEC configuration
+ */
+#define CONFIG_TSEC_ENET		/* TSEC ethernet support */
+
+#define CONFIG_GMII			1	/* MII PHY management */
+#define CONFIG_TSEC1		1
+
+#define CONFIG_TSEC1_NAME	"TSEC0"
+#define TSEC1_PHY_ADDR		0
+#define TSEC1_FLAGS			TSEC_GIGABIT
+#define TSEC1_PHYIDX			0
+
+/*
+ * Configure on-board RTC
+ */
+#define CONFIG_RTC_DS1337
+#define CFG_I2C_RTC_ADDR		0x68
+
+/*
+ * Environment
+ */
+#ifndef CFG_RAMBOOT
+	#define CFG_ENV_IS_IN_FLASH	1
+	#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + 0x7D000)
+	#define CFG_ENV_SECT_SIZE	0x1000	/* 64K(one sector) for env */
+	#define CFG_ENV_SIZE		0x2000
+
+/* Address and size of Redundant Environment Sector */
+#else
+	#define CFG_ENV_IS_NOWHERE	1	/* Store ENV in memory only */
+	#define CFG_ENV_ADDR		(CFG_MONITOR_BASE - 0x1000)
+	#define CFG_ENV_SIZE		0x2000
+#endif
+
+#define	CFG_ENV_FILE		"/dev/mtdblock8"
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+#define CONFIG_GSP_SERIALNB
+#define CFG_SERIALNB_ADDR		(CFG_MONITOR_BASE + 0x7F000)
+#define	CFG_SERIALNB_FILE	"/dev/mtdblock9"
+
+#define CONFIG_BOOT_FROM_NAND
+#define CONFIG_TWO_IMAGES
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_JFFS2
+
+#if defined(CFG_RAMBOOT)
+    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_LOADS
+#endif
+
+#define CONFIG_CMDLINE_EDITING 1
+
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP			/* undef to save memory */
+#define CFG_LOAD_ADDR	0x2000000	/* default load address */
+#define CFG_PROMPT	"=> "		/* Monitor Command Prompt */
+#define CFG_CBSIZE	1024		/* Console I/O Buffer Size */
+
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)	/* Print Buffer Size */
+#define CFG_MAXARGS	16		/* max number of command args */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size */
+#define CFG_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ	(8 << 20)	/* Initial Memory map for Linux*/
+
+/* Cache Configuration */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+#define CFG_CACHELINE_SHIFT	5	/*log base 2 of the above value*/
+
+#define CFG_RCWH_PCIHOST 0x80000000	/* PCIHOST  */
+
+/* 33MHz IN, 165MHz CSB, 330 DDR, 330 CORE */
+/* 0x65040000 */
+#define CFG_HRCW_LOW (\
+	0x20000000 /* reserved, must be set */ |\
+	HRCWL_DDRCM | \
+	HRCWL_LCL_BUS_TO_SCB_CLK_1X1 |\
+	HRCWL_DDR_TO_SCB_CLK_2X1 |\
+	HRCWL_CSB_TO_CLKIN_5X1 |\
+	HRCWL_CORE_TO_CSB_2X1)
+
+
+/* 0xa0606c00 */
+#define CFG_HRCW_HIGH (\
+	HRCWH_PCI_HOST |\
+	HRCWH_PCI1_ARBITER_ENABLE |\
+	HRCWH_CORE_ENABLE |\
+	HRCWH_FROM_0X00000100 |\
+	HRCWH_BOOTSEQ_DISABLE |\
+	HRCWH_SW_WATCHDOG_DISABLE |\
+	HRCWH_ROM_LOC_LOCAL_8BIT |\
+	HRCWH_RL_EXT_LEGACY |\
+	HRCWH_TSEC1M_IN_RGMII |\
+	HRCWH_TSEC2M_IN_RGMII |\
+	HRCWH_BIG_ENDIAN |\
+	HRCWH_LALE_NORMAL)
+
+/* System IO Config */
+#define CFG_SICRH	(SICRH_ETSEC2_B | SICRH_ETSEC2_C | SICRH_ETSEC2_D | \
+	SICRH_ETSEC2_E | SICRH_ETSEC2_F | SICRH_ETSEC2_G | SICRH_TSOBI1 | \
+	SICRH_TSOBI2)	/* RGMII */
+#define CFG_SICRL	(SICRL_LBC | SICRL_USBDR | SICRL_ETSEC2_A) /* | SICRL_SPI_D */	/* Enable Internal USB Phy, GPIOs shared with LBC and TSEC2  */
+
+#define CFG_HID0_INIT	0x000000000
+#define CFG_HID0_FINAL	(HID0_ENABLE_MACHINE_CHECK | \
+			 HID0_ENABLE_DYNAMIC_POWER_MANAGMENT)
+
+#define CFG_HID2 HID2_HBE
+
+/* DDR @ 0x00000000 */
+#define CFG_IBAT0L	(CFG_SDRAM_BASE | BATL_PP_10)
+#define CFG_IBAT0U	(CFG_SDRAM_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+
+/* PCI @ 0x80000000 */
+#define CFG_IBAT1L	(CFG_PCI1_MEM_BASE | BATL_PP_10)
+#define CFG_IBAT1U	(CFG_PCI1_MEM_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CFG_IBAT2L	(CFG_PCI1_MMIO_BASE | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_IBAT2U	(CFG_PCI1_MMIO_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+
+/* PCI2 not supported on 8313 */
+#define CFG_IBAT3L	(0)
+#define CFG_IBAT3U	(0)
+#define CFG_IBAT4L	(0)
+#define CFG_IBAT4U	(0)
+
+/* IMMRBAR @ 0xE0000000, PCI IO @ 0xE2000000 & BCSR @ 0xE2400000 */
+#define CFG_IBAT5L	(CFG_IMMR | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_IBAT5U	(CFG_IMMR | BATU_BL_256M | BATU_VS | BATU_VP)
+
+/* SDRAM @ 0xF0000000, stack in DCACHE 0xFDF00000 & FLASH @ 0xFE000000 */
+#define CFG_IBAT6L	(0xF0000000 | BATL_PP_10)
+#define CFG_IBAT6U	(0xF0000000 | BATU_BL_256M | BATU_VS | BATU_VP)
+
+#define CFG_IBAT7L	(0)
+#define CFG_IBAT7U	(0)
+
+#define CFG_DBAT0L	CFG_IBAT0L
+#define CFG_DBAT0U	CFG_IBAT0U
+#define CFG_DBAT1L	CFG_IBAT1L
+#define CFG_DBAT1U	CFG_IBAT1U
+#define CFG_DBAT2L	CFG_IBAT2L
+#define CFG_DBAT2U	CFG_IBAT2U
+#define CFG_DBAT3L	CFG_IBAT3L
+#define CFG_DBAT3U	CFG_IBAT3U
+#define CFG_DBAT4L	CFG_IBAT4L
+#define CFG_DBAT4U	CFG_IBAT4U
+#define CFG_DBAT5L	CFG_IBAT5L
+#define CFG_DBAT5U	CFG_IBAT5U
+#define CFG_DBAT6L	CFG_IBAT6L
+#define CFG_DBAT6U	CFG_IBAT6U
+#define CFG_DBAT7L	CFG_IBAT7L
+#define CFG_DBAT7U	CFG_IBAT7U
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01	/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02	/* Software reboot */
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_ETHADDR		00:E0:86:00:00:01
+#define CONFIG_HAS_ETH0
+#define CONFIG_NET_MULTI	1
+
+#define CONFIG_IPADDR		192.168.0.1
+#define CONFIG_SERVERIP		192.168.0.2
+#define CONFIG_GATEWAYIP	192.168.0.2
+#define CONFIG_NETMASK		255.255.0.0
+#define CONFIG_NETDEV		eth1
+
+#define CONFIG_BOOTFILE		zvmppcpmhd.bin
+#define CONFIG_LOADADDR		0x08000000	/* default location for tftp and bootm */
+#define CONFIG_BOOTDELAY	5	/* -1 disables auto-boot */
+#define CONFIG_BAUDRATE		9600
+
+#define CONFIG_BOOTCOMMAND	"hw_boot"
+
+#define CONFIG_SILENT_CONSOLE	1
+
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"netdev=" MK_STR(CONFIG_NETDEV) "\0" 				\
+	"fallback=no\0"							\
+	"netretry=no\0"							\
+	"console=ttyS0\0"						\
+	"reboottype=normal\0"						\
+	"silent=yes\0"
+
+#undef MK_STR
+#undef XMK_STR
+
+#endif	/* __CONFIG_H */
Index: u-boot-1.3.1/board/avocent/avocent-pmhd/flash.c
===================================================================
--- /dev/null
+++ u-boot-1.3.1/board/avocent/avocent-pmhd/flash.c
@@ -0,0 +1,1173 @@
+/*
+ * (C) Copyright 2004-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002 Jun Gu <jung@artesyncp.com>
+ * Add support for Am29F016D and dynamic switch setting.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Modified 4/5/2001
+ * Wait for completion of each sector erase command issued
+ * 4/5/2001
+ * Chris Hallinan - DS4.COM, Inc. - clh@net1plus.com
+ */
+/* Modified  10Jun, 2008
+ * wait_for_DQ7_1 had a major bug.  It was using the timer tic for timeout but interrupts were
+ * disabled causing a hang if the flash failed to erase correctly.
+ * This function has been re-written to used udelay() wh ich does not used interrupts.
+ *  Jay Reeder - Avocent Fremont, CA.
+ */
+
+#include <common.h>
+#include <mpc83xx.h>
+#include <asm/processor.h>
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static int write_word (flash_info_t * info, ulong dest, ulong data);
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+static int write_word_1 (flash_info_t * info, ulong dest, ulong data);
+static int write_word_2 (flash_info_t * info, ulong dest, ulong data);
+static int flash_erase_1 (flash_info_t * info, int s_first, int s_last);
+static int flash_erase_2 (flash_info_t * info, int s_first, int s_last);
+static ulong flash_get_size_1 (vu_long * addr, int banknum);
+static ulong flash_get_size_2 (vu_long * addr, int banknum);
+#endif
+
+void
+flash_print_info (flash_info_t * info)
+{
+  int i;
+  int k;
+  int size;
+  int erased;
+  volatile unsigned long *flash;
+
+  if (info->flash_id == FLASH_UNKNOWN)
+	{
+	  printf ("missing or unknown FLASH type\n");
+	  return;
+	}
+
+  switch (info->flash_id & FLASH_VENDMASK)
+	{
+	case FLASH_MAN_AMD:
+	  printf ("AMD ");
+	  break;
+	case FLASH_MAN_STM:
+	  printf ("STM ");
+	  break;
+	case FLASH_MAN_FUJ:
+	  printf ("FUJITSU ");
+	  break;
+	case FLASH_MAN_SST:
+	  printf ("SST ");
+	  break;
+	case FLASH_MAN_MX:
+	  printf ("MACRONIX ");
+	  break;
+	default:
+	  printf ("Unknown Vendor ");
+	  break;
+	}
+
+  switch (info->flash_id & FLASH_TYPEMASK)
+	{
+	case FLASH_AM040:
+	  printf ("AM29F040 (512 Kbit, uniform sector size)\n");
+	  break;
+	case FLASH_AM400B:
+	  printf ("AM29LV400B (4 Mbit, bottom boot sect)\n");
+	  break;
+	case FLASH_AM400T:
+	  printf ("AM29LV400T (4 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_AM800B:
+	  printf ("AM29LV800B (8 Mbit, bottom boot sect)\n");
+	  break;
+	case FLASH_AM800T:
+	  printf ("AM29LV800T (8 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_AMD016:
+	  printf ("AM29F016D (16 Mbit, uniform sector size)\n");
+	  break;
+	case FLASH_AM160B:
+	  printf ("AM29LV160B (16 Mbit, bottom boot sect)\n");
+	  break;
+	case FLASH_AM160T:
+	  printf ("AM29LV160T (16 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_AM320B:
+	  printf ("AM29LV320B (32 Mbit, bottom boot sect)\n");
+	  break;
+	case FLASH_AM320T:
+	  printf ("AM29LV320T (32 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_AM033C:
+	  printf ("AM29LV033C (32 Mbit, top boot sector)\n");
+	  break;
+	case FLASH_SST800A:
+	  printf ("SST39LF/VF800 (8 Mbit, uniform sector size)\n");
+	  break;
+	case FLASH_SST160A:
+	  printf ("SST39LF/VF160 (16 Mbit, uniform sector size)\n");
+	  break;
+	case FLASH_SST040:
+	  printf ("SST39VF040 (4 Mbit, uniform sector size)\n");
+	  break;
+	case FLASH_STMW320DT:
+	  printf ("M29W320DT (32 M, top sector)\n");
+	  break;
+	case FLASH_MXLV320T:
+	  printf ("MXLV320T (32 Mbit, top sector)\n");
+	  break;
+	default:
+	  printf ("Unknown Chip Type\n");
+	  break;
+	}
+
+  printf ("  Size: %ld KB in %d Sectors\n",
+		  info->size >> 10, info->sector_count);
+
+for (i = 0; i < info->sector_count; i++) printf("info %p info->start[%d]=%08x\n", info, i, info->start[i]);
+  printf ("  Sector Start Addresses:");
+  for (i = 0; i < info->sector_count; ++i)
+	{
+	  /*
+	   * Check if whole sector is erased
+	   */
+	  if (i != (info->sector_count - 1))
+		size = info->start[i + 1] - info->start[i];
+	  else
+		size = info->start[0] + info->size - info->start[i];
+	  erased = 1;
+	  flash = (volatile unsigned long *) info->start[i];
+	  size = size >> 2;			/* divide by 4 for longword access */
+	  for (k = 0; k < size; k++)
+		{
+		  if (*flash++ != 0xffffffff)
+			{
+			  erased = 0;
+			  break;
+			}
+		}
+
+	  if ((i % 5) == 0)
+		printf ("\n   ");
+	  printf (" %08lX%s%s",
+			  info->start[i],
+			  erased ? " E" : "  ", info->protect[i] ? "RO " : "   ");
+	}
+  printf ("\n");
+  return;
+}
+
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+static ulong flash_get_size (vu_long * addr, int banknum)
+{
+	/* bit 0 used for big flash marking */
+	if ((ulong) addr & 0x1) {
+  		return flash_get_size_2 ((vu_long *) ((ulong) addr & 0xfffffffe), banknum);
+	}
+  	else {
+	  	return flash_get_size_1 (addr, banknum);
+	}
+}
+
+static ulong flash_get_size_1 (vu_long * addr, int banknum)
+#else
+ulong flash_get_size (vu_long * addr, int banknum)
+#endif
+{
+  short i;
+  CFG_FLASH_WORD_SIZE value;
+  ulong base = (ulong) addr;
+  volatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *) addr;
+  flash_info_t *info = &flash_info[banknum];
+
+  debug ("FLASH ADDR: %08x\n", (unsigned) addr);
+
+  /* Write auto select command: read Manufacturer ID */
+  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00900090;
+  udelay (1000);
+
+  value = addr2[0];
+  debug ("FLASH MANUFACT: %x\n", value);
+
+  switch (value)
+	{
+	case (CFG_FLASH_WORD_SIZE) AMD_MANUFACT:
+	  info->flash_id = FLASH_MAN_AMD;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) FUJ_MANUFACT:
+	  info->flash_id = FLASH_MAN_FUJ;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) SST_MANUFACT:
+	  info->flash_id = FLASH_MAN_SST;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) STM_MANUFACT:
+	  info->flash_id = FLASH_MAN_STM;
+	  break;
+	default:
+	  info->flash_id = FLASH_UNKNOWN;
+	  info->sector_count = 0;
+	  info->size = 0;
+	  return (0);				/* no or unknown flash  */
+	}
+
+  value = addr2[1];				/* device ID */
+  debug ("\nFLASH DEVICEID: %x\n", value);
+
+  switch (value)
+	{
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV040B:
+	  info->flash_id += FLASH_AM040;
+	  info->sector_count = 8;
+	  info->size = 0x0080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_F040B:
+	  info->flash_id += FLASH_AM040;
+	  info->sector_count = 8;
+	  info->size = 0x0080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) STM_ID_M29W040B:
+	  info->flash_id += FLASH_AM040;
+	  info->sector_count = 8;
+	  info->size = 0x0080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_F016D:
+	  info->flash_id += FLASH_AMD016;
+	  info->sector_count = 32;
+	  info->size = 0x00200000;	/* => 2 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV033C:
+	  info->flash_id += FLASH_AMDLV033C;
+	  info->sector_count = 64;
+	  info->size = 0x00400000;	/* => 4 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV400T:
+	  info->flash_id += FLASH_AM400T;
+	  info->sector_count = 11;
+	  info->size = 0x00080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV400B:
+	  info->flash_id += FLASH_AM400B;
+	  info->sector_count = 11;
+	  info->size = 0x00080000;	/* => 512 KiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV800T:
+	  info->flash_id += FLASH_AM800T;
+	  info->sector_count = 19;
+	  info->size = 0x00100000;	/* => 1 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV800B:
+	  info->flash_id += FLASH_AM800B;
+	  info->sector_count = 19;
+	  info->size = 0x00100000;	/* => 1 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV160T:
+	  info->flash_id += FLASH_AM160T;
+	  info->sector_count = 35;
+	  info->size = 0x00200000;	/* => 2 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV160B:
+	  info->flash_id += FLASH_AM160B;
+	  info->sector_count = 35;
+	  info->size = 0x00200000;	/* => 2 MiB */
+	  break;
+
+	case (CFG_FLASH_WORD_SIZE) SST_ID_xF040:
+	  info->flash_id += FLASH_SST040;
+	  info->sector_count = 128;
+	  info->size = 0x00080000;	/* => 512kB */
+	  break;
+
+	default:
+	  info->flash_id = FLASH_UNKNOWN;
+	  return (0);				/* => no or unknown flash */
+	}
+
+  /* set up sector start address table */
+  if (((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM040) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AMD016))
+	{
+	  for (i = 0; i < info->sector_count; i++)
+		info->start[i] = base + (i * (info->size/info->sector_count));
+	}
+  else
+	{
+	  if (info->flash_id & FLASH_BTYPE)
+		{
+		  /* set sector offsets for bottom boot block type */
+		  info->start[0] = base + 0x00000000;
+		  info->start[1] = base + 0x00004000;
+		  info->start[2] = base + 0x00006000;
+		  info->start[3] = base + 0x00008000;
+		  for (i = 4; i < info->sector_count; i++)
+			{
+			  info->start[i] = base + (i * 0x00010000) - 0x00030000;
+			}
+		}
+	  else
+		{
+		  /* set sector offsets for top boot block type */
+		  i = info->sector_count - 1;
+		  info->start[i--] = base + info->size - 0x00004000;
+		  info->start[i--] = base + info->size - 0x00006000;
+		  info->start[i--] = base + info->size - 0x00008000;
+		  for (; i >= 0; i--)
+			{
+			  info->start[i] = base + i * 0x00010000;
+			}
+		}
+	}
+
+  /* check for protected sectors */
+  for (i = 0; i < info->sector_count; i++)
+	{
+	  /* read sector protection at sector address, (A7 .. A0) = 0x02 */
+	  /* D0 = 1 if protected */
+	  addr2 = (volatile CFG_FLASH_WORD_SIZE *) (info->start[i]);
+
+	  /* For AMD29033C flash we need to resend the command of *
+	   * reading flash protection for upper 8 Mb of flash     */
+	  if (i == 32)
+		{
+		  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0xAAAAAAAA;
+		  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x55555555;
+		  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x90909090;
+		}
+
+	  if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)
+		info->protect[i] = 0;
+	  else
+		info->protect[i] = addr2[2] & 1;
+	}
+
+  /* issue bank reset to return to read mode */
+  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;
+
+  return (info->size);
+}
+
+/*Returns -1 on failure or 0 on success.*/
+static int
+wait_for_DQ7_1 (flash_info_t * info, int sect)
+{
+  int ulElapsed_ms=0;
+  ulong i;
+
+  volatile CFG_FLASH_WORD_SIZE *WordPtr =	(CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+  //Wait a maximum of about 1 minute (60000 ms)
+  for(i=0; i<CFG_FLASH_ERASE_TOUT; i++)
+  {
+      udelay(1000);     //Wait 1 millisecond by cpu ticks only (no interrupts)
+      ulElapsed_ms++;
+
+      //Erase done?
+      if ( (*WordPtr & (CFG_FLASH_WORD_SIZE) 0x00800080) !=  0)
+      {
+         ///printf("ms=%lu DQ=0x%4.4x ", i, *WordPtr);
+         return(0);
+      }
+
+	/* show that we're waiting */
+      if (ulElapsed_ms >= 1000)
+	{
+	   /* Display a dot every second */
+	   putc ('.');
+	   ulElapsed_ms = 0;
+	}
+   }
+   //Timed out
+   printf ("\nWARNING: Board flash.c_wait_for_DQ7_1() timed out. DQ=0x4.4x\n", *WordPtr);
+   return -1;
+}
+
+
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+int
+flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+  if (((info->flash_id & FLASH_TYPEMASK) == FLASH_AM320B) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM320T) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_MXLV320T) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_STMW320DT))
+	{
+	  return flash_erase_2 (info, s_first, s_last);
+	}
+  else
+	{
+	  return flash_erase_1 (info, s_first, s_last);
+	}
+}
+
+static int
+flash_erase_1 (flash_info_t * info, int s_first, int s_last)
+#else
+int
+flash_erase (flash_info_t * info, int s_first, int s_last)
+#endif
+{
+  volatile CFG_FLASH_WORD_SIZE *addr =
+	(CFG_FLASH_WORD_SIZE *) (info->start[0]);
+  volatile CFG_FLASH_WORD_SIZE *addr2;
+  int flag, prot, sect, l_sect;
+  int i;
+
+  if ((s_first < 0) || (s_first > s_last))
+	{
+	  if (info->flash_id == FLASH_UNKNOWN)
+		{
+		  printf ("- missing\n");
+		}
+	  else
+		{
+		  printf ("- no sectors to erase\n");
+		}
+	  return 1;
+	}
+
+  if (info->flash_id == FLASH_UNKNOWN)
+	{
+	  printf ("Can't erase unknown flash type - aborted\n");
+	  return 1;
+	}
+
+  prot = 0;
+  for (sect = s_first; sect <= s_last; ++sect)
+	{
+	  if (info->protect[sect])
+		{
+		  prot++;
+		}
+	}
+
+  if (prot)
+	{
+	  printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	}
+  else
+	{
+	  printf ("\n");
+	}
+
+  l_sect = -1;
+
+  /* Disable interrupts which might cause a timeout here */
+  flag = disable_interrupts ();
+
+  /* Start erase on unprotected sectors */
+  for (sect = s_first; sect <= s_last; sect++)
+  {
+       // printf("%d", sect);
+	 if (info->protect[sect] == 0)
+      {						/* not protected */
+		  addr2 = (CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+		  if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST && info->flash_id & FLASH_TYPEMASK != FLASH_SST040)
+			{
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00500050;	/* block erase */
+			  for (i = 0; i < 50; i++)
+				udelay (1000);	/* wait 1 ms */
+			}
+		  else
+			{
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00300030;	/* sector erase */
+			}
+		  l_sect = sect;
+
+		  /*
+		   * Wait for each sector to complete, it's more
+		   * reliable.  According to AMD Spec, you must
+		   * issue all erase commands within a specified
+		   * timeout.  This has been seen to fail, especially
+		   * if printf()s are included (for debug)!!
+		   */
+		  wait_for_DQ7_1 (info, sect);
+		  //putc('\n');
+	   }
+   }
+
+  /* re-enable interrupts if necessary */
+  if (flag)
+	enable_interrupts ();
+
+  /* wait at least 80us - let's wait 1 ms */
+  udelay (1000);
+
+  /* reset to read mode */
+  addr = (CFG_FLASH_WORD_SIZE *) info->start[0];
+  addr[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;	/* reset bank */
+  return 0;
+}
+
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int
+write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+  ulong cp, wp, data;
+  int i, l, rc;
+
+  wp = (addr & ~3);				/* get lower word aligned address */
+
+  /*
+   * handle unaligned start bytes
+   */
+  if ((l = addr - wp) != 0)
+	{
+	  data = 0;
+	  for (i = 0, cp = wp; i < l; ++i, ++cp)
+		{
+		  data = (data << 8) | (*(uchar *) cp);
+		}
+	  for (; i < 4 && cnt > 0; ++i)
+		{
+		  data = (data << 8) | *src++;
+		  --cnt;
+		  ++cp;
+		}
+	  for (; cnt == 0 && i < 4; ++i, ++cp)
+		{
+		  data = (data << 8) | (*(uchar *) cp);
+		}
+
+	  if ((rc = write_word (info, wp, data)) != 0)
+		{
+		  return (rc);
+		}
+	  wp += 4;
+	}
+
+  /*
+   * handle word aligned part
+   */
+  while (cnt >= 4)
+	{
+	  data = 0;
+	  for (i = 0; i < 4; ++i)
+		{
+		  data = (data << 8) | *src++;
+		}
+	  if ((rc = write_word (info, wp, data)) != 0)
+		{
+		  return (rc);
+		}
+	  wp += 4;
+	  cnt -= 4;
+	}
+
+  if (cnt == 0)
+	{
+	  return (0);
+	}
+
+  /*
+   * handle unaligned tail bytes
+   */
+  data = 0;
+  for (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp)
+	{
+	  data = (data << 8) | *src++;
+	  --cnt;
+	}
+  for (; i < 4; ++i, ++cp)
+	{
+	  data = (data << 8) | (*(uchar *) cp);
+	}
+
+  return (write_word (info, wp, data));
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+static int
+write_word (flash_info_t * info, ulong dest, ulong data)
+{
+  if (((info->flash_id & FLASH_TYPEMASK) == FLASH_AM320B) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM320T) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_MXLV320T) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_STMW320DT))
+	{
+	  return write_word_2 (info, dest, data);
+	}
+  else
+	{
+	  return write_word_1 (info, dest, data);
+	}
+}
+
+static int
+write_word_1 (flash_info_t * info, ulong dest, ulong data)
+#else
+static int
+write_word (flash_info_t * info, ulong dest, ulong data)
+#endif
+{
+  volatile CFG_FLASH_WORD_SIZE *addr2 =
+	(CFG_FLASH_WORD_SIZE *) (info->start[0]);
+  volatile CFG_FLASH_WORD_SIZE *dest2 = (CFG_FLASH_WORD_SIZE *) dest;
+  volatile CFG_FLASH_WORD_SIZE *data2 = (CFG_FLASH_WORD_SIZE *) & data;
+  ulong start;
+  int i;
+
+  /* Check if Flash is (sufficiently) erased */
+  if ((*((vu_long *) dest) & data) != data)
+	{
+	  return (2);
+	}
+
+  for (i = 0; i < 4 / sizeof (CFG_FLASH_WORD_SIZE); i++)
+	{
+	  int flag;
+
+	  /* Disable interrupts which might cause a timeout here */
+	  flag = disable_interrupts ();
+
+	  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+	  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+	  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00A000A0;
+
+	  dest2[i] = data2[i];
+
+	  /* re-enable interrupts if necessary */
+	  if (flag)
+		enable_interrupts ();
+
+	  /* data polling for D7 */
+	  start = get_timer (0);
+	  while ((dest2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+			 (data2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080))
+		{
+
+		  if (get_timer (start) > CFG_FLASH_WRITE_TOUT)
+			{
+			  return (1);
+			}
+		}
+	}
+
+  return (0);
+}
+
+#ifdef CFG_FLASH_2ND_16BIT_DEV
+
+#undef  CFG_FLASH_WORD_SIZE
+#define CFG_FLASH_WORD_SIZE unsigned short
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong
+flash_get_size_2 (vu_long * addr, flash_info_t * info)
+{
+  short i;
+  int n;
+  CFG_FLASH_WORD_SIZE value;
+  ulong base = (ulong) addr;
+  volatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *) addr;
+
+  debug ("FLASH ADDR: %08x\n", (unsigned) addr);
+
+  /* Write auto select command: read Manufacturer ID */
+  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00900090;
+  udelay (1000);
+
+  value = addr2[0];
+  debug ("FLASH MANUFACT: %x\n", value);
+
+  switch (value)
+	{
+	case (CFG_FLASH_WORD_SIZE) AMD_MANUFACT:
+	  info->flash_id = FLASH_MAN_AMD;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) FUJ_MANUFACT:
+	  info->flash_id = FLASH_MAN_FUJ;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) SST_MANUFACT:
+	  info->flash_id = FLASH_MAN_SST;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) STM_MANUFACT:
+	  info->flash_id = FLASH_MAN_STM;
+	  break;
+	case (CFG_FLASH_WORD_SIZE) MX_MANUFACT:
+	  info->flash_id = FLASH_MAN_MX;
+	  break;
+	default:
+	  info->flash_id = FLASH_UNKNOWN;
+	  info->sector_count = 0;
+	  info->size = 0;
+	  return (0);				/* no or unknown flash  */
+	}
+
+  value = addr2[1];				/* device ID */
+
+  debug ("\nFLASH DEVICEID: %x\n", value);
+
+  switch (value)
+	{
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV320T:
+	  info->flash_id += FLASH_AM320T;
+	  info->sector_count = 71;
+	  info->size = 0x00400000;
+	  break;					/* => 4 MiB     */
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV320B:
+	  info->flash_id += FLASH_AM320B;
+	  info->sector_count = 71;
+	  info->size = 0x00400000;
+	  break;					/* => 4 MiB     */
+
+	case (CFG_FLASH_WORD_SIZE) STM_ID_29W320DT:
+	  info->flash_id += FLASH_STMW320DT;
+	  info->sector_count = 67;
+	  info->size = 0x00400000;
+	  break;					/* => 4 MiB     */
+
+	case (CFG_FLASH_WORD_SIZE) MX_ID_LV320T:
+	  info->flash_id += FLASH_MXLV320T;
+	  info->sector_count = 71;
+	  info->size = 0x00400000;
+	  break;					/* => 4 MB      */
+
+	default:
+	  info->flash_id = FLASH_UNKNOWN;
+	  return (0);				/* => no or unknown flash */
+	}
+
+  /* set up sector start address table */
+  if (((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM040) ||
+	  ((info->flash_id & FLASH_TYPEMASK) == FLASH_AMD016))
+	{
+	  for (i = 0; i < info->sector_count; i++)
+		info->start[i] = base + (i * 0x00010000);
+	}
+  else if ((info->flash_id & FLASH_TYPEMASK) == FLASH_STMW320DT)
+	{
+	  /* set sector offsets for top boot block type           */
+	  base += info->size;
+	  i = info->sector_count;
+	  /*  1 x 16k boot sector */
+	  base -= 16 << 10;
+	  --i;
+	  info->start[i] = base;
+	  /*  2 x 8k  boot sectors */
+	  for (n = 0; n < 2; ++n)
+		{
+		  base -= 8 << 10;
+		  --i;
+		  info->start[i] = base;
+		}
+	  /*  1 x 32k boot sector */
+	  base -= 32 << 10;
+	  --i;
+	  info->start[i] = base;
+
+	  while (i > 0)
+		{						/* 64k regular sectors  */
+		  base -= 64 << 10;
+		  --i;
+		  info->start[i] = base;
+		}
+	}
+  else if ((info->flash_id & FLASH_TYPEMASK) == FLASH_MXLV320T)
+	{
+	  i = info->sector_count - 1;
+	  info->start[i--] = base + info->size - 0x00002000;
+	  info->start[i--] = base + info->size - 0x00004000;
+	  info->start[i--] = base + info->size - 0x00006000;
+	  info->start[i--] = base + info->size - 0x00008000;
+	  info->start[i--] = base + info->size - 0x0000a000;
+	  info->start[i--] = base + info->size - 0x0000c000;
+	  info->start[i--] = base + info->size - 0x0000e000;
+	  info->start[i--] = base + info->size - 0x00010000;
+
+	  for (; i >= 0; i--)
+		info->start[i] = base + i * 0x00010000;
+	}
+  else
+	{
+	  if (info->flash_id & FLASH_BTYPE)
+		{
+		  /* set sector offsets for bottom boot block type */
+		  info->start[0] = base + 0x00000000;
+		  info->start[1] = base + 0x00004000;
+		  info->start[2] = base + 0x00006000;
+		  info->start[3] = base + 0x00008000;
+		  for (i = 4; i < info->sector_count; i++)
+			{
+			  info->start[i] = base + (i * 0x00010000) - 0x00030000;
+			}
+		}
+	  else
+		{
+		  /* set sector offsets for top boot block type */
+		  i = info->sector_count - 1;
+		  info->start[i--] = base + info->size - 0x00004000;
+		  info->start[i--] = base + info->size - 0x00006000;
+		  info->start[i--] = base + info->size - 0x00008000;
+		  for (; i >= 0; i--)
+			{
+			  info->start[i] = base + i * 0x00010000;
+			}
+		}
+	}
+
+  /* check for protected sectors */
+  for (i = 0; i < info->sector_count; i++)
+	{
+	  /* read sector protection at sector address, (A7 .. A0) = 0x02 */
+	  /* D0 = 1 if protected */
+	  addr2 = (volatile CFG_FLASH_WORD_SIZE *) (info->start[i]);
+
+	  /* For AMD29033C flash we need to resend the command of *
+	   * reading flash protection for upper 8 Mb of flash     */
+	  if (i == 32)
+		{
+		  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0xAAAAAAAA;
+		  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x55555555;
+		  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x90909090;
+		}
+
+	  if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)
+		info->protect[i] = 0;
+	  else
+		info->protect[i] = addr2[2] & 1;
+	}
+
+  /* issue bank reset to return to read mode */
+  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;
+
+  return (info->size);
+}
+
+static int
+wait_for_DQ7_2 (flash_info_t * info, int sect)
+{
+  ulong start, now, last;
+  volatile CFG_FLASH_WORD_SIZE *addr =
+	(CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+  start = get_timer (0);
+  last = start;
+  while ((addr[0] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+		 (CFG_FLASH_WORD_SIZE) 0x00800080)
+	{
+	  if ((now = get_timer (start)) > CFG_FLASH_ERASE_TOUT)
+		{
+		  printf ("Timeout\n");
+		  return -1;
+		}
+	  /* show that we're waiting */
+	  if ((now - last) > 1000)
+		{						/* every second */
+		  putc ('.');
+		  last = now;
+		}
+	}
+  return 0;
+}
+
+static int
+flash_erase_2 (flash_info_t * info, int s_first, int s_last)
+{
+  volatile CFG_FLASH_WORD_SIZE *addr =
+	(CFG_FLASH_WORD_SIZE *) (info->start[0]);
+  volatile CFG_FLASH_WORD_SIZE *addr2;
+  int flag, prot, sect, l_sect;
+  int i;
+
+  if ((s_first < 0) || (s_first > s_last))
+	{
+	  if (info->flash_id == FLASH_UNKNOWN)
+		{
+		  printf ("- missing\n");
+		}
+	  else
+		{
+		  printf ("- no sectors to erase\n");
+		}
+	  return 1;
+	}
+
+  if (info->flash_id == FLASH_UNKNOWN)
+	{
+	  printf ("Can't erase unknown flash type - aborted\n");
+	  return 1;
+	}
+
+  prot = 0;
+  for (sect = s_first; sect <= s_last; ++sect)
+	{
+	  if (info->protect[sect])
+		{
+		  prot++;
+		}
+	}
+
+  if (prot)
+	{
+	  printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	}
+  else
+	{
+	  printf ("\n");
+	}
+
+  l_sect = -1;
+
+  /* Disable interrupts which might cause a timeout here */
+  flag = disable_interrupts ();
+
+  /* Start erase on unprotected sectors */
+  for (sect = s_first; sect <= s_last; sect++)
+	{
+	  if (info->protect[sect] == 0)
+		{						/* not protected */
+		  addr2 = (CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+		  if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)
+			{
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00500050;	/* block erase */
+			  for (i = 0; i < 50; i++)
+				udelay (1000);	/* wait 1 ms */
+			}
+		  else
+			{
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+			  addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+			  addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+			  addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00300030;	/* sector erase */
+			}
+		  l_sect = sect;
+		  /*
+		   * Wait for each sector to complete, it's more
+		   * reliable.  According to AMD Spec, you must
+		   * issue all erase commands within a specified
+		   * timeout.  This has been seen to fail, especially
+		   * if printf()s are included (for debug)!!
+		   */
+		  wait_for_DQ7_2 (info, sect);
+		}
+	}
+
+  /* re-enable interrupts if necessary */
+  if (flag)
+	enable_interrupts ();
+
+  /* wait at least 80us - let's wait 1 ms */
+  udelay (1000);
+
+  /* reset to read mode */
+  addr = (CFG_FLASH_WORD_SIZE *) info->start[0];
+  addr[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;	/* reset bank */
+
+  printf (" done\n");
+  return 0;
+}
+
+static int
+write_word_2 (flash_info_t * info, ulong dest, ulong data)
+{
+  volatile CFG_FLASH_WORD_SIZE *addr2 =
+	(CFG_FLASH_WORD_SIZE *) (info->start[0]);
+  volatile CFG_FLASH_WORD_SIZE *dest2 = (CFG_FLASH_WORD_SIZE *) dest;
+  volatile CFG_FLASH_WORD_SIZE *data2 = (CFG_FLASH_WORD_SIZE *) & data;
+  ulong start;
+  int i;
+
+  /* Check if Flash is (sufficiently) erased */
+  if ((*((vu_long *) dest) & data) != data)
+	{
+	  return (2);
+	}
+
+  for (i = 0; i < 4 / sizeof (CFG_FLASH_WORD_SIZE); i++)
+	{
+	  int flag;
+
+	  /* Disable interrupts which might cause a timeout here */
+	  flag = disable_interrupts ();
+
+	  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+	  addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+	  addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00A000A0;
+
+	  dest2[i] = data2[i];
+
+	  /* re-enable interrupts if necessary */
+	  if (flag)
+		enable_interrupts ();
+
+	  /* data polling for D7 */
+	  start = get_timer (0);
+	  while ((dest2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+			 (data2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080))
+		{
+
+		  if (get_timer (start) > CFG_FLASH_WRITE_TOUT)
+			{
+			  return (1);
+			}
+		}
+	}
+
+  return (0);
+}
+#endif /* CFG_FLASH_2ND_16BIT_DEV */
+
+unsigned long flash_init (void)
+{
+  	unsigned long total_size;
+  	unsigned long size_b0, size_b1;
+  	int i;
+
+  	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+  	total_size = 0;
+  	size_b0 = 0xffffffff;
+
+  	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		size_b1 = flash_get_size ((vu_long *) (CFG_FLASH_BASE +
+								   total_size), i);
+
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+				  i, size_b1, size_b1 >> 20);
+		}
+
+	  	/* Is this really needed ? - LP */
+	  	if (size_b1 > size_b0) {
+		  	printf ("## ERROR: Bank %d (0x%08lx = %ld MB) > Bank %d (0x%08lx = %ld MB)\n",
+			 	i, size_b1, size_b1 >> 20, i - 1, size_b0, size_b0 >>20);
+		  	goto out_error;
+		}
+
+	  	size_b0 = size_b1;
+	  	total_size += size_b1;
+	}
+
+  	/* Compute the Address Mask */
+  	for (i = 0; (total_size >> i) != 0; ++i) {
+
+	}
+  	i--;
+  	if (total_size != (1 << i)) {
+		printf ("## WARNING: Total FLASH size (0x%08lx = %ld MB) is not a power of 2\n",
+		 total_size, total_size >> 20);
+	}
+
+  	total_size = 0;
+
+  	for (i = 0; i < CFG_MAX_FLASH_BANKS && flash_info[i].size != 0; ++i) {
+		/* Re-do sizing to get full correct info */
+	  	/* Why ? - LP */
+	  	size_b1 = flash_get_size ((vu_long *) (CFG_FLASH_BASE +
+								   total_size), i);
+
+	  	/* This is done by flash_get_size - LP */
+	  	/* flash_get_offsets (CFG_FLASH_BASE + total_size, &flash_info[i]); */
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	  /* monitor protection ON by default */
+	  flash_protect (FLAG_PROTECT_SET,
+					 CFG_MONITOR_BASE,
+					 CFG_MONITOR_BASE + monitor_flash_len - 1,
+					 &flash_info[i]);
+#endif
+
+#ifdef  CFG_ENV_IS_IN_FLASH
+	  /* ENV protection ON by default */
+	  flash_protect (FLAG_PROTECT_SET,
+					 CFG_ENV_ADDR,
+					 CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[i]);
+#endif
+
+	  total_size += size_b1;
+	}
+
+  return (total_size);
+
+out_error:
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	  	flash_info[i].sector_count = -1;
+	  	flash_info[i].size = 0;
+	}
+  	return (0);
+}
Index: u-boot-1.3.1/board/avocent/avocent-pmhd/nand.c
===================================================================
--- /dev/null
+++ u-boot-1.3.1/board/avocent/avocent-pmhd/nand.c
@@ -0,0 +1,868 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006.
+ *
+ * Initialized by Nick.Spence@freescale.com
+ *                Wilson.Lo@freescale.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_CMD_NAND
+#if defined(CFG_NAND_LEGACY)
+ #error "U-Boot legacy NAND commands not supported."
+#else
+
+#include <malloc.h>
+#include <asm/errno.h>
+#include <nand.h>
+
+#undef CFG_FCM_DEBUG
+#define CFG_FCM_DEBUG_LVL 1
+#ifdef CFG_FCM_DEBUG
+#define FCM_DEBUG(n, args...)				\
+	do {						\
+		if (n <= (CFG_FCM_DEBUG_LVL + 0))	\
+			printf(args);			\
+	} while(0)
+#else /* CONFIG_FCM_DEBUG */
+#define FCM_DEBUG(n, args...) do { } while(0)
+#endif
+
+#define MIN(x, y)		((x < y) ? x : y)
+
+#define ERR_BYTE 0xFF	/* Value returned for read bytes when read failed */
+
+#define FCM_TIMEOUT_USECS 100000 /* Maximum number of uSecs to wait for FCM */
+
+/* Private structure holding NAND Flash device specific information */
+struct fcm_nand {
+	int		bank;       /* Chip select bank number             */
+	unsigned int	base;       /* Chip select base address            */
+	int		pgs;        /* NAND page size                      */
+	int		oobbuf;     /* Pointer to OOB block                */
+	unsigned int	page;       /* Last page written to / read from    */
+	unsigned int	fmr;        /* FCM Flash Mode Register value       */
+	unsigned int	mdr;        /* UPM/FCM Data Register value         */
+	unsigned int	use_mdr;    /* Non zero if the MDR is to be set    */
+	u_char	       *addr;       /* Address of assigned FCM buffer      */
+	unsigned int	read_bytes; /* Number of bytes read during command */
+	unsigned int	index;      /* Pointer to next byte to 'read'      */
+	unsigned int	req_bytes;  /* Number of bytes read if command ok  */
+	unsigned int	req_index;  /* New read index if command ok        */
+	unsigned int	status;     /* status read from LTESR after last op*/
+};
+
+
+/* These map to the positions used by the FCM hardware ECC generator */
+
+/* Small Page FLASH with FMR[ECCM] = 0 */
+static struct nand_oobinfo fcm_oob_sp_eccm0 = { /* TODO */
+	.useecc = MTD_NANDECC_AUTOPL_USR, /* MTD_NANDECC_PLACEONLY, */
+	.eccbytes = 3,
+	.eccpos = {6, 7, 8},
+	.oobfree = { {0, 5}, {9, 7} }
+};
+
+/* Small Page FLASH with FMR[ECCM] = 1 */
+static struct nand_oobinfo fcm_oob_sp_eccm1 = { /* TODO */
+	.useecc = MTD_NANDECC_AUTOPL_USR, /* MTD_NANDECC_PLACEONLY, */
+	.eccbytes = 3,
+	.eccpos = {8, 9, 10},
+	.oobfree = { {0, 5}, {6, 2}, {11, 5} }
+};
+
+/* Large Page FLASH with FMR[ECCM] = 0 */
+static struct nand_oobinfo fcm_oob_lp_eccm0 = {
+	.useecc = MTD_NANDECC_AUTOPL_USR, /* MTD_NANDECC_PLACEONLY, */
+	.eccbytes = 12,
+	.eccpos = {6, 7, 8, 22, 23, 24, 38, 39, 40, 54, 55, 56},
+	.oobfree = { {1, 5}, {9, 13}, {25, 13}, {41, 13}, {57, 7} }
+};
+
+/* Large Page FLASH with FMR[ECCM] = 1 */
+static struct nand_oobinfo fcm_oob_lp_eccm1 = {
+	.useecc = MTD_NANDECC_AUTOPL_USR, /* MTD_NANDECC_PLACEONLY, */
+	.eccbytes = 12,
+	.eccpos = {8, 9, 10, 24, 25, 26, 40, 41, 42, 56, 57, 58},
+	.oobfree = { {1, 7}, {11, 13}, {27, 13}, {43, 13}, {59, 5} }
+};
+
+/*
+ * execute FCM command and wait for it to complete
+ */
+static int fcm_run_command(struct mtd_info *mtd)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	long long end_tick;
+
+	/* Setup the FMR[OP] to execute without write protection */
+	lbc->fmr = fcm->fmr | 3;
+	if (fcm->use_mdr)
+		lbc->mdr = fcm->mdr;
+
+	FCM_DEBUG(5,"fcm_run_command: fmr= %08X fir= %08X fcr= %08X\n",
+		lbc->fmr, lbc->fir, lbc->fcr);
+	FCM_DEBUG(5,"fcm_run_command: fbar=%08X fpar=%08X fbcr=%08X bank=%d\n",
+		lbc->fbar, lbc->fpar, lbc->fbcr, fcm->bank);
+
+	/* clear event registers */
+	lbc->lteatr = 0;
+	lbc->ltesr |= (LTESR_FCT | LTESR_PAR | LTESR_CC);
+
+	/* execute special operation */
+	lbc->lsor = fcm->bank;
+
+	/* wait for FCM complete flag or timeout */
+	fcm->status = 0;
+	end_tick = usec2ticks(FCM_TIMEOUT_USECS) + get_ticks();
+
+	while (end_tick > get_ticks()) {
+		if (lbc->ltesr & LTESR_CC) {
+			fcm->status = lbc->ltesr &
+					(LTESR_FCT | LTESR_PAR | LTESR_CC);
+			break;
+		}
+	}
+
+	/* store mdr value in case it was needed */
+	if (fcm->use_mdr)
+		fcm->mdr = lbc->mdr;
+
+	fcm->use_mdr = 0;
+
+	FCM_DEBUG(5,"fcm_run_command: stat=%08X mdr= %08X fmr= %08X\n",
+		fcm->status, fcm->mdr, lbc->fmr);
+
+	/* if the operation completed ok then set the read buffer pointers */
+	if (fcm->status == LTESR_CC) {
+		fcm->read_bytes = fcm->req_bytes;
+		fcm->index      = fcm->req_index;
+		return 0;
+	}
+
+	return -1;
+}
+
+/*
+ * Set up the FCM hardware block and page address fields, and the fcm
+ * structure addr field to point to the correct FCM buffer in memory
+ */
+static void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	int buf_num;
+
+	fcm->page = page_addr;
+
+	lbc->fbar = page_addr >> (this->phys_erase_shift - this->page_shift);
+	if (fcm->pgs) {
+		lbc->fpar = ((page_addr << FPAR_LP_PI_SHIFT) & FPAR_LP_PI) |
+			    ( oob ? FPAR_LP_MS : 0) |
+			      column;
+		buf_num = (page_addr & 1) << 2;
+	} else {
+		lbc->fpar = ((page_addr << FPAR_SP_PI_SHIFT) & FPAR_SP_PI) |
+			    ( oob ? FPAR_SP_MS : 0) |
+			      column;
+		buf_num = page_addr & 7;
+	}
+	fcm->addr = (unsigned char*)(fcm->base + (buf_num * 1024));
+
+	/* for OOB data point to the second half of the buffer */
+	if (oob) {
+		fcm->addr += (fcm->pgs ? 2048 : 512);
+	}
+}
+
+/* not required for FCM */
+static void fcm_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	return;
+}
+
+
+/*
+ * FCM does not support 16 bit data busses
+ */
+static u16 fcm_read_word(struct mtd_info *mtd)
+{
+	printf("fcm_read_word: UNIMPLEMENTED.\n");
+	return 0;
+}
+static void fcm_write_word(struct mtd_info *mtd, u16 word)
+{
+	printf("fcm_write_word: UNIMPLEMENTED.\n");
+}
+
+/*
+ * Write buf to the FCM Controller Data Buffer
+ */
+static void fcm_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+
+	FCM_DEBUG(3,"fcm_write_buf: writing %d bytes starting with 0x%x"
+		    " at %d.\n", len, *((unsigned long*) buf), fcm->index);
+
+	/* If armed catch the address of the OOB buffer so that it can be */
+	/* updated with the real signature after the program comletes */
+	if (!fcm->oobbuf)
+		fcm->oobbuf = (int) buf;
+
+	/* copy the data into the FCM hardware buffer and update the index */
+	memcpy(&(fcm->addr[fcm->index]), buf, len);
+	fcm->index += len;
+	return;
+}
+
+
+/*
+ * FCM does not support individual writes. Instead these are either commands
+ * or data being written, both of which are handled through the cmdfunc
+ * handler.
+ */
+static void fcm_write_byte(struct mtd_info *mtd, u_char byte)
+{
+	printf("fcm_write_byte: UNIMPLEMENTED.\n");
+}
+
+/*
+ * read a byte from either the FCM hardware buffer if it has any data left
+ * otherwise issue a command to read a single byte.
+ */
+static u_char fcm_read_byte(struct mtd_info *mtd)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	unsigned char byte;
+
+	/* If there are still bytes in the FCM then use the next byte */
+	if(fcm->index < fcm->read_bytes) {
+		byte = fcm->addr[(fcm->index)++];
+		FCM_DEBUG(4,"fcm_read_byte: byte %u (%02X): %d of %d.\n",
+			  byte, byte, fcm->index-1, fcm->read_bytes);
+	} else {
+		/* otherwise issue a command to read 1 byte */
+		lbc->fir = (FIR_OP_RSW << FIR_OP0_SHIFT);
+		fcm->use_mdr = 1;
+		fcm->read_bytes = 0;
+		fcm->index = 0;
+		fcm->req_bytes = 0;
+		fcm->req_index = 0;
+		byte = fcm_run_command(mtd) ? ERR_BYTE : fcm->mdr & 0xff;
+		FCM_DEBUG(4,"fcm_read_byte: byte %u (%02X) from bus.\n",
+			  byte, byte);
+	}
+
+	return byte;
+}
+
+
+/*
+ * Read from the FCM Controller Data Buffer
+ */
+static void fcm_read_buf(struct mtd_info *mtd, u_char* buf, int len)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	int i;
+	int rest;
+
+	FCM_DEBUG(3,"fcm_read_buf: reading %d bytes.\n", len);
+
+	/* If last read failed then return error bytes */
+	if (fcm->status != LTESR_CC) {
+		/* just keep copying bytes so that the oob works */
+		memcpy(buf, &(fcm->addr[(fcm->index)]), len);
+		fcm->index += len;
+	}
+	else
+	{
+		/* see how much is still in the FCM buffer */
+		i = min(len, (fcm->read_bytes - fcm->index));
+		rest = i - len;
+		len = i;
+
+		memcpy(buf, &(fcm->addr[(fcm->index)]), len);
+		fcm->index += len;
+
+		/* If more data is needed then issue another block read */
+		if (rest) {
+			FCM_DEBUG(3,"fcm_read_buf: getting %d more bytes.\n",
+				    rest);
+			buf += len;
+			lbc->fir = (FIR_OP_RBW << FIR_OP0_SHIFT);
+			set_addr(mtd, 0, 0, 0);
+			lbc->fbcr = rest;
+			fcm->req_bytes = lbc->fbcr;
+			fcm->req_index = 0;
+			fcm->use_mdr = 0;
+			if (!fcm_run_command(mtd))
+				fcm_read_buf(mtd, buf, rest);
+			else
+				memcpy(buf, fcm->addr, rest);
+		}
+	}
+	return;
+}
+
+
+/*
+ * Verify buffer against the FCM Controller Data Buffer
+ */
+static int fcm_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	int i;
+	int rest;
+
+	FCM_DEBUG(3,"fcm_verify_buf: checking %d bytes starting with 0x%02x.\n",
+		len, *((unsigned long*) buf));
+	/* If last read failed then return error bytes */
+	if (fcm->status != LTESR_CC) {
+		return EFAULT;
+	}
+
+	/* see how much is still in the FCM buffer */
+	i = min(len, (fcm->read_bytes - fcm->index));
+	rest = i - len;
+	len = i;
+
+	if (memcmp(buf,	&(fcm->addr[(fcm->index)]), len)) {
+		return EFAULT;
+	}
+
+	fcm->index += len;
+	if (rest) {
+		FCM_DEBUG(3,"fcm_verify_buf: getting %d more bytes.\n", rest);
+		buf += len;
+		lbc->fir = (FIR_OP_RBW << FIR_OP0_SHIFT);
+		set_addr(mtd, 0, 0, 0);
+		lbc->fbcr = rest;
+		fcm->req_bytes = lbc->fbcr;
+		fcm->req_index = 0;
+		fcm->use_mdr = 0;
+		if (fcm_run_command(mtd))
+			return EFAULT;
+		return fcm_verify_buf(mtd, buf, rest);
+
+	}
+	return 0;
+}
+
+/* this function is called after Program and Erase Operations to
+ * check for success or failure */
+static int fcm_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	struct fcm_nand *fcm = this->priv;
+
+	if (fcm->status != LTESR_CC) {
+		return(0x1); /* Status Read error */
+	}
+
+	/* Use READ_STATUS command, but wait for the device to be ready */
+	fcm->use_mdr = 0;
+	fcm->req_index = 0;
+	fcm->read_bytes = 0;
+	fcm->index = 0;
+	fcm->oobbuf = -1;
+	lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+		   (FIR_OP_RBW << FIR_OP1_SHIFT);
+	lbc->fcr = (NAND_CMD_STATUS << FCR_CMD0_SHIFT);
+	set_addr(mtd, 0, 0, 0);
+	lbc->fbcr = 1;
+	fcm->req_bytes = lbc->fbcr;
+	fcm_run_command(mtd);
+	if (fcm->status != LTESR_CC) {
+		return(0x1); /* Status Read error */
+	}
+	return this->read_byte(mtd);
+}
+
+
+/* cmdfunc send commands to the FCM */
+static void fcm_cmdfunc(struct mtd_info *mtd, unsigned command,
+			int column, int page_addr)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+
+	fcm->use_mdr = 0;
+	fcm->req_index = 0;
+
+	/* clear the read buffer */
+	fcm->read_bytes = 0;
+	if (command != NAND_CMD_PAGEPROG) {
+		fcm->index = 0;
+		fcm->oobbuf = -1;
+	}
+
+	switch (command) {
+	/* READ0 and READ1 read the entire buffer to use hardware ECC */
+	case NAND_CMD_READ1:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_READ1, page_addr:"
+			    " 0x%x, column: 0x%x.\n", page_addr, column);
+		fcm->req_index = column + 256;
+		goto read0;
+	case NAND_CMD_READ0:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_READ0, page_addr:"
+			    " 0x%x, column: 0x%x.\n", page_addr, column);
+		fcm->req_index = column;
+read0:
+		if (fcm->pgs) {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_CW1 << FIR_OP3_SHIFT) |
+				   (FIR_OP_RBW << FIR_OP4_SHIFT);
+		} else {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_RBW << FIR_OP3_SHIFT);
+		}
+		lbc->fcr = (NAND_CMD_READ0     << FCR_CMD0_SHIFT) |
+			   (NAND_CMD_READSTART << FCR_CMD1_SHIFT);
+		lbc->fbcr = 0; /* read entire page to enable ECC */
+		set_addr(mtd, 0, page_addr, 0);
+		fcm->req_bytes = mtd->oobblock + mtd->oobsize;
+		goto write_cmd2;
+	/* READOOB read only the OOB becasue no ECC is performed */
+	case NAND_CMD_READOOB:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_READOOB, page_addr:"
+			    " 0x%x, column: 0x%x.\n", page_addr, column);
+		if (fcm->pgs) {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_CW1 << FIR_OP3_SHIFT) |
+				   (FIR_OP_RBW << FIR_OP4_SHIFT);
+			lbc->fcr = (NAND_CMD_READ0     << FCR_CMD0_SHIFT) |
+				   (NAND_CMD_READSTART << FCR_CMD1_SHIFT);
+		} else {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_RBW << FIR_OP3_SHIFT);
+			lbc->fcr = (NAND_CMD_READOOB << FCR_CMD0_SHIFT);
+		}
+		lbc->fbcr = mtd->oobsize - column;
+		set_addr(mtd, column, page_addr, 1);
+		goto write_cmd1;
+	/* READID must read all 5 possible bytes while CEB is active */
+	case NAND_CMD_READID:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_READID.\n");
+		lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			   (FIR_OP_UA  << FIR_OP1_SHIFT) |
+			   (FIR_OP_RBW << FIR_OP2_SHIFT);
+		lbc->fcr = (NAND_CMD_READID << FCR_CMD0_SHIFT);
+		lbc->fbcr = 5; /* 5 bytes for manuf, device and exts */
+		fcm->use_mdr = 1;
+		fcm->mdr = 0;
+		goto write_cmd0;
+	/* ERASE1 stores the block and page address */
+	case NAND_CMD_ERASE1:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_ERASE1, page_addr:"
+			    " 0x%x.\n", page_addr);
+		set_addr(mtd, 0, page_addr, 0);
+		goto end;
+	/* ERASE2 uses the block and page address from ERASE1 */
+	case NAND_CMD_ERASE2:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_ERASE2.\n");
+		lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+			   (FIR_OP_PA  << FIR_OP1_SHIFT) |
+			   (FIR_OP_CM1 << FIR_OP2_SHIFT);
+		lbc->fcr = (NAND_CMD_ERASE1 << FCR_CMD0_SHIFT) |
+			   (NAND_CMD_ERASE2 << FCR_CMD1_SHIFT);
+		lbc->fbcr = 0;
+		goto write_cmd1;
+	/* SEQIN sets up the addr buffer and all registers except the length */
+	case NAND_CMD_SEQIN:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_SEQIN/PAGE_PROG, page_addr:"
+			    " 0x%x, column: 0x%x.\n", page_addr, column);
+		if (column == 0) {
+			lbc->fbcr = 0; /* write entire page to enable ECC */
+		} else {
+			lbc->fbcr = 1; /* mark as partial page so no HW ECC */
+		}
+		if (fcm->pgs) {
+			/* always use READ0 for large page devices */
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP1_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_WB  << FIR_OP3_SHIFT) |
+				   (FIR_OP_CW1 << FIR_OP4_SHIFT);
+			lbc->fcr = (NAND_CMD_SEQIN << FCR_CMD0_SHIFT) |
+				   (NAND_CMD_PAGEPROG << FCR_CMD1_SHIFT);
+			set_addr(mtd, column, page_addr, 0);
+		} else {
+			lbc->fir = (FIR_OP_CW0 << FIR_OP0_SHIFT) |
+				   (FIR_OP_CM2 << FIR_OP1_SHIFT) |
+				   (FIR_OP_CA  << FIR_OP2_SHIFT) |
+				   (FIR_OP_PA  << FIR_OP3_SHIFT) |
+				   (FIR_OP_WB  << FIR_OP4_SHIFT) |
+				   (FIR_OP_CW1 << FIR_OP5_SHIFT);
+			if (column >= mtd->oobblock) {
+				/* OOB area --> READOOB */
+				column -= mtd->oobblock;
+				lbc->fcr = (NAND_CMD_READOOB << FCR_CMD0_SHIFT)
+					 | (NAND_CMD_PAGEPROG<< FCR_CMD1_SHIFT)
+					 | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT);
+				set_addr(mtd, column, page_addr, 1);
+			} else if (column < 256) {
+				/* First 256 bytes --> READ0 */
+				lbc->fcr = (NAND_CMD_READ0 << FCR_CMD0_SHIFT)
+					 | (NAND_CMD_PAGEPROG<< FCR_CMD1_SHIFT)
+					 | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT);
+				set_addr(mtd, column, page_addr, 0);
+			} else {
+				/* Second 256 bytes --> READ1 */
+				column -= 256;
+				lbc->fcr = (NAND_CMD_READ1 << FCR_CMD0_SHIFT)
+					 | (NAND_CMD_PAGEPROG<< FCR_CMD1_SHIFT)
+					 | (NAND_CMD_SEQIN << FCR_CMD2_SHIFT);
+				set_addr(mtd, column, page_addr, 0);
+			}
+		}
+		goto end;
+	/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+	case NAND_CMD_PAGEPROG:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_PAGEPROG"
+			    " writing %d bytes.\n",fcm->index);
+		/* if the write did not start at 0 or is not a full page */
+		/* then set the exact length, otherwise use a full page  */
+		/* write so the HW generates the ECC. */
+		if (lbc->fbcr ||
+		   (fcm->index != (mtd->oobblock + mtd->oobsize)))
+			lbc->fbcr = fcm->index;
+		fcm->req_bytes = 0;
+		goto write_cmd2;
+	/* CMD_STATUS must read the status byte while CEB is active */
+	/* Note - it does not wait for the ready line */
+	case NAND_CMD_STATUS:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_STATUS.\n");
+		lbc->fir = (FIR_OP_CM0 << FIR_OP0_SHIFT) |
+			   (FIR_OP_RBW << FIR_OP1_SHIFT);
+		lbc->fcr = (NAND_CMD_STATUS << FCR_CMD0_SHIFT);
+		lbc->fbcr = 1;
+		goto write_cmd0;
+	/* RESET without waiting for the ready line */
+	case NAND_CMD_RESET:
+		FCM_DEBUG(2,"fcm_cmdfunc: NAND_CMD_RESET.\n");
+		lbc->fir = (FIR_OP_CM0 << FIR_OP0_SHIFT);
+		lbc->fcr = (NAND_CMD_RESET << FCR_CMD0_SHIFT);
+		lbc->fbcr = 0;
+		goto write_cmd0;
+	default:
+		printk("fcm_cmdfunc: error, unsupported command.\n");
+		goto end;
+	}
+
+	/* Short cuts fall through to save code */
+ write_cmd0:
+	set_addr(mtd, 0, 0, 0);
+ write_cmd1:
+	fcm->req_bytes = lbc->fbcr;
+ write_cmd2:
+	fcm_run_command(mtd);
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* if we wrote a page then read back the oob to get the ECC */
+	if ((command == NAND_CMD_PAGEPROG) &&
+	    (this->eccmode > NAND_ECC_SOFT) &&
+	    (lbc->fbcr == 0) &&
+	    (fcm->oobbuf != 0) &&
+	    (fcm->oobbuf != -1)) {
+		int i;
+		uint *oob_config;
+		unsigned char *oob_buf;
+
+		i = fcm->page;
+		oob_buf = (unsigned char*) fcm->oobbuf;
+		oob_config = this->autooob->eccpos;
+
+		/* wait for the write to complete and check it passed */
+		if (!(this->waitfunc(mtd, this, FL_WRITING) & 0x01)) {
+			/* read back the OOB */
+			fcm_cmdfunc(mtd, NAND_CMD_READOOB, 0, i);
+			/* if it succeeded then copy the ECC bytes */
+			if (fcm->status == LTESR_CC) {
+				for (i = 0; i < this->eccbytes; i++) {
+					oob_buf[oob_config[i]] =
+						fcm->addr[oob_config[i]];
+				}
+			}
+		}
+	}
+#endif
+
+ end:
+	return;
+}
+
+/*
+ * fcm_enable_hwecc - start ECC generation
+ */
+static void fcm_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	return;
+}
+
+/*
+ * fcm_calculate_ecc - Calculate the ECC bytes
+ * This is done by hardware during the write process, so we use this
+ * to arm the oob buf capture on the next write_buf() call. The ECC bytes
+ * only need to be captured if CONFIG_MTD_NAND_VERIFY_WRITE is defined which
+ * reads back the pages and checks they match the data and oob buffers.
+ */
+static int fcm_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* arm capture of oob buf ptr on next write_buf */
+	fcm->oobbuf = 0;
+#endif
+	return 0;
+}
+
+/*
+ * fcm_correct_data - Detect and correct bit error(s)
+ * The detection and correction is done automatically by the hardware,
+ * if the complete page was read. If the status code is okay then there
+ * was no error, otherwise we return an error code indicating an uncorrectable
+ * error.
+ */
+static int fcm_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+
+	/* No errors */
+	if (fcm->status == LTESR_CC)
+		return 0;
+
+	return -1; /* uncorrectable error */
+}
+
+
+
+/*
+ * Dummy scan_bbt to complete setup of the FMR based on NAND size
+ */
+static int fcm_scan_bbt (struct mtd_info *mtd)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	register struct nand_chip *this = mtd->priv;
+	struct fcm_nand *fcm = this->priv;
+	unsigned int i;
+	unsigned int al;
+
+	if (!fcm) {
+		printk (KERN_ERR "fcm_scan_bbt():" \
+			" Failed to allocate chip specific data structure\n");
+		return -1;
+	}
+
+	/* calculate FMR Address Length field */
+	al = 0;
+	for (i = this->pagemask >> 16; i ; i >>= 8) {
+		al++;
+	}
+
+	/* add to ECCM mode set in fcm_init */
+	fcm->fmr |= 12 << FMR_CWTO_SHIFT |  /* Timeout > 12 mSecs */
+		    al << FMR_AL_SHIFT;
+
+	FCM_DEBUG(1,"fcm_init: nand->options  =   %08X\n", this->options);
+	FCM_DEBUG(1,"fcm_init: nand->numchips = %10d\n", this->numchips);
+	FCM_DEBUG(1,"fcm_init: nand->chipsize = %10d\n", this->chipsize);
+	FCM_DEBUG(1,"fcm_init: nand->pagemask = %10X\n", this->pagemask);
+	FCM_DEBUG(1,"fcm_init: nand->eccmode  = %10d\n", this->eccmode );
+	FCM_DEBUG(1,"fcm_init: nand->eccsize  = %10d\n", this->eccsize );
+	FCM_DEBUG(1,"fcm_init: nand->eccbytes = %10d\n", this->eccbytes);
+	FCM_DEBUG(1,"fcm_init: nand->eccsteps = %10d\n", this->eccsteps);
+	FCM_DEBUG(1,"fcm_init: nand->chip_delay = %8d\n", this->chip_delay);
+	FCM_DEBUG(1,"fcm_init: nand->badblockpos = %7d\n", this->badblockpos);
+	FCM_DEBUG(1,"fcm_init: nand->chip_shift = %8d\n", this->chip_shift);
+	FCM_DEBUG(1,"fcm_init: nand->page_shift = %8d\n", this->page_shift);
+	FCM_DEBUG(1,"fcm_init: nand->phys_erase_shift = %2d\n",
+						      this->phys_erase_shift);
+	FCM_DEBUG(1,"fcm_init: mtd->flags     =   %08X\n", mtd->flags);
+	FCM_DEBUG(1,"fcm_init: mtd->size      = %10d\n", mtd->size);
+	FCM_DEBUG(1,"fcm_init: mtd->erasesize = %10d\n", mtd->erasesize);
+	FCM_DEBUG(1,"fcm_init: mtd->oobblock  = %10d\n", mtd->oobblock);
+	FCM_DEBUG(1,"fcm_init: mtd->oobsize   = %10d\n", mtd->oobsize);
+	FCM_DEBUG(1,"fcm_init: mtd->oobavail  = %10d\n", mtd->oobavail);
+	FCM_DEBUG(1,"fcm_init: mtd->ecctype   = %10d\n", mtd->ecctype);
+	FCM_DEBUG(1,"fcm_init: mtd->eccsize   = %10d\n", mtd->eccsize);
+
+	/* adjust Option Register and ECC to match Flash page size */
+	if (mtd->oobblock == 512)
+		lbc->bank[fcm->bank].or &= ~(OR_FCM_PGS);
+	else if (mtd->oobblock == 2048) {
+		lbc->bank[fcm->bank].or |= OR_FCM_PGS;
+		/* adjust ecc setup if needed */
+		if ( (lbc->bank[fcm->bank].br & BR_DECC) == BR_DECC_CHK_GEN) {
+			mtd->eccsize = 2048;
+			mtd->oobavail -= 9;
+			this->eccmode = NAND_ECC_HW12_2048;
+			this->eccsize = 2048;
+			this->eccbytes += 9;
+			this->eccsteps = 1;
+			this->autooob = (fcm->fmr & FMR_ECCM) ?
+					&fcm_oob_lp_eccm1 : &fcm_oob_lp_eccm0;
+			memcpy(&mtd->oobinfo, this->autooob,
+					sizeof(mtd->oobinfo));
+		}
+	}
+	else {
+		printf("fcm_init: page size %d is not supported\n",
+			mtd->oobblock);
+		return -1;
+	}
+	fcm->pgs = (lbc->bank[fcm->bank].or>>OR_FCM_PGS_SHIFT) & 1;
+
+	if (al > 2) {
+		printf("fcm_init: %d address bytes is not supported\n", al+2);
+		return -1;
+	}
+
+	/* restore default scan_bbt function and call it */
+	this->scan_bbt = nand_default_bbt;
+	return nand_default_bbt(mtd);
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand_new.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for accesing device ready/busy line
+ * - enable_hwecc: function to enable (reset) hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+	volatile immap_t *im = (immap_t *) CFG_IMMR;
+	volatile lbus83xx_t *lbc= &im->lbus;
+	struct fcm_nand *fcm;
+	unsigned int bank;
+
+	/* Enable FCM detection of timeouts, ECC errors and completion */
+	lbc->ltedr &= ~(LTESR_FCT | LTESR_PAR | LTESR_CC);
+
+	fcm = kmalloc (sizeof(struct fcm_nand), GFP_KERNEL);
+	if (!fcm) {
+		printk (KERN_ERR "board_nand_init():" \
+			" Cannot allocate read buffer data structure\n");
+		return 1;
+	}
+
+	/* Find which chip select bank is being used for this device */
+	for (bank=0; bank<8; bank++) {
+		if ( (lbc->bank[bank].br & BR_V) &&
+		   ( (lbc->bank[bank].br & BR_MSEL) == BR_MS_FCM ) &&
+		   ( (lbc->bank[bank].br & BR_BA) ==
+		     (lbc->bank[bank].or & OR_FCM_AM &
+			(unsigned int)(nand->IO_ADDR_R) ) ) ) {
+			fcm->bank = bank;
+// TODO			fcm->fmr = FMR_ECCM; /* rest filled in later */
+			fcm->fmr = 0; /* rest filled in later */
+			fcm->read_bytes = 0;
+			fcm->index = 0;
+			fcm->pgs = (lbc->bank[bank].or>>OR_FCM_PGS_SHIFT) & 1;
+			fcm->base = lbc->bank[bank].br & BR_BA;
+			fcm->addr = (unsigned char*) (fcm->base);
+			nand->priv = fcm;
+			fcm->oobbuf = -1;
+			break;
+		}
+	}
+
+	if (!nand->priv) {
+		printk (KERN_ERR "board_nand_init():" \
+			" Could not find matching Chip Select\n");
+		return 1;
+	}
+
+	/* set up nand options */
+	nand->options = 0;
+	/* set up function call table */
+	nand->hwcontrol = fcm_hwcontrol;
+	nand->waitfunc = fcm_wait;
+	nand->read_byte = fcm_read_byte;
+	nand->write_byte = fcm_write_byte;
+	nand->read_word = fcm_read_word;
+	nand->write_word = fcm_write_word;
+	nand->read_buf = fcm_read_buf;
+	nand->verify_buf = fcm_verify_buf;
+	nand->write_buf = fcm_write_buf;
+	nand->cmdfunc = fcm_cmdfunc;
+	nand->scan_bbt = fcm_scan_bbt;
+
+	/* If CS Base Register selects full hardware ECC then use it */
+	if ( ( (lbc->bank[bank].br & BR_DECC) >> BR_DECC_SHIFT) == 2) {
+		/* put in small page settings and adjust later if needed */
+		nand->eccmode = NAND_ECC_HW3_512;
+		nand->autooob = (fcm->fmr & FMR_ECCM) ?
+				&fcm_oob_sp_eccm1 : &fcm_oob_sp_eccm0;
+		nand->calculate_ecc = fcm_calculate_ecc;
+		nand->correct_data = fcm_correct_data;
+		nand->enable_hwecc = fcm_enable_hwecc;
+	} else {
+		/* otherwise fall back to default software ECC */
+		nand->eccmode = NAND_ECC_SOFT;
+	}
+	return 0;
+}
+
+#endif
+#endif
Index: u-boot-1.3.1/common/main.c
===================================================================
--- u-boot-1.3.1.orig/common/main.c
+++ u-boot-1.3.1/common/main.c
@@ -241,6 +241,13 @@ static __inline__ int abortboot(int boot
 		/* delay 100 * 10ms */
 		for (i=0; !abort && i<100; ++i) {
 			if (tstc()) {	/* we got a key press	*/
+#if CONFIG_AVOCENT_PMHD
+				if (getc() == 0x03 || (gd->flags & GD_FLG_SILENT) == 0) {
+					abort  = 1;
+					bootdelay = 0;
+					break;
+				}
+#else
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
 # ifdef CONFIG_MENUKEY
@@ -249,6 +256,7 @@ static __inline__ int abortboot(int boot
 				(void) getc();  /* consume input	*/
 # endif
 				break;
+#endif
 			}
 			udelay(10000);
 		}
@@ -272,6 +280,11 @@ static __inline__ int abortboot(int boot
 
 void main_loop (void)
 {
+
+#ifdef CONFIG_SILENT_CONSOLE
+	char *StrPtr;
+#endif
+
 #ifndef CFG_HUSH_PARSER
 	static char lastcommand[CFG_CBSIZE] = { 0, };
 	int len;
@@ -296,7 +309,6 @@ void main_loop (void)
 #if defined(CONFIG_VFD) && defined(VFD_TEST_LOGO)
 	ulong bmp = 0;		/* default bitmap */
 	extern int trab_vfd (ulong bitmap);
-
 #ifdef CONFIG_MODEM_SUPPORT
 	if (do_mdm_init)
 		bmp = 1;	/* alternate bitmap */
@@ -304,6 +316,7 @@ void main_loop (void)
 	trab_vfd (bmp);
 #endif	/* CONFIG_VFD && VFD_TEST_LOGO */
 
+
 #ifdef CONFIG_BOOTCOUNT_LIMIT
 	bootcount = bootcount_load();
 	bootcount++;
@@ -360,6 +373,20 @@ void main_loop (void)
 	}
 #endif /* CONFIG_PREBOOT */
 
+#ifdef CONFIG_SILENT_CONSOLE
+	/* If booting in silent mode, the screen shows no indication of a successful boot.
+   	The following displays the version string with a silent mode statement and prints directly to the serial port  since
+	the console is in silent mode.*/
+      	StrPtr =  getenv("silent");
+      	if (strcmp(StrPtr,"yes")==0)
+	{
+		extern char version_string[];
+		serial_puts("\n");
+		serial_puts(version_string );
+		serial_puts("\nSilent mode...\n");
+	}
+#endif
+
 #if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
 	s = getenv ("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
Index: u-boot-1.3.1/common/console.c
===================================================================
--- u-boot-1.3.1.orig/common/console.c
+++ u-boot-1.3.1/common/console.c
@@ -363,9 +363,18 @@ int console_init_f (void)
 {
 	gd->have_console = 1;
 
+
 #ifdef CONFIG_SILENT_CONSOLE
-	if (getenv("silent") != NULL)
+	char *StrPtr;
+     	StrPtr =  getenv("silent");
+       if (StrPtr==NULL) {
+           gd->flags &= (~GD_FLG_SILENT);
+           return (0);
+       }
+     	if (strcmp(StrPtr,"yes")==0)
 		gd->flags |= GD_FLG_SILENT;
+     	else
+     		gd->flags &= (~GD_FLG_SILENT);
 #endif
 
 	return (0);
Index: u-boot-1.3.1/include/mpc83xx.h
===================================================================
--- u-boot-1.3.1.orig/include/mpc83xx.h
+++ u-boot-1.3.1/include/mpc83xx.h
@@ -102,6 +102,7 @@
 #define SPR_8311E_REV10			0x80B20010
 #define SPR_8313_REV10			0x80B10010
 #define SPR_8313E_REV10			0x80B00010
+#define SPR_8313E_REV21			0x80B10021
 
 /* SPCR - System Priority Configuration Register
  */
