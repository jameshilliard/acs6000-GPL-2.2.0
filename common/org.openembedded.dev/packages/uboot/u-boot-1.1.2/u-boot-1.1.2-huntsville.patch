diff -Naur u-boot-1.1.2/board/amazon/amazon.c uboot-1.1.2hsv/board/amazon/amazon.c
--- u-boot-1.1.2/board/amazon/amazon.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/amazon.c	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,798 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/cpm_85xx.h>
+#include <spd.h>
+
+#include "bdparam.h"
+#include "eeprom.h"
+
+#if defined(CONFIG_DDR_ECC)
+extern void ddr_enable_ecc(unsigned int dram_size);
+#endif
+
+extern long int spd_sdram(void);
+
+void local_bus_init(void);
+void sdram_init(void);
+
+/* we can NOT set bd_t within board_early_init_f(), bcz no ram has
+ * been allocated for gd->bd yet, have to do in board_early_init_r() */
+int board_early_init_f (void)
+{
+#ifdef CONFIG_AMAZON
+  volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+  volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+  volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+
+  /*=============================================
+   * CONFIG PORT (A)
+   *
+   *         OUTPUTS
+   * PA8   - APPFLASH_WP
+   * PA9   - BOOTFLASH_WP
+   * PA10  - POE_FLSH_UPGRADE_L
+   * PA11  - USB_RST_L
+   * PA15  - POE_RST_L
+   * PA16  - DIMM_RESET
+   * PA17  - LPORT_PHY_RESET_L
+   * PA18  - FPGA_RESET_L
+   * PA19  - GIGE1_RST_L
+   * PA21  - HD_CTRL_RST_L
+   * PA23  - GIGE2_RST_L
+   * PA30  - BOOTAPPFLASH_RST_L (left as input)
+   */
+#define PORT_A_OUTPUTS (CPM_PA_8  | CPM_PA_9  | CPM_PA_10 | CPM_PA_11 | \
+                        CPM_PA_15 | CPM_PA_16 | CPM_PA_17 | CPM_PA_18 | CPM_PA_19 | \
+                        CPM_PA_21 | CPM_PA_23)
+
+  cpm_iop->podra &= ~PORT_A_OUTPUTS;
+  cpm_iop->pdata |=  PORT_A_OUTPUTS;  /* default outputs are high */
+  cpm_iop->pdira |=  PORT_A_OUTPUTS;
+
+  /*=============================================
+   * CONFIG PORT (B)
+   *
+   *         OUTPUTS
+   * PB27  - XILINX CCLK
+   * PB28  - XILINX PROG
+   * PB29  - XILINX D0
+   *         INPUTS 
+   * PB22  - 12V PRI GOOD
+   * PB23  - 12V SEC GOOD
+   * PB24  - 48V PRI GOOD
+   * PB25  - 48V SEC GOOD
+   * PB30  - XILINX_INIT
+   * PB31  - XILINX_DONE
+   */
+#define PORT_B_OUTPUTS (CPM_PB_27 | CPM_PB_28 | CPM_PB_29)
+#define PORT_B_INPUTS  (CPM_PB_22 | CPM_PB_23 | CPM_PB_24 | CPM_PB_25 | CPM_PB_30 | CPM_PB_31)  
+
+#define PORT_B_XILINX_OUTPUTS (CPM_PB_27 | CPM_PB_28 | CPM_PB_29)
+#define PORT_B_XILINX_PROG     CPM_PB_28
+
+  cpm_iop->podrb &= ~PORT_B_OUTPUTS;
+  cpm_iop->pdatb |=  PORT_B_OUTPUTS;  /* default outputs are high */
+  cpm_iop->pdirb |=  PORT_B_OUTPUTS;
+
+  cpm_iop->podrb &= ~PORT_B_INPUTS;
+  cpm_iop->pdirb &= ~PORT_B_INPUTS;
+
+  cpm_iop->pdatb &= ~PORT_B_XILINX_OUTPUTS;   /* XILINX OUTPUTS LOW */
+  cpm_iop->pdatb |= PORT_B_XILINX_PROG;       /* PROG HIGH */
+
+  /*=============================================
+   * CONFIG PORT (D)
+   *
+   *         OUTPUTS
+   * PD22 - SW_DEBUG_LED_3
+   * PD23 - SW_DEBUG_LED_2
+   * PD24 - SW_DEBUG_LED_1
+   * PD25 - SW_DEBUG_LED_0
+   *         INPUTS
+   * PD18 - BD_REV_0
+   * PD19 - BD_REV_1
+   * PD20 - BD_REV_2
+   * PD21 - BD_REV_3
+   * PD29 - PROD_ID_0
+   * PD30 - PROD_ID_1
+   * PD31 - PROD_ID_2 (LABELED AS PROD_ID_3 ON SCHEMATIC) 
+   */
+#define PORT_D_OUTPUTS (CPM_PD_22 | CPM_PD_23 | CPM_PD_24 | CPM_PD_25)
+#define PORT_D_INPUTS  (CPM_PD_18 | CPM_PD_19 | CPM_PD_20 | CPM_PD_21 | CPM_PD_29 | CPM_PD_30 | CPM_PD_31)
+
+  cpm_iop->podrd &= ~PORT_D_OUTPUTS;
+  cpm_iop->pdatd |=  PORT_D_OUTPUTS;  /* default outputs are high */
+  cpm_iop->pdird |=  PORT_D_OUTPUTS;
+
+  cpm_iop->podrd &= ~PORT_D_INPUTS;
+  cpm_iop->pdird &= ~PORT_D_INPUTS;
+
+  /*
+   * configure Port D
+   *   I2C pins 
+   * PD14 - Bit Bang I2C SCL
+   * PD15 - Bit Bang I2C SDA
+   */
+  cpm_iop->ppard &= ~(CPM_PD_14 | CPM_PD_15);
+  cpm_iop->pdird &= ~(CPM_PD_14 | CPM_PD_15);
+  cpm_iop->podrd |=  (CPM_PD_14 | CPM_PD_15);
+  cpm_iop->pdatd |=  (CPM_PD_14 | CPM_PD_15);
+
+  asm("sync;isync;msync");
+
+#else
+	/*************************
+	 * FPGA register bit: (for DEBV1 2nd spin)
+	 *
+	 * 0xc0000020: board version and revision,
+	 *               MSB 4-bit is for version:  0x0 is for version 1: DEBV1
+	 *               LSB 4-bit is for revision: 0x2 is for 2nd spin, 0x1 is for 1st spin
+	 * 0xc0000021: FPGA code version, eg. 0x51
+	 * 0xc0000022: (TBD)
+	 * 0xc0000023: (TBD)
+	 */
+
+	unsigned short *fpgaregs = (unsigned short *)CFG_ATA_BASE_ADDR;
+	unsigned int board_type;			/* eg. OnBoard, KVMMAX */
+	unsigned int board_ver_rev;			/* V1 rev1 for 2nd spin */
+	unsigned int board_model;			/* 24/40-port, Dual/Single power, AC/DC */
+	unsigned int fpga_version;			/* FPGA code version */
+
+#ifdef CONFIG_DEB	
+	board_type = BOARD_ONBOARD;
+#else
+	board_type = BOARD_UNKNOWN;
+#endif
+	board_ver_rev = fpgaregs[0x20/sizeof(unsigned short)] / 0x100;
+	fpga_version = fpgaregs[0x20/sizeof(unsigned short)] % 0x100;
+
+#ifdef CONFIG_DEBV1
+	/*
+	 * 1st spin work around: fpga's board_ver_rev is not correct,
+	 *   we correct it.
+	 */
+	if (board_ver_rev >= 0xd0) {
+		board_ver_rev = 0x01;
+	}
+	
+	/**
+	 * cyclades: for DEBV1 board,
+	 * in order to enable some devices we need to preset some CCSR registers:
+	 *     CPM_PA_19         : 88E1111 PHY
+	 *     CPM_PA_21         : PCMCIA
+	 *     CPM_PA_23         : FAILOVER Eth (NATSEMI DP83816)
+	 *     CPM_PC_8          : OPAL-1 (88E6095 Switch)
+	 *     CPM_PC_9          : OPAL-2 (88E6095 Switch)
+	 *     CPM_PC_12         : OPAL-3 (88E6095 Switch)
+	 *     CPM_PC_14         : OPAL-4 (88E6095 Switch)
+	 *     CPM_PC_15         : OPAL-5 (88E6095 Switch)
+	 *
+	 * we also use these two bits to indicate Dual Power status:
+	 *     CPM_PC_6          : Dual power:PowerA status (ReadOnly)
+	 *     CPM_PC_7          : Dual power:PowerB status (ReadOnly)
+	 *
+	 * we also use these 6 bits(INPUT) to indicate board_model(ONLY
+	 * valid when board_ver_rev >= 0x02)
+	 *     CPM_PC_16         : 24/40 port, 0 for 40P, 1 for 24P
+	 *     CPM_PC_17         : PS, 0 for dual PS, 1 for single PS
+	 *     CPM_PC_18         : AC/DC, 0 for AC, 1 for DC
+	 *     CPM_PC_19         : DIS_sw6095, 0 for enable, 1 for disable
+	 *     CPM_PC_20         : (TBD)
+	 *     CPM_PC_21         : (TBD)
+	 *
+	 * we use PA13 output (only for board_ver_rev >=0x03) to
+	 * indicate console's LNK
+	 *     CPM_PA_13         : 0 for No LNK, 1 for has LINK
+	 *
+	 * After all setting are done, two more steps are followed at the very end:
+	 *     1. read the final config register just written,
+	 *     2. asm("sync");
+	 */
+	{
+		volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+		volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+		volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+		volatile ccsr_gur_t *gur = &immap->im_gur;
+		unsigned long tmp;
+
+		/* set direction to be output =1 */
+		cpm_iop->pdira |= (CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		cpm_iop->pdirc |= (CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+		/* direction input =0 */
+		cpm_iop->pdirc &= ~(CPM_PC_6 | CPM_PC_7);
+  
+		/* set general IO =0 */
+		cpm_iop->ppara &= ~(CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		cpm_iop->pparc &= ~(CPM_PC_6 | CPM_PC_7 | CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+
+		/* no need to change PSORx because of general IO */
+
+		/* set open drain to be regular =0 */
+		cpm_iop->podra &= ~(CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		cpm_iop->podrc &= ~(CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+		cpm_iop->podrc &= ~(CPM_PC_6 | CPM_PC_7);
+
+		asm("sync;isync;msync");
+		udelay(50);
+
+		/*
+		 * setting board_model according to board_ver_rev
+		 */
+		if (board_ver_rev < 0x02) { /* 1st spin */
+			int _24p = 0;
+#ifdef DEB_24_PORT
+			_24p = 1;
+#endif
+			/* 24/40 port, Dual PS, AC, EN_sw6095 */
+			board_model = (_24p<<7) | (0<<6) | (0<<5) | (0<<4);
+		} else {	/* >= 2nd spin */
+			cpm_iop->pdirc &= ~(CPM_PC_16 | CPM_PC_17 | CPM_PC_18
+					    | CPM_PC_19 | CPM_PC_20 | CPM_PC_21); /* input */
+			cpm_iop->pparc &= ~(CPM_PC_16 | CPM_PC_17 | CPM_PC_18
+					    | CPM_PC_19 | CPM_PC_20 | CPM_PC_21); /* GPIO */
+			cpm_iop->podrc &= ~(CPM_PC_16 | CPM_PC_17 | CPM_PC_18
+					    | CPM_PC_19 | CPM_PC_20 | CPM_PC_21); /* regular */
+			asm("sync;isync;msync");
+			udelay(50);
+			board_model = (cpm_iop->pdatc & 0x0000fc00) >> 8; /* get model# */
+		}
+
+		/*
+		 * for 3nd spin and later on, init console LNK LED.
+		 */
+		if (board_ver_rev >=0x03) {
+			cpm_iop->pdira |=  CPM_PA_13; /* output */
+			cpm_iop->ppara &= ~CPM_PA_13; /* GPIO */
+			cpm_iop->podra &= ~CPM_PA_13; /* regular */
+			cpm_iop->pdata &= ~CPM_PA_13; /* No LNK */
+			/* set to LINK ON after console init */
+		}
+
+
+		/* first set data bit to be 0 to reset devices */
+		cpm_iop->pdata &= ~(CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		cpm_iop->pdatc &= ~(CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+  
+		asm("sync;isync;msync");
+		udelay(10);
+
+		/* then set data bit to be 1 to de-assert reset*/
+		if (board_ver_rev < 0x02) {
+			cpm_iop->pdata |= (CPM_PA_19); /* 1st spin, don't enable any PCI device due to buggy PCI bus */
+		} else {
+			cpm_iop->pdata |= (CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		}
+
+		cpm_iop->pdatc |= (CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+
+		/*
+		 * enable CLK_OUT as SYSCLK in GUR, which is used as PCI bus
+		 * clk in 2nd spin, and no harm to 1st spin.
+		 */
+		gur->clkocr = 0x80000002;
+
+		/* do the last two steps */
+		tmp = gur->clkocr;
+		asm("sync;isync;msync");
+	}
+#endif /* CONFIG_DEBV1 */
+#endif /* CONFIG_AMAZON */
+	return 0;
+}
+
+/* set bd_t due to board_early_init_f() */
+int board_early_init_r (void)
+{
+//	volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+//  volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	bd->board_type    = BOARD_AMAZON;
+  bd->board_model   = 0x01;
+  bd->board_ver_rev = 0x01;
+  bd->fpga_version  = 0x01;
+	return 0;
+}
+
+int misc_init_r (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	char *tmp;
+
+	/* some bd_t entries are set in board_early_init_r() */
+
+	bd->pci = 1;
+	printf("Board type             : %02x\n", bd->board_type);
+	printf("Board version_revision : %02x\n", bd->board_ver_rev);
+	printf("Board model            : %02x\n", bd->board_model);
+	printf("FPGA  version          : %02x\n", bd->fpga_version);
+  printf("Amazon 32-Port, Single PS\n" );
+
+	if ((tmp = getenv ("fecmode1")) == NULL) {
+		setenv("fecmode1", "auto");
+		bd->mii_operation[0] = 0;
+	} else if (strcmp(tmp, "1000F") == 0 || strcmp(tmp, "1000f") == 0) {
+		bd->mii_operation[0] = 1;
+	} else if (strcmp(tmp, "1000H") == 0 || strcmp(tmp, "1000h") == 0) {
+		bd->mii_operation[0] = 2;
+	} else if (strcmp(tmp, "100F") == 0  || strcmp(tmp, "100f") == 0) {
+		bd->mii_operation[0] = 3;
+	} else if (strcmp(tmp, "100H") == 0  || strcmp(tmp, "100h") == 0) {
+		bd->mii_operation[0] = 4;
+	} else if (strcmp(tmp, "10F") == 0   || strcmp(tmp, "10f") == 0) {
+		bd->mii_operation[0] = 5;
+	} else if (strcmp(tmp, "10H") == 0   || strcmp(tmp, "10h") == 0) {
+		bd->mii_operation[0] = 6;
+	} else {
+		setenv("fecmode1", "auto");
+		bd->mii_operation[0] = 0;
+	}
+
+	if ((tmp = getenv ("fecmode2")) == NULL) {
+		setenv("fecmode2", "auto");
+		bd->mii_operation[1] = 0;
+	} else if (strcmp(tmp, "1000F") == 0 || strcmp(tmp, "1000f") == 0) {
+		bd->mii_operation[1] = 1;
+	} else if (strcmp(tmp, "1000H") == 0 || strcmp(tmp, "1000h") == 0) {
+		bd->mii_operation[1] = 2;
+	} else if (strcmp(tmp, "100F") == 0  || strcmp(tmp, "100f") == 0) {
+		bd->mii_operation[1] = 3;
+	} else if (strcmp(tmp, "100H") == 0  || strcmp(tmp, "100h") == 0) {
+		bd->mii_operation[1] = 4;
+	} else if (strcmp(tmp, "10F") == 0   || strcmp(tmp, "10f") == 0) {
+		bd->mii_operation[1] = 5;
+	} else if (strcmp(tmp, "10H") == 0   || strcmp(tmp, "10h") == 0) {
+		bd->mii_operation[1] = 6;
+	} else {
+		setenv("fecmode2", "auto");
+		bd->mii_operation[1] = 0;
+	}
+
+        if ((tmp = getenv("wdt")) == NULL) {
+                setenv("wdt", "on");
+                bd->wdt = 1;
+        } else if (strcmp(tmp, "on") == 0  || strcmp(tmp, "ON") == 0) {
+                bd->wdt = 1;
+        } else if (strcmp(tmp, "off") == 0 || strcmp(tmp, "OFF") == 0) {
+                bd->wdt = 0;
+	} else {
+                setenv("wdt", "on");
+                bd->wdt = 1;
+	}
+
+	if ((tmp = getenv("serial#")) == NULL) {
+		//unsigned char nbr[8];
+		//if (read_serial_number(nbr)) {
+		//	sprintf(bd->device_id,
+		//		"%02x%02x%02x%02x%02x%02x",
+		//		nbr[0], nbr[1], nbr[2],
+		//		nbr[3], nbr[4], nbr[5]);
+		//	setenv("serial#", bd->device_id);
+		//}
+		bd->device_id[0] = 0;
+        } else {
+                strncpy(bd->device_id, tmp, 15);
+        }
+	if (bd->wdt) {
+#ifdef CONFIG_WATCHDOG
+		extern void start_85xx_watchdog(void);
+		
+		start_85xx_watchdog();
+#endif
+	}
+	return 0;
+}
+
+int checkboard (void)
+{
+	volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+
+	uint pci_dual = get_pci_dual ();
+	uint pci1_32 = gur->pordevsr & 0x10000;		/* PORDEVSR[15] */
+	uint pci1_clk_sel = gur->porpllsr & 0x8000;	/* PORPLLSR[16] */
+	uint pci2_clk_sel = gur->porpllsr & 0x4000;	/* PORPLLSR[17] */
+
+	uint pci1_speed = get_pci1_clock_freq ();
+	uint pci2_speed = get_pci2_clock_freq ();
+
+	printf ("Board: Amazon\n");
+
+	printf ("    PCI1: %d bit, %s MHz, %s\n",
+		(pci1_32) ? 32 : 64,
+		(pci1_speed == 33000000) ? "33" :
+		(pci1_speed == 66000000) ? "66" : "unknown",
+		pci1_clk_sel ? "sync" : "async");
+
+	if (pci_dual) {
+		printf ("    PCI2: 32 bit, %s MHz, %s\n",
+			(pci2_speed == 33000000) ? "33" :
+			(pci2_speed == 66000000) ? "66" : "unknown",
+			pci2_clk_sel ? "sync" : "async");
+	} else {
+		printf ("    PCI2: disabled\n");
+	}
+
+	/*
+	 * Initialize local bus.
+	 */
+	local_bus_init ();
+
+	return 0;
+}
+
+long int
+initdram(int board_type)
+{
+	long dram_size = 0;
+
+	puts("Initializing\n");
+
+#if defined(CONFIG_DDR_DLL)
+	{
+		/*
+		 * Work around to stabilize DDR DLL MSYNC_IN.
+		 * Errata DDR9 seems to have been fixed.
+		 * This is now the workaround for Errata DDR11:
+		 *    Override DLL = 1, Course Adj = 1, Tap Select = 0
+		 */
+
+		volatile immap_t *immap = (immap_t *)CFG_IMMR;
+		volatile ccsr_gur_t *gur= &immap->im_gur;
+
+		gur->ddrdllcr = 0x81000000;
+		asm("sync;isync;msync");
+		udelay(200);
+	}
+#endif
+	dram_size = spd_sdram();
+
+#if defined(CONFIG_DDR_ECC)
+	/*
+	 * Initialize and enable DDR ECC.
+	 */
+	ddr_enable_ecc(dram_size);
+#endif
+	/*
+	 * SDRAM Initialization
+	 */
+	sdram_init();
+
+	puts("    DDR: ");
+	return dram_size;
+}
+
+/*
+ * Initialize Local Bus
+ */
+void
+local_bus_init(void)
+{
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+
+	uint clkdiv;
+	uint lbc_hz;
+	sys_info_t sysinfo;
+	uint temp_lbcdll;
+
+	/*
+	 * Errata LBC11.
+	 * Fix Local Bus clock glitch when DLL is enabled.
+	 *
+	 * If localbus freq is < 66Mhz, DLL bypass mode must be used.
+	 * If localbus freq is > 133Mhz, DLL can be safely enabled.
+	 * Between 66 and 133, the DLL is enabled with an override workaround.
+	 */
+
+	get_sys_info(&sysinfo);
+
+	/* cyclades: who sets lbc->lcrr? PowerOn reset value is 0x8000_0008 */
+	clkdiv = lbc->lcrr & 0x0f;
+	lbc_hz = sysinfo.freqSystemBus / 1000000 / clkdiv;
+
+	if (lbc_hz < 66) {
+		/* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+		lbc->lcrr = CFG_LBC_LCRR | 0x80000000;	/* DLL Bypass */
+
+	} else if (lbc_hz >= 133) {
+		/* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+		lbc->lcrr = CFG_LBC_LCRR & (~0x80000000); /* DLL Enabled */
+
+	} else {
+		/* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+		lbc->lcrr = CFG_LBC_LCRR & (~0x80000000);/* DLL Enabled */
+		udelay(200);
+
+		/*
+		 * Sample LBC DLL ctrl reg, upshift it to set the
+		 * override bits.
+		 */
+		temp_lbcdll = gur->lbcdllcr;
+		gur->lbcdllcr = (((temp_lbcdll & 0xff) << 16) | 0x80000000);
+		asm("sync;isync;msync");
+	}
+
+#if 0 /* these are configured by macros in AMAZON.h */
+/* local bus base register fields */
+#define BR_PS( n )    ((n & 0x03)<<(31-20))   /* port size           3=32bit */
+#define BR_DECC( n )  ((n & 0x03)<<(31-22))   /* data error checking 0=off   */
+#define BR_WP( n )    ((n & 0x01)<<(31-23))   /* write protect       0=R/W   */
+#define BR_MSEL( n )  ((n & 0x07)<<(31-26))   /* machine select      0=GPCM  */
+#define BR_ATOM( n )  ((n & 0x03)<<(31-29))   /* atomic memory operations    */
+#define BR_V( n )     ((n & 0x01)<<(31-31))   /* valid               1=valid */
+
+/* local bus option register fields for GPCM */
+#define OR_BCTLD( n ) ((n & 0x01)<<(31-19))   /* buffer control disable 0=enable */
+#define OR_CSNT( n )  ((n & 0x01)<<(31-20))
+#define OR_ACS( n )   ((n & 0x03)<<(31-22))
+#define OR_XACS( n )  ((n & 0x01)<<(31-23))
+#define OR_SCY( n )   ((n & 0x0F)<<(31-27))
+#define OR_SETA( n )  ((n & 0x01)<<(31-28))
+#define OR_TRLX( n )  ((n & 0x01)<<(31-29))
+#define OR_EHTR( n )  ((n & 0x01)<<(31-30))
+#define OR_EAD( n )   ((n & 0x01)<<(31-31))
+
+  /* the local bus access window is defind for 256M from 0xC0000000 to (0xD000000-1) 
+   * therefore the following Chip selects should be within this range 
+   */
+
+  /* XILINX CS5 base address 0xC5000000, length 1M, bus size = 32bits */
+
+  lbc->or5 = 0xFFF00000 | OR_BCTLD(0)|OR_CSNT(0)|OR_ACS(2)|OR_XACS(0)|
+                          OR_SCY(0)|OR_SETA(0)|OR_TRLX(0)|OR_EHTR(0)|OR_EAD(0);
+  lbc->br5 = 0xC5000000 | BR_PS(3)|BR_DECC(0)|BR_WP(0)|BR_MSEL(0)|BR_ATOM(0)|BR_V(1);
+
+  /* XILINX CS6 base address 0xC6000000, length 1M, bus size = 32bits */
+
+  lbc->or6 = 0xFFF00000 | OR_BCTLD(0)|OR_CSNT(0)|OR_ACS(2)|OR_XACS(0)|
+                          OR_SCY(0)|OR_SETA(0)|OR_TRLX(0)|OR_EHTR(0)|OR_EAD(0);
+  lbc->br6 = 0xC6000000 | BR_PS(3)|BR_DECC(0)|BR_WP(0)|BR_MSEL(0)|BR_ATOM(0)|BR_V(1);
+
+  /* XILINX CS7 base address 0xC7000000, length 1M, bus size = 32bits */
+
+  lbc->or7 = 0xFFF00000 | OR_BCTLD(0)|OR_CSNT(0)|OR_ACS(2)|OR_XACS(0)|
+                          OR_SCY(0)|OR_SETA(0)|OR_TRLX(0)|OR_EHTR(0)|OR_EAD(0);
+  lbc->br7 = 0xC7000000 | BR_PS(3)|BR_DECC(0)|BR_WP(0)|BR_MSEL(0)|BR_ATOM(0)|BR_V(1);
+#endif
+
+}
+
+/*
+ * Initialize SDRAM memory on the Local Bus.
+ */
+void
+sdram_init(void)
+{
+#if defined(CFG_OR2_PRELIM) && defined(CFG_BR2_PRELIM)
+
+	uint idx;
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+	uint *sdram_addr = (uint *)CFG_LBC_SDRAM_BASE;
+	uint cpu_board_rev;
+	uint lsdmr_common;
+
+	puts("    SDRAM: ");
+
+	print_size (CFG_LBC_SDRAM_SIZE * 1024 * 1024, "\n");
+
+	/*
+	 * Setup SDRAM Base and Option Registers
+	 */
+	lbc->or2 = CFG_OR2_PRELIM;
+	asm("msync");
+
+	lbc->br2 = CFG_BR2_PRELIM;
+	asm("msync");
+
+	lbc->lbcr = CFG_LBC_LBCR;
+	asm("msync");
+
+	lbc->lsrt = CFG_LBC_LSRT;
+	lbc->mrtpr = CFG_LBC_MRTPR;
+	asm("msync");
+
+	/*
+	 * Determine which address lines to use baed on CPU board rev.
+	 */
+	cpu_board_rev = get_cpu_board_revision();
+	lsdmr_common = CFG_LBC_LSDMR_COMMON;
+	if (cpu_board_rev == MPC85XX_CPU_BOARD_REV_1_0) {
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1617;
+	} else if (cpu_board_rev == MPC85XX_CPU_BOARD_REV_1_1) {
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1516;
+	} else {
+		/*
+		 * Assume something unable to identify itself is
+		 * really old, and likely has lines 16/17 mapped.
+		 */
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1617;
+	}
+
+	/*
+	 * Issue PRECHARGE ALL command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_PCHALL;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(100);
+
+	/*
+	 * Issue 8 AUTO REFRESH commands.
+	 */
+	for (idx = 0; idx < 8; idx++) {
+		lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_ARFRSH;
+		asm("sync;msync");
+		*sdram_addr = 0xff;
+		ppcDcbf((unsigned long) sdram_addr);
+		udelay(100);
+	}
+
+	/*
+	 * Issue 8 MODE-set command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_MRW;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(100);
+
+	/*
+	 * Issue NORMAL OP command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_NORMAL;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(200);    /* Overkill. Must wait > 200 bus cycles */
+
+#endif	/* enable SDRAM init */
+}
+
+#if defined(CFG_DRAM_TEST)
+int
+testdram(void)
+{
+	uint *pstart = (uint *) CFG_MEMTEST_START;
+	uint *pend = (uint *) CFG_MEMTEST_END;
+	uint *p;
+
+	printf("Testing DRAM from 0x%08x to 0x%08x\n",
+	       CFG_MEMTEST_START,
+	       CFG_MEMTEST_END);
+
+	printf("DRAM test phase 1:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0xaaaaaaaa;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0xaaaaaaaa) {
+			printf ("DRAM test fails at: %08x, expected [%08x], got [%08x]\n", (uint) p, 0xaaaaaaaa, *p);
+			return 1;
+		}
+	}
+
+	printf("DRAM test phase 2:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0x55555555;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0x55555555) {
+			printf ("DRAM test fails at: %08x, expected [%08x], got [%08x]\n", (uint) p, 0x55555555, *p);
+			return 1;
+		}
+	}
+
+	printf("DRAM test passed.\n");
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_PCI)
+
+/*
+ * Initialize PCI Devices, report devices found.
+ */
+
+#ifndef CONFIG_PCI_PNP
+static struct pci_config_table pci_mpc85xxcds_config_table[] = {
+    { PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+      PCI_IDSEL_NUMBER, PCI_ANY_ID,
+      pci_cfgfunc_config_device, { PCI_ENET0_IOADDR,
+				   PCI_ENET0_MEMADDR,
+				   PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER
+      } },
+    { }
+};
+#ifdef CONFIG_AMAZON
+static struct pci_config_table pci_mpc85xxcds_config_table2[] = {
+    { PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+      PCI_IDSEL_NUMBER, PCI_ANY_ID,
+      pci_cfgfunc_config_device, { PCI_ENET0_IOADDR,
+				   PCI_ENET0_MEMADDR,
+				   PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER
+      } },
+    { }
+};
+#endif
+#endif
+
+static struct pci_controller hose = {
+#ifndef CONFIG_PCI_PNP
+	config_table: pci_mpc85xxcds_config_table,
+#endif
+};
+
+#ifdef CONFIG_AMAZON
+static struct pci_controller hose2 = {
+#ifndef CONFIG_PCI_PNP
+//	config_table: pci_mpc85xxcds_config_table2,
+#endif
+};
+#endif  /* CONFIG_AMAZON */
+
+#endif	/* CONFIG_PCI */
+
+void
+pci_init_board(void)
+{
+#ifdef CONFIG_PCI
+	extern void pci_mpc85xx_init(struct pci_controller *hose);
+
+	debug("%s\n", __FUNCTION__);
+	pci_mpc85xx_init(&hose);
+  pci_mpc85xx_init_2(&hose2);
+
+	debug("finished %s\n", __FUNCTION__);
+#endif
+}
+
+extern flash_info_t flash_info[];
+
+int last_stage_init(void)
+{
+  unsigned short n;
+  flash_info_t *info;
+
+  info = &flash_info[0];
+  /*
+   * unprotect all sectors 
+   */
+  for ( n = 0; n < info->sector_count; ++n )  
+  {
+#ifdef CFG_FLASH_PROTECTION
+    flash_real_protect ( info, n, 0 );
+#endif
+  }
+  return 0;
+}
+
diff -Naur u-boot-1.1.2/board/amazon/bdparam.c uboot-1.1.2hsv/board/amazon/bdparam.c
--- u-boot-1.1.2/board/amazon/bdparam.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/bdparam.c	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+/**
+   cyclades: this src file bdparam.c is to replace cadmus.c to supply
+   some board info. the following functions are provided:
+
+   unsigned int get_board_version(void);
+   unsigned long get_clock_freq(void);
+   unsigned int get_pci_dual(void);
+   unsigned int get_pci_slot(void);
+   unsigned long get_pci1_clock_freq(void);
+   unsigned long get_pci2_clock_freq(void);
+   
+   */
+#include <common.h>
+#include "bdparam.h"
+#include <asm/immap_85xx.h>
+#include <asm/cpm_85xx.h>
+
+unsigned int
+get_board_model(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd;
+
+	if (gd->flags & GD_FLG_RELOC) {
+		bd = gd->bd;
+		return bd->board_model;
+	}
+
+#ifdef CONFIG_DEB
+	{
+		volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+		volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+		volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+		unsigned int board_ver_rev = get_board_ver_rev();
+
+		/*
+		 * setting board_model according to board_ver_rev
+		 */
+		if (board_ver_rev < 0x02) { /* 1st spin */
+			int _24p = 0;
+#ifdef DEB_24_PORT
+			_24p = 1;
+#endif
+			/* 24/40 port, Dual PS, AC, EN_sw6095 */
+			return (_24p<<7) | (0<<6) | (0<<5) | (0<<4);
+		} else {	/* >= 2nd spin */
+			return (cpm_iop->pdatc & 0x0000fc00) >> 8;
+		}
+	}
+#endif
+	return 0;
+}
+
+unsigned int
+get_board_ver_rev(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd;
+	unsigned int board_ver_rev;
+
+#if 1
+	if (gd->flags & GD_FLG_RELOC) {
+		bd = gd->bd;
+		return bd->board_ver_rev;
+	}
+#endif
+
+	board_ver_rev = 0;
+	return board_ver_rev;
+}
+
+
+unsigned long
+get_clock_freq(void)
+{
+#ifdef CONFIG_DEB
+	unsigned int board_ver_rev = get_board_ver_rev();
+
+	if (board_ver_rev == 0x01)
+		return 66666666;		/* SYS_CLK_FREQ is set 66MHZ */
+	else if (board_ver_rev == 0x02)
+		return 33333333;		/* SYS_CLK_FREQ is set 33MHZ */
+	else
+		return 33333333; /* default */
+#else
+	return 33333333;		/* SYS_CLK_FREQ is set 66MHZ */
+#endif
+}
+
+
+/* in KVMMAXV1/DEBV1 board, PCI1 use PCI1_CLK instead of SYS_CLK_FREQ */
+unsigned long
+get_pci1_clock_freq(void)
+{
+#ifdef CONFIG_DEB
+	unsigned int board_ver_rev = get_board_ver_rev();
+
+	if (board_ver_rev == 0x01)
+		return 33000000;
+	else if (board_ver_rev == 0x02) {
+		unsigned long sysclk = get_clock_freq();
+		sysclk /= 1000000;	/* convert to whole MHz */
+		return sysclk*1000000;
+	} else
+		return 33000000; /* default */
+#else
+	return 33000000;		/* PCI1_CLK is set 33MHZ */
+#endif
+}
+
+/* in KVMMAXV1/DEBV1 board, PCI2 use PCI2_CLK instead of SYS_CLK_FREQ */
+unsigned long
+get_pci2_clock_freq(void)
+{
+#ifdef CONFIG_DEB
+	unsigned int board_ver_rev = get_board_ver_rev();
+
+	if (board_ver_rev == 0x01)
+		return 33000000;
+	else if (board_ver_rev == 0x02) {
+		unsigned long sysclk = get_clock_freq();
+		sysclk /= 1000000;	/* convert to whole MHz */
+		return sysclk*1000000;
+	} else
+		return 33000000; /* default */
+#else
+	return 33000000;		/* PCI1_CLK is set 33MHZ */
+#endif
+}
+
+
+unsigned int
+get_pci_dual(void)
+{
+	return 1;			/* use both PCI1 and PCI2 */
+}
diff -Naur u-boot-1.1.2/board/amazon/bdparam.h uboot-1.1.2hsv/board/amazon/bdparam.h
--- u-boot-1.1.2/board/amazon/bdparam.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/bdparam.h	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+   cyclades: use bdparam.h to replace cadmus.h
+    */
+#ifndef __BDPARAM_H_
+#define __BDPARAM_H_
+
+
+/*
+ * Amazon Board System Register interface.
+ */
+#define BOARD_AMAZON  0 
+#define BOARD_UNKNOWN	0xff
+
+/*
+ * Returns board version and revision.
+ */
+extern unsigned int get_board_ver_rev(void);
+
+/*
+ * Returns either 33333333 or 66666666 as the SYS_CLK_FREQ.
+ */
+extern unsigned long get_clock_freq(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the PCI1_CLK_FREQ
+ */
+extern unsigned long get_pci1_clock_freq(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the PCI1_CLK_FREQ
+ */
+extern unsigned long get_pci2_clock_freq(void);
+
+
+/*
+ * Returns PCI DUAL.
+ */
+extern unsigned int get_pci_dual(void);
+
+/*
+ * Returns board model number
+ */
+extern unsigned int get_board_model(void);
+
+#endif	/* __BDPARAM_H_ */
diff -Naur u-boot-1.1.2/board/amazon/cadmus.c uboot-1.1.2hsv/board/amazon/cadmus.c
--- u-boot-1.1.2/board/amazon/cadmus.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/cadmus.c	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+
+
+/*
+ * CADMUS Board System Registers
+ */
+#ifndef CFG_CADMUS_BASE_REG
+#define CFG_CADMUS_BASE_REG	(CADMUS_BASE_ADDR + 0x4000)
+#endif
+
+typedef struct cadmus_reg {
+    u_char cm_ver;		/* Board version */
+    u_char cm_csr;		/* General control/status */
+    u_char cm_rst;		/* Reset control */
+    u_char cm_hsclk;		/* High speed clock */
+    u_char cm_hsxclk;		/* High speed clock extended */
+    u_char cm_led;		/* LED data */
+    u_char cm_pci;		/* PCI control/status */
+    u_char cm_dma;		/* DMA control */
+    u_char cm_reserved[248];	/* Total 256 bytes */
+} cadmus_reg_t;
+
+
+unsigned int
+get_board_version(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	return cadmus->cm_ver;
+}
+
+
+unsigned long
+get_clock_freq(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	uint pci1_speed = (cadmus->cm_pci >> 2) & 0x3; /* PSPEED in [4:5] */
+
+	if (pci1_speed == 0) {
+		return 33000000;
+	} else if (pci1_speed == 1) {
+		return 66000000;
+	} else {
+		/* Really, unknown. Be safe? */
+		return 33000000;
+	}
+}
+
+
+unsigned int
+get_pci_slot(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	/*
+	 * PCI slot in USER bits CSR[6:7] by convention.
+	 */
+	return ((cadmus->cm_csr >> 6) & 0x3) + 1;
+}
+
+
+unsigned int
+get_pci_dual(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	/*
+	 * PCI DUAL in CM_PCI[3]
+	 */
+	return cadmus->cm_pci & 0x10;
+}
diff -Naur u-boot-1.1.2/board/amazon/cadmus.h uboot-1.1.2hsv/board/amazon/cadmus.h
--- u-boot-1.1.2/board/amazon/cadmus.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/cadmus.h	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CADMUS_H_
+#define __CADMUS_H_
+
+
+/*
+ * CADMUS Board System Register interface.
+ */
+
+/*
+ * Returns board version register.
+ */
+extern unsigned int get_board_version(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the SYS_CLK_FREQ.
+ */
+extern unsigned long get_clock_freq(void);
+
+
+/*
+ * Returns 1 - 4, as found in the USER CSR[6:7] bits.
+ */
+extern unsigned int get_pci_slot(void);
+
+
+/*
+ * Returns PCI DUAL as found in CM_PCI[3].
+ */
+extern unsigned int get_pci_dual(void);
+
+
+#endif	/* __CADMUS_H_ */
diff -Naur u-boot-1.1.2/board/amazon/cmd_leds.c uboot-1.1.2hsv/board/amazon/cmd_leds.c
--- u-boot-1.1.2/board/amazon/cmd_leds.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/cmd_leds.c	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,394 @@
+
+/*
+ * LED diagnostic
+ */
+#include <common.h>
+#include <config.h>
+#include <command.h>
+
+#ifdef CONFIG_AMAZON
+
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/cpm_85xx.h>
+
+#ifdef CONFIG_MV88E6095
+
+  #include "../board/amazon/sw6095.h"
+  extern GT_QD_DEV *qdMultiDev[MAX_NR_SWITCHES];
+  #define MAX_PHY_PORTS (MAX_NR_SWITCHES * 8)
+
+#endif
+
+
+//#define RELOC(a)	((typeof(a))((unsigned long)(a) + gd->reloc_off))
+
+//=========================================================
+
+static unsigned hex1_bin (char c)
+{
+	if (c >= '0' && c <= '9')
+		return (c - '0');
+	if (c >= 'a' && c <= 'f')
+		return (c + 10 - 'a');
+	if (c >= 'A' && c <= 'F')
+		return (c + 10 - 'A');
+	return 0;
+}
+
+static unsigned hex2_bin (char *s)
+{
+	unsigned h = 0;
+
+  while ( *s ) 
+  {
+    h = (h << 4) | hex1_bin(*s++);
+  }
+  return h;
+}
+
+/*
+ * PB31 - Xilinx DONE       input
+ * PB30 - Xilinx Init       input
+ * PB29 - Xilinx D0         output
+ * PB28 - Xilinx Prog       output
+ * PB27 - Xilinx cclk       output
+ * PB26 - spare
+ * PB25 - 48v sec volts good    input
+ * PB24 - 48v pri volts good    input
+ * PB23 - 12v sec good          input
+ * PB22 - 12v pri good          input
+ * PB21 - 12v sec status LED    output
+ * PB20 - 12v pri status LED    output
+ * PB19 - 48v sec status LED    output
+ * PB18 - 48v pri status LED    output
+ */
+
+//=========================================================
+
+static void emit_debug_led( int led, int state )
+{
+  volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+  volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+  volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+
+  struct led_t 
+  {
+    unsigned port;
+    unsigned mask;
+  } led_table[] = 
+  {
+    { 0x0D, CPM_PD_22 },  /* SW debug 3 */
+    { 0x0D, CPM_PD_23 },  /* SW debug 2 */
+    { 0x0D, CPM_PD_24 },  /* SW debug 1 */
+    { 0x0D, CPM_PD_25 }   /* SW debug 0 */
+  };
+
+  led %= 4;
+
+  if ( led_table[led].port == 0x0D ) 
+  {
+    if ( state ) 
+    {
+      cpm_iop->pdatd |= led_table[led].mask;
+    }
+    else 
+    {
+      cpm_iop->pdatd &= ~led_table[led].mask;
+    }
+  }
+}
+
+//=========================================================
+
+static void emit_port_led( int port, int led, unsigned state )
+{
+  int dev = (port % MAX_PHY_PORTS) / 8;
+  GT_U16 reg;
+
+  dev = (MAX_NR_SWITCHES-1) - dev;
+  led = !led;
+  gprtGetPhyReg( qdMultiDev[dev], port % 8, 25, & reg );
+  reg &= ~(         0x03  << (led *2));
+  reg |=  ((state & 0x03) << (led *2));
+  reg |=  0x7000; /* all LEDS active HIGH */
+  gprtSetPhyReg( qdMultiDev[dev], port % 8, 25,   reg );
+}
+
+//=========================================================
+
+#define dup_bit( v, from, to )  v = (v & ~(31-to)) | ( ((v>>(31-from)) & 0x01) << (31-to))
+
+static void do_power( void )
+{
+  volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+  volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+  volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+
+  while ( ! ctrlc() ) 
+  {
+    unsigned long port;
+
+    port = cpm_iop->pdatb;
+//    printf( "port = %8X\n", port );
+    dup_bit( port, 25, 19 );
+    dup_bit( port, 24, 18 );
+    dup_bit( port, 23, 21 );
+    dup_bit( port, 22, 20 );
+    cpm_iop->pdatb = port;
+    udelay( 100000 );
+  }
+}
+
+//=========================================================
+
+static void do_debug( unsigned pattern )
+{
+  int led, led_count = 4;
+  int count = 0;
+
+  while ( ! ctrlc() ) 
+  {
+    if ( pattern ) 
+    {
+      for ( led = 0; led < led_count; ++led ) 
+      {
+        emit_debug_led( led, pattern & (0x01 << led) );
+      }
+    }
+    else 
+    {
+      for ( led = 0; led < led_count; ++led ) 
+      {
+        emit_debug_led( led, count & (0x01 << led) );
+      }
+      ++count;
+    }
+    udelay( 500000/2 );
+  }
+}
+
+//=========================================================
+
+#define PORT_LED_ON       3
+#define PORT_LED_OFF      2
+#define PORT_LED_DEFAULT  0
+
+static void upd_port_leds( unsigned char led_states[] )
+{
+  int led, led_count = MAX_PHY_PORTS * 2;
+
+  for ( led = 0; led < led_count; ++led ) 
+  {
+    emit_port_led( led / 2, led % 2, led_states[ led ] );
+  }
+}
+
+static void rotate_port_leds( unsigned char led_states[], int count )
+{
+  int led, led_count = MAX_PHY_PORTS * 2;
+  unsigned char tmp;
+
+  while ( count > 0 ) 
+  {
+    --count;
+    tmp = led_states[ led_count-1 ];
+    for ( led = led_count-1; led > 0; --led ) 
+    {
+      led_states[ led ] = led_states[ led-1 ];
+    }
+    led_states[ 0 ] = tmp;
+  }
+  while ( count < 0 ) 
+  {
+    ++count;
+    tmp = led_states[ 0 ];
+    for ( led = 0; led < led_count-1; ++led )
+    {
+      led_states[ led ] = led_states[ led+1 ];
+    }
+    led_states[ led_count-1 ] = tmp;
+  }
+}
+
+//=========================================================
+
+static void do_port( void )
+{
+  int led, led_count = MAX_PHY_PORTS * 2;
+  unsigned char led_states[ MAX_PHY_PORTS * 2 ];
+  unsigned char tmp_state;
+
+  while ( ! ctrlc() ) 
+  {
+    int n, i;
+
+    /* blink all */
+    for ( n = 0; n < 2; ++n ) 
+    {
+      memset( led_states, PORT_LED_ON, sizeof( led_states ) );
+      upd_port_leds( led_states );
+      udelay( 500000/2 ); 
+      memset( led_states, PORT_LED_OFF, sizeof( led_states ) );
+      upd_port_leds( led_states );
+      udelay( 500000/2 );
+      if( ctrlc() ) goto quit;
+    }
+    memset( led_states, PORT_LED_OFF, sizeof( led_states ) );
+    upd_port_leds( led_states );
+
+    /* scroll port columns */
+
+    for ( n = 0; n < 2; ++n ) 
+    {
+      led_states[ 0 ] = PORT_LED_ON;
+      led_states[ 2 ] = PORT_LED_ON;
+      for ( i = 0; i < 16; ++i ) 
+      {
+        upd_port_leds( led_states );
+        udelay( 500000/8 );
+        rotate_port_leds( led_states, 1 );
+
+        upd_port_leds( led_states );
+        udelay( 500000/8 );
+        rotate_port_leds( led_states, 3 );
+
+        if( ctrlc() ) goto quit;
+      }
+    }
+    memset( led_states, PORT_LED_OFF, sizeof( led_states ) );
+    upd_port_leds( led_states );
+
+    /* scroll port rows */
+
+    for ( n = 0; n < 2; ++n ) 
+    {
+      for ( led = 0; led < led_count; led += 4 ) 
+      {
+        led_states[ led+0 ] = PORT_LED_ON;
+        led_states[ led+1 ] = PORT_LED_ON;
+        led_states[ led+2 ] = PORT_LED_OFF;
+        led_states[ led+3 ] = PORT_LED_OFF;
+      }
+      for ( i = 0; i < 2; ++i ) 
+      {
+        upd_port_leds( led_states );
+        udelay( 500000/2 );
+        rotate_port_leds( led_states, 2 );
+        if( ctrlc() ) goto quit;
+      }
+    }
+    memset( led_states, PORT_LED_OFF, sizeof( led_states ) );
+    upd_port_leds( led_states );
+
+    /* bar graph */
+
+    for ( n = 0; n < 2; ++n ) 
+    {
+      /* grow right */
+      for ( i = 0; i < 16; ++i ) 
+      {
+        rotate_port_leds( led_states, 4 );
+        led_states[ 0 ] = PORT_LED_ON;
+        led_states[ 1 ] = PORT_LED_ON;
+        led_states[ 2 ] = PORT_LED_ON;
+        led_states[ 3 ] = PORT_LED_ON;
+        upd_port_leds( led_states );
+        udelay( 500000/8 );
+        if( ctrlc() ) goto quit;
+      }
+      /* shrink left */ 
+      for ( i = 0; i < 16; ++i ) 
+      {
+        led_states[ 0 ] = PORT_LED_OFF;
+        led_states[ 1 ] = PORT_LED_OFF;
+        led_states[ 2 ] = PORT_LED_OFF;
+        led_states[ 3 ] = PORT_LED_OFF;
+        rotate_port_leds( led_states, -4 );
+        upd_port_leds( led_states );
+        udelay( 500000/8 );
+        if( ctrlc() ) goto quit;
+      }
+    }
+    memset( led_states, PORT_LED_OFF, sizeof( led_states ) );
+    upd_port_leds( led_states );
+  }
+quit:
+  memset( led_states, PORT_LED_DEFAULT, sizeof( led_states ) );
+  upd_port_leds( led_states );
+}
+
+//=========================================================
+
+int do_leds (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	int rcode = 0;
+  unsigned led_pattern;
+#if 1 /* DHS - show LBC regs */
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+
+  printf( "LBCR = %08X\n", lbc->lbcr );
+  printf( "LCRR = %08X\n", lbc->lcrr );
+
+  printf( "BR5 = %08X\n", lbc->br5 );
+  printf( "OR5 = %08X\n", lbc->or5 );
+  printf( "BR6 = %08X\n", lbc->br6 );
+  printf( "OR6 = %08X\n", lbc->or6 );
+  printf( "BR7 = %08X\n", lbc->br7 );
+  printf( "OR7 = %08X\n", lbc->or7 );
+#endif
+
+  switch ( argc ) 
+  {
+    case 1:
+      do_debug( 0 );
+      break;
+
+    case 2:
+      if ( 0==strcmp( argv[1], "power" ) ) 
+      {
+        do_power();
+        break;
+      }
+      if ( 0==strcmp( argv[1], "debug" ) ) 
+      {
+        do_debug( 0 );
+        break;
+      }
+      if ( 0==strcmp( argv[1], "port" ) ) 
+      {
+        do_port();
+        break;
+      }
+      break;
+
+    case 3:
+      led_pattern = hex2_bin(argv[2]);
+      printf( "led_pattern = %0x\n", led_pattern );
+      if ( 0==strcmp( argv[1], "debug" ) ) 
+      {
+        do_debug( led_pattern );
+        break;
+      }
+      break;
+  }
+  return rcode;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	leds,	3,	1,	do_leds,
+	"leds    - exercise LEDS\n", 
+	"port \nleds debug\nleds power\n"
+	"  - debug [ pattern ] - debug LEDs\n"
+	"  - port              - port LEDs\n"
+	"  - power status in to LED outputs\n"
+);
+
+#endif	/* CONFIG_AMAZON */
+
+//#endif	/* CFG_CMD_LEDS */
diff -Naur u-boot-1.1.2/board/amazon/cmd_macaddr.c uboot-1.1.2hsv/board/amazon/cmd_macaddr.c
--- u-boot-1.1.2/board/amazon/cmd_macaddr.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/cmd_macaddr.c	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,239 @@
+
+/*
+ * Amazon MAC address configuration
+ */
+#include <common.h>
+#include <config.h>
+#include <command.h>
+
+#ifdef CONFIG_AMAZON
+
+#include <linux/ctype.h>
+
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/cpm_85xx.h>
+
+extern char console_buffer[];
+
+static int atoi(const char *s)
+{
+	int i=0;
+
+	while (isdigit(*s))
+  {
+		i = i*10 + (*s++) - '0';
+  }
+	return i;
+}
+
+#if 0
+int amazon_get_ethaddr (void)
+{
+	for (;;) {
+		int n;
+
+#ifdef CONFIG_BOOT_RETRY_TIME
+		reset_cmd_timeout ();
+#endif
+
+		n = readline2 ("Enter board ethernet address: ", 0 );
+
+		if (n < 0)
+			return (n);
+
+		if (n == 0)
+			continue;
+
+		if (n == 17) {
+			int i;
+			char *p, *q;
+			uchar ea[6];
+
+			/* see if it looks like an ethernet address */
+
+			p = console_buffer;
+
+			for (i = 0; i < 6; i++) {
+				char term = (i == 5 ? '\0' : ':');
+
+				ea[i] = simple_strtol (p, &q, 16);
+
+				if ((q - p) != 2 || *q++ != term)
+					break;
+
+				p = q;
+			}
+
+			if (i == 6) {
+				/* it looks ok - set it */
+				printf ("Setting ethernet addr to %s\n",
+					console_buffer);
+
+				setenv ("ethaddr", console_buffer);
+
+				puts ("Remember to do a 'saveenv' to "
+					"make it permanent\n");
+
+				return (0);
+			}
+		}
+
+		printf ("Invalid ethernet addr (%s) - please re-enter\n",
+			console_buffer);
+	}
+}
+#endif
+
+
+
+//  while ( ! ctrlc() ) 
+
+#if 0
+	tmp = getenv ( (unsigned char *) ((mac==0) ? "ethaddr" : "eth1addr") );
+	if ( ! tmp ) 
+  {
+    tmp = (mac==0) ? MK_STR(CONFIG_ETHADDR) : MK_STR(CONFIG_ETH1ADDR);
+  }
+#endif
+
+//=========================================================
+
+static int valid_mac( char *mac )
+{
+  int i;
+
+  for ( i = 0; i < 6; ++i ) 
+  {
+    if ( ! isxdigit( *mac ) ) 
+    {
+      break;
+    }
+    while ( isxdigit( *mac ) ) 
+    { 
+      ++mac;
+    }
+    if ( i < 5 ) 
+    {
+      if ( *mac != ':' ) 
+      {
+        break;
+      }
+      ++mac;
+    }
+  }
+  return (i == 6);
+}
+
+//=========================================================
+
+static char *get_ethname( int mac_inx )
+{
+  static char *ethNames[4] = 
+  {
+    "ethaddr", 
+    "eth1addr", 
+    "eth2addr", 
+    "eth3addr" 
+  };
+  return ethNames[ mac_inx % 4 ];
+}
+
+//=========================================================
+
+static char *get_mac_addr( unsigned mac_inx )
+{
+  return getenv( get_ethname(mac_inx) );
+}
+
+//=========================================================
+
+static void set_mac_addr( unsigned mac_inx, char *value )
+{
+  setenv( get_ethname(mac_inx), console_buffer );
+}
+
+//=========================================================
+
+static void do_mac_w_prompt( unsigned mac_inx )
+{
+  char prompt[10];
+  char *value;
+
+  for (;;) 
+  {
+    sprintf( prompt, "MAC %d: ", mac_inx );
+
+    value = get_mac_addr( mac_inx );
+    if ( readline2( prompt, value ) <= 0 ) 
+    {
+      break;
+    }
+    if ( valid_mac( console_buffer ) ) 
+    {
+      set_mac_addr( mac_inx, console_buffer );
+      break;
+    }
+    printf( "\nInvalid MAC address [%s], Please re-enter!\n", console_buffer );
+  }
+}
+
+//=========================================================
+
+static void do_mac_wo_prompt( unsigned mac_inx, char *value )
+{
+}
+
+//=========================================================
+
+int do_cfgmac (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+  unsigned mac_inx;
+
+  switch ( argc ) 
+  {
+    case 1: 
+      do_mac_w_prompt( 0 );
+      break;
+
+    case 2:
+      mac_inx = atoi( argv[1] );
+      if ( mac_inx > 3 ) 
+      {
+        printf( "\nInvalid selection : [%d]\n", mac_inx );
+        break;
+      }
+      do_mac_w_prompt( mac_inx );
+      break;
+
+    case 3:
+      mac_inx = atoi( argv[1] );
+      if ( mac_inx > 3 ) 
+      {
+        printf( "\nInvalid selection : [%d]\n", mac_inx );
+        break;
+      }
+      do_mac_wo_prompt( mac_inx, argv[2] );
+      break;
+    default:
+      printf( "\nIncorrect usage\n" );
+      break;
+  }
+  printf( "\n" );
+  return 0;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	cfgmac,	3,	0,	do_cfgmac,
+	"cfgmac  - configure a MAC adddress\n", 
+  "[0..3] hex_mac_address\n"
+	" Example: cfgmac 1 00:e0:86:02:00:01\n"
+  "   This sets mac address 1 without prompt\n"
+	" Example: cfgmac 2\n"
+  "   This sets mac address 2 via prompting\n"
+);
+
+#endif	/* CONFIG_AMAZON */
+
diff -Naur u-boot-1.1.2/board/amazon/cmd_newboot.c uboot-1.1.2hsv/board/amazon/cmd_newboot.c
--- u-boot-1.1.2/board/amazon/cmd_newboot.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/cmd_newboot.c	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,176 @@
+
+/*
+ * Command to PROGRAM new boot firmware from mem
+ */
+#include <common.h>
+#include <config.h>
+#include <command.h>
+
+#ifdef CONFIG_AMAZON
+
+#include <image.h>
+#include <environment.h>
+#include <asm/byteorder.h>
+#include <linux/ctype.h>
+
+extern flash_info_t flash_info[];
+
+//=========================================================
+
+int strcasecmp( const char *s1, const char *s2 )
+{
+  int diff;
+
+  while ( *s1 && *s2 ) 
+  {
+    diff = tolower(*s1) - tolower(*s2);
+    if ( diff ) 
+    {
+      return diff;
+    }
+    s1++;
+    s2++;
+  }
+  return tolower(*s1) - tolower(*s2);
+}
+
+//=========================================================
+
+int do_newboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+  char *addr_str;
+  image_header_t *hdr;
+  ulong flashAddr;
+  ulong flashSize;
+  int rc;
+  flash_info_t *info;
+  int n, sect_first = 127;
+  int sect_last  = 130;
+
+  printf( "Update U-Boot firmware\n" );
+
+  addr_str = getenv( "loadaddr" );
+  if ( ! addr_str ) 
+  {
+    printf( "Environment variable 'loadaddr' is undefined\n" );
+    return -1;
+  }
+  hdr = (image_header_t *) simple_strtoul (addr_str, NULL, 16);
+
+  if ( ntohl(hdr->ih_magic) != IH_MAGIC ) 
+  {
+    printf( "Wrong image magic\n" );
+    return -1;
+  }
+
+#if 0
+  printf( "magic        = %08x\n", ntohl( hdr->ih_magic ) );
+  printf( "size         = %08x, %d\n", ntohl( hdr->ih_size ), ntohl( hdr->ih_size ) );
+  printf( "load address = %08x\n", ntohl( hdr->ih_load ) );
+  printf( "image type   = %02x\n", hdr->ih_type );
+  printf( "image name   = %s\n", hdr->ih_name );
+#endif
+
+  if ( hdr->ih_type != IH_TYPE_FIRMWARE ) 
+  {
+    printf( "Wrong image type\n");
+    return -1;
+  }
+  flashAddr = 0xFFF80000;
+  flashSize = ntohl(hdr->ih_size);
+  /*
+   * erase flash prior to write 
+   */
+  info = &flash_info[0];
+  printf( "erasing flash sectors" );
+  /*
+   * unprotect sectors of interest 
+   */
+  for ( n = sect_first; n <= sect_last; ++n ) 
+  {
+#ifdef CFG_FLASH_PROTECTION
+    flash_real_protect ( info, n, 0 );
+#else
+    info->protect[n] = 0;
+#endif
+  }
+  rc = flash_erase (info, sect_first, sect_last );
+  if ( rc ) 
+  {
+    printf( "error erasing sector %d, error %d\n", n, rc );
+    return -1;
+  }
+  /*
+   * write boot firmware to flash 
+   */
+  printf( "programing flash sectors" );
+  rc = flash_write( hdr+1, flashAddr, flashSize );
+  if ( rc ) 
+  {
+    printf( "Flash write failed, error %d\n", rc );
+    return -1;
+  }
+  printf( "\nU-Boot update completed\n" );
+  return 0;  
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	newboot,	1,	0,	do_newboot,
+	"newboot  - programs new boot flash from memory\n", 
+  "programs boot flash firmware from image loaded into ram\n"
+);
+
+
+//=========================================================
+
+int do_setboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+  char tmp[ 100 ];
+
+  if( ! getenv( "bootargs_nfs" ) )
+  {    
+    setenv ("bootargs_nfs", CONFIG_BOOTARGS_NFS );
+  }
+  if ( ! getenv( "bootargs_flash" ) ) 
+  {
+    setenv ("bootargs_flash", CONFIG_BOOTARGS_FLASH );
+  }
+
+  if( argc == 2 ) 
+  {
+    if ( 0==strcasecmp( "nfs", argv[1] ) ) 
+    {
+      getenv_r( "bootargs_nfs", tmp, sizeof(tmp) );
+      setenv( "bootargs", tmp );
+    }
+    else if ( 0==strcasecmp( "flash", argv[1] ) ) 
+    {
+      getenv_r( "bootargs_flash", tmp, sizeof(tmp) );
+      setenv( "bootargs", tmp );
+      setenv( "bootcmd", CONFIG_BOOTCOMMAND );
+    }
+    else 
+    {
+      printf( "Unknown selection : %s\n", argv[1] );
+    }
+  }
+  return 0;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	setboot,	2,	0,	do_setboot,
+	"setboot - adjusts the bootargs env var to your boot preference\n", 
+  "[nfs or flash]\n"
+  " Example: setboot nfs \n"
+  "   This sets bootargs from bootargs_nfs\n" 
+  " Example: setboot flash \n"
+  "   This sets bootargs from bootargs_flash\n" 
+);
+
+#endif	/* CONFIG_AMAZON */
+
+
diff -Naur u-boot-1.1.2/board/amazon/config.mk uboot-1.1.2hsv/board/amazon/config.mk
--- u-boot-1.1.2/board/amazon/config.mk	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/config.mk	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,30 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# mpc8555cds board
+#
+TEXT_BASE = 0xfff80000
+
+PLATFORM_CPPFLAGS += -DCONFIG_E500=1
+PLATFORM_CPPFLAGS += -DCONFIG_MPC85xx=1
+#PLATFORM_CPPFLAGS += -mno-string
+PLATFORM_CPPFLAGS += -DCONFIG_MPC8555=1
diff -Naur u-boot-1.1.2/board/amazon/eeprom.c uboot-1.1.2hsv/board/amazon/eeprom.c
--- u-boot-1.1.2/board/amazon/eeprom.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/eeprom.c	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+#include <i2c.h>
+
+#include "eeprom.h"
+
+
+typedef struct {
+	char idee_pcbid[4];		/* "CCID" for CDC v1.X */
+	u8 idee_major;
+	u8 idee_minor;
+	char idee_serial[10];
+	char idee_errata[2];
+	char idee_date[8];		/* yyyymmdd */
+	/* The rest of the EEPROM space is reserved */
+} id_eeprom_t;
+
+
+
+/*
+   cyclades: we don't use eeprom to save cpu board rev. use FPGA instead.
+   TODO:
+   */
+unsigned int
+get_cpu_board_revision(void)
+{
+	uint major = 0;
+	uint minor = 0;
+
+/* 	id_eeprom_t id_eeprom; */
+
+/* 	i2c_read(CFG_I2C_EEPROM_ADDR, 0, 2, */
+/* 		 (uchar *) &id_eeprom, sizeof(id_eeprom)); */
+
+/* 	major = id_eeprom.idee_major; */
+/* 	minor = id_eeprom.idee_minor; */
+
+/* 	if (major == 0xff && minor == 0xff) { */
+/* 		major = minor = 0; */
+/* 	} */
+
+	return MPC85XX_CPU_BOARD_REV(major,minor);
+}
diff -Naur u-boot-1.1.2/board/amazon/eeprom.h uboot-1.1.2hsv/board/amazon/eeprom.h
--- u-boot-1.1.2/board/amazon/eeprom.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/eeprom.h	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EEPROM_H_
+#define __EEPROM_H_
+
+
+/*
+ * EEPROM Board System Register interface.
+ */
+
+
+/*
+ * CPU Board Revision
+ */
+#define MPC85XX_CPU_BOARD_REV(maj, min)	((((maj)&0xff) << 8) | ((min) & 0xff))
+#define MPC85XX_CPU_BOARD_MAJOR(rev)	(((rev) >> 8) & 0xff)
+#define MPC85XX_CPU_BOARD_MINOR(rev)	((rev) & 0xff)
+
+#define MPC85XX_CPU_BOARD_REV_UNKNOWN	MPC85XX_CPU_BOARD_REV(0,0)
+#define MPC85XX_CPU_BOARD_REV_1_0	MPC85XX_CPU_BOARD_REV(1,0)
+#define MPC85XX_CPU_BOARD_REV_1_1	MPC85XX_CPU_BOARD_REV(1,1)
+
+/*
+ * Returns CPU board revision register as a 16-bit value with
+ * the Major in the high byte, and Minor in the low byte.
+ */
+extern unsigned int get_cpu_board_revision(void);
+
+
+#endif	/* __EEPROM_H_ */
diff -Naur u-boot-1.1.2/board/amazon/init.S uboot-1.1.2hsv/board/amazon/init.S
--- u-boot-1.1.2/board/amazon/init.S	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/init.S	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,339 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ * Copyright 2002,2003, Motorola Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * amazon board init.S
+ *
+ * modified by Yang Yang, Cyclades Corp.
+ * changed parts are prepended with "cyclades"
+ * 2/14/05
+ *
+ * copied for use by Avocent's Amazon
+ */
+	
+#include <ppc_asm.tmpl>
+#include <ppc_defs.h>
+#include <asm/cache.h>
+#include <asm/mmu.h>
+#include <config.h>
+#include <mpc85xx.h>
+
+
+/*
+ * TLB0 and TLB1 Entries
+ *
+ * Out of reset, TLB1's Entry 0 maps the highest 4K for CCSRBAR.
+ * However, CCSRBAR is then relocated to CFG_CCSRBAR right after
+ * these TLB entries are established.
+ *
+ * The TLB entries for DDR are dynamically setup in spd_sdram()
+ * and use TLB1 Entries 8 through 15 as needed according to the
+ * size of DDR memory.
+ *
+ * MAS0: tlbsel, esel, nv
+ * MAS1: valid, iprot, tid, ts, tsize
+ * MAS2: epn, sharen, x0, x1, w, i, m, g, e
+ * MAS3: rpn, u0-u3, ux, sx, uw, sw, ur, sr
+ */
+
+#define	entry_start \
+	mflr	r1 	;	\
+	bl	0f 	;
+
+#define	entry_end \
+0:	mflr	r0	;	\
+	mtlr	r1	;	\
+	blr		;
+
+
+	.section	.bootpg, "ax"
+
+#ifdef CONFIG_AMAZON
+	.globl	tlb2_entry
+tlb2_entry:
+	entry_start
+	/*
+	 * Number of TLB0 and TLB1 entries in the following table
+	 */
+ 	.long 1
+
+	/**
+	 * Amazon: Flash size is 16M. Can't 16M prior to relocation of CCSRBAR. 
+	 *         So this is done afterward. 
+	 */
+	/*
+	 * TLB1 entry 15:16M	Non-cacheable, guarded
+	 */
+	.long TLB1_MAS0(1, 15, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_16M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_FLASH_BASE + 0x000000), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_FLASH_BASE + 0x000000), 0,0,0,0,0,1,0,1,0,1)
+
+	entry_end
+#endif
+
+	.globl	tlb1_entry
+tlb1_entry:
+	entry_start
+
+	/*
+	 * Number of TLB0 and TLB1 entries in the following table
+	 */
+	/**
+	 * cyclades: change TLB entry number 13 to real # entries
+	 * 5 TLB0 + 8 TLB1 = 13 entries
+	 */
+#ifdef CONFIG_AMAZON
+ 	.long 11
+#else
+ 	.long 13
+#endif
+
+#if (CFG_CCSRBAR_DEFAULT != CFG_CCSRBAR)
+	/*
+	 * TLB0		4K	Non-cacheable, guarded
+	 * 0xff700000	4K	Initial CCSRBAR mapping
+	 *
+	 * This ends up at a TLB0 Index==0 entry, and must not collide
+	 * with other TLB0 Entries.
+	 */
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_CCSRBAR_DEFAULT), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_CCSRBAR_DEFAULT), 0,0,0,0,0,1,0,1,0,1)
+#else
+#error("Update the number of table entries in tlb1_entry")
+#endif
+
+	/*
+	 * TLB0		16K	Cacheable, non-guarded
+	 * cyclades:	CFG_INIT_RAM_ADDR, 0xe401_0000 16K 0xe401_4000
+	 * 0xe401_0000	16K	Temporary Global data for initialization
+	 *			use L1 D-cache (32KB) for this.
+	 * 
+	 * Use four 4K TLB0 entries.  These entries must be cacheable
+	 * as they provide the bootstrap memory before the memory
+	 * controler and real memory have been configured.
+	 *
+	 * cyclades:	end up at TLB0 indices 0x10, 0x11, 0x12, 0x13
+	 * These entries end up at TLB0 Indicies 0x10, 0x11, 0x12, 0x13
+	 * and must not collide with other TLB0 entries.
+	 */
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 4 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 4 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 8 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 8 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 12 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 12 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/**
+	 * cyclades: Flash size is 8M,
+	 * no tsize can be exactly 8M, should we have two 4M size TLB entries?
+	 */
+	/*
+	 * DO NOT use entry 0, seems it caused core crash!!!
+	 * TLB1 entry 15:4M	Non-cacheable, guarded
+	 * 0xff800000	4M	FLASH first half
+	 * Out of reset this entry is only 4K.
+	 *
+	 * second half 4M will be assigned at TLB1 entry 6
+	 */
+#ifndef CONFIG_AMAZON
+	.long TLB1_MAS0(1, 15, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_4M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_FLASH_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_FLASH_BASE), 0,0,0,0,0,1,0,1,0,1)
+#endif
+	/*
+	 * TLB1 entry 1:256M	Non-cacheable, guarded
+	 * 0x80000000	256M	PCI1 MEM First half
+	 */
+	.long TLB1_MAS0(1, 1, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI1_MEM_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI1_MEM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 2:256M	Non-cacheable, guarded
+	 * 0x90000000	256M	PCI1 MEM Second half
+	 */
+	.long TLB1_MAS0(1, 2, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI1_MEM_BASE + 0x10000000),
+			0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI1_MEM_BASE + 0x10000000),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 3:256M	Non-cacheable, guarded
+	 * 0xa0000000	256M	PCI2 MEM First half
+	 */
+	.long TLB1_MAS0(1, 3, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI2_MEM_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI2_MEM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 4:256M	Non-cacheable, guarded
+	 * 0xb0000000	256M	PCI2 MEM Second half
+	 */
+	.long TLB1_MAS0(1, 4, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI2_MEM_BASE + 0x10000000),
+			0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI2_MEM_BASE + 0x10000000),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 5:64M	Non-cacheable, guarded
+	 * 0xe000_0000	1M	CCSRBAR
+	 * 0xe200_0000	16M	PCI1 IO
+	 * 0xe300_0000	16M	PCI2 IO
+	 */
+	.long TLB1_MAS0(1, 5, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_64M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_CCSRBAR), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_CCSRBAR), 0,0,0,0,0,1,0,1,0,1)
+
+	/**
+	 * cyclades: Flash size is 8M,
+	 * no tsize can be exactly 8M, should we have two 4M size TLB entries?
+	 */
+	/*
+	 * TLB1 entry 6:4M	Non-cacheable, guarded
+	 * 0xffc00000	4M	FLASH second half
+	 * Out of reset this entry is only 4K.
+	 *
+	 * first half 4M is assigned at TLB1 entry 15
+	 */
+#ifndef CONFIG_AMAZON
+	.long TLB1_MAS0(1, 6, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_4M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_FLASH_BASE + 0x400000), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_FLASH_BASE + 0x400000), 0,0,0,0,0,1,0,1,0,1)
+#endif
+	/**
+	 * cyclades: localbus is 256M,
+	 */
+	/*
+	 * TLB1 entry 7:256M	Non-cacheable, guarded
+	 * 0xc0000000	256M	LocalBus, FPGA for CF, etc
+	 *
+	 */
+	.long TLB1_MAS0(1, 7, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_LBC_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_LBC_BASE), 0,0,0,0,0,1,0,1,0,1)
+	
+	entry_end
+
+/*
+ * LAW(Local Access Window) configuration:
+ *
+ * 0x0000_0000     0x7fff_ffff     DDR                     2G
+ * 0x8000_0000     0x9fff_ffff     PCI1 MEM                512M
+ * 0xa000_0000     0xbfff_ffff     PCI2 MEM                512M
+ * cyclades: we have LocalBus mem map for Compact Flash
+ * 0xc000_0000     0xcfff_ffff     LOCALBUS                256M
+ * 0xe000_0000     0xe00f_ffff     CCSR                    1M
+ * 0xe200_0000     0xe2ff_ffff     PCI1 IO                 16M
+ * 0xe300_0000     0xe3ff_ffff     PCI2 IO                 16M
+ * 0xff80_0000     0xffff_ffff     FLASH (boot bank)       8M
+ *
+ * Notes:
+ *    CCSRBAR and L2-as-SRAM don't need a configured Local Access Window.
+ *    If flash is 8M at default position (last 8M), no LAW needed.
+ *
+ * The defines below are 1-off of the actual LAWAR0 usage.
+ * So LAWAR3 define uses the LAWAR4 register in the ECM.
+ */
+
+/**
+ * cyclades: DDR size is 256M
+ */	
+#define LAWBAR0 0
+#define LAWAR0  ((LAWAR_TRGT_IF_DDR | (LAWAR_SIZE & LAWAR_SIZE_256M)) & ~LAWAR_EN)
+
+#define LAWBAR1 ((CFG_PCI1_MEM_BASE>>12) & 0xfffff)
+#define LAWAR1 	(LAWAR_EN | LAWAR_TRGT_IF_PCI1 | (LAWAR_SIZE & LAWAR_SIZE_512M))
+
+#define LAWBAR2 ((CFG_PCI2_MEM_BASE>>12) & 0xfffff)
+#define LAWAR2 	(LAWAR_EN | LAWAR_TRGT_IF_PCI2 | (LAWAR_SIZE & LAWAR_SIZE_512M))
+
+#define LAWBAR3 ((CFG_PCI1_IO_BASE>>12) & 0xfffff)
+#define LAWAR3 	(LAWAR_EN | LAWAR_TRGT_IF_PCI1 | (LAWAR_SIZE & LAWAR_SIZE_16M))
+
+#define LAWBAR4 ((CFG_PCI2_IO_BASE>>12) & 0xfffff)
+#define LAWAR4 	(LAWAR_EN | LAWAR_TRGT_IF_PCI2 | (LAWAR_SIZE & LAWAR_SIZE_16M))
+
+/* cyclades: LocalBus */
+/* LBC window - maps 256M 0xc0000000 -> 0xcfffffff */
+#define LAWBAR5 ((CFG_LBC_BASE>>12) & 0xfffff)
+#define LAWAR5 	(LAWAR_EN | LAWAR_TRGT_IF_LBC | (LAWAR_SIZE & LAWAR_SIZE_256M))
+
+#ifdef CONFIG_AMAZON
+#define LAWBAR6 ((CFG_FLASH_BASE>>12) & 0xfffff)
+#define LAWAR6 	(LAWAR_EN | LAWAR_TRGT_IF_LBC | (LAWAR_SIZE & LAWAR_SIZE_16M))
+#endif
+	.section .bootpg, "ax"
+	.globl	law_entry
+
+law_entry:
+	entry_start
+/* cyclades: only 6 entries in LAWBAR/LAWAR */
+#ifdef CONFIG_AMAZON
+ 	.long 7
+#else
+ 	.long 6
+#endif
+	.long LAWBAR0,LAWAR0
+	.long LAWBAR1,LAWAR1
+	.long LAWBAR2,LAWAR2
+	.long LAWBAR3,LAWAR3
+	.long LAWBAR4,LAWAR4
+	.long LAWBAR5,LAWAR5
+#ifdef CONFIG_AMAZON
+	.long LAWBAR6,LAWAR6
+#endif
+	entry_end
diff -Naur u-boot-1.1.2/board/amazon/Makefile uboot-1.1.2hsv/board/amazon/Makefile
--- u-boot-1.1.2/board/amazon/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/Makefile	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,59 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+# (C) Copyright 2001
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+# cyclades: we don't use cadmus registers, use our config method, cycparam.
+# OBJS	:= $(BOARD).o \
+# 	   cadmus.o \
+# 	   eeprom.o
+OBJS	:= $(BOARD).o \
+	   bdparam.o \
+	   eeprom.o \
+	   sw6095.o \
+		 cmd_leds.o \
+		 cmd_newboot.o \
+		 cmd_macaddr.o
+
+SOBJS	:= init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Naur u-boot-1.1.2/board/amazon/sw6095.c uboot-1.1.2hsv/board/amazon/sw6095.c
--- u-boot-1.1.2/board/amazon/sw6095.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/sw6095.c	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,1208 @@
+/*
+ * Avocent
+ *   Support for Marvell's 88E6095 11-port switch chips for Amazon board.
+ *
+ * copied from Marvell's sample/MultiDevice/msApiInit.c
+ *
+ *
+ * Our block diagrams is like this:
+ * 
+ * -----------------------------------(Amazon Version 1,2)----------------------------
+ *
+ *                                -----------------------
+ *                                |MPC85xx TSEC2 Eth MAC|
+ *                                -----------------------
+ *                                             |
+ *                                             |
+ *                                             |
+ *  8------10------9  8------10------9  8------10------9  8------10------9
+ *  |  88E6095  #1 |--|  88E6095  #2 |--|  88E6095  #3 |--|  88E6095  #4 |
+ *  ----------------  ----------------  ----------------  ----------------
+ *    0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7   
+ *
+ *
+ *             Ethernet port of CPU is connected to port 10 of Device #3,
+ *             port 9 of Device #1 is connected to port 8 of Device #2,
+ *             port 9 of Device #2 is connected to port 8 of Device #3,
+ *             and so on.
+ *
+ *             Device #1 uses Phy Address 0x04,
+ *             Device #2 uses Phy Address 0x03,
+ *             Device #3 uses Phy Address 0x02,
+ *             Device #4 uses Phy Address 0x01,
+ *             Notes: Phy Address 0 cannot be used in a Multi Chip Address Mode.
+ *
+ *             Each Switch Device has to be configured to Multi Chip Address Mode.
+ *
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <miiphy.h>
+
+#ifdef CONFIG_MV88E6095
+
+#include "sw6095.h"
+#include "bdparam.h"
+
+#if 1 /* disable debug printing */
+  #undef MSG_PRINT
+  #define MSG_PRINT(x) 
+#endif
+
+#define MULTI_ADDR_MODE
+
+#ifndef N_OF_QD_DEVICES
+#define N_OF_QD_DEVICES		MAX_NR_SWITCHES	/* number of 88E6095 devices connected */
+#endif
+
+#define DEVICE1_ID		1
+#define DEVICE2_ID		DEVICE1_ID + 1
+#define DEVICE3_ID		DEVICE1_ID + 2
+#define DEVICE4_ID		DEVICE1_ID + 3
+
+static unsigned device_phy_addr[ N_OF_QD_DEVICES ] = { 0x04, 0x03, 0x02, 0x01 }; 
+
+//#define DEVICE1_PHY_ADDR	0x01
+//#define DEVICE2_PHY_ADDR	DEVICE1_PHY_ADDR + 1
+//#define DEVICE3_PHY_ADDR	DEVICE1_PHY_ADDR + 2
+//#define DEVICE4_PHY_ADDR	DEVICE1_PHY_ADDR + 3
+
+typedef struct routing_tbl_entry_s {
+	GT_32 devnum;
+	GT_LPORT portnum;
+} routing_tbl_entry_t;
+
+	
+/* cyclades: can have more than ONE cascade port? Yes! */
+#define DEVICE1_CPU_PORT		9
+#define DEVICE1_CASCADE_PORT	0xE 		/* 0xE means no CAS_PORT */
+#define DEVICE2_CPU_PORT		9
+#define DEVICE2_CASCADE_PORT	8
+#define DEVICE3_CPU_PORT		10
+#define DEVICE3_CASCADE_PORT	8
+#define DEVICE4_CPU_PORT		8
+#define DEVICE4_CASCADE_PORT	0xE
+
+#define ANOTHER_CPU_DEVICE_CASCADE_PORT 9
+
+#define S_CPU_DEVICE_ID		        DEVICE3_ID
+//#define S_CPU_DEVICE_PHY_ADDR	    DEVICE3_PHY_ADDR
+#define S_CPU_DEVICE_CPU_PORT	    DEVICE3_CPU_PORT
+#define S_CPU_DEVICE_CAS_PORT	    0xF            /* use Routing Table in G2 Reg0x6. */
+
+#define S_CPU_DEVICE_ROUTING_TBL {{1,8}, {2,8}, {4,9}, {-1,-1}}
+
+#define PORT_BIT(p)  (0x01 << (p))
+
+static unsigned device_port_startup[ N_OF_QD_DEVICES ] = 
+{
+  PORT_BIT(9),
+  PORT_BIT(8) | PORT_BIT(9),
+  PORT_BIT(8) | PORT_BIT(9) | PORT_BIT(10),
+  PORT_BIT(8),
+};
+
+                   /*    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10   */
+#define VLANTABLE  {{0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x000, 0x0ff, 0x000}, \
+                    {0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x1ff, 0x000}, \
+                    {0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x3ff}, \
+                    {0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x0ff, 0x000, 0x000}}
+ 
+#define DEFAULTVID {{0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007, 0x008, 0x000, 0x000, 0x000}, \
+                    {0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f, 0x010, 0x000, 0x000, 0x000}, \
+                    {0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x017, 0x018, 0x000, 0x000, 0x000}, \
+                    {0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x01f, 0x020, 0x000, 0x000, 0x000}}
+
+#define UNM   MEMBER_EGRESS_UNMODIFIED
+#define NOT   NOT_A_MEMBER
+#define UNT   MEMBER_EGRESS_UNTAGGED
+#define TAG   MEMBER_EGRESS_TAGGED
+
+#define DEVICE1_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+        }
+#define DEVICE2_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:9, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:10, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:11, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:12, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:13, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:14, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:15, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:16, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+        }
+#define DEVICE3_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:9, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:10, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:11, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:12, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:13, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:14, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:15, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:16, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:17, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:18, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:19, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:20, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:21, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:22, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:23, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:24, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:25, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:26, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:27, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:28, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:29, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:30, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:31, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:32, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+        }
+#define DEVICE4_VTU_ENTRIES {{DBNum:0, vid:25, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:26, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:27, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:28, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:29, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:30, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:31, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:32, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+        }
+
+static routing_tbl_entry_t s_cpu_device_routing_tbl[N_OF_QD_DEVICES] = S_CPU_DEVICE_ROUTING_TBL;
+static int vlantable[N_OF_QD_DEVICES][MAX_PORTS_PER_SWITCH] = VLANTABLE;
+static int defaultvid[N_OF_QD_DEVICES][MAX_PORTS_PER_SWITCH] = DEFAULTVID;
+static GT_VTU_ENTRY device1_vtu_entries[]=DEVICE1_VTU_ENTRIES;
+static GT_VTU_ENTRY device2_vtu_entries[]=DEVICE2_VTU_ENTRIES;
+static GT_VTU_ENTRY device3_vtu_entries[]=DEVICE3_VTU_ENTRIES;
+static GT_VTU_ENTRY device4_vtu_entries[]=DEVICE4_VTU_ENTRIES;
+
+GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES] = {0,};
+
+/*
+ * read mii register - see qdFFmii.c
+ */ 
+GT_BOOL ffReadMii(GT_QD_DEV* dev, 
+		  unsigned int portNumber , 
+		  unsigned int MIIReg, unsigned int* value)
+{
+	int ret;
+	unsigned short data=0xffff;
+  
+	if(!dev || !value)
+		return GT_FALSE;
+	debug("%s, %s, %d, calling miiphy_read(%u, %u, 0x%x)\n", __FILE__, __FUNCTION__, __LINE__, (unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short*)value);
+	ret=miiphy_read((unsigned char)(dev->phyAddr), (unsigned char)MIIReg, &data);
+	debug("%s, %s, %d, got value = %04x\n", __FILE__, __FUNCTION__, __LINE__, data);
+	if(ret==0) {
+		*value=(unsigned int)data;
+		return GT_TRUE;
+	}
+	return GT_FALSE;
+}
+
+/*
+ * write mii register - see qdFFmii.c
+ */ 
+GT_BOOL ffWriteMii(GT_QD_DEV* dev, 
+		   unsigned int portNumber , 
+		   unsigned int MIIReg, 
+		   unsigned int value)
+{
+	int ret;
+
+	if(!dev)
+		return GT_FALSE;
+	debug("%s, %s, %d, calling miiphy_write(%u, %u, %04x)\n", __FILE__, __FUNCTION__, __LINE__, (unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short)(value & 0x0000ffff));
+	ret=miiphy_write((unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short)(value & 0x0000ffff));
+	debug("%s, %s, %d, got ret = %d\n", __FILE__, __FUNCTION__, __LINE__, ret);
+	if(ret==0)
+		return GT_TRUE;
+	return GT_FALSE;
+}
+
+/*
+ * setup some constants for board autodetection.
+ */
+int sw6095_setup_const(bd_t *bis)
+{
+//	unsigned int bd_ver_rev = bis->board_ver_rev;
+//	unsigned int bd_model = bis->board_model;
+
+	return 0;
+}
+
+#if 1   /* option to dump out the routing table */
+static inline void dumpRoutingTable( GT_QD_DEV *dev ) {}
+#else
+static void dumpRoutingTable( GT_QD_DEV *dev )
+{
+	GT_U32 devnum;
+	GT_LPORT portnum;
+	GT_STATUS status = GT_FAIL;
+
+  MSG_PRINT(( "Dump Routing Table\n" ));
+  for ( devnum = 0; devnum < 8; ++devnum ) 
+  {
+    if ((status=gsysGetDevRoutingTable( dev, devnum, & portnum))!=GT_OK) 
+    {
+      MSG_PRINT(( "dumpRoutingTable: gsysGetDevRoutingTable: failed\n" ));
+      return;
+    }
+    MSG_PRINT(( "  devnum %d, portnum %d\n", devnum, portnum ));
+  }
+  MSG_PRINT(( "...\n" ));
+}
+#endif
+
+/*
+ * Initialize each Switch Devices. This should be done in BSP driver init routine.
+ * Since BSP is not combined with QuarterDeck driver, we are doing here.
+ * This routine will setup Switch Devices according to the above description.
+ */
+GT_STATUS qdMultiDevStart(void)
+{
+	GT_STATUS status = GT_FAIL;
+	GT_SYS_CONFIG   cfg;
+	int cpuPort;
+	int cascadePort;
+	int i,j;
+	int cpu_device_id = S_CPU_DEVICE_ID;
+	int another_cpu_cascadePort = ANOTHER_CPU_DEVICE_CASCADE_PORT;
+	routing_tbl_entry_t *rt_entry = s_cpu_device_routing_tbl;
+	int s_cpu_device_cas_port = S_CPU_DEVICE_CAS_PORT;
+
+	memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
+	
+	/* 
+	 * Create QD Device Structure for each device.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		qdMultiDev[i] = (GT_QD_DEV*)malloc(sizeof(GT_QD_DEV));
+
+		if(qdMultiDev[i] == NULL)
+		{
+			while(i--)
+				free(qdMultiDev[i]);
+			return GT_FAIL;
+		}
+
+		memset((char*)qdMultiDev[i],0,sizeof(GT_QD_DEV));
+	}
+	
+	/*
+	 * Register all the required functions to QuarterDeck Driver for each device.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		cfg.BSPFunctions.readMii   = ffReadMii;
+		cfg.BSPFunctions.writeMii  = ffWriteMii;
+#ifdef USE_SEMAPHORE
+		cfg.BSPFunctions.semCreate = osSemCreate;
+		cfg.BSPFunctions.semDelete = osSemDelete;
+		cfg.BSPFunctions.semTake   = osSemWait;
+		cfg.BSPFunctions.semGive   = osSemSignal;
+#else
+		cfg.BSPFunctions.semCreate = NULL;
+		cfg.BSPFunctions.semDelete = NULL;
+		cfg.BSPFunctions.semTake   = NULL;
+		cfg.BSPFunctions.semGive   = NULL;
+#endif
+
+		cfg.initPorts = GT_TRUE;	/* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
+		switch (i)
+		{
+		case 0: /* if we are registering device 1 */
+			cfg.cpuPortNum = DEVICE1_CPU_PORT;
+			break;
+		case 1: /* if we are registering device 2 */
+			cfg.cpuPortNum = DEVICE2_CPU_PORT;	
+			break;
+		case 2: /* if we are registering device 3 */
+			cfg.cpuPortNum = DEVICE3_CPU_PORT;	
+			break;
+		case 3: /* if we are registering device 4 */
+			cfg.cpuPortNum = DEVICE4_CPU_PORT;	
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+#ifdef MANUAL_MODE	/* not defined. this is only for sample */
+		/* user may want to use this mode when there are two QD switchs on the same MII bus. */
+		cfg.mode.scanMode = SMI_MANUAL_MODE;	/* Use QD located at manually defined base addr */
+		cfg.mode.baseAddr = 0x10;	/* valid value in this case is either 0 or 0x10 */
+#else
+#ifdef MULTI_ADDR_MODE	/* It should have been defined for this sample code */
+		cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;	/* find a QD in indirect access mode */
+//		cfg.mode.baseAddr = DEVICE1_PHY_ADDR + i; /* this is the phyAddr used by QD family device. Valid values are 1 ~ 31.*/
+		cfg.mode.baseAddr = device_phy_addr[i]; /* this is the phyAddr used by QD family device. Valid values are 1 ~ 31.*/
+#else
+		cfg.mode.scanMode = SMI_AUTO_SCAN_MODE;	/* Scan 0 or 0x10 base address to find the QD */
+		cfg.mode.baseAddr = 0;
+#endif
+#endif
+
+		if((status=qdLoadDriver(&cfg, qdMultiDev[i])) != GT_OK)
+		{
+			MSG_PRINT(("qdLoadDriver return Failed on device [%d]\n", i+1));
+			goto errorExit;
+		}
+
+ 		MSG_PRINT(("Opal #%d\n",i+1));
+		MSG_PRINT(("Device ID     : 0x%x\n",qdMultiDev[i]->deviceId));
+		MSG_PRINT(("Base Reg Addr : 0x%x\n",qdMultiDev[i]->baseRegAddr));
+		MSG_PRINT(("No of Ports   : %d\n",qdMultiDev[i]->numOfPorts));
+		MSG_PRINT(("CPU Port      : %d\n",qdMultiDev[i]->cpuPortNum));
+
+		/*
+		 *  start the QuarterDeck
+		 */
+		if((status=sysEnable(qdMultiDev[i])) != GT_OK)
+		{
+			MSG_PRINT(("sysEnable return Failed\n"));
+			goto errorExit;
+		}
+	}
+
+	/* 
+	 *	Now, we need to configure Cascading information for each devices.
+	 *	1. Set Interswitch port mode for port 8 and 9 for device 1,2,3,4,5
+	 *	   so that switch device can expect Marvell Tag from frames 
+	 *         ingressing/egressing this port.
+	 *	2. Set CPU Port information (for To_CPU frame) for each port of device.
+	 *	3. Set Cascading Port information (for From_CPU frame) for each device.
+	 *      4. Set Device ID (if required)
+	 *	Note: DeviceID is hardware configurable.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		switch (i) {
+		case 0: /* if we are registering device 1 */
+			cpuPort = DEVICE1_CPU_PORT; 		
+			cascadePort = DEVICE1_CASCADE_PORT;	
+			break;
+		case 1: /* if we are registering device 2 */
+			cpuPort = DEVICE2_CPU_PORT; 		
+			cascadePort = DEVICE2_CASCADE_PORT;	
+			break;
+		case 2: /* if we are registering device 3 */
+			cpuPort = DEVICE3_CPU_PORT; 		
+			cascadePort = DEVICE3_CASCADE_PORT;	
+			break;
+		case 3: /* if we are registering device 4 */
+			cpuPort = DEVICE4_CPU_PORT; 		
+			cascadePort = DEVICE4_CASCADE_PORT;	
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+
+		/*
+		 *	1. Set Interswitch port mode for port 8 and 9 for device 1,2,3,4,5
+		 *         so that switch device can expect Marvell Tag from frames 
+		 *         ingressing/egressing this port.
+		 *	2. Set CPU Port information (for To_CPU frame) for each port of device.
+		 */			
+		for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
+		{
+			if((j == cpuPort) || (j == cascadePort) || ((i==(cpu_device_id-1))&&(j==another_cpu_cascadePort)))
+			{
+ 				MSG_PRINT(("Opal #%d Port %d is setting inter-switch port\n",i+1, j));
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_TRUE)) != GT_OK)
+				{
+					MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode TRUE)\n",status,j));
+					goto errorExit;
+				}
+			}
+			else
+			{
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_FALSE)) != GT_OK)
+				{
+					MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode FALSE)\n",status,j));
+					goto errorExit;
+				}
+			}
+
+			/* NOTE:
+			 * cyclades: should S_CPU_DEVICE_ID's cpuPort be set to interswitch (AKA. Marvell Tag port)?
+			 *           Finally we should if modified TSEC2 MAC driver supports MT, we can disable
+			 *           it temporarily for developing.
+			 */
+#if 0
+			if((i==(cpu_device_id-1)) && (j==cpuPort)) {
+ 				MSG_PRINT(("Opal #%d is S_CPU_DEVICE_ID, its CPU_PORT %d is NOT set to Marvell Tag port because lack MAC driver support \n",i+1, j));
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_FALSE)) != GT_OK)
+				{
+					MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode FALSE)\n",status,j));
+					goto errorExit;
+				}
+			}
+#endif
+
+			if((status=gprtSetCPUPort(qdMultiDev[i],j,cpuPort)) != GT_OK)
+			{
+				MSG_PRINT(("gprtSetCPUPort returned %i\n",status));
+				goto errorExit;
+			}
+		}
+
+		/*
+		 *	3. Set Cascading Port information (for From_CPU fram) for each device.
+		 */	 	
+		if((status=gsysSetCascadePort(qdMultiDev[i],cascadePort)) != GT_OK)
+		{
+			MSG_PRINT(("gsysSetCascadePort returned %i\n",status));
+			goto errorExit;
+		}
+
+		/*
+		 *  cyclades: Q? for S_CPU_DEVICE_ID, how to set another_cpu_cascadePort?
+		 *          seems only ONE CAS_PORT per DEVICE!
+		 *  solution: set S_CPU_DEVICE_ID's CAS_PORT to be 0xF, then use routing
+		 *          table to route From_CPU marvell-tagged frame to the specified
+		 *          6095 device.
+		 */
+		if(i==(cpu_device_id-1)) {
+      dumpRoutingTable( qdMultiDev[i] );
+			if((status=gsysSetCascadePort(qdMultiDev[i],s_cpu_device_cas_port)) != GT_OK)
+			{
+				MSG_PRINT(("gsysSetCascadePort returned %i\n",status));
+				goto errorExit;
+			}
+			while(rt_entry && rt_entry->devnum !=-1) {
+ 				MSG_PRINT(("gsysSetDevRoutingTable(Opal#%d, dev %i, port %i)\n",i+1, rt_entry->devnum, rt_entry->portnum)); 
+				if((status=gsysSetDevRoutingTable(qdMultiDev[i],rt_entry->devnum, rt_entry->portnum)) != GT_OK)
+				{
+					MSG_PRINT(("gsysSetDevRoutingTable returned %i\n",status));
+					goto errorExit;
+				}
+				rt_entry++;
+			}
+      dumpRoutingTable( qdMultiDev[i] );
+		}
+		/*
+		 * 	4. Set Device ID (if required)
+		 */	 	
+		if((status=gsysSetDeviceNumber(qdMultiDev[i],DEVICE1_ID+i)) != GT_OK)
+		{
+			MSG_PRINT(("gsysSetDeviceNumber returned %i\n",status));
+			goto errorExit;
+		}
+
+    if ( 0 ) /* DHS FIXME */
+    {
+      GT_U32 devNum = -1;
+		  if((status=gsysGetDeviceNumber(qdMultiDev[i], & devNum )) != GT_OK)
+		  {
+			  MSG_PRINT(("gsysGetDeviceNumber returned %i\n",status));
+			  goto errorExit;
+		  }
+      MSG_PRINT(( "gsysGetDeviceNumber( %d ) : %d\n", DEVICE1_ID+i, devNum ));
+    }
+	}
+
+	/* 
+	 *	For HW guy happy, we manually invert LED0, LED1, LED2 setting for all FE ports.
+	 *	set all PHY reg 0x19 bit(12,13,14) to be 1.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		switch (i) {
+		case 0: /* if we are registering device 1 */
+		case 1: /* if we are registering device 2 */
+		case 2: /* if we are registering device 3 */
+		case 3: /* if we are registering device 4 */
+		case 4: /* if we are registering device 5 */
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+		/*
+		 * set all PHYs LED0 to indicate ACT, LED1 to indicate LINK
+     */
+		for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
+		{
+			GT_U16 data = 0;
+			GT_U32 regAddr = 0x16;
+
+			if(j>=NR_FE_PER_SWITCH)	/* GE ports */
+				continue;
+
+			if((status=gprtGetPhyReg(qdMultiDev[i],j,regAddr, &data)) != GT_OK)
+			{
+				debug("gprtGetPhyReg returned %i (port %i, reg 0x%02x, data 0x04)\n",status,j,regAddr,data);
+				goto errorExit;
+			}
+      data &= ~(0x0FFF);    /* remove LED control bits */
+      data |= (0x05 << 4);  /* set LED1 to indicate LINK */
+      data |= (0x0B << 0);  /* set LED0 to indicate ACT(BLINK mode) */
+
+			if((status=gprtSetPhyReg(qdMultiDev[i],j,regAddr,data)) != GT_OK)
+			{
+				debug("gprtSetPhyReg returned %i (port %i, reg 0x%02x, data 0x04)\n",status,j,regAddr,data);
+				goto errorExit;
+			}
+		}
+
+		/*
+		 * set all PHY reg 0x19 bit(12,13,14) to be 1. Selects HIGH drive for LEDs. 
+		 */			
+		for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
+		{
+			GT_U16 data = 0;
+			GT_U32 regAddr = 0x19;
+
+			if(j>=NR_FE_PER_SWITCH)	/* GE ports */
+				continue;
+
+			if((status=gprtGetPhyReg(qdMultiDev[i],j,regAddr, &data)) != GT_OK)
+			{
+				MSG_PRINT(("gprtGetPhyReg returned %i (port %i, reg 0x%02x, data 0x04)\n",status,j,regAddr,data));
+				goto errorExit;
+			}
+			data |= 0x7000;     /* set all LEDs to active HIGH */
+      data &= ~(0x003F);  /* set all LEDs to NORMAL mode */
+			if((status=gprtSetPhyReg(qdMultiDev[i],j,regAddr,data)) != GT_OK)
+			{
+				MSG_PRINT(("gprtSetPhyReg returned %i (port %i, reg 0x%02x, data 0x04)\n",status,j,regAddr,data));
+				goto errorExit;
+			}
+		}
+	}
+
+	MSG_PRINT(("QuarterDeck has been started.\n"));
+
+	return GT_OK;
+
+ errorExit:
+
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(qdMultiDev[i] != NULL)
+		{
+			qdUnloadDriver(qdMultiDev[i]);
+	  		free(qdMultiDev[i]);
+		}
+	}	
+
+	MSG_PRINT(("QuarterDeck initialization failed.\n"));
+
+	return status;
+}
+
+static GT_STATUS set_port_vlantable_helper(GT_QD_DEV *dev, GT_LPORT port, int vlantable)
+{
+	GT_LPORT mem_ports[MAX_SWITCH_PORTS];
+	GT_U8    mem_portslen =0;
+	int j;
+
+	for(j=0; j<MAX_SWITCH_PORTS; j++) {
+		if((vlantable>>j)&0x1) {
+			mem_ports[mem_portslen]=j;
+			mem_portslen++;
+		}
+	}
+	return gvlnSetPortVlanPorts(dev, port, mem_ports, mem_portslen);
+}
+
+static GT_STATUS set_vtu_helper(GT_QD_DEV *dev, int id)
+{
+	/* id is deviceID starting from 0 */
+	int j;
+	GT_STATUS status;
+	switch(id) {
+	case 0:			/* Opal 1 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device1_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device1_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 1:			/* Opal 2 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device2_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device2_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 2:			/* Opal 3 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device3_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device3_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 3:			/* Opal 4 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device4_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device4_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	default:		/* No such device */
+		return GT_NO_SUCH;
+	}
+	return GT_OK;
+}
+
+/*
+ * set up Cross-chip Port-Based VLANs:
+ *   1) set all 11 ports of all 4 switches 802.1Q disabled except
+ *      for S_CPU_DEVICE_ID's S_CPU_DEVICE_CPU_PORT which set to Fallback
+ *   2) set all ports's VLANTABLE according to vlantable
+ *   3) set all ports's DEFAULTVID according to defaultvid
+ *   4) set VTU entries accordingly for 5 devices
+ * return 0 on success
+ */
+int sw6095_setvlans(bd_t *bis)
+{
+	int i, j;
+	GT_STATUS status;
+
+	for(i=0; i<N_OF_QD_DEVICES; i++) {
+		for(j=0; j<MAX_PORTS_PER_SWITCH; j++) {
+			/* 1) set QMode disabled */
+			if((status=gvlnSetPortVlanDot1qMode(qdMultiDev[i], j, GT_DISABLE)) != GT_OK) {
+				printf("SW6095 #%d port %d setting QMode=disabled Failed\n", i+1, j);
+				return status;
+			}
+			/* 2) set VLANTABLE */
+			if((status=set_port_vlantable_helper(qdMultiDev[i], j, vlantable[i][j])) != GT_OK) {
+				printf("SW6095 #%d port %d setting VLANTABLE Failed\n", i+1, j);
+				return status;
+			}
+			/* 3) set DEFAULTVID */
+			if((status=gvlnSetPortVid(qdMultiDev[i], j, defaultvid[i][j])) != GT_OK) {
+				printf("SW6095 #%d port %d setting DEFAULTVID Failed\n", i+1, j);
+				return status;
+			}
+		}
+		if((status=set_vtu_helper(qdMultiDev[i], i)) != GT_OK) {
+			printf("SW6095 #%d setting VTU Failed\n", i+1);
+			return status;
+		}
+	}
+	/* set S_CPU_DEVICE_CPU_PORT's QMode fallback */
+	if((status=gvlnSetPortVlanDot1qMode(qdMultiDev[S_CPU_DEVICE_ID-1], S_CPU_DEVICE_CPU_PORT, GT_FALLBACK)) != GT_OK) {
+		printf("SW6095 #%d port %d setting QMode=fallback Failed\n", S_CPU_DEVICE_ID, S_CPU_DEVICE_CPU_PORT);
+		return status;
+	}
+	printf("Marvell 88E6095 switches set VLANs OK!\n");
+	return 0;
+}
+
+/* return 0 on success */
+int sw6095_startup(bd_t *bis)
+{
+	int i, j;
+	GT_STATUS status;
+//	int sp, ep;
+
+	for(i=0; i<N_OF_QD_DEVICES; i++) {
+#if 0
+		switch (i) {
+		case 0: 			/* OPAL 1 */
+			sp=9, ep=9;
+			break;
+		case 1: 			/* OPAL 2 */
+			sp=8, ep=9;
+			break;
+		case 2: 			/* OPAL 3 */
+			sp=8, ep=10;
+			break;
+		case 3: 			/* OPAL 4 */
+			sp=8, ep=9;
+			break;
+		default:
+			sp=0, ep=-1;
+		}
+#endif
+    for ( j = 0; j < 11; ++j ) 
+    {
+      if ( ! (device_port_startup[ i ] & PORT_BIT(j)) )
+      {
+        continue;
+      }
+//		for(j=sp; j<=ep; j++) {
+			status = GT_FAIL;
+			if((status=gpcsSetDpxValue(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+				if((status=gpcsSetForcedDpx(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+					debug("SW6095 #%d port %d setting Force Full Duplex OK\n", i+1, j);
+				}
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force Full Duplex Failed\n", i+1, j);
+				continue;
+			}
+
+			status = GT_FAIL;
+			if((status=gpcsSetForceSpeed(qdMultiDev[i], j, PORT_FORCE_SPEED_1000_MBPS)) == GT_OK) {
+				debug("SW6095 #%d port %d setting Force 1000Mbps Speed OK\n", i+1, j);
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force 1000Mbps Speed Failed\n", i+1, j);
+				continue;
+			}
+
+			status = GT_FAIL;
+			if((status=gpcsSetLinkValue(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+				if((status=gpcsSetForcedLink(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+					debug("SW6095 #%d port %d setting Force Link Up OK\n", i+1, j);
+				}
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force Link Up Failed\n", i+1, j);
+				continue;
+			}
+		}
+#if 0 /* disable auto-crossover */
+    for ( j = 0; j < 8; ++j ) 
+    {
+			GT_U16 data1=0;
+			GT_U16 data2=0;
+			if ((status=gprtGetPhyReg(qdMultiDev[i], j, 4, &data1)) == GT_OK) 
+      {
+        data2 = data1;
+        data2 &= ~((0x03)<<4);
+        data2 |=  ((0x01)<<4); /* tx on txp/txn */
+        if ((status = gprtSetPhyReg( qdMultiDev[i], j, 16, data2)) == GT_OK)
+        {
+          printf("SW6095 phy crossover adjust %d:%d reg 16, old=%04x, new=%04x\n", i, j, data1, data2 );
+          if ((status = gprtPhyReset( qdMultiDev[i], j )) == GT_OK ) 
+          {
+            printf("SW6095 phy reset port %d:%d\n", i, j );
+          }
+        }
+      }
+    }
+#endif
+#if 1
+		{				/* dump port 3's PHY registers */
+			int j;
+			for(j=0; j<32; j++) {
+				GT_U16 data=0;
+      
+				if((status=gprtGetPhyReg(qdMultiDev[i], 3, j, &data)) == GT_OK) {
+					debug("----------port %d PHY reg 0x%02x is 0x%04x\n", 3, j, data);
+				}
+			}
+		}
+#endif
+
+  if (0) /* DHS FIXME */
+  {
+    GT_BOOL enable;
+    GT_BOOL state;
+    GT_PORT_CONFIG_MODE c_mode;
+    GT_PPU_STATE	mode;
+
+    unsigned port = 10;
+
+    if ((status=gprtGetC_Mode( qdMultiDev[i], port, &c_mode )) != GT_OK ) 
+    {
+      MSG_PRINT(( "gprtGetC_Mode() failed\n" ));
+    }
+    else 
+    {
+      MSG_PRINT(( "gprtGetC_Mode() dev %d : port %d: %02X\n", i+1, port, c_mode ));
+    }
+
+    if ((status=gsysGetPPUEn( qdMultiDev[i], & enable )) != GT_OK )
+    {
+      MSG_PRINT(( "gsysGetPPUEn() failed\n" ));
+    }
+    else 
+    {
+      MSG_PRINT(( "gsysGetPPUEn() = %d\n", enable ));
+    }
+
+    if ((status=gsysGetPPUState( qdMultiDev[i], & mode )) != GT_OK )
+    {
+      MSG_PRINT(( "gsysGetPPUState() failed\n" ));
+    }
+    else 
+    {
+      MSG_PRINT(( "gsysGetPPUState() = %d\n", mode ));
+    }
+
+    if ((status=gprtGetPHYDetect( qdMultiDev[i], 10, & state )) != GT_OK )
+    {
+      MSG_PRINT(( "gprtGetPHYDetect() failed\n" ));
+    }
+    else 
+    {
+      MSG_PRINT(( "gprtGetPHYDetect(10) = %d\n", state ));
+    }
+  }    
+
+//#define PORT_MONITORING
+#ifdef PORT_MONITORING
+
+  if (1) 
+  {
+    unsigned dst = 0;
+    unsigned port;
+    if ((status=gsysSetIngressMonitorDest( qdMultiDev[i], dst )) == GT_OK )
+    {
+      unsigned src;
+      for ( src = 1; src < 10; ++src ) 
+      {
+        if ((status=gprtSetIngressMonitorSource( qdMultiDev[i], src, GT_TRUE )) == GT_OK) 
+        {
+          MSG_PRINT(( "Port Monitoring Configured Dev %d : port %d -> %d\n", i+1, src, dst ));
+        }
+        else 
+        {
+          MSG_PRINT(( "gprtSetIngressMonitorSource() failed %d\n", status ));
+        }
+      }
+    }
+    else 
+    {
+      MSG_PRINT(( "gsysSetIngressMonitorDest() failed %d\n", status ));
+    } 
+    for ( port = 8; port < 11; ++port )
+    {
+      GT_PORT_CONFIG_MODE c_mode;
+
+      if ((status=gprtGetC_Mode( qdMultiDev[i], port, &c_mode )) != GT_OK ) 
+      {
+        MSG_PRINT(( "gprtGetC_Mode() failed\n" ));
+      }
+      else 
+      {
+      }
+    }
+  }
+#endif
+
+	}
+	return 0;
+}
+
+int sw6095_initialize(bd_t *bis)
+{
+
+	printf("Marvell 88E6095 switches are starting up ...\n");
+	if(sw6095_setup_const(bis) != 0) {
+		printf("Marvell 88E6095 switches Failed: Setup board constants Failed!!\n");
+		return -1;
+	}
+		
+	if(qdMultiDevStart() != GT_OK) {
+		printf("Marvell 88E6095 switches Failed: Init switch driver Failed!!\n");
+		return -1;
+	}
+
+	if(sw6095_setvlans(bis)!=0) {
+		printf("Marvell 88E6095 switches Failed: Set VLANs Failed!!\n");
+		return -1;
+	}
+	if(sw6095_startup(bis)!=0) {
+		printf("Marvell 88E6095 switches Failed: Startup switch chip Failed!!\n");
+		return -1;
+	}
+	printf("Marvell 88E6095 switches startup OK!!\n");
+	return 0;
+}
+
+#endif /* CONFIG_MV88E6095 */
diff -Naur u-boot-1.1.2/board/amazon/sw6095.h uboot-1.1.2hsv/board/amazon/sw6095.h
--- u-boot-1.1.2/board/amazon/sw6095.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/sw6095.h	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,51 @@
+/*
+ * Cyclades:
+ *   Support for Marvell's 88E6095 11-port switch chips for DEB board.
+ *
+ * Got from SOHO's msSample.h
+ * 
+ */
+
+#ifndef __SW6095_H__
+#define __SW6095_H__
+
+#include <common.h>
+#include <marvell/msApi.h>
+
+#ifndef MAX_NR_SWITCHES
+#define MAX_NR_SWITCHES 	4
+#endif
+
+#ifndef MAX_PORTS_PER_SWITCH
+#define MAX_PORTS_PER_SWITCH 	11
+#endif
+
+#define NR_FE_PER_SWITCH	8
+#define NR_GE_PER_SWITCH	(MAX_PORTS_PER_SWITCH - NR_FE_PER_SWITCH)
+
+#define MAX_NET_PORT_TOTAL	(NR_FE_PER_SWITCH * MAX_NR_SWITCHES)
+
+static inline int port_nr_to_sw_nr(int port_nr) {
+	if(port_nr>=MAX_NET_PORT_TOTAL || port_nr<0) return -1;
+	return (port_nr/NR_FE_PER_SWITCH);
+}
+
+static inline int port_nr_to_fe_nr(int port_nr) {
+	if(port_nr>=MAX_NET_PORT_TOTAL || port_nr<0) return -1;
+	return (port_nr%NR_FE_PER_SWITCH);
+}
+
+#define MSG_PRINT(x) printf x
+
+
+#undef USE_SEMAPHORE
+
+#ifdef USE_SEMAPHORE
+GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state);
+GT_STATUS osSemDelete(GT_SEM smid);
+GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut);
+GT_STATUS osSemSignal(GT_SEM smid);
+#endif
+
+
+#endif /* __SW6095_H__ */
diff -Naur u-boot-1.1.2/board/amazon/u-boot.lds uboot-1.1.2hsv/board/amazon/u-boot.lds
--- u-boot-1.1.2/board/amazon/u-boot.lds	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/amazon/u-boot.lds	2007-05-29 16:51:10.000000000 -0500
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  .resetvec 0xFFFFFFFC :
+  {
+    *(.resetvec)
+  } = 0xffff
+
+  .bootpg 0xFFFFF000 :
+  {
+    cpu/mpc85xx/start.o	(.bootpg)
+    board/amazon/init.o (.bootpg)
+  } = 0xffff
+
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    cpu/mpc85xx/start.o	(.text)
+    board/amazon/init.o (.text)
+    cpu/mpc85xx/traps.o (.text)
+    cpu/mpc85xx/interrupts.o (.text)
+    cpu/mpc85xx/cpu_init.o (.text)
+    cpu/mpc85xx/cpu.o (.text)
+    cpu/mpc85xx/tsec.o (.text)
+    cpu/mpc85xx/speed.o (.text)
+    cpu/mpc85xx/pci.o (.text)
+    common/dlmalloc.o (.text)
+    lib_generic/crc32.o (.text)
+    lib_ppc/extable.o (.text)
+    lib_generic/zlib.o (.text)
+    *(.text)
+    *(.fixup)
+    *(.got1)
+   }
+    _etext = .;
+    PROVIDE (etext = .);
+    .rodata    :
+   {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >> 2;
+  __fixup_entries = (. - _FIXUP_TABLE_) >> 2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  _end = . ;
+  PROVIDE (end = .);
+}
diff -Naur u-boot-1.1.2/board/cray/L1/bootscript.hush uboot-1.1.2hsv/board/cray/L1/bootscript.hush
--- u-boot-1.1.2/board/cray/L1/bootscript.hush	2003-05-20 09:26:46.000000000 -0500
+++ uboot-1.1.2hsv/board/cray/L1/bootscript.hush	2007-05-29 16:51:10.000000000 -0500
@@ -1,4 +1,4 @@
-# $Header$
+# $Header: /usr/cvsroot//gartop/uboot/uboot-1.1.2/board/cray/L1/bootscript.hush,v 1.1.1.1 2005/02/05 03:15:30 yang Exp $
 # hush bootscript for PPCBOOT on L1
 # note: all #s are in hex, do _NOT_ prefix it with 0x
 
diff -Naur u-boot-1.1.2/board/debmax/bdparam.c uboot-1.1.2hsv/board/debmax/bdparam.c
--- u-boot-1.1.2/board/debmax/bdparam.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/bdparam.c	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,178 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+/**
+   cyclades: this src file bdparam.c is to replace cadmus.c to supply
+   some board info. the following functions are provided:
+
+   unsigned int get_board_version(void);
+   unsigned long get_clock_freq(void);
+   unsigned int get_pci_dual(void);
+   unsigned int get_pci_slot(void);
+   unsigned long get_pci1_clock_freq(void);
+   unsigned long get_pci2_clock_freq(void);
+   
+   */
+#include <common.h>
+#include "bdparam.h"
+#include <asm/immap_85xx.h>
+#include <asm/cpm_85xx.h>
+
+unsigned int
+get_board_model(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd;
+
+	if (gd->flags & GD_FLG_RELOC) {
+		bd = gd->bd;
+		return bd->board_model;
+	}
+
+#ifdef CONFIG_DEB
+	{
+		volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+		volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+		volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+		unsigned int board_ver_rev = get_board_ver_rev();
+
+		/*
+		 * setting board_model according to board_ver_rev
+		 */
+		if (board_ver_rev < 0x02) { /* 1st spin */
+			int _24p = 0;
+#ifdef DEB_24_PORT
+			_24p = 1;
+#endif
+			/* 24/40 port, Dual PS, AC, EN_sw6095 */
+			return (_24p<<7) | (0<<6) | (0<<5) | (0<<4);
+		} else {	/* >= 2nd spin */
+			return (cpm_iop->pdatc & 0x0000fc00) >> 8;
+		}
+	}
+#endif
+	return 0;
+}
+
+unsigned int
+get_board_ver_rev(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd;
+	unsigned short *fpgaregs = (unsigned short *)CFG_ATA_BASE_ADDR;
+	unsigned int board_ver_rev;
+
+	if (gd->flags & GD_FLG_RELOC) {
+		bd = gd->bd;
+		return bd->board_ver_rev;
+	}
+	
+	/*************************
+	 * FPGA register bit: (for DEBV1 2nd spin)
+	 *
+	 * 0xc0000020: board version and revision,
+	 *               MSB 4-bit is for version:  0x0 is for version 1: DEBV1
+	 *               LSB 4-bit is for revision: 0x2 is for 2nd spin, 0x1 is for 1st spin
+	 * 0xc0000021: FPGA code version, eg. 0x51
+	 * 0xc0000022: (TBD)
+	 * 0xc0000023: (TBD)
+	 */
+	board_ver_rev = fpgaregs[0x20/sizeof(unsigned short)] / 0x100;
+
+#ifdef CONFIG_DEBV1
+	/*
+	 * 1st spin work around: fpga's board_ver_rev is not correct,
+	 *   we correct it.
+	 */
+	if (board_ver_rev >= 0xd0) {
+		board_ver_rev = 0x01;
+	}
+#endif
+	return board_ver_rev;
+}
+
+
+unsigned long
+get_clock_freq(void)
+{
+#ifdef CONFIG_DEB
+	unsigned int board_ver_rev = get_board_ver_rev();
+
+	if (board_ver_rev == 0x01)
+		return 66666666;		/* SYS_CLK_FREQ is set 66MHZ */
+	else if (board_ver_rev == 0x02)
+		return 33333333;		/* SYS_CLK_FREQ is set 33MHZ */
+	else
+		return 33333333; /* default */
+#else
+	return 66666666;		/* SYS_CLK_FREQ is set 66MHZ */
+#endif
+}
+
+
+/* in KVMMAXV1/DEBV1 board, PCI1 use PCI1_CLK instead of SYS_CLK_FREQ */
+unsigned long
+get_pci1_clock_freq(void)
+{
+#ifdef CONFIG_DEB
+	unsigned int board_ver_rev = get_board_ver_rev();
+
+	if (board_ver_rev == 0x01)
+		return 33000000;
+	else if (board_ver_rev == 0x02) {
+		unsigned long sysclk = get_clock_freq();
+		sysclk /= 1000000;	/* convert to whole MHz */
+		return sysclk*1000000;
+	} else
+		return 33000000; /* default */
+#else
+	return 33000000;		/* PCI1_CLK is set 33MHZ */
+#endif
+}
+
+/* in KVMMAXV1/DEBV1 board, PCI2 use PCI2_CLK instead of SYS_CLK_FREQ */
+unsigned long
+get_pci2_clock_freq(void)
+{
+#ifdef CONFIG_DEB
+	unsigned int board_ver_rev = get_board_ver_rev();
+
+	if (board_ver_rev == 0x01)
+		return 33000000;
+	else if (board_ver_rev == 0x02) {
+		unsigned long sysclk = get_clock_freq();
+		sysclk /= 1000000;	/* convert to whole MHz */
+		return sysclk*1000000;
+	} else
+		return 33000000; /* default */
+#else
+	return 33000000;		/* PCI1_CLK is set 33MHZ */
+#endif
+}
+
+
+unsigned int
+get_pci_dual(void)
+{
+	return 1;			/* use both PCI1 and PCI2 */
+}
diff -Naur u-boot-1.1.2/board/debmax/bdparam.h uboot-1.1.2hsv/board/debmax/bdparam.h
--- u-boot-1.1.2/board/debmax/bdparam.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/bdparam.h	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+   cyclades: use bdparam.h to replace cadmus.h
+    */
+#ifndef __BDPARAM_H_
+#define __BDPARAM_H_
+
+
+/*
+ * KVMMAXV1/DEBV1 Board System Register interface.
+ */
+#define BOARD_ONBOARD	0
+#define BOARD_UNKNOWN	0xff
+
+/*
+ * Returns board version and revision.
+ */
+extern unsigned int get_board_ver_rev(void);
+
+/*
+ * Returns either 33333333 or 66666666 as the SYS_CLK_FREQ.
+ */
+extern unsigned long get_clock_freq(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the PCI1_CLK_FREQ
+ */
+extern unsigned long get_pci1_clock_freq(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the PCI1_CLK_FREQ
+ */
+extern unsigned long get_pci2_clock_freq(void);
+
+
+/*
+ * Returns PCI DUAL.
+ */
+extern unsigned int get_pci_dual(void);
+
+/*
+ * Returns board model number
+ */
+extern unsigned int get_board_model(void);
+
+#endif	/* __BDPARAM_H_ */
diff -Naur u-boot-1.1.2/board/debmax/cadmus.c uboot-1.1.2hsv/board/debmax/cadmus.c
--- u-boot-1.1.2/board/debmax/cadmus.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/cadmus.c	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+
+
+/*
+ * CADMUS Board System Registers
+ */
+#ifndef CFG_CADMUS_BASE_REG
+#define CFG_CADMUS_BASE_REG	(CADMUS_BASE_ADDR + 0x4000)
+#endif
+
+typedef struct cadmus_reg {
+    u_char cm_ver;		/* Board version */
+    u_char cm_csr;		/* General control/status */
+    u_char cm_rst;		/* Reset control */
+    u_char cm_hsclk;		/* High speed clock */
+    u_char cm_hsxclk;		/* High speed clock extended */
+    u_char cm_led;		/* LED data */
+    u_char cm_pci;		/* PCI control/status */
+    u_char cm_dma;		/* DMA control */
+    u_char cm_reserved[248];	/* Total 256 bytes */
+} cadmus_reg_t;
+
+
+unsigned int
+get_board_version(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	return cadmus->cm_ver;
+}
+
+
+unsigned long
+get_clock_freq(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	uint pci1_speed = (cadmus->cm_pci >> 2) & 0x3; /* PSPEED in [4:5] */
+
+	if (pci1_speed == 0) {
+		return 33000000;
+	} else if (pci1_speed == 1) {
+		return 66000000;
+	} else {
+		/* Really, unknown. Be safe? */
+		return 33000000;
+	}
+}
+
+
+unsigned int
+get_pci_slot(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	/*
+	 * PCI slot in USER bits CSR[6:7] by convention.
+	 */
+	return ((cadmus->cm_csr >> 6) & 0x3) + 1;
+}
+
+
+unsigned int
+get_pci_dual(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	/*
+	 * PCI DUAL in CM_PCI[3]
+	 */
+	return cadmus->cm_pci & 0x10;
+}
diff -Naur u-boot-1.1.2/board/debmax/cadmus.h uboot-1.1.2hsv/board/debmax/cadmus.h
--- u-boot-1.1.2/board/debmax/cadmus.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/cadmus.h	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CADMUS_H_
+#define __CADMUS_H_
+
+
+/*
+ * CADMUS Board System Register interface.
+ */
+
+/*
+ * Returns board version register.
+ */
+extern unsigned int get_board_version(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the SYS_CLK_FREQ.
+ */
+extern unsigned long get_clock_freq(void);
+
+
+/*
+ * Returns 1 - 4, as found in the USER CSR[6:7] bits.
+ */
+extern unsigned int get_pci_slot(void);
+
+
+/*
+ * Returns PCI DUAL as found in CM_PCI[3].
+ */
+extern unsigned int get_pci_dual(void);
+
+
+#endif	/* __CADMUS_H_ */
diff -Naur u-boot-1.1.2/board/debmax/config.mk uboot-1.1.2hsv/board/debmax/config.mk
--- u-boot-1.1.2/board/debmax/config.mk	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/config.mk	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,30 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# mpc8555cds board
+#
+TEXT_BASE = 0xfff80000
+
+PLATFORM_CPPFLAGS += -DCONFIG_E500=1
+PLATFORM_CPPFLAGS += -DCONFIG_MPC85xx=1
+PLATFORM_CPPFLAGS += -DCONFIG_MPC8555=1
diff -Naur u-boot-1.1.2/board/debmax/debmax.c uboot-1.1.2hsv/board/debmax/debmax.c
--- u-boot-1.1.2/board/debmax/debmax.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/debmax.c	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,677 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/cpm_85xx.h>
+#include <spd.h>
+
+#include "bdparam.h"
+#include "eeprom.h"
+
+#if defined(CONFIG_DDR_ECC)
+extern void ddr_enable_ecc(unsigned int dram_size);
+#endif
+
+extern long int spd_sdram(void);
+
+void local_bus_init(void);
+void sdram_init(void);
+
+/* we can NOT set bd_t within board_early_init_f(), bcz no ram has
+ * been allocated for gd->bd yet, have to do in board_early_init_r() */
+int board_early_init_f (void)
+{
+	/*************************
+	 * FPGA register bit: (for DEBV1 2nd spin)
+	 *
+	 * 0xc0000020: board version and revision,
+	 *               MSB 4-bit is for version:  0x0 is for version 1: DEBV1
+	 *               LSB 4-bit is for revision: 0x2 is for 2nd spin, 0x1 is for 1st spin
+	 * 0xc0000021: FPGA code version, eg. 0x51
+	 * 0xc0000022: (TBD)
+	 * 0xc0000023: (TBD)
+	 */
+
+	unsigned short *fpgaregs = (unsigned short *)CFG_ATA_BASE_ADDR;
+	unsigned int board_type;			/* eg. OnBoard, KVMMAX */
+	unsigned int board_ver_rev;			/* V1 rev1 for 2nd spin */
+	unsigned int board_model;			/* 24/40-port, Dual/Single power, AC/DC */
+	unsigned int fpga_version;			/* FPGA code version */
+
+#ifdef CONFIG_DEB	
+	board_type = BOARD_ONBOARD;
+#else
+	board_type = BOARD_UNKNOWN;
+#endif
+	board_ver_rev = fpgaregs[0x20/sizeof(unsigned short)] / 0x100;
+	fpga_version = fpgaregs[0x20/sizeof(unsigned short)] % 0x100;
+
+#ifdef CONFIG_DEBV1
+	/*
+	 * 1st spin work around: fpga's board_ver_rev is not correct,
+	 *   we correct it.
+	 */
+	if (board_ver_rev >= 0xd0) {
+		board_ver_rev = 0x01;
+	}
+	
+	/**
+	 * cyclades: for DEBV1 board,
+	 * in order to enable some devices we need to preset some CCSR registers:
+	 *     CPM_PA_19         : 88E1111 PHY
+	 *     CPM_PA_21         : PCMCIA
+	 *     CPM_PA_23         : FAILOVER Eth (NATSEMI DP83816)
+	 *     CPM_PC_8          : OPAL-1 (88E6095 Switch)
+	 *     CPM_PC_9          : OPAL-2 (88E6095 Switch)
+	 *     CPM_PC_12         : OPAL-3 (88E6095 Switch)
+	 *     CPM_PC_14         : OPAL-4 (88E6095 Switch)
+	 *     CPM_PC_15         : OPAL-5 (88E6095 Switch)
+	 *
+	 * we also use these two bits to indicate Dual Power status:
+	 *     CPM_PC_6          : Dual power:PowerA status (ReadOnly)
+	 *     CPM_PC_7          : Dual power:PowerB status (ReadOnly)
+	 *
+	 * we also use these 6 bits(INPUT) to indicate board_model(ONLY
+	 * valid when board_ver_rev >= 0x02)
+	 *     CPM_PC_16         : 24/40 port, 0 for 40P, 1 for 24P
+	 *     CPM_PC_17         : PS, 0 for dual PS, 1 for single PS
+	 *     CPM_PC_18         : AC/DC, 0 for AC, 1 for DC
+	 *     CPM_PC_19         : DIS_sw6095, 0 for enable, 1 for disable
+	 *     CPM_PC_20         : (TBD)
+	 *     CPM_PC_21         : (TBD)
+	 *
+	 * we use PA13 output (only for board_ver_rev >=0x03) to
+	 * indicate console's LNK
+	 *     CPM_PA_13         : 0 for No LNK, 1 for has LINK
+	 *
+	 * After all setting are done, two more steps are followed at the very end:
+	 *     1. read the final config register just written,
+	 *     2. asm("sync");
+	 */
+	{
+		volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+		volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+		volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+		volatile ccsr_gur_t *gur = &immap->im_gur;
+		unsigned long tmp;
+
+		/* set direction to be output =1 */
+		cpm_iop->pdira |= (CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		cpm_iop->pdirc |= (CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+		/* direction input =0 */
+		cpm_iop->pdirc &= ~(CPM_PC_6 | CPM_PC_7);
+  
+		/* set general IO =0 */
+		cpm_iop->ppara &= ~(CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		cpm_iop->pparc &= ~(CPM_PC_6 | CPM_PC_7 | CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+
+		/* no need to change PSORx because of general IO */
+
+		/* set open drain to be regular =0 */
+		cpm_iop->podra &= ~(CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		cpm_iop->podrc &= ~(CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+		cpm_iop->podrc &= ~(CPM_PC_6 | CPM_PC_7);
+
+		asm("sync;isync;msync");
+		udelay(50);
+
+		/*
+		 * setting board_model according to board_ver_rev
+		 */
+		if (board_ver_rev < 0x02) { /* 1st spin */
+			int _24p = 0;
+#ifdef DEB_24_PORT
+			_24p = 1;
+#endif
+			/* 24/40 port, Dual PS, AC, EN_sw6095 */
+			board_model = (_24p<<7) | (0<<6) | (0<<5) | (0<<4);
+		} else {	/* >= 2nd spin */
+			cpm_iop->pdirc &= ~(CPM_PC_16 | CPM_PC_17 | CPM_PC_18
+					    | CPM_PC_19 | CPM_PC_20 | CPM_PC_21); /* input */
+			cpm_iop->pparc &= ~(CPM_PC_16 | CPM_PC_17 | CPM_PC_18
+					    | CPM_PC_19 | CPM_PC_20 | CPM_PC_21); /* GPIO */
+			cpm_iop->podrc &= ~(CPM_PC_16 | CPM_PC_17 | CPM_PC_18
+					    | CPM_PC_19 | CPM_PC_20 | CPM_PC_21); /* regular */
+			asm("sync;isync;msync");
+			udelay(50);
+			board_model = (cpm_iop->pdatc & 0x0000fc00) >> 8; /* get model# */
+		}
+
+		/*
+		 * for 3nd spin and later on, init console LNK LED.
+		 */
+		if (board_ver_rev >=0x03) {
+			cpm_iop->pdira |=  CPM_PA_13; /* output */
+			cpm_iop->ppara &= ~CPM_PA_13; /* GPIO */
+			cpm_iop->podra &= ~CPM_PA_13; /* regular */
+			cpm_iop->pdata &= ~CPM_PA_13; /* No LNK */
+			/* set to LINK ON after console init */
+		}
+
+
+		/* first set data bit to be 0 to reset devices */
+		cpm_iop->pdata &= ~(CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		cpm_iop->pdatc &= ~(CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+  
+		asm("sync;isync;msync");
+		udelay(10);
+
+		/* then set data bit to be 1 to de-assert reset*/
+		if (board_ver_rev < 0x02) {
+			cpm_iop->pdata |= (CPM_PA_19); /* 1st spin, don't enable any PCI device due to buggy PCI bus */
+		} else {
+			cpm_iop->pdata |= (CPM_PA_19 | CPM_PA_21 | CPM_PA_23);
+		}
+
+		cpm_iop->pdatc |= (CPM_PC_8 | CPM_PC_9 | CPM_PC_12 | CPM_PC_14 | CPM_PC_15);
+
+		/*
+		 * enable CLK_OUT as SYSCLK in GUR, which is used as PCI bus
+		 * clk in 2nd spin, and no harm to 1st spin.
+		 */
+		gur->clkocr = 0x80000002;
+
+		/* do the last two steps */
+		tmp = gur->clkocr;
+		asm("sync;isync;msync");
+	}
+#endif /* CONFIG_DEBV1 */
+	return 0;
+}
+
+/* set bd_t due to board_early_init_f() */
+int board_early_init_r (void)
+{
+	/*************************
+	 * FPGA register bit: (for DEBV1 2nd spin)
+	 *
+	 * 0xc0000020: board version and revision,
+	 *               MSB 4-bit is for version:  0x0 is for version 1: DEBV1
+	 *               LSB 4-bit is for revision: 0x2 is for 2nd spin, 0x1 is for 1st spin
+	 * 0xc0000021: FPGA code version, eg. 0x51
+	 * 0xc0000022: (TBD)
+	 * 0xc0000023: (TBD)
+	 */
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	unsigned short *fpgaregs = (unsigned short *)CFG_ATA_BASE_ADDR;
+
+#ifdef CONFIG_DEB	
+	bd->board_type = BOARD_ONBOARD;
+#else
+	bd->board_type = BOARD_UNKNOWN;
+#endif
+	bd->board_ver_rev = fpgaregs[0x20/sizeof(unsigned short)] / 0x100;
+	bd->fpga_version = fpgaregs[0x20/sizeof(unsigned short)] % 0x100;
+
+#ifdef CONFIG_DEBV1
+	/*
+	 * 1st spin work around: fpga's board_ver_rev is not correct,
+	 *   we correct it.
+	 */
+	if (bd->board_ver_rev >= 0xd0)
+		bd->board_ver_rev = 0x01;
+
+	{
+		volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+		volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+		volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+
+		/*
+		 * setting board_model according to board_ver_rev
+		 */
+		if (bd->board_ver_rev < 0x02) { /* 1st spin */
+			int _24p = 0;
+#ifdef DEB_24_PORT
+			_24p = 1;
+#endif
+			/* 24/40 port, Dual PS, AC, EN_sw6095 */
+			bd->board_model = (_24p<<7) | (0<<6) | (0<<5) | (0<<4);
+		} else {	/* >= 2nd spin */
+			bd->board_model = (cpm_iop->pdatc & 0x0000fc00) >> 8;
+		}
+	}
+#endif
+	return 0;
+}
+
+int misc_init_r (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	char *tmp;
+	//unsigned long val;
+
+	/* some bd_t entries are set in board_early_init_r() */
+	bd->pci = 1;
+	printf("Board type             : %02x\n", bd->board_type);
+	printf("Board version_revision : %02x\n", bd->board_ver_rev);
+	printf("Board model            : %02x\n", bd->board_model);
+	printf("FPGA  version          : %02x\n", bd->fpga_version);
+
+	if (bd->board_type == BOARD_ONBOARD) {
+		if (bd->board_ver_rev >= 0x02) {
+			unsigned int mdl = bd->board_model;
+			printf("OnBoard %d-Port, %s PS\n", (mdl&0x80 ? 24 : 40),
+			       (mdl&0x40 ? "Single" : "Dual"));
+		}
+	}
+
+	if ((tmp = getenv ("fecmode1")) == NULL) {
+		setenv("fecmode1", "auto");
+		bd->mii_operation[0] = 0;
+	} else if (strcmp(tmp, "1000F") == 0 || strcmp(tmp, "1000f") == 0) {
+		bd->mii_operation[0] = 1;
+	} else if (strcmp(tmp, "1000H") == 0 || strcmp(tmp, "1000h") == 0) {
+		bd->mii_operation[0] = 2;
+	} else if (strcmp(tmp, "100F") == 0  || strcmp(tmp, "100f") == 0) {
+		bd->mii_operation[0] = 3;
+	} else if (strcmp(tmp, "100H") == 0  || strcmp(tmp, "100h") == 0) {
+		bd->mii_operation[0] = 4;
+	} else if (strcmp(tmp, "10F") == 0   || strcmp(tmp, "10f") == 0) {
+		bd->mii_operation[0] = 5;
+	} else if (strcmp(tmp, "10H") == 0   || strcmp(tmp, "10h") == 0) {
+		bd->mii_operation[0] = 6;
+	} else {
+		setenv("fecmode1", "auto");
+		bd->mii_operation[0] = 0;
+	}
+
+	if ((tmp = getenv ("fecmode2")) == NULL) {
+		setenv("fecmode2", "auto");
+		bd->mii_operation[1] = 0;
+	} else if (strcmp(tmp, "1000F") == 0 || strcmp(tmp, "1000f") == 0) {
+		bd->mii_operation[1] = 1;
+	} else if (strcmp(tmp, "1000H") == 0 || strcmp(tmp, "1000h") == 0) {
+		bd->mii_operation[1] = 2;
+	} else if (strcmp(tmp, "100F") == 0  || strcmp(tmp, "100f") == 0) {
+		bd->mii_operation[1] = 3;
+	} else if (strcmp(tmp, "100H") == 0  || strcmp(tmp, "100h") == 0) {
+		bd->mii_operation[1] = 4;
+	} else if (strcmp(tmp, "10F") == 0   || strcmp(tmp, "10f") == 0) {
+		bd->mii_operation[1] = 5;
+	} else if (strcmp(tmp, "10H") == 0   || strcmp(tmp, "10h") == 0) {
+		bd->mii_operation[1] = 6;
+	} else {
+		setenv("fecmode2", "auto");
+		bd->mii_operation[1] = 0;
+	}
+
+        if ((tmp = getenv("wdt")) == NULL) {
+                setenv("wdt", "on");
+                bd->wdt = 1;
+        } else if (strcmp(tmp, "on") == 0  || strcmp(tmp, "ON") == 0) {
+                bd->wdt = 1;
+        } else if (strcmp(tmp, "off") == 0 || strcmp(tmp, "OFF") == 0) {
+                bd->wdt = 0;
+	} else {
+                setenv("wdt", "on");
+                bd->wdt = 1;
+	}
+
+	if ((tmp = getenv("serial#")) == NULL) {
+		//unsigned char nbr[8];
+		//if (read_serial_number(nbr)) {
+		//	sprintf(bd->device_id,
+		//		"%02x%02x%02x%02x%02x%02x",
+		//		nbr[0], nbr[1], nbr[2],
+		//		nbr[3], nbr[4], nbr[5]);
+		//	setenv("serial#", bd->device_id);
+		//}
+		bd->device_id[0] = 0;
+        } else {
+                strncpy(bd->device_id, tmp, 15);
+        }
+	if (bd->wdt) {
+#ifdef CONFIG_WATCHDOG
+		extern void start_85xx_watchdog(void);
+		
+		start_85xx_watchdog();
+#endif
+	}
+	return 0;
+}
+
+int checkboard (void)
+{
+	volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+
+	uint pci_dual = get_pci_dual ();
+	uint pci1_32 = gur->pordevsr & 0x10000;		/* PORDEVSR[15] */
+	uint pci1_clk_sel = gur->porpllsr & 0x8000;	/* PORPLLSR[16] */
+	uint pci2_clk_sel = gur->porpllsr & 0x4000;	/* PORPLLSR[17] */
+
+	uint pci1_speed = get_pci1_clock_freq ();
+	uint pci2_speed = get_pci2_clock_freq ();
+
+#ifdef CONFIG_KVMMAX
+	printf ("Board: KVMMAX\n");
+#elif defined CONFIG_DEB
+	printf ("Board: OnBoard\n");
+#endif
+
+	printf ("    PCI1: %d bit, %s MHz, %s\n",
+		(pci1_32) ? 32 : 64,
+		(pci1_speed == 33000000) ? "33" :
+		(pci1_speed == 66000000) ? "66" : "unknown",
+		pci1_clk_sel ? "sync" : "async");
+
+	if (pci_dual) {
+		printf ("    PCI2: 32 bit, %s MHz, %s\n",
+			(pci2_speed == 33000000) ? "33" :
+			(pci2_speed == 66000000) ? "66" : "unknown",
+			pci2_clk_sel ? "sync" : "async");
+	} else {
+		printf ("    PCI2: disabled\n");
+	}
+
+	/*
+	 * Initialize local bus.
+	 */
+	local_bus_init ();
+#ifdef CONFIG_DEBV1
+	{
+		/**
+		 * cyclades: for DEBV1 board,
+		 * we also use these two bits to indicate Dual Power status:
+		 *     CPM_PC_6          : Dual power:PowerA status (ReadOnly)
+		 *     CPM_PC_7          : Dual power:PowerB status (ReadOnly)
+		 */
+		volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+		volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+		volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+
+		printf("PowerA: [%s]\n", (cpm_iop->pdatc&CPM_PC_6 ? "ON": "OFF"));
+		printf("PowerB: [%s]\n", (cpm_iop->pdatc&CPM_PC_7 ? "ON": "OFF"));
+	}
+#endif
+
+	return 0;
+}
+
+long int
+initdram(int board_type)
+{
+	long dram_size = 0;
+
+	puts("Initializing\n");
+
+#if defined(CONFIG_DDR_DLL)
+	{
+		/*
+		 * Work around to stabilize DDR DLL MSYNC_IN.
+		 * Errata DDR9 seems to have been fixed.
+		 * This is now the workaround for Errata DDR11:
+		 *    Override DLL = 1, Course Adj = 1, Tap Select = 0
+		 */
+
+		volatile immap_t *immap = (immap_t *)CFG_IMMR;
+		volatile ccsr_gur_t *gur= &immap->im_gur;
+
+		gur->ddrdllcr = 0x81000000;
+		asm("sync;isync;msync");
+		udelay(200);
+	}
+#endif
+	dram_size = spd_sdram();
+
+#if defined(CONFIG_DDR_ECC)
+	/*
+	 * Initialize and enable DDR ECC.
+	 */
+	ddr_enable_ecc(dram_size);
+#endif
+	/*
+	 * SDRAM Initialization
+	 */
+	sdram_init();
+
+	puts("    DDR: ");
+	return dram_size;
+}
+
+/*
+ * Initialize Local Bus
+ */
+void
+local_bus_init(void)
+{
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+
+	uint clkdiv;
+	uint lbc_hz;
+	sys_info_t sysinfo;
+	uint temp_lbcdll;
+
+	/*
+	 * Errata LBC11.
+	 * Fix Local Bus clock glitch when DLL is enabled.
+	 *
+	 * If localbus freq is < 66Mhz, DLL bypass mode must be used.
+	 * If localbus freq is > 133Mhz, DLL can be safely enabled.
+	 * Between 66 and 133, the DLL is enabled with an override workaround.
+	 */
+
+	get_sys_info(&sysinfo);
+
+	/* cyclades: who sets lbc->lcrr? PowerOn reset value is 0x8000_0008 */
+	clkdiv = lbc->lcrr & 0x0f;
+	lbc_hz = sysinfo.freqSystemBus / 1000000 / clkdiv;
+
+	if (lbc_hz < 66) {
+		/* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+		lbc->lcrr = CFG_LBC_LCRR | 0x80000000;	/* DLL Bypass */
+
+	} else if (lbc_hz >= 133) {
+		/* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+		lbc->lcrr = CFG_LBC_LCRR & (~0x80000000); /* DLL Enabled */
+
+	} else {
+		/* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+		lbc->lcrr = CFG_LBC_LCRR & (~0x80000000);/* DLL Enabled */
+		udelay(200);
+
+		/*
+		 * Sample LBC DLL ctrl reg, upshift it to set the
+		 * override bits.
+		 */
+		temp_lbcdll = gur->lbcdllcr;
+		gur->lbcdllcr = (((temp_lbcdll & 0xff) << 16) | 0x80000000);
+		asm("sync;isync;msync");
+	}
+}
+
+/*
+ * Initialize SDRAM memory on the Local Bus.
+ */
+void
+sdram_init(void)
+{
+#if defined(CFG_OR2_PRELIM) && defined(CFG_BR2_PRELIM)
+
+	uint idx;
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+	uint *sdram_addr = (uint *)CFG_LBC_SDRAM_BASE;
+	uint cpu_board_rev;
+	uint lsdmr_common;
+
+	puts("    SDRAM: ");
+
+	print_size (CFG_LBC_SDRAM_SIZE * 1024 * 1024, "\n");
+
+	/*
+	 * Setup SDRAM Base and Option Registers
+	 */
+	lbc->or2 = CFG_OR2_PRELIM;
+	asm("msync");
+
+	lbc->br2 = CFG_BR2_PRELIM;
+	asm("msync");
+
+	lbc->lbcr = CFG_LBC_LBCR;
+	asm("msync");
+
+	lbc->lsrt = CFG_LBC_LSRT;
+	lbc->mrtpr = CFG_LBC_MRTPR;
+	asm("msync");
+
+	/*
+	 * Determine which address lines to use baed on CPU board rev.
+	 */
+	cpu_board_rev = get_cpu_board_revision();
+	lsdmr_common = CFG_LBC_LSDMR_COMMON;
+	if (cpu_board_rev == MPC85XX_CPU_BOARD_REV_1_0) {
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1617;
+	} else if (cpu_board_rev == MPC85XX_CPU_BOARD_REV_1_1) {
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1516;
+	} else {
+		/*
+		 * Assume something unable to identify itself is
+		 * really old, and likely has lines 16/17 mapped.
+		 */
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1617;
+	}
+
+	/*
+	 * Issue PRECHARGE ALL command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_PCHALL;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(100);
+
+	/*
+	 * Issue 8 AUTO REFRESH commands.
+	 */
+	for (idx = 0; idx < 8; idx++) {
+		lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_ARFRSH;
+		asm("sync;msync");
+		*sdram_addr = 0xff;
+		ppcDcbf((unsigned long) sdram_addr);
+		udelay(100);
+	}
+
+	/*
+	 * Issue 8 MODE-set command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_MRW;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(100);
+
+	/*
+	 * Issue NORMAL OP command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_NORMAL;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(200);    /* Overkill. Must wait > 200 bus cycles */
+
+#endif	/* enable SDRAM init */
+}
+
+#if defined(CFG_DRAM_TEST)
+int
+testdram(void)
+{
+	uint *pstart = (uint *) CFG_MEMTEST_START;
+	uint *pend = (uint *) CFG_MEMTEST_END;
+	uint *p;
+
+	printf("Testing DRAM from 0x%08x to 0x%08x\n",
+	       CFG_MEMTEST_START,
+	       CFG_MEMTEST_END);
+
+	printf("DRAM test phase 1:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0xaaaaaaaa;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0xaaaaaaaa) {
+			printf ("DRAM test fails at: %08x, expected [%08x], got [%08x]\n", (uint) p, 0xaaaaaaaa, *p);
+			return 1;
+		}
+	}
+
+	printf("DRAM test phase 2:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0x55555555;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0x55555555) {
+			printf ("DRAM test fails at: %08x, expected [%08x], got [%08x]\n", (uint) p, 0x55555555, *p);
+			return 1;
+		}
+	}
+
+	printf("DRAM test passed.\n");
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_PCI)
+
+/*
+ * Initialize PCI Devices, report devices found.
+ */
+
+#ifndef CONFIG_PCI_PNP
+static struct pci_config_table pci_mpc85xxcds_config_table[] = {
+    { PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+      PCI_IDSEL_NUMBER, PCI_ANY_ID,
+      pci_cfgfunc_config_device, { PCI_ENET0_IOADDR,
+				   PCI_ENET0_MEMADDR,
+				   PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER
+      } },
+    { }
+};
+#endif
+
+static struct pci_controller hose = {
+#ifndef CONFIG_PCI_PNP
+	config_table: pci_mpc85xxcds_config_table,
+#endif
+};
+
+#endif	/* CONFIG_PCI */
+
+void
+pci_init_board(void)
+{
+#ifdef CONFIG_PCI
+	extern void pci_mpc85xx_init(struct pci_controller *hose);
+
+	debug("%s\n", __FUNCTION__);
+	pci_mpc85xx_init(&hose);
+	debug("finished %s\n", __FUNCTION__);
+#endif
+}
diff -Naur u-boot-1.1.2/board/debmax/eeprom.c uboot-1.1.2hsv/board/debmax/eeprom.c
--- u-boot-1.1.2/board/debmax/eeprom.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/eeprom.c	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+#include <i2c.h>
+
+#include "eeprom.h"
+
+
+typedef struct {
+	char idee_pcbid[4];		/* "CCID" for CDC v1.X */
+	u8 idee_major;
+	u8 idee_minor;
+	char idee_serial[10];
+	char idee_errata[2];
+	char idee_date[8];		/* yyyymmdd */
+	/* The rest of the EEPROM space is reserved */
+} id_eeprom_t;
+
+
+
+/*
+   cyclades: we don't use eeprom to save cpu board rev. use FPGA instead.
+   TODO:
+   */
+unsigned int
+get_cpu_board_revision(void)
+{
+	uint major = 0;
+	uint minor = 0;
+
+/* 	id_eeprom_t id_eeprom; */
+
+/* 	i2c_read(CFG_I2C_EEPROM_ADDR, 0, 2, */
+/* 		 (uchar *) &id_eeprom, sizeof(id_eeprom)); */
+
+/* 	major = id_eeprom.idee_major; */
+/* 	minor = id_eeprom.idee_minor; */
+
+/* 	if (major == 0xff && minor == 0xff) { */
+/* 		major = minor = 0; */
+/* 	} */
+
+	return MPC85XX_CPU_BOARD_REV(major,minor);
+}
diff -Naur u-boot-1.1.2/board/debmax/eeprom.h uboot-1.1.2hsv/board/debmax/eeprom.h
--- u-boot-1.1.2/board/debmax/eeprom.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/eeprom.h	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EEPROM_H_
+#define __EEPROM_H_
+
+
+/*
+ * EEPROM Board System Register interface.
+ */
+
+
+/*
+ * CPU Board Revision
+ */
+#define MPC85XX_CPU_BOARD_REV(maj, min)	((((maj)&0xff) << 8) | ((min) & 0xff))
+#define MPC85XX_CPU_BOARD_MAJOR(rev)	(((rev) >> 8) & 0xff)
+#define MPC85XX_CPU_BOARD_MINOR(rev)	((rev) & 0xff)
+
+#define MPC85XX_CPU_BOARD_REV_UNKNOWN	MPC85XX_CPU_BOARD_REV(0,0)
+#define MPC85XX_CPU_BOARD_REV_1_0	MPC85XX_CPU_BOARD_REV(1,0)
+#define MPC85XX_CPU_BOARD_REV_1_1	MPC85XX_CPU_BOARD_REV(1,1)
+
+/*
+ * Returns CPU board revision register as a 16-bit value with
+ * the Major in the high byte, and Minor in the low byte.
+ */
+extern unsigned int get_cpu_board_revision(void);
+
+
+#endif	/* __EEPROM_H_ */
diff -Naur u-boot-1.1.2/board/debmax/init.S uboot-1.1.2hsv/board/debmax/init.S
--- u-boot-1.1.2/board/debmax/init.S	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/init.S	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,292 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ * Copyright 2002,2003, Motorola Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * kvmmaxv1/debv1 board init.S
+ *
+ * modified by Yang Yang, Cyclades Corp.
+ * changed parts are prepended with "cyclades"
+ * 2/14/05
+ *
+ */
+	
+#include <ppc_asm.tmpl>
+#include <ppc_defs.h>
+#include <asm/cache.h>
+#include <asm/mmu.h>
+#include <config.h>
+#include <mpc85xx.h>
+
+
+/*
+ * TLB0 and TLB1 Entries
+ *
+ * Out of reset, TLB1's Entry 0 maps the highest 4K for CCSRBAR.
+ * However, CCSRBAR is then relocated to CFG_CCSRBAR right after
+ * these TLB entries are established.
+ *
+ * The TLB entries for DDR are dynamically setup in spd_sdram()
+ * and use TLB1 Entries 8 through 15 as needed according to the
+ * size of DDR memory.
+ *
+ * MAS0: tlbsel, esel, nv
+ * MAS1: valid, iprot, tid, ts, tsize
+ * MAS2: epn, sharen, x0, x1, w, i, m, g, e
+ * MAS3: rpn, u0-u3, ux, sx, uw, sw, ur, sr
+ */
+
+#define	entry_start \
+	mflr	r1 	;	\
+	bl	0f 	;
+
+#define	entry_end \
+0:	mflr	r0	;	\
+	mtlr	r1	;	\
+	blr		;
+
+
+	.section	.bootpg, "ax"
+	.globl	tlb1_entry
+tlb1_entry:
+	entry_start
+
+	/*
+	 * Number of TLB0 and TLB1 entries in the following table
+	 */
+	/**
+	 * cyclades: change TLB entry number 13 to real # entries
+	 * 5 TLB0 + 8 TLB1 = 13 entries
+	 */
+ 	.long 13
+
+#if (CFG_CCSRBAR_DEFAULT != CFG_CCSRBAR)
+	/*
+	 * TLB0		4K	Non-cacheable, guarded
+	 * 0xff700000	4K	Initial CCSRBAR mapping
+	 *
+	 * This ends up at a TLB0 Index==0 entry, and must not collide
+	 * with other TLB0 Entries.
+	 */
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_CCSRBAR_DEFAULT), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_CCSRBAR_DEFAULT), 0,0,0,0,0,1,0,1,0,1)
+#else
+#error("Update the number of table entries in tlb1_entry")
+#endif
+
+	/*
+	 * TLB0		16K	Cacheable, non-guarded
+	 * cyclades:	CFG_INIT_RAM_ADDR, 0xe401_0000 16K 0xe401_4000
+	 * 0xe401_0000	16K	Temporary Global data for initialization
+	 *			use L1 D-cache (32KB) for this.
+	 * 
+	 * Use four 4K TLB0 entries.  These entries must be cacheable
+	 * as they provide the bootstrap memory before the memory
+	 * controler and real memory have been configured.
+	 *
+	 * cyclades:	end up at TLB0 indices 0x10, 0x11, 0x12, 0x13
+	 * These entries end up at TLB0 Indicies 0x10, 0x11, 0x12, 0x13
+	 * and must not collide with other TLB0 entries.
+	 */
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 4 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 4 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 8 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 8 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 12 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 12 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/**
+	 * cyclades: Flash size is 8M,
+	 * no tsize can be exactly 8M, should we have two 4M size TLB entries?
+	 */
+	/*
+	 * DO NOT use entry 0, seems it caused core crash!!!
+	 * TLB1 entry 15:4M	Non-cacheable, guarded
+	 * 0xff800000	4M	FLASH first half
+	 * Out of reset this entry is only 4K.
+	 *
+	 * second half 4M will be assigned at TLB1 entry 6
+	 */
+	.long TLB1_MAS0(1, 15, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_4M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_FLASH_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_FLASH_BASE), 0,0,0,0,0,1,0,1,0,1)
+	
+	/*
+	 * TLB1 entry 1:256M	Non-cacheable, guarded
+	 * 0x80000000	256M	PCI1 MEM First half
+	 */
+	.long TLB1_MAS0(1, 1, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI1_MEM_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI1_MEM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 2:256M	Non-cacheable, guarded
+	 * 0x90000000	256M	PCI1 MEM Second half
+	 */
+	.long TLB1_MAS0(1, 2, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI1_MEM_BASE + 0x10000000),
+			0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI1_MEM_BASE + 0x10000000),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 3:256M	Non-cacheable, guarded
+	 * 0xa0000000	256M	PCI2 MEM First half
+	 */
+	.long TLB1_MAS0(1, 3, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI2_MEM_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI2_MEM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 4:256M	Non-cacheable, guarded
+	 * 0xb0000000	256M	PCI2 MEM Second half
+	 */
+	.long TLB1_MAS0(1, 4, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI2_MEM_BASE + 0x10000000),
+			0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI2_MEM_BASE + 0x10000000),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 5:64M	Non-cacheable, guarded
+	 * 0xe000_0000	1M	CCSRBAR
+	 * 0xe200_0000	16M	PCI1 IO
+	 * 0xe300_0000	16M	PCI2 IO
+	 */
+	.long TLB1_MAS0(1, 5, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_64M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_CCSRBAR), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_CCSRBAR), 0,0,0,0,0,1,0,1,0,1)
+
+	/**
+	 * cyclades: Flash size is 8M,
+	 * no tsize can be exactly 8M, should we have two 4M size TLB entries?
+	 */
+	/*
+	 * TLB1 entry 6:4M	Non-cacheable, guarded
+	 * 0xffc00000	4M	FLASH second half
+	 * Out of reset this entry is only 4K.
+	 *
+	 * first half 4M is assigned at TLB1 entry 15
+	 */
+	.long TLB1_MAS0(1, 6, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_4M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_FLASH_BASE + 0x400000), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_FLASH_BASE + 0x400000), 0,0,0,0,0,1,0,1,0,1)
+	
+	/**
+	 * cyclades: localbus is 256M,
+	 */
+	/*
+	 * TLB1 entry 7:256M	Non-cacheable, guarded
+	 * 0xc0000000	256M	LocalBus, FPGA for CF, etc
+	 *
+	 */
+	.long TLB1_MAS0(1, 7, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_LBC_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_LBC_BASE), 0,0,0,0,0,1,0,1,0,1)
+	
+	entry_end
+
+/*
+ * LAW(Local Access Window) configuration:
+ *
+ * 0x0000_0000     0x7fff_ffff     DDR                     2G
+ * 0x8000_0000     0x9fff_ffff     PCI1 MEM                512M
+ * 0xa000_0000     0xbfff_ffff     PCI2 MEM                512M
+ * cyclades: we have LocalBus mem map for Compact Flash
+ * 0xc000_0000     0xcfff_ffff     LOCALBUS                256M
+ * 0xe000_0000     0xe00f_ffff     CCSR                    1M
+ * 0xe200_0000     0xe2ff_ffff     PCI1 IO                 16M
+ * 0xe300_0000     0xe3ff_ffff     PCI2 IO                 16M
+ * 0xff80_0000     0xffff_ffff     FLASH (boot bank)       8M
+ *
+ * Notes:
+ *    CCSRBAR and L2-as-SRAM don't need a configured Local Access Window.
+ *    If flash is 8M at default position (last 8M), no LAW needed.
+ *
+ * The defines below are 1-off of the actual LAWAR0 usage.
+ * So LAWAR3 define uses the LAWAR4 register in the ECM.
+ */
+
+/**
+ * cyclades: DDR size is 256M
+ */	
+#define LAWBAR0 0
+#define LAWAR0  ((LAWAR_TRGT_IF_DDR | (LAWAR_SIZE & LAWAR_SIZE_256M)) & ~LAWAR_EN)
+
+#define LAWBAR1 ((CFG_PCI1_MEM_BASE>>12) & 0xfffff)
+#define LAWAR1 	(LAWAR_EN | LAWAR_TRGT_IF_PCI1 | (LAWAR_SIZE & LAWAR_SIZE_512M))
+
+#define LAWBAR2 ((CFG_PCI2_MEM_BASE>>12) & 0xfffff)
+#define LAWAR2 	(LAWAR_EN | LAWAR_TRGT_IF_PCI2 | (LAWAR_SIZE & LAWAR_SIZE_512M))
+
+#define LAWBAR3 ((CFG_PCI1_IO_BASE>>12) & 0xfffff)
+#define LAWAR3 	(LAWAR_EN | LAWAR_TRGT_IF_PCI1 | (LAWAR_SIZE & LAWAR_SIZE_16M))
+
+#define LAWBAR4 ((CFG_PCI2_IO_BASE>>12) & 0xfffff)
+#define LAWAR4 	(LAWAR_EN | LAWAR_TRGT_IF_PCI2 | (LAWAR_SIZE & LAWAR_SIZE_16M))
+
+/* cyclades: LocalBus */
+/* LBC window - maps 256M 0xc0000000 -> 0xcfffffff */
+#define LAWBAR5 ((CFG_LBC_BASE>>12) & 0xfffff)
+#define LAWAR5 	(LAWAR_EN | LAWAR_TRGT_IF_LBC | (LAWAR_SIZE & LAWAR_SIZE_256M))
+
+	.section .bootpg, "ax"
+	.globl	law_entry
+
+law_entry:
+	entry_start
+/* cyclades: only 6 entries in LAWBAR/LAWAR */
+ 	.long 6
+	.long LAWBAR0,LAWAR0,LAWBAR1,LAWAR1,LAWBAR2,LAWAR2,LAWBAR3,LAWAR3
+	.long LAWBAR4,LAWAR4,LAWBAR5,LAWAR5
+	entry_end
diff -Naur u-boot-1.1.2/board/debmax/Makefile uboot-1.1.2hsv/board/debmax/Makefile
--- u-boot-1.1.2/board/debmax/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/Makefile	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,56 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+# (C) Copyright 2001
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+# cyclades: we don't use cadmus registers, use our config method, cycparam.
+# OBJS	:= $(BOARD).o \
+# 	   cadmus.o \
+# 	   eeprom.o
+OBJS	:= $(BOARD).o \
+	   bdparam.o \
+	   eeprom.o \
+	   sw6095.o
+
+SOBJS	:= init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Naur u-boot-1.1.2/board/debmax/sw6095.c uboot-1.1.2hsv/board/debmax/sw6095.c
--- u-boot-1.1.2/board/debmax/sw6095.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/sw6095.c	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,1279 @@
+/*
+ * Cyclades:
+ *   Support for Marvell's 88E6095 11-port switch chips for DEB board.
+ *
+ * copied from Marvell's sample/MultiDevice/msApiInit.c
+ *
+ *
+ * Our block diagrams are like this:
+ * 
+ * -----------------------------------(DEB Version 1, DEBV1)------------------------------
+ *
+ *                                  -----------------------                                  
+ *                                  |MPC85xx TSEC2 Eth MAC|                                  
+ *                                  -----------------------                                  
+ *                                             |                              		 
+ *                                             |                              		 
+ *                                             |                              		 
+ *  8------10------9  8------10------9  8------10------9  8------10------9  8------10------9 
+ *  |  88E6095  #4 |--|  88E6095  #3 |--|  88E6095  #1 |--|  88E6095  #2 |--|  88E6095  #5 | 
+ *  ----------------  ----------------  ----------------  ----------------  ---------------- 
+ *    0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7    
+ *
+ *
+ * For 24-port model, there are no switch #4 or #3. ($4--#3)--#1--#2--#5
+ *
+ *             Ethernet port of CPU is connected to port 10 of Device #1,
+ *             port 9 of Device #1 is connected to port 8 of Device #2,
+ *             port 8 of Device #1 is connected to port 9 of Device #3,
+ *             and so on.
+ *
+ *             Device #1 uses Phy Address 0x01,
+ *             Device #2 uses Phy Address 0x02,
+ *             Device #3 uses Phy Address 0x03,
+ *             Device #4 uses Phy Address 0x04,
+ *             Device #5 uses Phy Address 0x05
+ *             Notes: Phy Address 0 cannot be used in a Multi Chip Address Mode.
+ *
+ *             Each Switch Device has to be configured to Multi Chip Address Mode.
+ *
+ * 
+ *
+ * NOTE: In later version, block diagram will probably change to:
+ * 
+ * ---------------------------(DEB Version 1 Revision 1, DEBV1_REV1)----------------------
+ *
+ *                                  -----------------------                                  
+ *                                  |MPC85xx TSEC2 Eth MAC|                                  
+ *                                  -----------------------                                  
+ *                                             |                              		 
+ *                                             |                              		 
+ *                                             |                              		 
+ *  8------10------9  8------10------9  8------10------9  8------10------9  8------10------9 
+ *  |  88E6095  #1 |--|  88E6095  #2 |--|  88E6095  #3 |--|  88E6095  #4 |--|  88E6095  #5 | 
+ *  ----------------  ----------------  ----------------  ----------------  ---------------- 
+ *    0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7    
+ *
+ *
+ *             The difference between DEBV1 and DEBV1_REV1 is the numbering of 88E6095 chips:
+ *             in DEBV1:
+ *                (#4--#3)--#1--#2--#5
+ *             in DEBV1_REV1:
+ *                #1--#2--#3--(#4--#5)
+ *
+ *             chip number in '( )' doesn't exist in 24-port model.
+ *
+ *
+ *             
+ * NOTE: Before we get DEBV1_REV1, we modify original DEBV1 boards to get DEBV1_REV1_PRE
+ *
+ * -----------------------(DEB Version 1 Revision 1 Pre, DEBV1_REV1_PRE)----------------------
+ *
+ *                                  -----------------------                                  
+ *                                  |MPC85xx TSEC2 Eth MAC|                                  
+ *                                  -----------------------                                  
+ *                                             |                              		 
+ *                                             |                              		 
+ *                                             |                              		 
+ *  8------10------9  8------10------9  8------10------9  8------10------9  8------10------9 
+ *  |  88E6095  #1 |--|  88E6095  #2 |--|  88E6095  #3 |--|  88E6095  #4 |--|  88E6095  #5 | 
+ *  ----------------  ----------------  ----------------  ----------------  ---------------- 
+ *    0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7       0 1 2 ... 7    
+ *
+ * 
+ *       we have changed all original DEBV1 boards to DEBV1_REV1 SMI
+ *       addr numbering as follows:
+ *
+ *              DEBV1                DEBV1_REV1_PRE
+ *       ----------------        ----------------------
+ *               #4         ->             #1
+ *               #3         ->             #2
+ *               #1         ->             #3
+ *               #2         ->             #4
+ *               #5         ->             #5 (not change)
+ *
+ *       So there is no DEBV1 style numbering. However, for 24-port
+ *       model, DEBV1_REV1 boards have devices #1-#2-#3, while
+ *       DEBV1_REV1_PRE, which were originally DEBV1 boards with their
+ *       SMI addr renumbered, have devices #3-#4-#5. For 40-port
+ *       model, both DEBV1_REV1 and DEBV1_REV1_PRE boards are
+ *       identical. So:
+ *       
+ *       in DEBV1_REV1:
+ *       	#1--#2--#3--(#4--#5)
+ *       in DEBV1_REV1_PRE:
+ *       	(#1--#2)--#3--#4--#5
+ *       
+ * 
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <miiphy.h>
+
+#ifdef CONFIG_MV88E6095
+
+#include "sw6095.h"
+#include "bdparam.h"
+
+static int DEB_24P_DEVICE_FIRST;
+static int DEB_24P_DEVICE_SECOND;
+static int DEB_24P_DEVICE_THIRD;
+
+static int __DEB_24_PORT;
+
+#define is_24p() __DEB_24_PORT
+
+#define MULTI_ADDR_MODE
+
+#ifndef N_OF_QD_DEVICES
+#define N_OF_QD_DEVICES		MAX_NR_SWITCHES	/* number of 88E6095 devices connected */
+#endif
+
+#define DEVICE1_ID		1
+#define DEVICE2_ID		DEVICE1_ID + 1
+#define DEVICE3_ID		DEVICE1_ID + 2
+#define DEVICE4_ID		DEVICE1_ID + 3
+#define DEVICE5_ID		DEVICE1_ID + 4
+
+#define DEVICE1_PHY_ADDR	0x01
+#define DEVICE2_PHY_ADDR	DEVICE1_PHY_ADDR + 1
+#define DEVICE3_PHY_ADDR	DEVICE1_PHY_ADDR + 2
+#define DEVICE4_PHY_ADDR	DEVICE1_PHY_ADDR + 3
+#define DEVICE5_PHY_ADDR	DEVICE1_PHY_ADDR + 4
+
+typedef struct routing_tbl_entry_s {
+	GT_U32 devnum;
+	GT_LPORT portnum;
+} routing_tbl_entry_t;
+
+	
+/* cyclades: can have more than ONE cascade port? Yes! */
+#define DEVICE1_CPU_PORT		9
+#define DEVICE1_CASCADE_PORT	0xE 		/* 0xE means no CAS_PORT */
+#define DEVICE2_CPU_PORT		9
+#define DEVICE2_CASCADE_PORT	8
+#define DEVICE3_CPU_PORT		10
+#define DEVICE3_CASCADE_PORT	8
+#define DEVICE4_CPU_PORT		8
+#define DEVICE4_CASCADE_PORT	9
+#define DEVICE5_CPU_PORT		8
+#define DEVICE5_CASCADE_PORT	0xE
+#define ANOTHER_CPU_DEVICE_CASCADE_PORT 9
+#define S_CPU_DEVICE_ID		DEVICE3_ID
+#define S_CPU_DEVICE_PHY_ADDR	DEVICE3_PHY_ADDR
+#define S_CPU_DEVICE_CPU_PORT	DEVICE3_CPU_PORT
+#define S_CPU_DEVICE_CAS_PORT	0xF            /* use Routing Table in G2 Reg0x6. */
+#define S_CPU_DEVICE_ROUTING_TBL {{1,8}, {2,8}, {4,9}, {5,9}, {-1,-1}}
+#define VLANTABLE  {{0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x000, 0x0ff, 0x000}, \
+                    {0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x1ff, 0x000}, \
+                    {0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x3ff}, \
+                    {0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x2ff, 0x100, 0x000}, \
+		    {0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x0ff, 0x000, 0x000}}
+#define DEFAULTVID {{0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007, 0x008, 0x000, 0x000, 0x000}, \
+                    {0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f, 0x010, 0x000, 0x000, 0x000}, \
+		    {0x011, 0x012, 0x013, 0x014, 0x015, 0x016, 0x017, 0x018, 0x000, 0x000, 0x000}, \
+                    {0x019, 0x01a, 0x01b, 0x01c, 0x01d, 0x01e, 0x01f, 0x020, 0x000, 0x000, 0x000}, \
+		    {0x021, 0x022, 0x023, 0x024, 0x025, 0x026, 0x027, 0x028, 0x000, 0x000, 0x000}}
+#define UNM MEMBER_EGRESS_UNMODIFIED
+#define NOT NOT_A_MEMBER
+#define UNT MEMBER_EGRESS_UNTAGGED
+#define TAG MEMBER_EGRESS_TAGGED
+#define DEVICE1_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		            }
+#define DEVICE2_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:9, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:10, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:11, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:12, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:13, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:14, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:15, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:16, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+                            }
+#define DEVICE3_VTU_ENTRIES {{DBNum:0, vid:1, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:2, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:3, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:4, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:5, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:6, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:7, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:8, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:9, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:10, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:11, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:12, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:13, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:14, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:15, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:16, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:17, \
+			      vtuData:{ \
+				memberTagP:{UNM, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:18, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNM, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:19, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNM, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:20, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNM, NOT, NOT, NOT, NOT, NOT, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:21, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNM, NOT, NOT, NOT, NOT, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:22, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNM, NOT, NOT, NOT, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:23, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, NOT, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:24, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, NOT, NOT, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:25, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:26, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:27, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:28, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:29, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:30, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:31, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:32, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:33, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:34, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:35, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:36, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:37, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:38, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:39, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:40, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+                            }
+#define DEVICE4_VTU_ENTRIES {{DBNum:0, vid:25, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:26, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:27, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:28, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:29, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:30, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:31, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:32, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			     {DBNum:0, vid:33, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:34, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:35, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:36, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:37, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:38, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:39, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:40, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNM, UNM, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+			    }
+#define DEVICE5_VTU_ENTRIES {{DBNum:0, vid:33, \
+			      vtuData:{ \
+				memberTagP:{UNT, NOT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:34, \
+			      vtuData:{ \
+				memberTagP:{NOT, UNT, NOT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:35, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, UNT, NOT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:36, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, UNT, NOT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:37, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, UNT, NOT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:38, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, UNT, NOT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:39, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, UNT, NOT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+		             {DBNum:0, vid:40, \
+			      vtuData:{ \
+				memberTagP:{NOT, NOT, NOT, NOT, NOT, NOT, NOT, UNT, TAG, NOT, NOT}, \
+				portStateP:{0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0}}, \
+			      vidPriOverride:0, vidPriority:0}, \
+}
+
+static routing_tbl_entry_t s_cpu_device_routing_tbl[N_OF_QD_DEVICES] = S_CPU_DEVICE_ROUTING_TBL;
+static int vlantable[N_OF_QD_DEVICES][MAX_PORTS_PER_SWITCH] = VLANTABLE;
+static int defaultvid[N_OF_QD_DEVICES][MAX_PORTS_PER_SWITCH] = DEFAULTVID;
+static GT_VTU_ENTRY device1_vtu_entries[]=DEVICE1_VTU_ENTRIES;
+static GT_VTU_ENTRY device2_vtu_entries[]=DEVICE2_VTU_ENTRIES;
+static GT_VTU_ENTRY device3_vtu_entries[]=DEVICE3_VTU_ENTRIES;
+static GT_VTU_ENTRY device4_vtu_entries[]=DEVICE4_VTU_ENTRIES;
+static GT_VTU_ENTRY device5_vtu_entries[]=DEVICE5_VTU_ENTRIES;
+
+GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES] = {0,};
+
+/*
+ * read mii register - see qdFFmii.c
+ */ 
+GT_BOOL ffReadMii(GT_QD_DEV* dev, 
+		  unsigned int portNumber , 
+		  unsigned int MIIReg, unsigned int* value)
+{
+	int ret;
+	unsigned short data=0xffff;
+  
+	if(!dev || !value)
+		return GT_FALSE;
+	debug("%s, %s, %d, calling miiphy_read(%u, %u, 0x%x)\n", __FILE__, __FUNCTION__, __LINE__, (unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short*)value);
+	ret=miiphy_read((unsigned char)(dev->phyAddr), (unsigned char)MIIReg, &data);
+	debug("%s, %s, %d, got value = %04x\n", __FILE__, __FUNCTION__, __LINE__, data);
+	if(ret==0) {
+		*value=(unsigned int)data;
+		return GT_TRUE;
+	}
+	return GT_FALSE;
+}
+
+/*
+ * write mii register - see qdFFmii.c
+ */ 
+GT_BOOL ffWriteMii(GT_QD_DEV* dev, 
+		   unsigned int portNumber , 
+		   unsigned int MIIReg, 
+		   unsigned int value)
+{
+	int ret;
+
+	if(!dev)
+		return GT_FALSE;
+	debug("%s, %s, %d, calling miiphy_write(%u, %u, %04x)\n", __FILE__, __FUNCTION__, __LINE__, (unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short)(value & 0x0000ffff));
+	ret=miiphy_write((unsigned char)(dev->phyAddr), (unsigned char)MIIReg, (unsigned short)(value & 0x0000ffff));
+	debug("%s, %s, %d, got ret = %d\n", __FILE__, __FUNCTION__, __LINE__, ret);
+	if(ret==0)
+		return GT_TRUE;
+	return GT_FALSE;
+}
+
+/*
+ * setup some constants for board autodetection.
+ */
+int sw6095_setup_const(bd_t *bis)
+{
+	unsigned int bd_ver_rev = bis->board_ver_rev;
+	unsigned int bd_model = bis->board_model;
+	int debv1_rev1_pre = 0;
+	int DEB_SWITCH_24P_NUMBERING;
+
+
+	if (bd_ver_rev == 0x01)
+		debv1_rev1_pre = 1;
+
+	if (debv1_rev1_pre)
+		DEB_SWITCH_24P_NUMBERING = 345;
+	else
+		DEB_SWITCH_24P_NUMBERING = 123;
+
+	if (DEB_SWITCH_24P_NUMBERING == 345) {
+		DEB_24P_DEVICE_FIRST = 3;
+		DEB_24P_DEVICE_SECOND = 4;
+		DEB_24P_DEVICE_THIRD = 5;
+	} else if (DEB_SWITCH_24P_NUMBERING == 123) {
+		DEB_24P_DEVICE_FIRST = 1;
+		DEB_24P_DEVICE_SECOND = 2;
+		DEB_24P_DEVICE_THIRD = 3;
+	} else {
+		return -1;
+	}
+
+	__DEB_24_PORT = bd_model & 0x80;
+	return 0;
+}
+
+/*
+ * Initialize each Switch Devices. This should be done in BSP driver init routine.
+ * Since BSP is not combined with QuarterDeck driver, we are doing here.
+ * This routine will setup Switch Devices according to the above description.
+ */
+GT_STATUS qdMultiDevStart(void)
+{
+	GT_STATUS status = GT_FAIL;
+	GT_SYS_CONFIG   cfg;
+	int cpuPort;
+	int cascadePort;
+	int i,j;
+	int cpu_device_id = S_CPU_DEVICE_ID;
+	int another_cpu_cascadePort = ANOTHER_CPU_DEVICE_CASCADE_PORT;
+	routing_tbl_entry_t *rt_entry = s_cpu_device_routing_tbl;
+	int s_cpu_device_cas_port = S_CPU_DEVICE_CAS_PORT;
+
+	memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
+	
+	/* 
+	 * Create QD Device Structure for each device.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		qdMultiDev[i] = (GT_QD_DEV*)malloc(sizeof(GT_QD_DEV));
+
+		if(qdMultiDev[i] == NULL)
+		{
+			while(i--)
+				free(qdMultiDev[i]);
+			return GT_FAIL;
+		}
+
+		memset((char*)qdMultiDev[i],0,sizeof(GT_QD_DEV));
+	}
+	
+	/*
+	 * Register all the required functions to QuarterDeck Driver for each device.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		cfg.BSPFunctions.readMii   = ffReadMii;
+		cfg.BSPFunctions.writeMii  = ffWriteMii;
+#ifdef USE_SEMAPHORE
+		cfg.BSPFunctions.semCreate = osSemCreate;
+		cfg.BSPFunctions.semDelete = osSemDelete;
+		cfg.BSPFunctions.semTake   = osSemWait;
+		cfg.BSPFunctions.semGive   = osSemSignal;
+#else
+		cfg.BSPFunctions.semCreate = NULL;
+		cfg.BSPFunctions.semDelete = NULL;
+		cfg.BSPFunctions.semTake   = NULL;
+		cfg.BSPFunctions.semGive   = NULL;
+#endif
+
+		cfg.initPorts = GT_TRUE;	/* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
+		switch (i)
+		{
+		case 0: /* if we are registering device 1 */
+			cfg.cpuPortNum = DEVICE1_CPU_PORT;
+			break;
+		case 1: /* if we are registering device 2 */
+			cfg.cpuPortNum = DEVICE2_CPU_PORT;	
+			break;
+		case 2: /* if we are registering device 3 */
+			cfg.cpuPortNum = DEVICE3_CPU_PORT;	
+			break;
+		case 3: /* if we are registering device 4 */
+			cfg.cpuPortNum = DEVICE4_CPU_PORT;	
+			break;
+		case 4: /* if we are registering device 5 */
+			cfg.cpuPortNum = DEVICE5_CPU_PORT;	
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+#ifdef MANUAL_MODE	/* not defined. this is only for sample */
+		/* user may want to use this mode when there are two QD switchs on the same MII bus. */
+		cfg.mode.scanMode = SMI_MANUAL_MODE;	/* Use QD located at manually defined base addr */
+		cfg.mode.baseAddr = 0x10;	/* valid value in this case is either 0 or 0x10 */
+#else
+#ifdef MULTI_ADDR_MODE	/* It should have been defined for this sample code */
+		cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;	/* find a QD in indirect access mode */
+		cfg.mode.baseAddr = DEVICE1_PHY_ADDR + i; /* this is the phyAddr used by QD family device. Valid values are 1 ~ 31.*/
+#else
+		cfg.mode.scanMode = SMI_AUTO_SCAN_MODE;	/* Scan 0 or 0x10 base address to find the QD */
+		cfg.mode.baseAddr = 0;
+#endif
+#endif
+
+		if((status=qdLoadDriver(&cfg, qdMultiDev[i])) != GT_OK)
+		{
+			MSG_PRINT(("qdLoadDriver return Failed on device [%d]\n", i+1));
+			goto errorExit;
+		}
+
+ 		MSG_PRINT(("Opal #%d\n",i+1));
+		MSG_PRINT(("Device ID     : 0x%x\n",qdMultiDev[i]->deviceId));
+		MSG_PRINT(("Base Reg Addr : 0x%x\n",qdMultiDev[i]->baseRegAddr));
+		MSG_PRINT(("No of Ports   : %d\n",qdMultiDev[i]->numOfPorts));
+		MSG_PRINT(("CPU Port      : %d\n",qdMultiDev[i]->cpuPortNum));
+
+		/*
+		 *  start the QuarterDeck
+		 */
+		if((status=sysEnable(qdMultiDev[i])) != GT_OK)
+		{
+			MSG_PRINT(("sysEnable return Failed\n"));
+			goto errorExit;
+		}
+	}
+
+	/* 
+	 *	Now, we need to configure Cascading information for each devices.
+	 *	1. Set Interswitch port mode for port 8 and 9 for device 1,2,3,4,5
+	 *	   so that switch device can expect Marvell Tag from frames 
+	 *         ingressing/egressing this port.
+	 *	2. Set CPU Port information (for To_CPU frame) for each port of device.
+	 *	3. Set Cascading Port information (for From_CPU frame) for each device.
+	 *      4. Set Device ID (if required)
+	 *	Note: DeviceID is hardware configurable.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		switch (i) {
+		case 0: /* if we are registering device 1 */
+			cpuPort = DEVICE1_CPU_PORT; 		
+			cascadePort = DEVICE1_CASCADE_PORT;	
+			break;
+		case 1: /* if we are registering device 2 */
+			cpuPort = DEVICE2_CPU_PORT; 		
+			cascadePort = DEVICE2_CASCADE_PORT;	
+			break;
+		case 2: /* if we are registering device 3 */
+			cpuPort = DEVICE3_CPU_PORT; 		
+			cascadePort = DEVICE3_CASCADE_PORT;	
+			break;
+		case 3: /* if we are registering device 4 */
+			cpuPort = DEVICE4_CPU_PORT; 		
+			cascadePort = DEVICE4_CASCADE_PORT;	
+			break;
+		case 4: /* if we are registering device 5 */
+			cpuPort = DEVICE5_CPU_PORT; 		
+			cascadePort = DEVICE5_CASCADE_PORT;	
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+
+		/*
+		 *	1. Set Interswitch port mode for port 8 and 9 for device 1,2,3,4,5
+		 *         so that switch device can expect Marvell Tag from frames 
+		 *         ingressing/egressing this port.
+		 *	2. Set CPU Port information (for To_CPU frame) for each port of device.
+		 */			
+		for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
+		{
+			if((j == cpuPort) || (j == cascadePort) || ((i==(cpu_device_id-1))&&(j==another_cpu_cascadePort)))
+			{
+/* 				MSG_PRINT(("Opal #%d Port %d is setting inter-switch port\n",i+1, j)); */
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_TRUE)) != GT_OK)
+				{
+					MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode TRUE)\n",status,j));
+					goto errorExit;
+				}
+			}
+			else
+			{
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_FALSE)) != GT_OK)
+				{
+					MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode FALSE)\n",status,j));
+					goto errorExit;
+				}
+			}
+
+			/* NOTE:
+			 * cyclades: should S_CPU_DEVICE_ID's cpuPort be set to interswitch (AKA. Marvell Tag port)?
+			 *           Finally we should if modified TSEC2 MAC driver supports MT, we can disable
+			 *           it temporarily for developing.
+			 */
+#if 1
+			if((i==(cpu_device_id-1)) && (j==cpuPort)) {
+/* 				MSG_PRINT(("Opal #%d is S_CPU_DEVICE_ID, its CPU_PORT %d is NOT set to Marvell Tag port because lack MAC driver support \n",i+1, j)); */
+				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_FALSE)) != GT_OK)
+				{
+					MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode FALSE)\n",status,j));
+					goto errorExit;
+				}
+			}
+#endif
+
+			if((status=gprtSetCPUPort(qdMultiDev[i],j,cpuPort)) != GT_OK)
+			{
+				MSG_PRINT(("gprtSetCPUPort returned %i\n",status));
+				goto errorExit;
+			}
+		}
+
+		/*
+		 *	3. Set Cascading Port information (for From_CPU fram) for each device.
+		 */	 	
+		if((status=gsysSetCascadePort(qdMultiDev[i],cascadePort)) != GT_OK)
+		{
+			MSG_PRINT(("gsysSetCascadePort returned %i\n",status));
+			goto errorExit;
+		}
+
+		/*
+		 *  cyclades: Q? for S_CPU_DEVICE_ID, how to set another_cpu_cascadePort?
+		 *          seems only ONE CAS_PORT per DEVICE!
+		 *  solution: set S_CPU_DEVICE_ID's CAS_PORT to be 0xF, then use routing
+		 *          table to route From_CPU marvell-tagged frame to the specified
+		 *          6095 device.
+		 */
+		if(i==(cpu_device_id-1)) {
+			if((status=gsysSetCascadePort(qdMultiDev[i],s_cpu_device_cas_port)) != GT_OK)
+			{
+				MSG_PRINT(("gsysSetCascadePort returned %i\n",status));
+				goto errorExit;
+			}
+			while(rt_entry && rt_entry->devnum !=-1) {
+/* 				MSG_PRINT(("gsysSetDevRoutingTable(Opal#%d, %i, %i)\n",i+1, rt_entry->devnum, rt_entry->portnum)); */
+				if((status=gsysSetDevRoutingTable(qdMultiDev[i],rt_entry->devnum, rt_entry->portnum)) != GT_OK)
+				{
+					MSG_PRINT(("gsysSetDevRoutingTable returned %i\n",status));
+					goto errorExit;
+				}
+				rt_entry++;
+			}
+		}
+
+		/*
+		 * 	4. Set Device ID (if required)
+		 */	 	
+		if((status=gsysSetDeviceNumber(qdMultiDev[i],DEVICE1_ID+i)) != GT_OK)
+		{
+			MSG_PRINT(("gsysSetDeviceNumber returned %i\n",status));
+			goto errorExit;
+		}
+	}
+
+	/* 
+	 *	For HW guy happy, we manually invert LED0 setting for all FE ports.
+	 *	set all PHY reg 0x19 bit-12 to be 1.
+	 */
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		switch (i) {
+		case 0: /* if we are registering device 1 */
+		case 1: /* if we are registering device 2 */
+		case 2: /* if we are registering device 3 */
+		case 3: /* if we are registering device 4 */
+		case 4: /* if we are registering device 5 */
+			break;
+		default: /* we don't have any more device. it shouldn't happen in our sample setup. */
+			goto errorExit;
+		}
+
+
+		/*
+		 * set all PHY reg 0x19 bit-12 to be 1.
+		 */			
+		for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
+		{
+			GT_U16 data = 0;
+			GT_U32 regAddr = 0x19;
+
+			if(j>=NR_FE_PER_SWITCH)	/* GE ports */
+				continue;
+
+			if((status=gprtGetPhyReg(qdMultiDev[i],j,regAddr, &data)) != GT_OK)
+			{
+				MSG_PRINT(("gprtGetPhyReg returned %i (port %i, reg 0x%02x, data 0x04)\n",status,j,regAddr,data));
+				goto errorExit;
+			}
+			data |= 0x1000;
+			if((status=gprtSetPhyReg(qdMultiDev[i],j,regAddr,data)) != GT_OK)
+			{
+				MSG_PRINT(("gprtSetPhyReg returned %i (port %i, reg 0x%02x, data 0x04)\n",status,j,regAddr,data));
+				goto errorExit;
+			}
+		}
+	}
+
+	MSG_PRINT(("QuarterDeck has been started.\n"));
+
+	return GT_OK;
+
+ errorExit:
+
+	for(i=0; i<N_OF_QD_DEVICES; i++)
+	{
+		if(qdMultiDev[i] != NULL)
+		{
+			qdUnloadDriver(qdMultiDev[i]);
+	  		free(qdMultiDev[i]);
+		}
+	}	
+
+	MSG_PRINT(("QuarterDeck initialization failed.\n"));
+
+	return status;
+}
+
+static GT_STATUS set_port_vlantable_helper(GT_QD_DEV *dev, GT_LPORT port, int vlantable)
+{
+	GT_LPORT mem_ports[MAX_SWITCH_PORTS];
+	GT_U8    mem_portslen =0;
+	int j;
+
+	for(j=0; j<MAX_SWITCH_PORTS; j++) {
+		if((vlantable>>j)&0x1) {
+			mem_ports[mem_portslen]=j;
+			mem_portslen++;
+		}
+	}
+	return gvlnSetPortVlanPorts(dev, port, mem_ports, mem_portslen);
+}
+
+static GT_STATUS set_vtu_helper(GT_QD_DEV *dev, int id)
+{
+	/* id is deviceID starting from 0 */
+	int j;
+	GT_STATUS status;
+	switch(id) {
+	case 0:			/* Opal 1 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device1_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device1_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 1:			/* Opal 2 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device2_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device2_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 2:			/* Opal 3 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device3_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device3_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 3:			/* Opal 4 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device4_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device4_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	case 4:			/* Opal 5 */
+		if((status=gvtuFlush(dev)) != GT_OK) {
+			printf("SW6095 #%d flushing VTU Failed\n", id+1);
+			return status;
+		}
+		for(j=0; j<(sizeof(device5_vtu_entries)/sizeof(GT_VTU_ENTRY)); j++) {
+			if((status=gvtuAddEntry(dev, &device5_vtu_entries[j])) != GT_OK) {
+				printf("SW6095 #%d Add VTU Entry Failed\n", id+1);
+				return status;
+			}
+		}
+		break;
+	default:		/* No such device */
+		return GT_NO_SUCH;
+	}
+	return GT_OK;
+}
+
+/*
+ * set up Cross-chip Port-Based VLANs:
+ *   1) set all 11 ports of all 5 switches 802.1Q disabled except
+ *      for S_CPU_DEVICE_ID's S_CPU_DEVICE_CPU_PORT which set to Fallback
+ *   2) set all ports's VLANTABLE according to vlantable
+ *   3) set all ports's DEFAULTVID according to defaultvid
+ *   4) set VTU entries accordingly for 5 devices
+ * return 0 on success
+ */
+int sw6095_setvlans(bd_t *bis)
+{
+	int i, j;
+	GT_STATUS status;
+
+	for(i=0; i<N_OF_QD_DEVICES; i++) {
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		for(j=0; j<MAX_PORTS_PER_SWITCH; j++) {
+			/* 1) set QMode disabled */
+			if((status=gvlnSetPortVlanDot1qMode(qdMultiDev[i], j, GT_DISABLE)) != GT_OK) {
+				printf("SW6095 #%d port %d setting QMode=disabled Failed\n", i+1, j);
+				return status;
+			}
+			/* 2) set VLANTABLE */
+			if((status=set_port_vlantable_helper(qdMultiDev[i], j, vlantable[i][j])) != GT_OK) {
+				printf("SW6095 #%d port %d setting VLANTABLE Failed\n", i+1, j);
+				return status;
+			}
+			/* 3) set DEFAULTVID */
+			if((status=gvlnSetPortVid(qdMultiDev[i], j, defaultvid[i][j])) != GT_OK) {
+				printf("SW6095 #%d port %d setting DEFAULTVID Failed\n", i+1, j);
+				return status;
+			}
+		}
+		if((status=set_vtu_helper(qdMultiDev[i], i)) != GT_OK) {
+			printf("SW6095 #%d setting VTU Failed\n", i+1);
+			return status;
+		}
+	}
+	/* set S_CPU_DEVICE_CPU_PORT's QMode fallback */
+	if((status=gvlnSetPortVlanDot1qMode(qdMultiDev[S_CPU_DEVICE_ID-1], S_CPU_DEVICE_CPU_PORT, GT_FALLBACK)) != GT_OK) {
+		printf("SW6095 #%d port %d setting QMode=fallback Failed\n", S_CPU_DEVICE_ID, S_CPU_DEVICE_CPU_PORT);
+		return status;
+	}
+	printf("Marvell 88E6095 switches set VLANs OK!\n");
+	return 0;
+}
+
+/* return 0 on success */
+int sw6095_startup(bd_t *bis)
+{
+	int i, j;
+	GT_STATUS status;
+	int sp, ep;
+
+	for(i=0; i<N_OF_QD_DEVICES; i++) {
+		if(is_24p()) {
+			if(!(i==DEB_24P_DEVICE_FIRST-1 || i==DEB_24P_DEVICE_SECOND-1 || i==DEB_24P_DEVICE_THIRD-1))
+				continue;
+		}
+		switch (i) {
+		case 0: 			/* OPAL 1 */
+			sp=9, ep=9;
+			break;
+		case 1: 			/* OPAL 2 */
+			sp=8, ep=9;
+			break;
+		case 2: 			/* OPAL 3 */
+			sp=8, ep=10;
+			break;
+		case 3: 			/* OPAL 4 */
+			sp=8, ep=9;
+			break;
+		case 4: 			/* OPAL 5 */
+			sp=8, ep=8;
+			break;
+		default:
+			sp=0, ep=-1;
+		}
+
+		for(j=sp; j<=ep; j++) {
+			status = GT_FAIL;
+			if((status=gpcsSetDpxValue(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+				if((status=gpcsSetForcedDpx(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+					debug("SW6095 #%d port %d setting Force Full Duplex OK\n", i+1, j);
+				}
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force Full Duplex Failed\n", i+1, j);
+				continue;
+			}
+
+			status = GT_FAIL;
+			if((status=gpcsSetForceSpeed(qdMultiDev[i], j, PORT_FORCE_SPEED_1000_MBPS)) == GT_OK) {
+				debug("SW6095 #%d port %d setting Force 1000Mbps Speed OK\n", i+1, j);
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force 1000Mbps Speed Failed\n", i+1, j);
+				continue;
+			}
+
+			status = GT_FAIL;
+			if((status=gpcsSetLinkValue(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+				if((status=gpcsSetForcedLink(qdMultiDev[i], j, GT_TRUE)) == GT_OK) {
+					debug("SW6095 #%d port %d setting Force Link Up OK\n", i+1, j);
+				}
+			}
+			if(status !=GT_OK) {
+				debug("SW6095 #%d port %d setting Force Link Up Failed\n", i+1, j);
+				continue;
+			}
+		}
+#if 0
+		{				/* dump port 3's PHY registers */
+			int j;
+			for(j=0; j<32; j++) {
+				GT_U16 data=0;
+      
+				if((status=gprtGetPhyReg(qdMultiDev[i], 3, j, &data)) == GT_OK) {
+					debug("----------port %d PHY reg 0x%02x is 0x%04x\n", 3, j, data);
+				}
+			}
+		}
+#endif
+	}
+	return 0;
+}
+
+int sw6095_initialize(bd_t *bis)
+{
+	if (get_board_model() & 0x10) /* DISabled SW6095 */
+		return 0;
+
+	printf("Marvell 88E6095 switches are starting up ...\n");
+	if(sw6095_setup_const(bis) != 0) {
+		printf("Marvell 88E6095 switches Failed: Setup board constants Failed!!\n");
+		return -1;
+	}
+		
+	if(qdMultiDevStart() != GT_OK) {
+		printf("Marvell 88E6095 switches Failed: Init switch driver Failed!!\n");
+		return -1;
+	}
+
+	if(sw6095_setvlans(bis)!=0) {
+		printf("Marvell 88E6095 switches Failed: Set VLANs Failed!!\n");
+		return -1;
+	}
+	if(sw6095_startup(bis)!=0) {
+		printf("Marvell 88E6095 switches Failed: Startup switch chip Failed!!\n");
+		return -1;
+	}
+	printf("Marvell 88E6095 switches startup OK!!\n");
+	return 0;
+}
+
+#endif /* CONFIG_MV88E6095 */
diff -Naur u-boot-1.1.2/board/debmax/sw6095.h uboot-1.1.2hsv/board/debmax/sw6095.h
--- u-boot-1.1.2/board/debmax/sw6095.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/sw6095.h	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,51 @@
+/*
+ * Cyclades:
+ *   Support for Marvell's 88E6095 11-port switch chips for DEB board.
+ *
+ * Got from SOHO's msSample.h
+ * 
+ */
+
+#ifndef __SW6095_H__
+#define __SW6095_H__
+
+#include <common.h>
+#include <marvell/msApi.h>
+
+#ifndef MAX_NR_SWITCHES
+#define MAX_NR_SWITCHES 	5
+#endif
+
+#ifndef MAX_PORTS_PER_SWITCH
+#define MAX_PORTS_PER_SWITCH 	11
+#endif
+
+#define NR_FE_PER_SWITCH	8
+#define NR_GE_PER_SWITCH	(MAX_PORTS_PER_SWITCH - NR_FE_PER_SWITCH)
+
+#define MAX_NET_PORT_TOTAL	(NR_FE_PER_SWITCH * MAX_NR_SWITCHES)
+
+static inline int port_nr_to_sw_nr(int port_nr) {
+	if(port_nr>=MAX_NET_PORT_TOTAL || port_nr<0) return -1;
+	return (port_nr/NR_FE_PER_SWITCH);
+}
+
+static inline int port_nr_to_fe_nr(int port_nr) {
+	if(port_nr>=MAX_NET_PORT_TOTAL || port_nr<0) return -1;
+	return (port_nr%NR_FE_PER_SWITCH);
+}
+
+#define MSG_PRINT(x) printf x
+
+
+#undef USE_SEMAPHORE
+
+#ifdef USE_SEMAPHORE
+GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state);
+GT_STATUS osSemDelete(GT_SEM smid);
+GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut);
+GT_STATUS osSemSignal(GT_SEM smid);
+#endif
+
+
+#endif /* __SW6095_H__ */
diff -Naur u-boot-1.1.2/board/debmax/u-boot.lds uboot-1.1.2hsv/board/debmax/u-boot.lds
--- u-boot-1.1.2/board/debmax/u-boot.lds	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debmax/u-boot.lds	2007-05-29 16:51:13.000000000 -0500
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  .resetvec 0xFFFFFFFC :
+  {
+    *(.resetvec)
+  } = 0xffff
+
+  .bootpg 0xFFFFF000 :
+  {
+    cpu/mpc85xx/start.o	(.bootpg)
+    board/debmax/init.o (.bootpg)
+  } = 0xffff
+
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    cpu/mpc85xx/start.o	(.text)
+    board/debmax/init.o (.text)
+    cpu/mpc85xx/traps.o (.text)
+    cpu/mpc85xx/interrupts.o (.text)
+    cpu/mpc85xx/cpu_init.o (.text)
+    cpu/mpc85xx/cpu.o (.text)
+    cpu/mpc85xx/tsec.o (.text)
+    cpu/mpc85xx/speed.o (.text)
+    cpu/mpc85xx/pci.o (.text)
+    common/dlmalloc.o (.text)
+    lib_generic/crc32.o (.text)
+    lib_ppc/extable.o (.text)
+    lib_generic/zlib.o (.text)
+    *(.text)
+    *(.fixup)
+    *(.got1)
+   }
+    _etext = .;
+    PROVIDE (etext = .);
+    .rodata    :
+   {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >> 2;
+  __fixup_entries = (. - _FIXUP_TABLE_) >> 2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  _end = . ;
+  PROVIDE (end = .);
+}
diff -Naur u-boot-1.1.2/board/debv1/cadmus.c uboot-1.1.2hsv/board/debv1/cadmus.c
--- u-boot-1.1.2/board/debv1/cadmus.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/cadmus.c	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+
+
+/*
+ * CADMUS Board System Registers
+ */
+#ifndef CFG_CADMUS_BASE_REG
+#define CFG_CADMUS_BASE_REG	(CADMUS_BASE_ADDR + 0x4000)
+#endif
+
+typedef struct cadmus_reg {
+    u_char cm_ver;		/* Board version */
+    u_char cm_csr;		/* General control/status */
+    u_char cm_rst;		/* Reset control */
+    u_char cm_hsclk;		/* High speed clock */
+    u_char cm_hsxclk;		/* High speed clock extended */
+    u_char cm_led;		/* LED data */
+    u_char cm_pci;		/* PCI control/status */
+    u_char cm_dma;		/* DMA control */
+    u_char cm_reserved[248];	/* Total 256 bytes */
+} cadmus_reg_t;
+
+
+unsigned int
+get_board_version(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	return cadmus->cm_ver;
+}
+
+
+unsigned long
+get_clock_freq(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	uint pci1_speed = (cadmus->cm_pci >> 2) & 0x3; /* PSPEED in [4:5] */
+
+	if (pci1_speed == 0) {
+		return 33000000;
+	} else if (pci1_speed == 1) {
+		return 66000000;
+	} else {
+		/* Really, unknown. Be safe? */
+		return 33000000;
+	}
+}
+
+
+unsigned int
+get_pci_slot(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	/*
+	 * PCI slot in USER bits CSR[6:7] by convention.
+	 */
+	return ((cadmus->cm_csr >> 6) & 0x3) + 1;
+}
+
+
+unsigned int
+get_pci_dual(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	/*
+	 * PCI DUAL in CM_PCI[3]
+	 */
+	return cadmus->cm_pci & 0x10;
+}
diff -Naur u-boot-1.1.2/board/debv1/cadmus.h uboot-1.1.2hsv/board/debv1/cadmus.h
--- u-boot-1.1.2/board/debv1/cadmus.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/cadmus.h	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CADMUS_H_
+#define __CADMUS_H_
+
+
+/*
+ * CADMUS Board System Register interface.
+ */
+
+/*
+ * Returns board version register.
+ */
+extern unsigned int get_board_version(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the SYS_CLK_FREQ.
+ */
+extern unsigned long get_clock_freq(void);
+
+
+/*
+ * Returns 1 - 4, as found in the USER CSR[6:7] bits.
+ */
+extern unsigned int get_pci_slot(void);
+
+
+/*
+ * Returns PCI DUAL as found in CM_PCI[3].
+ */
+extern unsigned int get_pci_dual(void);
+
+
+#endif	/* __CADMUS_H_ */
diff -Naur u-boot-1.1.2/board/debv1/config.mk uboot-1.1.2hsv/board/debv1/config.mk
--- u-boot-1.1.2/board/debv1/config.mk	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/config.mk	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,30 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# mpc8555cds board
+#
+TEXT_BASE = 0xfff80000
+
+PLATFORM_CPPFLAGS += -DCONFIG_E500=1
+PLATFORM_CPPFLAGS += -DCONFIG_MPC85xx=1
+PLATFORM_CPPFLAGS += -DCONFIG_MPC8555=1
diff -Naur u-boot-1.1.2/board/debv1/debv1.c uboot-1.1.2hsv/board/debv1/debv1.c
--- u-boot-1.1.2/board/debv1/debv1.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/debv1.c	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,346 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <spd.h>
+
+#include "cadmus.h"
+#include "eeprom.h"
+
+#if defined(CONFIG_DDR_ECC)
+extern void ddr_enable_ecc(unsigned int dram_size);
+#endif
+
+extern long int spd_sdram(void);
+
+void local_bus_init(void);
+void sdram_init(void);
+
+int board_early_init_f (void)
+{
+	return 0;
+}
+
+int checkboard (void)
+{
+	volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+
+	/* PCI slot in USER bits CSR[6:7] by convention. */
+	uint pci_slot = get_pci_slot ();
+
+	uint pci_dual = get_pci_dual ();	/* PCI DUAL in CM_PCI[3] */
+	uint pci1_32 = gur->pordevsr & 0x10000;	/* PORDEVSR[15] */
+	uint pci1_clk_sel = gur->porpllsr & 0x8000;	/* PORPLLSR[16] */
+	uint pci2_clk_sel = gur->porpllsr & 0x4000;	/* PORPLLSR[17] */
+
+	uint pci1_speed = get_clock_freq ();	/* PCI PSPEED in [4:5] */
+
+	uint cpu_board_rev = get_cpu_board_revision ();
+
+	printf ("Board: CDS Version 0x%02x, PCI Slot %d\n",
+		get_board_version (), pci_slot);
+
+	printf ("CPU Board Revision %d.%d (0x%04x)\n",
+		MPC85XX_CPU_BOARD_MAJOR (cpu_board_rev),
+		MPC85XX_CPU_BOARD_MINOR (cpu_board_rev), cpu_board_rev);
+
+	printf ("    PCI1: %d bit, %s MHz, %s\n",
+		(pci1_32) ? 32 : 64,
+		(pci1_speed == 33000000) ? "33" :
+		(pci1_speed == 66000000) ? "66" : "unknown",
+		pci1_clk_sel ? "sync" : "async");
+
+	if (pci_dual) {
+		printf ("    PCI2: 32 bit, 66 MHz, %s\n",
+			pci2_clk_sel ? "sync" : "async");
+	} else {
+		printf ("    PCI2: disabled\n");
+	}
+
+	/*
+	 * Initialize local bus.
+	 */
+	local_bus_init ();
+
+	return 0;
+}
+
+long int
+initdram(int board_type)
+{
+	long dram_size = 0;
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+
+	puts("Initializing\n");
+
+#if defined(CONFIG_DDR_DLL)
+	{
+		/*
+		 * Work around to stabilize DDR DLL MSYNC_IN.
+		 * Errata DDR9 seems to have been fixed.
+		 * This is now the workaround for Errata DDR11:
+		 *    Override DLL = 1, Course Adj = 1, Tap Select = 0
+		 */
+
+		volatile ccsr_gur_t *gur= &immap->im_gur;
+
+		gur->ddrdllcr = 0x81000000;
+		asm("sync;isync;msync");
+		udelay(200);
+	}
+#endif
+	dram_size = spd_sdram();
+
+#if defined(CONFIG_DDR_ECC)
+	/*
+	 * Initialize and enable DDR ECC.
+	 */
+	ddr_enable_ecc(dram_size);
+#endif
+	/*
+	 * SDRAM Initialization
+	 */
+	sdram_init();
+
+	puts("    DDR: ");
+	return dram_size;
+}
+
+/*
+ * Initialize Local Bus
+ */
+void
+local_bus_init(void)
+{
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+
+	uint clkdiv;
+	uint lbc_hz;
+	sys_info_t sysinfo;
+	uint temp_lbcdll;
+
+	/*
+	 * Errata LBC11.
+	 * Fix Local Bus clock glitch when DLL is enabled.
+	 *
+	 * If localbus freq is < 66Mhz, DLL bypass mode must be used.
+	 * If localbus freq is > 133Mhz, DLL can be safely enabled.
+	 * Between 66 and 133, the DLL is enabled with an override workaround.
+	 */
+
+	get_sys_info(&sysinfo);
+	clkdiv = lbc->lcrr & 0x0f;
+	lbc_hz = sysinfo.freqSystemBus / 1000000 / clkdiv;
+
+	if (lbc_hz < 66) {
+		lbc->lcrr |= 0x80000000;	/* DLL Bypass */
+
+	} else if (lbc_hz >= 133) {
+		lbc->lcrr &= (~0x80000000);		/* DLL Enabled */
+
+	} else {
+		lbc->lcrr &= (~0x8000000);	/* DLL Enabled */
+		udelay(200);
+
+		/*
+		 * Sample LBC DLL ctrl reg, upshift it to set the
+		 * override bits.
+		 */
+		temp_lbcdll = gur->lbcdllcr;
+		gur->lbcdllcr = (((temp_lbcdll & 0xff) << 16) | 0x80000000);
+		asm("sync;isync;msync");
+	}
+}
+
+/*
+ * Initialize SDRAM memory on the Local Bus.
+ */
+void
+sdram_init(void)
+{
+#if defined(CFG_OR2_PRELIM) && defined(CFG_BR2_PRELIM)
+
+	uint idx;
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+	uint *sdram_addr = (uint *)CFG_LBC_SDRAM_BASE;
+	uint cpu_board_rev;
+	uint lsdmr_common;
+
+	puts("    SDRAM: ");
+
+	print_size (CFG_LBC_SDRAM_SIZE * 1024 * 1024, "\n");
+
+	/*
+	 * Setup SDRAM Base and Option Registers
+	 */
+	lbc->or2 = CFG_OR2_PRELIM;
+	asm("msync");
+
+	lbc->br2 = CFG_BR2_PRELIM;
+	asm("msync");
+
+	lbc->lbcr = CFG_LBC_LBCR;
+	asm("msync");
+
+	lbc->lsrt = CFG_LBC_LSRT;
+	lbc->mrtpr = CFG_LBC_MRTPR;
+	asm("msync");
+
+	/*
+	 * Determine which address lines to use baed on CPU board rev.
+	 */
+	cpu_board_rev = get_cpu_board_revision();
+	lsdmr_common = CFG_LBC_LSDMR_COMMON;
+	if (cpu_board_rev == MPC85XX_CPU_BOARD_REV_1_0) {
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1617;
+	} else if (cpu_board_rev == MPC85XX_CPU_BOARD_REV_1_1) {
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1516;
+	} else {
+		/*
+		 * Assume something unable to identify itself is
+		 * really old, and likely has lines 16/17 mapped.
+		 */
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1617;
+	}
+
+	/*
+	 * Issue PRECHARGE ALL command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_PCHALL;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(100);
+
+	/*
+	 * Issue 8 AUTO REFRESH commands.
+	 */
+	for (idx = 0; idx < 8; idx++) {
+		lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_ARFRSH;
+		asm("sync;msync");
+		*sdram_addr = 0xff;
+		ppcDcbf((unsigned long) sdram_addr);
+		udelay(100);
+	}
+
+	/*
+	 * Issue 8 MODE-set command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_MRW;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(100);
+
+	/*
+	 * Issue NORMAL OP command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_NORMAL;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(200);    /* Overkill. Must wait > 200 bus cycles */
+
+#endif	/* enable SDRAM init */
+}
+
+#if defined(CFG_DRAM_TEST)
+int
+testdram(void)
+{
+	uint *pstart = (uint *) CFG_MEMTEST_START;
+	uint *pend = (uint *) CFG_MEMTEST_END;
+	uint *p;
+
+	printf("Testing DRAM from 0x%08x to 0x%08x\n",
+	       CFG_MEMTEST_START,
+	       CFG_MEMTEST_END);
+
+	printf("DRAM test phase 1:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0xaaaaaaaa;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0xaaaaaaaa) {
+			printf ("DRAM test fails at: %08x\n", (uint) p);
+			return 1;
+		}
+	}
+
+	printf("DRAM test phase 2:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0x55555555;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0x55555555) {
+			printf ("DRAM test fails at: %08x\n", (uint) p);
+			return 1;
+		}
+	}
+
+	printf("DRAM test passed.\n");
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_PCI)
+
+/*
+ * Initialize PCI Devices, report devices found.
+ */
+
+#ifndef CONFIG_PCI_PNP
+static struct pci_config_table pci_mpc85xxcds_config_table[] = {
+    { PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+      PCI_IDSEL_NUMBER, PCI_ANY_ID,
+      pci_cfgfunc_config_device, { PCI_ENET0_IOADDR,
+				   PCI_ENET0_MEMADDR,
+				   PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER
+      } },
+    { }
+};
+#endif
+
+static struct pci_controller hose = {
+#ifndef CONFIG_PCI_PNP
+	config_table: pci_mpc85xxcds_config_table,
+#endif
+};
+
+#endif	/* CONFIG_PCI */
+
+void
+pci_init_board(void)
+{
+#ifdef CONFIG_PCI
+	extern void pci_mpc85xx_init(struct pci_controller *hose);
+
+	pci_mpc85xx_init(&hose);
+#endif
+}
diff -Naur u-boot-1.1.2/board/debv1/eeprom.c uboot-1.1.2hsv/board/debv1/eeprom.c
--- u-boot-1.1.2/board/debv1/eeprom.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/eeprom.c	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+#include <i2c.h>
+
+#include "eeprom.h"
+
+
+typedef struct {
+	char idee_pcbid[4];		/* "CCID" for CDC v1.X */
+	u8 idee_major;
+	u8 idee_minor;
+	char idee_serial[10];
+	char idee_errata[2];
+	char idee_date[8];		/* yyyymmdd */
+	/* The rest of the EEPROM space is reserved */
+} id_eeprom_t;
+
+
+unsigned int
+get_cpu_board_revision(void)
+{
+	uint major = 0;
+	uint minor = 0;
+
+	id_eeprom_t id_eeprom;
+
+	i2c_read(CFG_I2C_EEPROM_ADDR, 0, 2,
+		 (uchar *) &id_eeprom, sizeof(id_eeprom));
+
+	major = id_eeprom.idee_major;
+	minor = id_eeprom.idee_minor;
+
+	if (major == 0xff && minor == 0xff) {
+		major = minor = 0;
+	}
+
+	return MPC85XX_CPU_BOARD_REV(major,minor);
+}
diff -Naur u-boot-1.1.2/board/debv1/eeprom.h uboot-1.1.2hsv/board/debv1/eeprom.h
--- u-boot-1.1.2/board/debv1/eeprom.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/eeprom.h	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EEPROM_H_
+#define __EEPROM_H_
+
+
+/*
+ * EEPROM Board System Register interface.
+ */
+
+
+/*
+ * CPU Board Revision
+ */
+#define MPC85XX_CPU_BOARD_REV(maj, min)	((((maj)&0xff) << 8) | ((min) & 0xff))
+#define MPC85XX_CPU_BOARD_MAJOR(rev)	(((rev) >> 8) & 0xff)
+#define MPC85XX_CPU_BOARD_MINOR(rev)	((rev) & 0xff)
+
+#define MPC85XX_CPU_BOARD_REV_UNKNOWN	MPC85XX_CPU_BOARD_REV(0,0)
+#define MPC85XX_CPU_BOARD_REV_1_0	MPC85XX_CPU_BOARD_REV(1,0)
+#define MPC85XX_CPU_BOARD_REV_1_1	MPC85XX_CPU_BOARD_REV(1,1)
+
+/*
+ * Returns CPU board revision register as a 16-bit value with
+ * the Major in the high byte, and Minor in the low byte.
+ */
+extern unsigned int get_cpu_board_revision(void);
+
+
+#endif	/* __CADMUS_H_ */
diff -Naur u-boot-1.1.2/board/debv1/init.S uboot-1.1.2hsv/board/debv1/init.S
--- u-boot-1.1.2/board/debv1/init.S	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/init.S	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,255 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ * Copyright 2002,2003, Motorola Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <ppc_asm.tmpl>
+#include <ppc_defs.h>
+#include <asm/cache.h>
+#include <asm/mmu.h>
+#include <config.h>
+#include <mpc85xx.h>
+
+
+/*
+ * TLB0 and TLB1 Entries
+ *
+ * Out of reset, TLB1's Entry 0 maps the highest 4K for CCSRBAR.
+ * However, CCSRBAR is then relocated to CFG_CCSRBAR right after
+ * these TLB entries are established.
+ *
+ * The TLB entries for DDR are dynamically setup in spd_sdram()
+ * and use TLB1 Entries 8 through 15 as needed according to the
+ * size of DDR memory.
+ *
+ * MAS0: tlbsel, esel, nv
+ * MAS1: valid, iprot, tid, ts, tsize
+ * MAS2: epn, sharen, x0, x1, w, i, m, g, e
+ * MAS3: rpn, u0-u3, ux, sx, uw, sw, ur, sr
+ */
+
+#define	entry_start \
+	mflr	r1 	;	\
+	bl	0f 	;
+
+#define	entry_end \
+0:	mflr	r0	;	\
+	mtlr	r1	;	\
+	blr		;
+
+
+	.section	.bootpg, "ax"
+	.globl	tlb1_entry
+tlb1_entry:
+	entry_start
+
+	/*
+	 * Number of TLB0 and TLB1 entries in the following table
+	 */
+	.long 13
+
+#if (CFG_CCSRBAR_DEFAULT != CFG_CCSRBAR)
+	/*
+	 * TLB0		4K	Non-cacheable, guarded
+	 * 0xff700000	4K	Initial CCSRBAR mapping
+	 *
+	 * This ends up at a TLB0 Index==0 entry, and must not collide
+	 * with other TLB0 Entries.
+	 */
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_CCSRBAR_DEFAULT), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_CCSRBAR_DEFAULT), 0,0,0,0,0,1,0,1,0,1)
+#else
+#error("Update the number of table entries in tlb1_entry")
+#endif
+
+	/*
+	 * TLB0		16K	Cacheable, non-guarded
+	 * 0xd001_0000	16K	Temporary Global data for initialization
+	 *
+	 * Use four 4K TLB0 entries.  These entries must be cacheable
+	 * as they provide the bootstrap memory before the memory
+	 * controler and real memory have been configured.
+	 *
+	 * These entries end up at TLB0 Indicies 0x10, 0x14, 0x18 and 0x1c,
+	 * and must not collide with other TLB0 entries.
+	 */
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 4 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 4 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 8 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 8 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 12 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 12 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+
+	/*
+	 * TLB 0:	16M	Non-cacheable, guarded
+	 * 0xff000000	16M	FLASH
+	 * Out of reset this entry is only 4K.
+	 */
+	.long TLB1_MAS0(1, 0, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_16M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_FLASH_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_FLASH_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB 1:	256M	Non-cacheable, guarded
+	 * 0x80000000	256M	PCI1 MEM First half
+	 */
+	.long TLB1_MAS0(1, 1, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI1_MEM_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI1_MEM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB 2:	256M	Non-cacheable, guarded
+	 * 0x90000000	256M	PCI1 MEM Second half
+	 */
+	.long TLB1_MAS0(1, 2, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI1_MEM_BASE + 0x10000000),
+			0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI1_MEM_BASE + 0x10000000),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB 3:	256M	Non-cacheable, guarded
+	 * 0xa0000000	256M	PCI2 MEM First half
+	 */
+	.long TLB1_MAS0(1, 3, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI2_MEM_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI2_MEM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB 4:	256M	Non-cacheable, guarded
+	 * 0xb0000000	256M	PCI2 MEM Second half
+	 */
+	.long TLB1_MAS0(1, 4, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI2_MEM_BASE + 0x10000000),
+			0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI2_MEM_BASE + 0x10000000),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB 5:	64M	Non-cacheable, guarded
+	 * 0xe000_0000	1M	CCSRBAR
+	 * 0xe200_0000	16M	PCI1 IO
+	 * 0xe300_0000	16M	PCI2 IO
+	 */
+	.long TLB1_MAS0(1, 5, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_64M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_CCSRBAR), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_CCSRBAR), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB 6:	64M	Cacheable, non-guarded
+	 * 0xf000_0000	64M	LBC SDRAM
+	 */
+	.long TLB1_MAS0(1, 6, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_64M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_LBC_SDRAM_BASE), 0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_LBC_SDRAM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB 7:	1M	Non-cacheable, guarded
+	 * 0xf8000000	1M	CADMUS registers
+	 */
+	.long TLB1_MAS0(1, 7, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_1M)
+	.long TLB1_MAS2(E500_TLB_EPN(CADMUS_BASE_ADDR), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CADMUS_BASE_ADDR), 0,0,0,0,0,1,0,1,0,1)
+
+	entry_end
+
+/*
+ * LAW(Local Access Window) configuration:
+ *
+ * 0x0000_0000     0x7fff_ffff     DDR                     2G
+ * 0x8000_0000     0x9fff_ffff     PCI1 MEM                512M
+ * 0xa000_0000     0xbfff_ffff     PCI2 MEM                512M
+ * 0xe000_0000     0xe000_ffff     CCSR                    1M
+ * 0xe200_0000     0xe2ff_ffff     PCI1 IO                 16M
+ * 0xe300_0000     0xe3ff_ffff     PCI2 IO                 16M
+ * 0xf000_0000     0xf7ff_ffff     SDRAM                   128M
+ * 0xf800_0000     0xf80f_ffff     NVRAM/CADMUS (*)        1M
+ * 0xff00_0000     0xff7f_ffff     FLASH (2nd bank)        8M
+ * 0xff80_0000     0xffff_ffff     FLASH (boot bank)       8M
+ *
+ * Notes:
+ *    CCSRBAR and L2-as-SRAM don't need a configured Local Access Window.
+ *    If flash is 8M at default position (last 8M), no LAW needed.
+ *
+ * The defines below are 1-off of the actual LAWAR0 usage.
+ * So LAWAR3 define uses the LAWAR4 register in the ECM.
+ */
+
+#define LAWBAR0 0
+#define LAWAR0  ((LAWAR_TRGT_IF_DDR | (LAWAR_SIZE & LAWAR_SIZE_128M)) & ~LAWAR_EN)
+
+#define LAWBAR1 ((CFG_PCI1_MEM_BASE>>12) & 0xfffff)
+#define LAWAR1 	(LAWAR_EN | LAWAR_TRGT_IF_PCI1 | (LAWAR_SIZE & LAWAR_SIZE_512M))
+
+#define LAWBAR2 ((CFG_PCI2_MEM_BASE>>12) & 0xfffff)
+#define LAWAR2 	(LAWAR_EN | LAWAR_TRGT_IF_PCI2 | (LAWAR_SIZE & LAWAR_SIZE_512M))
+
+#define LAWBAR3 ((CFG_PCI1_IO_BASE>>12) & 0xfffff)
+#define LAWAR3 	(LAWAR_EN | LAWAR_TRGT_IF_PCI1 | (LAWAR_SIZE & LAWAR_SIZE_16M))
+
+#define LAWBAR4 ((CFG_PCI2_IO_BASE>>12) & 0xfffff)
+#define LAWAR4 	(LAWAR_EN | LAWAR_TRGT_IF_PCI2 | (LAWAR_SIZE & LAWAR_SIZE_16M))
+
+/* LBC window - maps 256M 0xf0000000 -> 0xffffffff */
+#define LAWBAR5 ((CFG_LBC_SDRAM_BASE>>12) & 0xfffff)
+#define LAWAR5 	(LAWAR_EN | LAWAR_TRGT_IF_LBC | (LAWAR_SIZE & LAWAR_SIZE_256M))
+
+	.section .bootpg, "ax"
+	.globl	law_entry
+
+law_entry:
+	entry_start
+	.long 6
+	.long LAWBAR0,LAWAR0,LAWBAR1,LAWAR1,LAWBAR2,LAWAR2,LAWBAR3,LAWAR3
+	.long LAWBAR4,LAWAR4,LAWBAR5,LAWAR5
+	entry_end
diff -Naur u-boot-1.1.2/board/debv1/Makefile uboot-1.1.2hsv/board/debv1/Makefile
--- u-boot-1.1.2/board/debv1/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/Makefile	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,51 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+# (C) Copyright 2001
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= $(BOARD).o \
+	   cadmus.o \
+	   eeprom.o
+
+SOBJS	:= init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Naur u-boot-1.1.2/board/debv1/u-boot.lds uboot-1.1.2hsv/board/debv1/u-boot.lds
--- u-boot-1.1.2/board/debv1/u-boot.lds	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/debv1/u-boot.lds	2007-05-29 16:51:21.000000000 -0500
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  .resetvec 0xFFFFFFFC :
+  {
+    *(.resetvec)
+  } = 0xffff
+
+  .bootpg 0xFFFFF000 :
+  {
+    cpu/mpc85xx/start.o	(.bootpg)
+    board/debv1/init.o (.bootpg)
+  } = 0xffff
+
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    cpu/mpc85xx/start.o	(.text)
+    board/debv1/init.o (.text)
+    cpu/mpc85xx/traps.o (.text)
+    cpu/mpc85xx/interrupts.o (.text)
+    cpu/mpc85xx/cpu_init.o (.text)
+    cpu/mpc85xx/cpu.o (.text)
+    cpu/mpc85xx/tsec.o (.text)
+    cpu/mpc85xx/speed.o (.text)
+    cpu/mpc85xx/pci.o (.text)
+    common/dlmalloc.o (.text)
+    lib_generic/crc32.o (.text)
+    lib_ppc/extable.o (.text)
+    lib_generic/zlib.o (.text)
+    *(.text)
+    *(.fixup)
+    *(.got1)
+   }
+    _etext = .;
+    PROVIDE (etext = .);
+    .rodata    :
+   {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >> 2;
+  __fixup_entries = (. - _FIXUP_TABLE_) >> 2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  _end = . ;
+  PROVIDE (end = .);
+}
diff -Naur u-boot-1.1.2/board/gth/ee_dev.h uboot-1.1.2hsv/board/gth/ee_dev.h
--- u-boot-1.1.2/board/gth/ee_dev.h	2002-03-08 15:31:06.000000000 -0600
+++ uboot-1.1.2hsv/board/gth/ee_dev.h	2007-05-29 16:51:11.000000000 -0500
@@ -1,5 +1,5 @@
 /* By Thomas.Lange@Corelatus.com 001025
-   $Revision: 1.6 $
+   $Revision: 1.1.1.1 $
 
    Definitions for EEPROM/VOLT METER  DS2438
    Copyright (C) 2000-2001 Corelatus AB */
diff -Naur u-boot-1.1.2/board/jse/host_bridge.c uboot-1.1.2hsv/board/jse/host_bridge.c
--- u-boot-1.1.2/board/jse/host_bridge.c	2004-12-31 03:32:50.000000000 -0600
+++ uboot-1.1.2hsv/board/jse/host_bridge.c	2007-05-29 16:51:03.000000000 -0500
@@ -17,7 +17,7 @@
  *    along with this program; if not, write to the Free Software
  *    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
-#ident "$Id:$"
+#ident "$Id: host_bridge.c,v 1.1.1.1 2005/02/05 03:15:30 yang Exp $"
 
 # include  <common.h>
 # include  <pci.h>
diff -Naur u-boot-1.1.2/board/kvmmaxv1/bdparam.c uboot-1.1.2hsv/board/kvmmaxv1/bdparam.c
--- u-boot-1.1.2/board/kvmmaxv1/bdparam.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/bdparam.c	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+/**
+   cyclades: this src file bdparam.c is to replace cadmus.c to supply
+   some board info. the following functions are provided:
+
+   unsigned int get_board_version(void);
+   unsigned long get_clock_freq(void);
+   unsigned int get_pci_dual(void);
+   unsigned int get_pci_slot(void);
+   unsigned long get_pci1_clock_freq(void);
+   unsigned long get_pci2_clock_freq(void);
+   
+   */
+#include <common.h>
+
+
+
+unsigned int
+get_board_version(void)
+{
+  return 1;
+}
+
+
+unsigned long
+get_clock_freq(void)
+{
+  return 66666666;		/* SYS_CLK_FREQ is set 66MHZ */
+}
+
+
+/* in KVMMAXV1 board, PCI1 use PCI1_CLK instead of SYS_CLK_FREQ */
+unsigned long
+get_pci1_clock_freq(void)
+{
+  return 33000000;		/* PCI1_CLK is set 33MHZ */
+}
+
+/* in KVMMAXV1 board, PCI2 use PCI2_CLK instead of SYS_CLK_FREQ */
+unsigned long
+get_pci2_clock_freq(void)
+{
+  return 33000000;		/* PCI2_CLK is set 33MHZ */
+}
+
+
+unsigned int
+get_pci_slot(void)
+{
+  return 1;
+}
+
+
+unsigned int
+get_pci_dual(void)
+{
+  return 1;			/* use both PCI1 and PCI2 */
+}
diff -Naur u-boot-1.1.2/board/kvmmaxv1/bdparam.h uboot-1.1.2hsv/board/kvmmaxv1/bdparam.h
--- u-boot-1.1.2/board/kvmmaxv1/bdparam.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/bdparam.h	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+   cyclades: use bdparam.h to replace cadmus.h
+    */
+#ifndef __BDPARAM_H_
+#define __BDPARAM_H_
+
+
+/*
+ * KVMMAXV1 Board System Register interface.
+ */
+
+/*
+ * Returns board version register.
+ */
+extern unsigned int get_board_version(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the SYS_CLK_FREQ.
+ */
+extern unsigned long get_clock_freq(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the PCI1_CLK_FREQ
+ */
+extern unsigned long get_pci1_clock_freq(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the PCI1_CLK_FREQ
+ */
+extern unsigned long get_pci2_clock_freq(void);
+
+
+/*
+ * Returns 1 - 4, as found in the USER CSR[6:7] bits.
+ */
+extern unsigned int get_pci_slot(void);
+
+
+/*
+ * Returns PCI DUAL as found in CM_PCI[3].
+ */
+extern unsigned int get_pci_dual(void);
+
+
+#endif	/* __BDPARAM_H_ */
diff -Naur u-boot-1.1.2/board/kvmmaxv1/cadmus.c uboot-1.1.2hsv/board/kvmmaxv1/cadmus.c
--- u-boot-1.1.2/board/kvmmaxv1/cadmus.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/cadmus.c	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+
+
+/*
+ * CADMUS Board System Registers
+ */
+#ifndef CFG_CADMUS_BASE_REG
+#define CFG_CADMUS_BASE_REG	(CADMUS_BASE_ADDR + 0x4000)
+#endif
+
+typedef struct cadmus_reg {
+    u_char cm_ver;		/* Board version */
+    u_char cm_csr;		/* General control/status */
+    u_char cm_rst;		/* Reset control */
+    u_char cm_hsclk;		/* High speed clock */
+    u_char cm_hsxclk;		/* High speed clock extended */
+    u_char cm_led;		/* LED data */
+    u_char cm_pci;		/* PCI control/status */
+    u_char cm_dma;		/* DMA control */
+    u_char cm_reserved[248];	/* Total 256 bytes */
+} cadmus_reg_t;
+
+
+unsigned int
+get_board_version(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	return cadmus->cm_ver;
+}
+
+
+unsigned long
+get_clock_freq(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	uint pci1_speed = (cadmus->cm_pci >> 2) & 0x3; /* PSPEED in [4:5] */
+
+	if (pci1_speed == 0) {
+		return 33000000;
+	} else if (pci1_speed == 1) {
+		return 66000000;
+	} else {
+		/* Really, unknown. Be safe? */
+		return 33000000;
+	}
+}
+
+
+unsigned int
+get_pci_slot(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	/*
+	 * PCI slot in USER bits CSR[6:7] by convention.
+	 */
+	return ((cadmus->cm_csr >> 6) & 0x3) + 1;
+}
+
+
+unsigned int
+get_pci_dual(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_CADMUS_BASE_REG;
+
+	/*
+	 * PCI DUAL in CM_PCI[3]
+	 */
+	return cadmus->cm_pci & 0x10;
+}
diff -Naur u-boot-1.1.2/board/kvmmaxv1/cadmus.h uboot-1.1.2hsv/board/kvmmaxv1/cadmus.h
--- u-boot-1.1.2/board/kvmmaxv1/cadmus.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/cadmus.h	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CADMUS_H_
+#define __CADMUS_H_
+
+
+/*
+ * CADMUS Board System Register interface.
+ */
+
+/*
+ * Returns board version register.
+ */
+extern unsigned int get_board_version(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the SYS_CLK_FREQ.
+ */
+extern unsigned long get_clock_freq(void);
+
+
+/*
+ * Returns 1 - 4, as found in the USER CSR[6:7] bits.
+ */
+extern unsigned int get_pci_slot(void);
+
+
+/*
+ * Returns PCI DUAL as found in CM_PCI[3].
+ */
+extern unsigned int get_pci_dual(void);
+
+
+#endif	/* __CADMUS_H_ */
diff -Naur u-boot-1.1.2/board/kvmmaxv1/config.mk uboot-1.1.2hsv/board/kvmmaxv1/config.mk
--- u-boot-1.1.2/board/kvmmaxv1/config.mk	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/config.mk	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,30 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# mpc8555cds board
+#
+TEXT_BASE = 0xfff80000
+
+PLATFORM_CPPFLAGS += -DCONFIG_E500=1
+PLATFORM_CPPFLAGS += -DCONFIG_MPC85xx=1
+PLATFORM_CPPFLAGS += -DCONFIG_MPC8555=1
diff -Naur u-boot-1.1.2/board/kvmmaxv1/eeprom.c uboot-1.1.2hsv/board/kvmmaxv1/eeprom.c
--- u-boot-1.1.2/board/kvmmaxv1/eeprom.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/eeprom.c	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+#include <i2c.h>
+
+#include "eeprom.h"
+
+
+typedef struct {
+	char idee_pcbid[4];		/* "CCID" for CDC v1.X */
+	u8 idee_major;
+	u8 idee_minor;
+	char idee_serial[10];
+	char idee_errata[2];
+	char idee_date[8];		/* yyyymmdd */
+	/* The rest of the EEPROM space is reserved */
+} id_eeprom_t;
+
+
+
+/*
+   cyclades: we don't use eeprom to save cpu board rev. use FPGA instead.
+   TODO:
+   */
+unsigned int
+get_cpu_board_revision(void)
+{
+	uint major = 0;
+	uint minor = 0;
+
+/* 	id_eeprom_t id_eeprom; */
+
+/* 	i2c_read(CFG_I2C_EEPROM_ADDR, 0, 2, */
+/* 		 (uchar *) &id_eeprom, sizeof(id_eeprom)); */
+
+/* 	major = id_eeprom.idee_major; */
+/* 	minor = id_eeprom.idee_minor; */
+
+/* 	if (major == 0xff && minor == 0xff) { */
+/* 		major = minor = 0; */
+/* 	} */
+
+	return MPC85XX_CPU_BOARD_REV(major,minor);
+}
diff -Naur u-boot-1.1.2/board/kvmmaxv1/eeprom.h uboot-1.1.2hsv/board/kvmmaxv1/eeprom.h
--- u-boot-1.1.2/board/kvmmaxv1/eeprom.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/eeprom.h	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EEPROM_H_
+#define __EEPROM_H_
+
+
+/*
+ * EEPROM Board System Register interface.
+ */
+
+
+/*
+ * CPU Board Revision
+ */
+#define MPC85XX_CPU_BOARD_REV(maj, min)	((((maj)&0xff) << 8) | ((min) & 0xff))
+#define MPC85XX_CPU_BOARD_MAJOR(rev)	(((rev) >> 8) & 0xff)
+#define MPC85XX_CPU_BOARD_MINOR(rev)	((rev) & 0xff)
+
+#define MPC85XX_CPU_BOARD_REV_UNKNOWN	MPC85XX_CPU_BOARD_REV(0,0)
+#define MPC85XX_CPU_BOARD_REV_1_0	MPC85XX_CPU_BOARD_REV(1,0)
+#define MPC85XX_CPU_BOARD_REV_1_1	MPC85XX_CPU_BOARD_REV(1,1)
+
+/*
+ * Returns CPU board revision register as a 16-bit value with
+ * the Major in the high byte, and Minor in the low byte.
+ */
+extern unsigned int get_cpu_board_revision(void);
+
+
+#endif	/* __CADMUS_H_ */
diff -Naur u-boot-1.1.2/board/kvmmaxv1/init.S uboot-1.1.2hsv/board/kvmmaxv1/init.S
--- u-boot-1.1.2/board/kvmmaxv1/init.S	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/init.S	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,292 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ * Copyright 2002,2003, Motorola Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * kvmmaxv1 board init.S
+ *
+ * modified by Yang Yang, Cyclades Corp.
+ * changed parts are prepended with "cyclades"
+ * 2/14/05
+ *
+ */
+	
+#include <ppc_asm.tmpl>
+#include <ppc_defs.h>
+#include <asm/cache.h>
+#include <asm/mmu.h>
+#include <config.h>
+#include <mpc85xx.h>
+
+
+/*
+ * TLB0 and TLB1 Entries
+ *
+ * Out of reset, TLB1's Entry 0 maps the highest 4K for CCSRBAR.
+ * However, CCSRBAR is then relocated to CFG_CCSRBAR right after
+ * these TLB entries are established.
+ *
+ * The TLB entries for DDR are dynamically setup in spd_sdram()
+ * and use TLB1 Entries 8 through 15 as needed according to the
+ * size of DDR memory.
+ *
+ * MAS0: tlbsel, esel, nv
+ * MAS1: valid, iprot, tid, ts, tsize
+ * MAS2: epn, sharen, x0, x1, w, i, m, g, e
+ * MAS3: rpn, u0-u3, ux, sx, uw, sw, ur, sr
+ */
+
+#define	entry_start \
+	mflr	r1 	;	\
+	bl	0f 	;
+
+#define	entry_end \
+0:	mflr	r0	;	\
+	mtlr	r1	;	\
+	blr		;
+
+
+	.section	.bootpg, "ax"
+	.globl	tlb1_entry
+tlb1_entry:
+	entry_start
+
+	/*
+	 * Number of TLB0 and TLB1 entries in the following table
+	 */
+	/**
+	 * cyclades: change TLB entry number 13 to real # entries
+	 * 5 TLB0 + 8 TLB1 = 13 entries
+	 */
+ 	.long 13
+
+#if (CFG_CCSRBAR_DEFAULT != CFG_CCSRBAR)
+	/*
+	 * TLB0		4K	Non-cacheable, guarded
+	 * 0xff700000	4K	Initial CCSRBAR mapping
+	 *
+	 * This ends up at a TLB0 Index==0 entry, and must not collide
+	 * with other TLB0 Entries.
+	 */
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_CCSRBAR_DEFAULT), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_CCSRBAR_DEFAULT), 0,0,0,0,0,1,0,1,0,1)
+#else
+#error("Update the number of table entries in tlb1_entry")
+#endif
+
+	/*
+	 * TLB0		16K	Cacheable, non-guarded
+	 * cyclades:	CFG_INIT_RAM_ADDR, 0xe401_0000 16K 0xe401_4000
+	 * 0xe401_0000	16K	Temporary Global data for initialization
+	 *			use L1 D-cache (32KB) for this.
+	 * 
+	 * Use four 4K TLB0 entries.  These entries must be cacheable
+	 * as they provide the bootstrap memory before the memory
+	 * controler and real memory have been configured.
+	 *
+	 * cyclades:	end up at TLB0 indices 0x10, 0x11, 0x12, 0x13
+	 * These entries end up at TLB0 Indicies 0x10, 0x11, 0x12, 0x13
+	 * and must not collide with other TLB0 entries.
+	 */
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 4 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 4 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 8 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 8 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	.long TLB1_MAS0(0, 0, 0)
+	.long TLB1_MAS1(1, 0, 0, 0, 0)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_INIT_RAM_ADDR + 12 * 1024),
+			0,0,0,0,0,0,0,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_INIT_RAM_ADDR + 12 * 1024),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/**
+	 * cyclades: Flash size is 8M,
+	 * no tsize can be exactly 8M, should we have two 4M size TLB entries?
+	 */
+	/*
+	 * DO NOT use entry 0, seems it caused core crash!!!
+	 * TLB1 entry 15:4M	Non-cacheable, guarded
+	 * 0xff800000	4M	FLASH first half
+	 * Out of reset this entry is only 4K.
+	 *
+	 * second half 4M will be assigned at TLB1 entry 6
+	 */
+	.long TLB1_MAS0(1, 15, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_4M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_FLASH_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_FLASH_BASE), 0,0,0,0,0,1,0,1,0,1)
+	
+	/*
+	 * TLB1 entry 1:256M	Non-cacheable, guarded
+	 * 0x80000000	256M	PCI1 MEM First half
+	 */
+	.long TLB1_MAS0(1, 1, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI1_MEM_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI1_MEM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 2:256M	Non-cacheable, guarded
+	 * 0x90000000	256M	PCI1 MEM Second half
+	 */
+	.long TLB1_MAS0(1, 2, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI1_MEM_BASE + 0x10000000),
+			0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI1_MEM_BASE + 0x10000000),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 3:256M	Non-cacheable, guarded
+	 * 0xa0000000	256M	PCI2 MEM First half
+	 */
+	.long TLB1_MAS0(1, 3, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI2_MEM_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI2_MEM_BASE), 0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 4:256M	Non-cacheable, guarded
+	 * 0xb0000000	256M	PCI2 MEM Second half
+	 */
+	.long TLB1_MAS0(1, 4, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_PCI2_MEM_BASE + 0x10000000),
+			0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_PCI2_MEM_BASE + 0x10000000),
+			0,0,0,0,0,1,0,1,0,1)
+
+	/*
+	 * TLB1 entry 5:64M	Non-cacheable, guarded
+	 * 0xe000_0000	1M	CCSRBAR
+	 * 0xe200_0000	16M	PCI1 IO
+	 * 0xe300_0000	16M	PCI2 IO
+	 */
+	.long TLB1_MAS0(1, 5, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_64M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_CCSRBAR), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_CCSRBAR), 0,0,0,0,0,1,0,1,0,1)
+
+	/**
+	 * cyclades: Flash size is 8M,
+	 * no tsize can be exactly 8M, should we have two 4M size TLB entries?
+	 */
+	/*
+	 * TLB1 entry 6:4M	Non-cacheable, guarded
+	 * 0xffc00000	4M	FLASH second half
+	 * Out of reset this entry is only 4K.
+	 *
+	 * first half 4M is assigned at TLB1 entry 15
+	 */
+	.long TLB1_MAS0(1, 6, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_4M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_FLASH_BASE + 0x400000), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_FLASH_BASE + 0x400000), 0,0,0,0,0,1,0,1,0,1)
+	
+	/**
+	 * cyclades: localbus is 256M,
+	 */
+	/*
+	 * TLB1 entry 7:256M	Non-cacheable, guarded
+	 * 0xc0000000	256M	LocalBus, FPGA for CF, etc
+	 *
+	 */
+	.long TLB1_MAS0(1, 7, 0)
+	.long TLB1_MAS1(1, 1, 0, 0, BOOKE_PAGESZ_256M)
+	.long TLB1_MAS2(E500_TLB_EPN(CFG_LBC_BASE), 0,0,0,0,1,0,1,0)
+	.long TLB1_MAS3(E500_TLB_RPN(CFG_LBC_BASE), 0,0,0,0,0,1,0,1,0,1)
+	
+	entry_end
+
+/*
+ * LAW(Local Access Window) configuration:
+ *
+ * 0x0000_0000     0x7fff_ffff     DDR                     2G
+ * 0x8000_0000     0x9fff_ffff     PCI1 MEM                512M
+ * 0xa000_0000     0xbfff_ffff     PCI2 MEM                512M
+ * cyclades: we have LocalBus mem map for Compact Flash
+ * 0xc000_0000     0xcfff_ffff     LOCALBUS                256M
+ * 0xe000_0000     0xe000_ffff     CCSR                    1M
+ * 0xe200_0000     0xe2ff_ffff     PCI1 IO                 16M
+ * 0xe300_0000     0xe3ff_ffff     PCI2 IO                 16M
+ * 0xff80_0000     0xffff_ffff     FLASH (boot bank)       8M
+ *
+ * Notes:
+ *    CCSRBAR and L2-as-SRAM don't need a configured Local Access Window.
+ *    If flash is 8M at default position (last 8M), no LAW needed.
+ *
+ * The defines below are 1-off of the actual LAWAR0 usage.
+ * So LAWAR3 define uses the LAWAR4 register in the ECM.
+ */
+
+/**
+ * cyclades: DDR size is 256M
+ */	
+#define LAWBAR0 0
+#define LAWAR0  ((LAWAR_TRGT_IF_DDR | (LAWAR_SIZE & LAWAR_SIZE_256M)) & ~LAWAR_EN)
+
+#define LAWBAR1 ((CFG_PCI1_MEM_BASE>>12) & 0xfffff)
+#define LAWAR1 	(LAWAR_EN | LAWAR_TRGT_IF_PCI1 | (LAWAR_SIZE & LAWAR_SIZE_512M))
+
+#define LAWBAR2 ((CFG_PCI2_MEM_BASE>>12) & 0xfffff)
+#define LAWAR2 	(LAWAR_EN | LAWAR_TRGT_IF_PCI2 | (LAWAR_SIZE & LAWAR_SIZE_512M))
+
+#define LAWBAR3 ((CFG_PCI1_IO_BASE>>12) & 0xfffff)
+#define LAWAR3 	(LAWAR_EN | LAWAR_TRGT_IF_PCI1 | (LAWAR_SIZE & LAWAR_SIZE_16M))
+
+#define LAWBAR4 ((CFG_PCI2_IO_BASE>>12) & 0xfffff)
+#define LAWAR4 	(LAWAR_EN | LAWAR_TRGT_IF_PCI2 | (LAWAR_SIZE & LAWAR_SIZE_16M))
+
+/* cyclades: LocalBus */
+/* LBC window - maps 256M 0xc0000000 -> 0xcfffffff */
+#define LAWBAR5 ((CFG_LBC_BASE>>12) & 0xfffff)
+#define LAWAR5 	(LAWAR_EN | LAWAR_TRGT_IF_LBC | (LAWAR_SIZE & LAWAR_SIZE_256M))
+
+	.section .bootpg, "ax"
+	.globl	law_entry
+
+law_entry:
+	entry_start
+/* cyclades: only 6 entries in LAWBAR/LAWAR */
+ 	.long 6
+	.long LAWBAR0,LAWAR0,LAWBAR1,LAWAR1,LAWBAR2,LAWAR2,LAWBAR3,LAWAR3
+	.long LAWBAR4,LAWAR4,LAWBAR5,LAWAR5
+	entry_end
diff -Naur u-boot-1.1.2/board/kvmmaxv1/kvmmaxv1.c uboot-1.1.2hsv/board/kvmmaxv1/kvmmaxv1.c
--- u-boot-1.1.2/board/kvmmaxv1/kvmmaxv1.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/kvmmaxv1.c	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,366 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <spd.h>
+
+/* cyclades: use bdparam.h instead of cadmus.h */
+/* #include "cadmus.h" */
+#include "bdparam.h"
+#include "eeprom.h"
+
+#if defined(CONFIG_DDR_ECC)
+extern void ddr_enable_ecc(unsigned int dram_size);
+#endif
+
+extern long int spd_sdram(void);
+
+void local_bus_init(void);
+void sdram_init(void);
+
+int board_early_init_f (void)
+{
+	return 0;
+}
+
+int checkboard (void)
+{
+	volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+
+	/* PCI slot in USER bits CSR[6:7] by convention. */
+	uint pci_slot = get_pci_slot ();
+
+	uint pci_dual = get_pci_dual ();	/* PCI DUAL in CM_PCI[3] */
+	uint pci1_32 = gur->pordevsr & 0x10000;	/* PORDEVSR[15] */
+	uint pci1_clk_sel = gur->porpllsr & 0x8000;	/* PORPLLSR[16] */
+	uint pci2_clk_sel = gur->porpllsr & 0x4000;	/* PORPLLSR[17] */
+
+	/* cyclades: in kvmmaxv1 board, pci_clk is not sys_clk */
+/* 	uint pci1_speed = get_clock_freq ();	/\* PCI PSPEED in [4:5] *\/ */
+	uint pci1_speed = get_pci1_clock_freq ();
+	uint pci2_speed = get_pci2_clock_freq ();
+
+	/*
+	   cyclades: kvmmaxv1, we don't use eeprom for processor, use FPGA
+	   to save those info, it's on localbus, 0xc000_0020, 16-bit,
+	   [0:7] board ID, [8:15] FPGA rev. TODO:
+	   */
+	uint cpu_board_rev = get_cpu_board_revision ();
+
+	printf ("Board: KVMMAXV1 Version 0x%02x, PCI Slot %d\n",
+		get_board_version (), pci_slot);
+
+	printf ("CPU Board Revision %d.%d (0x%04x)\n",
+		MPC85XX_CPU_BOARD_MAJOR (cpu_board_rev),
+		MPC85XX_CPU_BOARD_MINOR (cpu_board_rev), cpu_board_rev);
+
+	printf ("    PCI1: %d bit, %s MHz, %s\n",
+		(pci1_32) ? 32 : 64,
+		(pci1_speed == 33000000) ? "33" :
+		(pci1_speed == 66000000) ? "66" : "unknown",
+		pci1_clk_sel ? "sync" : "async");
+
+	if (pci_dual) {
+		printf ("    PCI2: 32 bit, %s MHz, %s\n",
+			(pci2_speed == 33000000) ? "33" :
+			(pci2_speed == 66000000) ? "66" : "unknown",
+			pci2_clk_sel ? "sync" : "async");
+	} else {
+		printf ("    PCI2: disabled\n");
+	}
+
+	/*
+	 * Initialize local bus.
+	 */
+	local_bus_init ();
+
+	return 0;
+}
+
+long int
+initdram(int board_type)
+{
+	long dram_size = 0;
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+
+	puts("Initializing\n");
+
+#if defined(CONFIG_DDR_DLL)
+	{
+		/*
+		 * Work around to stabilize DDR DLL MSYNC_IN.
+		 * Errata DDR9 seems to have been fixed.
+		 * This is now the workaround for Errata DDR11:
+		 *    Override DLL = 1, Course Adj = 1, Tap Select = 0
+		 */
+
+		volatile ccsr_gur_t *gur= &immap->im_gur;
+
+		gur->ddrdllcr = 0x81000000;
+		asm("sync;isync;msync");
+		udelay(200);
+	}
+#endif
+	dram_size = spd_sdram();
+
+#if defined(CONFIG_DDR_ECC)
+	/*
+	 * Initialize and enable DDR ECC.
+	 */
+	ddr_enable_ecc(dram_size);
+#endif
+	/*
+	 * SDRAM Initialization
+	 */
+	sdram_init();
+
+	puts("    DDR: ");
+	return dram_size;
+}
+
+/*
+ * Initialize Local Bus
+ */
+void
+local_bus_init(void)
+{
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+
+	uint clkdiv;
+	uint lbc_hz;
+	sys_info_t sysinfo;
+	uint temp_lbcdll;
+
+	/*
+	 * Errata LBC11.
+	 * Fix Local Bus clock glitch when DLL is enabled.
+	 *
+	 * If localbus freq is < 66Mhz, DLL bypass mode must be used.
+	 * If localbus freq is > 133Mhz, DLL can be safely enabled.
+	 * Between 66 and 133, the DLL is enabled with an override workaround.
+	 */
+
+	get_sys_info(&sysinfo);
+
+	/* cyclades: who sets lbc->lcrr? PowerOn reset value is 0x8000_0008 */
+	clkdiv = lbc->lcrr & 0x0f;
+	lbc_hz = sysinfo.freqSystemBus / 1000000 / clkdiv;
+
+	if (lbc_hz < 66) {
+	  /* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+/* 		lbc->lcrr |= 0x80000000;	/\* DLL Bypass *\/ */
+		lbc->lcrr = CFG_LBC_LCRR | 0x80000000;	/* DLL Bypass */
+
+	} else if (lbc_hz >= 133) {
+	  /* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+/* 		lbc->lcrr &= (~0x80000000);		/\* DLL Enabled *\/ */
+		lbc->lcrr = CFG_LBC_LCRR & (~0x80000000); /* DLL Enabled */
+
+	} else {
+	  /* cyclades: using CFG_LBC_LCRR to set lbc->lcrr */
+/* 		lbc->lcrr &= (~0x8000000);	/\* DLL Enabled *\/ */
+		lbc->lcrr = CFG_LBC_LCRR & (~0x80000000);/* DLL Enabled */
+		udelay(200);
+
+		/*
+		 * Sample LBC DLL ctrl reg, upshift it to set the
+		 * override bits.
+		 */
+		temp_lbcdll = gur->lbcdllcr;
+		gur->lbcdllcr = (((temp_lbcdll & 0xff) << 16) | 0x80000000);
+		asm("sync;isync;msync");
+	}
+}
+
+/*
+ * Initialize SDRAM memory on the Local Bus.
+ */
+void
+sdram_init(void)
+{
+#if defined(CFG_OR2_PRELIM) && defined(CFG_BR2_PRELIM)
+
+	uint idx;
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_lbc_t *lbc = &immap->im_lbc;
+	uint *sdram_addr = (uint *)CFG_LBC_SDRAM_BASE;
+	uint cpu_board_rev;
+	uint lsdmr_common;
+
+	puts("    SDRAM: ");
+
+	print_size (CFG_LBC_SDRAM_SIZE * 1024 * 1024, "\n");
+
+	/*
+	 * Setup SDRAM Base and Option Registers
+	 */
+	lbc->or2 = CFG_OR2_PRELIM;
+	asm("msync");
+
+	lbc->br2 = CFG_BR2_PRELIM;
+	asm("msync");
+
+	lbc->lbcr = CFG_LBC_LBCR;
+	asm("msync");
+
+	lbc->lsrt = CFG_LBC_LSRT;
+	lbc->mrtpr = CFG_LBC_MRTPR;
+	asm("msync");
+
+	/*
+	 * Determine which address lines to use baed on CPU board rev.
+	 */
+	cpu_board_rev = get_cpu_board_revision();
+	lsdmr_common = CFG_LBC_LSDMR_COMMON;
+	if (cpu_board_rev == MPC85XX_CPU_BOARD_REV_1_0) {
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1617;
+	} else if (cpu_board_rev == MPC85XX_CPU_BOARD_REV_1_1) {
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1516;
+	} else {
+		/*
+		 * Assume something unable to identify itself is
+		 * really old, and likely has lines 16/17 mapped.
+		 */
+		lsdmr_common |= CFG_LBC_LSDMR_BSMA1617;
+	}
+
+	/*
+	 * Issue PRECHARGE ALL command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_PCHALL;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(100);
+
+	/*
+	 * Issue 8 AUTO REFRESH commands.
+	 */
+	for (idx = 0; idx < 8; idx++) {
+		lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_ARFRSH;
+		asm("sync;msync");
+		*sdram_addr = 0xff;
+		ppcDcbf((unsigned long) sdram_addr);
+		udelay(100);
+	}
+
+	/*
+	 * Issue 8 MODE-set command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_MRW;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(100);
+
+	/*
+	 * Issue NORMAL OP command.
+	 */
+	lbc->lsdmr = lsdmr_common | CFG_LBC_LSDMR_OP_NORMAL;
+	asm("sync;msync");
+	*sdram_addr = 0xff;
+	ppcDcbf((unsigned long) sdram_addr);
+	udelay(200);    /* Overkill. Must wait > 200 bus cycles */
+
+#endif	/* enable SDRAM init */
+}
+
+#if defined(CFG_DRAM_TEST)
+int
+testdram(void)
+{
+	uint *pstart = (uint *) CFG_MEMTEST_START;
+	uint *pend = (uint *) CFG_MEMTEST_END;
+	uint *p;
+
+	printf("Testing DRAM from 0x%08x to 0x%08x\n",
+	       CFG_MEMTEST_START,
+	       CFG_MEMTEST_END);
+
+	printf("DRAM test phase 1:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0xaaaaaaaa;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0xaaaaaaaa) {
+			printf ("DRAM test fails at: %08x\n", (uint) p);
+			return 1;
+		}
+	}
+
+	printf("DRAM test phase 2:\n");
+	for (p = pstart; p < pend; p++)
+		*p = 0x55555555;
+
+	for (p = pstart; p < pend; p++) {
+		if (*p != 0x55555555) {
+			printf ("DRAM test fails at: %08x\n", (uint) p);
+			return 1;
+		}
+	}
+
+	printf("DRAM test passed.\n");
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_PCI)
+
+/*
+ * Initialize PCI Devices, report devices found.
+ */
+
+#ifndef CONFIG_PCI_PNP
+static struct pci_config_table pci_mpc85xxcds_config_table[] = {
+    { PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+      PCI_IDSEL_NUMBER, PCI_ANY_ID,
+      pci_cfgfunc_config_device, { PCI_ENET0_IOADDR,
+				   PCI_ENET0_MEMADDR,
+				   PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER
+      } },
+    { }
+};
+#endif
+
+static struct pci_controller hose = {
+#ifndef CONFIG_PCI_PNP
+	config_table: pci_mpc85xxcds_config_table,
+#endif
+};
+
+#endif	/* CONFIG_PCI */
+
+void
+pci_init_board(void)
+{
+#ifdef CONFIG_PCI
+	extern void pci_mpc85xx_init(struct pci_controller *hose);
+
+	pci_mpc85xx_init(&hose);
+#endif
+}
diff -Naur u-boot-1.1.2/board/kvmmaxv1/Makefile uboot-1.1.2hsv/board/kvmmaxv1/Makefile
--- u-boot-1.1.2/board/kvmmaxv1/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/Makefile	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,55 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+# (C) Copyright 2001
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+# cyclades: we don't use cadmus registers, use our config method, cycparam.
+# OBJS	:= $(BOARD).o \
+# 	   cadmus.o \
+# 	   eeprom.o
+OBJS	:= $(BOARD).o \
+	   bdparam.o \
+	   eeprom.o
+
+SOBJS	:= init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Naur u-boot-1.1.2/board/kvmmaxv1/u-boot.lds uboot-1.1.2hsv/board/kvmmaxv1/u-boot.lds
--- u-boot-1.1.2/board/kvmmaxv1/u-boot.lds	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/board/kvmmaxv1/u-boot.lds	2007-05-29 16:51:03.000000000 -0500
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SEARCH_DIR(/lib); SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/local/lib); SEARCH_DIR(/usr/local/powerpc-any-elf/lib);
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  .resetvec 0xFFFFFFFC :
+  {
+    *(.resetvec)
+  } = 0xffff
+
+  .bootpg 0xFFFFF000 :
+  {
+    cpu/mpc85xx/start.o	(.bootpg)
+    board/kvmmaxv1/init.o (.bootpg)
+  } = 0xffff
+
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text) 	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data) 	}
+  .rel.rodata    : { *(.rel.rodata) 	}
+  .rela.rodata   : { *(.rela.rodata) 	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    cpu/mpc85xx/start.o	(.text)
+    board/kvmmaxv1/init.o (.text)
+    cpu/mpc85xx/traps.o (.text)
+    cpu/mpc85xx/interrupts.o (.text)
+    cpu/mpc85xx/cpu_init.o (.text)
+    cpu/mpc85xx/cpu.o (.text)
+    cpu/mpc85xx/tsec.o (.text)
+    cpu/mpc85xx/speed.o (.text)
+    cpu/mpc85xx/pci.o (.text)
+    common/dlmalloc.o (.text)
+    lib_generic/crc32.o (.text)
+    lib_ppc/extable.o (.text)
+    lib_generic/zlib.o (.text)
+    *(.text)
+    *(.fixup)
+    *(.got1)
+   }
+    _etext = .;
+    PROVIDE (etext = .);
+    .rodata    :
+   {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >> 2;
+  __fixup_entries = (. - _FIXUP_TABLE_) >> 2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+  }
+  _end = . ;
+  PROVIDE (end = .);
+}
diff -Naur u-boot-1.1.2/board/MAI/bios_emulator/scitech/src/common/makefile uboot-1.1.2hsv/board/MAI/bios_emulator/scitech/src/common/makefile
--- u-boot-1.1.2/board/MAI/bios_emulator/scitech/src/common/makefile	2002-11-19 05:04:15.000000000 -0600
+++ uboot-1.1.2hsv/board/MAI/bios_emulator/scitech/src/common/makefile	2007-05-29 16:51:08.000000000 -0500
@@ -7,7 +7,7 @@
 #               DPMSLib library files. Requires Borland C++ 4.52 to build
 #               some components.
 #
-# $Date: 2002/10/02 15:35:20 $ $Author: hfrieden $
+# $Date: 2005/02/05 03:15:30 $ $Author: yang $
 #
 #############################################################################
 
diff -Naur u-boot-1.1.2/board/MAI/bios_emulator/scitech/src/pm/tests/vftest.c uboot-1.1.2hsv/board/MAI/bios_emulator/scitech/src/pm/tests/vftest.c
--- u-boot-1.1.2/board/MAI/bios_emulator/scitech/src/pm/tests/vftest.c	2003-06-27 16:31:55.000000000 -0500
+++ uboot-1.1.2hsv/board/MAI/bios_emulator/scitech/src/pm/tests/vftest.c	2007-05-29 16:51:08.000000000 -0500
@@ -22,7 +22,7 @@
 *  ========================================================================
 *
 * Filename:     $Workfile$
-* Version:      $Revision: 1.1 $
+* Version:      $Revision: 1.1.1.1 $
 *
 * Language:     ANSI C
 * Environment:  any
@@ -33,7 +33,7 @@
 *                                   VF_init()
 *                                   VF_exit()
 *
-* $Date: 2002/10/02 15:35:21 $ $Author: hfrieden $
+* $Date: 2005/02/05 03:15:30 $ $Author: yang $
 *
 ****************************************************************************/
 
diff -Naur u-boot-1.1.2/board/ns9750dev/led.c uboot-1.1.2hsv/board/ns9750dev/led.c
--- u-boot-1.1.2/board/ns9750dev/led.c	2004-02-27 02:20:54.000000000 -0600
+++ uboot-1.1.2hsv/board/ns9750dev/led.c	2007-05-29 16:51:16.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: led.c,v 1.1 2004/02/16 10:37:20 mpietrek Exp $
+ * $Id: led.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @Descr: Defines helper functions for toggeling LEDs
  * @Usage:
diff -Naur u-boot-1.1.2/board/xilinx/common/xdma_channel_sg.c uboot-1.1.2hsv/board/xilinx/common/xdma_channel_sg.c
--- u-boot-1.1.2/board/xilinx/common/xdma_channel_sg.c	2004-02-23 17:54:46.000000000 -0600
+++ uboot-1.1.2hsv/board/xilinx/common/xdma_channel_sg.c	2007-05-29 16:51:13.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: xdma_channel_sg.c,v 1.6 2003/02/03 19:50:33 moleres Exp $ */
+/* $Id: xdma_channel_sg.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 /******************************************************************************
 *
 *     Author: Xilinx, Inc.
diff -Naur u-boot-1.1.2/board/xilinx/common/xipif_v1_23_b.c uboot-1.1.2hsv/board/xilinx/common/xipif_v1_23_b.c
--- u-boot-1.1.2/board/xilinx/common/xipif_v1_23_b.c	2004-09-29 17:44:00.000000000 -0500
+++ uboot-1.1.2hsv/board/xilinx/common/xipif_v1_23_b.c	2007-05-29 16:51:13.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: xipif_v1_23_b.c,v 1.1 2002/03/18 23:24:52 linnj Exp $ */
+/* $Id: xipif_v1_23_b.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 /******************************************************************************
 *
 *       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
diff -Naur u-boot-1.1.2/board/xilinx/common/xipif_v1_23_b.h uboot-1.1.2hsv/board/xilinx/common/xipif_v1_23_b.h
--- u-boot-1.1.2/board/xilinx/common/xipif_v1_23_b.h	2004-09-29 17:44:00.000000000 -0500
+++ uboot-1.1.2hsv/board/xilinx/common/xipif_v1_23_b.h	2007-05-29 16:51:13.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: xipif_v1_23_b.h,v 1.1 2002/03/18 23:24:52 linnj Exp $ */
+/* $Id: xipif_v1_23_b.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 /******************************************************************************
 *
 *	XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
diff -Naur u-boot-1.1.2/board/xilinx/xilinx_iic/xiic_l.c uboot-1.1.2hsv/board/xilinx/xilinx_iic/xiic_l.c
--- u-boot-1.1.2/board/xilinx/xilinx_iic/xiic_l.c	2004-09-29 17:44:01.000000000 -0500
+++ uboot-1.1.2hsv/board/xilinx/xilinx_iic/xiic_l.c	2007-05-29 16:51:13.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: xiic_l.c,v 1.2 2002/12/05 19:32:40 meinelte Exp $ */
+/* $Id: xiic_l.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 /******************************************************************************
 *
 *	XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
diff -Naur u-boot-1.1.2/board/xilinx/xilinx_iic/xiic_l.h uboot-1.1.2hsv/board/xilinx/xilinx_iic/xiic_l.h
--- u-boot-1.1.2/board/xilinx/xilinx_iic/xiic_l.h	2004-09-29 17:44:01.000000000 -0500
+++ uboot-1.1.2hsv/board/xilinx/xilinx_iic/xiic_l.h	2007-05-29 16:51:13.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: xiic_l.h,v 1.2 2002/12/05 19:32:40 meinelte Exp $ */
+/* $Id: xiic_l.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 /*****************************************************************************
 *
 *	XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
diff -Naur u-boot-1.1.2/common/bedbug.c uboot-1.1.2hsv/common/bedbug.c
--- u-boot-1.1.2/common/bedbug.c	2003-06-27 16:32:30.000000000 -0500
+++ uboot-1.1.2hsv/common/bedbug.c	2007-05-29 16:51:23.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id: bedbug.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 
 #include <common.h>
 
diff -Naur u-boot-1.1.2/common/cmd_ace.c uboot-1.1.2hsv/common/cmd_ace.c
--- u-boot-1.1.2/common/cmd_ace.c	2004-09-29 17:55:14.000000000 -0500
+++ uboot-1.1.2hsv/common/cmd_ace.c	2007-05-29 16:51:23.000000000 -0500
@@ -17,7 +17,7 @@
  *    along with this program; if not, write to the Free Software
  *    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
-#ident "$Id:$"
+#ident "$Id: cmd_ace.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $"
 
 /*
  * The Xilinx SystemACE chip support is activated by defining
diff -Naur u-boot-1.1.2/common/cmd_bdinfo.c uboot-1.1.2hsv/common/cmd_bdinfo.c
--- u-boot-1.1.2/common/cmd_bdinfo.c	2004-12-31 03:32:50.000000000 -0600
+++ uboot-1.1.2hsv/common/cmd_bdinfo.c	2007-05-29 16:51:22.000000000 -0500
@@ -68,13 +68,13 @@
 	print_str ("pci_busfreq",   strmhz(buf, bd->bi_pci_busfreq));
 #endif
 #else	/* ! CONFIG_405GP, CONFIG_405CR, CONFIG_405EP, CONFIG_XILINX_ML300 */
-#if defined(CONFIG_8260) || defined(CONFIG_MPC8560)
+#if defined(CONFIG_8260) || defined(CONFIG_MPC8560) || defined(CONFIG_MPC8555) || defined(CONFIG_MPC8541)
 	print_str ("vco",	    strmhz(buf, bd->bi_vco));
 	print_str ("sccfreq",	    strmhz(buf, bd->bi_sccfreq));
 	print_str ("brgfreq",	    strmhz(buf, bd->bi_brgfreq));
 #endif
 	print_str ("intfreq",	    strmhz(buf, bd->bi_intfreq));
-#if defined(CONFIG_8260) || defined(CONFIG_MPC8560)
+#if defined(CONFIG_8260) || defined(CONFIG_MPC8560) || defined(CONFIG_MPC8555) || defined(CONFIG_MPC8541)
 	print_str ("cpmfreq",	    strmhz(buf, bd->bi_cpmfreq));
 #endif
 	print_str ("busfreq",	    strmhz(buf, bd->bi_busfreq));
@@ -86,6 +86,10 @@
 	print_str ("vcofreq",	    strmhz(buf, bd->bi_vcofreq));
 	print_str ("pevfreq",	    strmhz(buf, bd->bi_pevfreq));
 #endif
+#if defined(CONFIG_KVMMAX) || defined(CONFIG_DEB) || defined(CONFIG_AMAZON)
+	print_str ("pci1_busfreq",   strmhz(buf, bd->bi_pci1_busfreq));
+	print_str ("pci2_busfreq",   strmhz(buf, bd->bi_pci2_busfreq));
+#endif
 
 	puts ("ethaddr     =");
 	for (i=0; i<6; ++i) {
diff -Naur u-boot-1.1.2/common/cmd_bootm.c uboot-1.1.2hsv/common/cmd_bootm.c
--- u-boot-1.1.2/common/cmd_bootm.c	2004-11-20 18:06:34.000000000 -0600
+++ uboot-1.1.2hsv/common/cmd_bootm.c	2007-05-29 16:51:23.000000000 -0500
@@ -580,12 +580,16 @@
 	kbd->bi_flbfreq /= 1000000L;
 	kbd->bi_vcofreq /= 1000000L;
 #endif
-#if defined(CONFIG_8260) || defined(CONFIG_MPC8560)
+#if defined(CONFIG_8260) || defined(CONFIG_MPC8560) || defined(CONFIG_MPC8555) || defined(CONFIG_MPC8541)
 		kbd->bi_cpmfreq /= 1000000L;
 		kbd->bi_brgfreq /= 1000000L;
 		kbd->bi_sccfreq /= 1000000L;
 		kbd->bi_vco     /= 1000000L;
 #endif /* CONFIG_8260 */
+#if defined(CONFIG_KVMMAX) || defined(CONFIG_DEB) || defined(CONFIG_AMAZON)
+		kbd->bi_pci1_busfreq /= 1000000L;
+		kbd->bi_pci2_busfreq /= 1000000L;
+#endif
 #if defined(CONFIG_MPC5xxx)
 		kbd->bi_ipbfreq /= 1000000L;
 		kbd->bi_pcifreq /= 1000000L;
@@ -656,7 +660,7 @@
 			csum = crc32 (0, (char *)data, len);
 #endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
 
-			if (csum != hdr->ih_dcrc) {
+			if (csum != ntohl(hdr->ih_dcrc)) {
 				puts ("Bad Data CRC\n");
 				SHOW_BOOT_PROGRESS (-12);
 				do_reset (cmdtp, flag, argc, argv);
@@ -994,6 +998,86 @@
 	NULL
 );
 
+int do_cyc_boot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int rcode = 0;
+    int len, i, aux;
+	char *s;
+	int image = 0;
+	int hw_boot = (strcmp(argv[0], "hw_boot") == 0);
+    char bootcmd[512];
+
+    /* pre-set load_addr */
+    if ((s = getenv("loadaddr")) == NULL) {
+	    setenv("loadaddr", CONFIG_LOADADDR_DEF);
+    }
+
+    /* check currentimage */
+    if ((s = getenv("currentimage")) != NULL) {
+		image = simple_strtoul(s, NULL, 10);
+    }
+
+	if (!hw_boot) {		// network boot
+		if (image >= 1 && image <= 2) 		
+			len = sprintf(bootcmd, "root=/dev/ram currentimage=%d", image);
+		else
+			len = sprintf(bootcmd, "root=/dev/ram");
+	} else {			// hardware boot
+		if (image < 1 || image > 2) {
+			printf("Warning: parameter 'currentimage' is missing, trying image '1'\n");
+			image = 1;
+		}
+		len = sprintf(bootcmd, "root=/dev/hda%d", image+4);
+	}
+
+	if ((s = getenv("baudrate")) != NULL)
+		len += sprintf(&bootcmd[len], " console=ttyS0,%s", s);
+#ifdef CONFIG_BAUDRATE
+	else {
+		len += sprintf(&bootcmd[len], " console=ttyS0,%d", CONFIG_BAUDRATE);
+	}
+#endif
+	for (i=1; i < argc; i++) {
+		aux = strlen(argv[i]);
+		if (len + aux >= sizeof(bootcmd)) break;
+		len += sprintf(&bootcmd[len], " %s", argv[i]);
+	}
+
+	setenv("bootargs", bootcmd);
+
+	if (strcmp(argv[0], "hw_boot")) {
+    	/* check bootfile */
+    	if ((s = getenv("bootfile")) == NULL) {
+			printf("Error: parameter 'bootfile' is missing\n");
+			return(1); 
+	    }
+		s = "tftpboot;bootm";
+	} else {
+		sprintf(bootcmd, "fatload ide 0:%d $loadaddr * ; bootm", image);
+		s = bootcmd;
+	}
+
+#ifndef CFG_HUSH_PARSER
+	if (run_command (s, flag) < 0) rcode = 1;
+#else
+	if (parse_string_outer(s,
+		FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP) != 0 ) rcode = 1;
+#endif
+	return rcode;
+}
+
+U_BOOT_CMD(
+ 	hw_boot,	CFG_MAXARGS,	1,	do_cyc_boot,
+ 	"hw_boot - do a hardware boot, i.e., run: 'fatload ide 0:<img> <addr> '*';bootm'\n",
+	NULL
+);
+
+U_BOOT_CMD(
+ 	net_boot,	CFG_MAXARGS,	1,	do_cyc_boot,
+ 	"net_boot - do a network boot, i.e., run: 'tftpboot;bootm'\n",
+	NULL
+);
+
 #endif
 
 #if (CONFIG_COMMANDS & CFG_CMD_IMI)
diff -Naur u-boot-1.1.2/common/cmd_doc.c uboot-1.1.2hsv/common/cmd_doc.c
--- u-boot-1.1.2/common/cmd_doc.c	2003-09-10 17:30:54.000000000 -0500
+++ uboot-1.1.2hsv/common/cmd_doc.c	2007-05-29 16:51:23.000000000 -0500
@@ -3,7 +3,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2000.c,v 1.46 2001/10/02 15:05:13 dwmw2 Exp $
+ * $Id: cmd_doc.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  */
 
 #include <common.h>
diff -Naur u-boot-1.1.2/common/cmd_flash.c uboot-1.1.2hsv/common/cmd_flash.c
--- u-boot-1.1.2/common/cmd_flash.c	2004-12-31 03:32:50.000000000 -0600
+++ uboot-1.1.2hsv/common/cmd_flash.c	2007-05-29 16:51:22.000000000 -0500
@@ -506,6 +506,7 @@
 	"flinfo N\n    - print information for FLASH memory bank # N\n"
 );
 
+#ifndef CONFIG_CYCLADES // Cyclades products will not allow erasing the flash
 U_BOOT_CMD(
 	erase,   3,   1,  do_flerase,
 	"erase   - erase FLASH memory\n",
@@ -532,5 +533,5 @@
 	"protect off bank N\n    - make FLASH bank # N writable\n"
 	"protect off all\n    - make all FLASH banks writable\n"
 );
-
+#endif // CONFIG_CYCLADES
 #endif	/* CFG_CMD_FLASH */
diff -Naur u-boot-1.1.2/common/cmd_ide.c uboot-1.1.2hsv/common/cmd_ide.c
--- u-boot-1.1.2/common/cmd_ide.c	2004-12-31 03:32:50.000000000 -0600
+++ uboot-1.1.2hsv/common/cmd_ide.c	2007-05-29 16:51:23.000000000 -0500
@@ -886,6 +886,21 @@
 
 
 #if defined(__PPC__) || defined(CONFIG_PXA_PCMCIA)
+
+static void
+output_swap_data(int dev, ulong *sect_buf, int words)
+{
+	ushort  *dbuf;
+	volatile ushort *pbuf;
+
+	pbuf = (ushort *)(ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	dbuf = (ushort *)sect_buf;
+	while (words--) {
+		st_le16(pbuf, *dbuf++);
+		st_le16(pbuf, *dbuf++);
+	}
+}
+
 static void
 output_data(int dev, ulong *sect_buf, int words)
 {
@@ -1108,7 +1123,11 @@
 		return;
 #endif
 
+#ifdef CONFIG_IDE_BYTESWAP
+	input_data (device, iobuf, ATA_SECTORWORDS);
+#else
 	input_swap_data (device, iobuf, ATA_SECTORWORDS);
+#endif
 
 	ident_cpy (dev_desc->revision, iop->fw_rev, sizeof(dev_desc->revision));
 	ident_cpy (dev_desc->vendor, iop->model, sizeof(dev_desc->vendor));
@@ -1320,7 +1339,11 @@
 			break;
 		}
 
+#ifdef CONFIG_IDE_BYTESWAP
+		input_swap_data (device, buffer, ATA_SECTORWORDS);
+#else
 		input_data (device, buffer, ATA_SECTORWORDS);
+#endif
 		(void) ide_inb (device, ATA_STATUS);	/* clear IRQ */
 
 		++n;
@@ -1405,7 +1428,11 @@
 			goto WR_OUT;
 		}
 
+#ifdef CONFIG_IDE_BYTESWAP
+		output_swap_data (device, buffer, ATA_SECTORWORDS);
+#else
 		output_data (device, buffer, ATA_SECTORWORDS);
+#endif
 		c = ide_inb (device, ATA_STATUS);	/* clear IRQ */
 		++n;
 		++blknr;
diff -Naur u-boot-1.1.2/common/console.c uboot-1.1.2hsv/common/console.c
--- u-boot-1.1.2/common/console.c	2004-04-18 12:39:39.000000000 -0500
+++ uboot-1.1.2hsv/common/console.c	2007-05-29 16:51:22.000000000 -0500
@@ -27,6 +27,11 @@
 #include <console.h>
 #include <exports.h>
 
+#ifdef CONFIG_DEBV1
+#include <asm/immap_85xx.h>
+#include <asm/cpm_85xx.h>
+#endif
+
 #ifdef CONFIG_AMIGAONEG3SE
 int console_changed = 0;
 #endif
@@ -381,6 +386,24 @@
 		gd->flags |= GD_FLG_SILENT;
 #endif
 
+#ifdef CONFIG_DEBV1
+	{
+		/*
+		 * For Onboard revision 3 and later, use PA_13 as
+		 * console's DTR to indicate LINK.
+		 */
+		extern unsigned int get_board_ver_rev(void);
+		unsigned int board_ver_rev; /* V1 rev1 for 2nd spin */
+
+		board_ver_rev = get_board_ver_rev();
+		if (board_ver_rev >=0x3) {
+			volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+			volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+			volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+			cpm_iop->pdata |=  CPM_PA_13; /* Has LNK */
+		}
+	}
+#endif
 	return (0);
 }
 
diff -Naur u-boot-1.1.2/common/cyc_env.c uboot-1.1.2hsv/common/cyc_env.c
--- u-boot-1.1.2/common/cyc_env.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/common/cyc_env.c	2007-05-29 16:51:23.000000000 -0500
@@ -0,0 +1,188 @@
+/*****************************************************************
+* File: cyc_env.c
+*
+* Copyright (C) 2003 Cyclades Corporation
+*
+* www.cyclades.com
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* as published by the Free Software Foundation; either version
+* 2 of the License, or (at your option) any later version.
+*
+* Description: API for u-boot enviroment variables
+*
+****************************************************************/
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+#include <malloc.h>
+#include <cyc_env.h>
+
+#undef DEBUG_ENV
+#ifdef DEBUG_ENV
+#define DEBUGF(fmt,args...) printf(fmt ,##args)
+#else
+#define DEBUGF(fmt,args...)
+#endif
+
+static env_t *env_ptr = NULL;
+
+/*
+ * The application must call this routine just after reading
+ * /proc/flash/boot_ori and before any other call to this interface
+*/
+char *cyc_set_env_ptr(char *ptr)
+{
+	env_ptr = (env_t *)(ptr - sizeof(env_t));
+
+	return(env_ptr->data);
+}
+
+/*
+ * Checks if the crc32 of the u-boot enviroment variables is valid.
+*/
+int cyc_check_crc(void)
+{
+	return (crc32(0, env_ptr->data, ENV_SIZE) == env_ptr->crc);
+}
+
+/*
+ * Copies the idefault environment variables to the u-boot env-t struct and
+ * calculates the crc32.
+*/
+
+void cyc_set_default_env(char *def_vars[])
+{
+	int i, len, size;
+
+	memset(env_ptr->data, 0, ENV_SIZE);
+
+	for(i=0, size=0; def_vars[i]; i+=2) {
+		len = strlen(def_vars[i]);
+		if (size + len > ENV_SIZE-2) break;
+		memcpy(&env_ptr->data[size], def_vars[i], len);
+		size += len;
+		env_ptr->data[size++] = '=';
+		len = strlen(def_vars[i+1]);
+		if (size + len > ENV_SIZE-3) break;
+		memcpy(&env_ptr->data[size], def_vars[i+1], len);
+		size += len+1;
+	}
+
+	if (size < ENV_SIZE)
+		memset(&env_ptr->data[size], 0, ENV_SIZE-size);
+
+	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
+}
+
+static int
+envmatch (unsigned char *s1, unsigned char *env)
+{
+	unsigned char *save_env = env;
+
+	for  ( ; *s1 == *env && *s1 != '='; s1++, env++) ;
+
+	if ((*s1 == '=') ||
+		(*s1 == '\0' && *env == '=')) return(env - save_env + 1);
+
+	return(-1);
+}
+
+int cyc_setenv (char *name, char *val)
+{
+	int   len, oldval;
+	unsigned char *env, *nxt = NULL;
+
+	/*
+	 * search if variable with this name already exists
+	 */
+	oldval = -1;
+	for (env=env_ptr->data; *env; env=nxt+1) {
+		for (nxt=env; *nxt; ++nxt)
+			;
+		if ((oldval = envmatch(name, env)) >= 0)
+			break;
+	}
+
+	/*
+	 * Delete any existing definition
+	 */
+	if (oldval >= 0) {
+
+		if (*++nxt == '\0') {
+			if (env > env_ptr->data) {
+				env--;
+			} else {
+				*env = '\0';
+			}
+		} else {
+			for (;;) {
+				*env = *nxt++;
+				if ((*env == '\0') && (*nxt == '\0'))
+					break;
+				++env;
+			}
+		}
+		*++env = '\0';
+	}
+
+	/* Delete only ? */
+	if (!val || !*val) {
+		env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
+		return 0;
+	}
+
+	/*
+	 * Append new definition at the end
+	 */
+	for (env=env_ptr->data; *env || *(env+1); ++env)
+		;
+	if (env > env_ptr->data)
+		++env;
+	/*
+	 * Overflow when:
+	 * "name" + "=" + "val" +"\0\0"  > ENV_SIZE - (env-env_ptr->data)
+	 */
+	len = strlen(name) + 3 + strlen(val);
+
+	if (len > (&env_ptr->data[ENV_SIZE]-env)) {
+		return 1;
+	}
+	while ((*env = *name++) != '\0')
+		env++;
+
+	*env = '=';
+	while ((*++env = *val++) != '\0') ;
+
+	/* end is marked with double '\0' */
+	*++env = '\0';
+
+	/* Update CRC */
+	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
+
+	return 0;
+}
+
+
+char *cyc_getenv (unsigned char *name)
+{
+
+	int   oldval;
+	unsigned char *env, *nxt = NULL;
+
+	/*
+	 * search if variable with this name already exists
+	 */
+	oldval = -1;
+	for (env=env_ptr->data; *env; env=nxt+1) {
+		for (nxt=env; *nxt; ++nxt)
+			;
+		if ((oldval = envmatch(name, env)) >= 0)
+			return(env+oldval);
+	}
+
+	return (NULL);
+}
diff -Naur u-boot-1.1.2/common/docecc.c uboot-1.1.2hsv/common/docecc.c
--- u-boot-1.1.2/common/docecc.c	2004-07-11 15:04:53.000000000 -0500
+++ uboot-1.1.2hsv/common/docecc.c	2007-05-29 16:51:23.000000000 -0500
@@ -7,7 +7,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com)
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: docecc.c,v 1.4 2001/10/02 15:05:13 dwmw2 Exp $
+ * $Id: docecc.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naur u-boot-1.1.2/common/main.c uboot-1.1.2hsv/common/main.c
--- u-boot-1.1.2/common/main.c	2004-04-23 15:32:06.000000000 -0500
+++ uboot-1.1.2hsv/common/main.c	2007-05-29 16:51:23.000000000 -0500
@@ -536,7 +536,7 @@
  *		-1 if break
  *		-2 if timed out
  */
-int readline (const char *const prompt)
+int readline2 (const char *const prompt, const char *default_text)
 {
 	char   *p = console_buffer;
 	int	n = 0;				/* buffer index		*/
@@ -551,6 +551,16 @@
 	}
 	col = plen;
 
+  if ( default_text ) 
+  {
+    while ( (c = *default_text++) != 0 ) 
+    {
+      ++col;
+      putc( c );
+      *p++ = c;
+      ++n;
+    }
+  }
 	for (;;) {
 #ifdef CONFIG_BOOT_RETRY_TIME
 		while (!tstc()) {	/* while no incoming data */
@@ -634,6 +644,11 @@
 		}
 	}
 }
+
+int readline (const char *const prompt)
+{
+  return readline2( prompt, NULL );
+}
 
 /****************************************************************************/
 
diff -Naur u-boot-1.1.2/common/Makefile uboot-1.1.2hsv/common/Makefile
--- u-boot-1.1.2/common/Makefile	2004-12-16 11:35:57.000000000 -0600
+++ uboot-1.1.2hsv/common/Makefile	2007-05-29 16:51:23.000000000 -0500
@@ -54,11 +54,15 @@
 
 CPPFLAGS += -I..
 
-all:	$(LIB) $(AOBJS)
+# DHS all:	$(LIB) $(AOBJS) cyc_env.o
+
+all:	$(LIB) $(AOBJS) cyc_env.o
 
 $(LIB): .depend $(OBJS)
 	$(AR) crv $@ $(OBJS)
 
+cyc_env.o: cyc_env.c
+
 environment.o: environment.c ../tools/envcrc
 	$(CC) $(AFLAGS) -Wa,--no-warn \
 		-DENV_CRC=$(shell ../tools/envcrc) \
diff -Naur u-boot-1.1.2/cpu/mpc85xx/cpu.c uboot-1.1.2hsv/cpu/mpc85xx/cpu.c
--- u-boot-1.1.2/cpu/mpc85xx/cpu.c	2004-07-09 18:27:14.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/cpu.c	2007-05-29 16:50:52.000000000 -0500
@@ -30,6 +30,10 @@
 #include <command.h>
 #include <asm/cache.h>
 
+#ifdef CONFIG_DEBV1
+#include <asm/cpm_85xx.h>
+#endif
+
 /* ------------------------------------------------------------------------- */
 
 int checkcpu (void)
@@ -109,7 +113,9 @@
 		printf("    LBC: unknown (lcrr: 0x%08x)\n", lcrr);
 	}
 
-	if (ver == SVR_8560) {
+	/* cyclades: 8555/8541 also has CPM */
+/* 	if (ver == SVR_8560) { */
+	if (ver == SVR_8560 || ver == SVR_8555 || ver == SVR_8541) {
 		printf("    CPM: %lu Mhz\n",
 		       sysinfo.freqSystemBus / 1000000);
 	}
@@ -122,6 +128,40 @@
 
 /* ------------------------------------------------------------------------- */
 
+static void wdt_85xx_do_hreset(void)
+{
+	unsigned long val;
+
+	/*
+	 * set up wdt timeout to be the smallest by making TCR[WP]=11
+	 * and TCR[WPEXT]=1111,
+	 *
+	 * enable processor reset output by making TCR[WRC]=10.
+	 *
+	 * disable all timer interrupts: WIE, DIE, FIE, ARE.
+	 */
+	val = mfspr(TCR);
+	val |= (TCR_WP(3) + (15 << 17));
+	val |= TCR_WRC(2);
+	val &= ~(TCR_WIE | TCR_PIE | TCR_FIE | TCR_ARE);
+	mtspr(TCR, val);
+
+	/* if above change doesn't work, we need to do more */
+	val = mfspr(TSR);
+	val |= TSR_ENW | TSR_WIS;
+	mtspr(TSR, val);
+
+	mtspr(TBWL, 0);
+	mtspr(TBWU, 0);
+	
+	val = mfspr(HID0);
+	val |= 0x00004000;
+	val &= ~0x00002000;
+	mtspr(HID0, val);
+	
+	return;
+}
+
 int do_reset (cmd_tbl_t *cmdtp, bd_t *bd, int flag, int argc, char *argv[])
 {
 	/*
@@ -129,7 +169,66 @@
 	 * Make sure MSR[DE] = 1
 	 */
 	unsigned long val;
+#ifdef CONFIG_DEBV1
+	extern unsigned int get_board_ver_rev(void);
 
+	/*
+	 * we need to do HW patch way for HRESET on 1st and 2nd spin
+	 * because WDT support is missing on these two spins(no
+	 * HRESET_REQ connects back to reset circuit). But for 3rd
+	 * spin and later on revisions, we can and should do WDT
+	 * way.
+	 *
+	 * Using HW patch way may result incomplete HRESET sometime
+	 * due to no enough current from CPM PC-26 pin.
+	 */
+	if (get_board_ver_rev() <0x3)
+	{
+		/*
+		 * On DEB 2nd spin HW, we did a HW patch to do HRESET.
+		 * From MPC85xx's DS, setting MSR[DE], DBCR0[IDM|RST]
+		 * does NOT cause HRESET_REQ pin to be asserted.
+		 *
+		 * Use PC26 output a 0 to HRESET the system
+		 */
+		volatile immap_t *immap = (immap_t *) CFG_CCSRBAR;
+		volatile ccsr_cpm_t *cpm = &immap->im_cpm;
+		volatile ccsr_cpm_iop_t *cpm_iop = &cpm->im_cpm_iop;
+
+		/* set general IO =0 */
+		cpm_iop->pparc &= ~(CPM_PC_26);
+
+		/* no need to change PSORx because of general IO */
+
+		/* set open drain to be regular =0 */
+		cpm_iop->podrc &= ~(CPM_PC_26);
+
+		/* set direction to be output =1 */
+		cpm_iop->pdirc |= (CPM_PC_26);
+
+		asm("sync;isync;msync");
+		udelay(50);
+
+		cpm_iop->pdatc &= ~(CPM_PC_26);
+  
+		asm("sync;isync;msync");
+		udelay(10);
+		do{} while(1);
+	}
+#endif
+#if 1 /* DHS testing */
+	{
+		/*
+		 * Use Watchdog timer to implement HRESET_REQ instead
+		 * of above HW patch.
+		 */
+		wdt_85xx_do_hreset();
+		do{} while(1);
+	}
+#endif
+#if 1 /* DHS testing */
+  mtmsr( mfmsr() | MSR_DE );
+#endif
 	val = mfspr(DBCR0);
 	val |= 0x70000000;
 	mtspr(DBCR0,val);
@@ -147,17 +246,43 @@
 	sys_info_t  sys_info;
 
 	get_sys_info(&sys_info);
-	return ((sys_info.freqSystemBus + 3L) / 4L);
+	return ((sys_info.freqSystemBus + 7L) / 8L);
 }
 
 
 #if defined(CONFIG_WATCHDOG)
+
+unsigned char watchdog_enable = 0;
+
 void
-watchdog_reset(void)
+start_85xx_watchdog(void)
 {
-	int re_enable = disable_interrupts();
-	reset_85xx_watchdog();
-	if (re_enable) enable_interrupts();
+	/*
+	 * Clear TSR(WIS) bit by writing 1
+	 */
+	unsigned long val, aux;
+	int div;
+	sys_info_t sysinfo;
+	/* Set up the watchdog timer timeout (between 2 and 4 seconds). */
+	get_sys_info(&sysinfo);
+	for (div = 63, aux = sysinfo.freqSystemBus / 8 * 2; 
+		aux > 0; div --, aux /= 2);
+	val = mfspr(TCR);
+	val &= ~((15 << 17) + TCR_WP(3) + (3 << 28));
+	val |= ((div / 4) << 17) + TCR_WP(div % 4) + (2 << 28);
+	mtspr(TCR, val);
+	/* Reset watchdog timer registers */
+	val = mfspr(TSR);
+	val |= TSR_ENW | TSR_WIS;
+	mtspr(TSR, val);
+	/* Reset time base registers */
+        mtspr(TBWL, 0);
+	mtspr(TBWU, 0);
+	/* Start counter */
+	val = mfspr(HID0);
+	val |= 0x00004000;
+	mtspr(HID0, val);
+	watchdog_enable = 1;
 }
 
 void
@@ -167,10 +292,22 @@
 	 * Clear TSR(WIS) bit by writing 1
 	 */
 	unsigned long val;
-	val = mfspr(tsr);
-	val |= 0x40000000;
-	mtspr(tsr, val);
+	if (watchdog_enable) {
+		val = mfspr(TSR);
+		val |= TSR_WIS;
+		val &= ~(TSR_PIS|TSR_FIS);
+		mtspr(TSR, val);
+	}
 }
+
+void
+watchdog_reset(void)
+{
+	int re_enable = disable_interrupts();
+	reset_85xx_watchdog();
+	if (re_enable) enable_interrupts();
+}
+
 #endif	/* CONFIG_WATCHDOG */
 
 #if defined(CONFIG_DDR_ECC)
diff -Naur u-boot-1.1.2/cpu/mpc85xx/i2c.c uboot-1.1.2hsv/cpu/mpc85xx/i2c.c
--- u-boot-1.1.2/cpu/mpc85xx/i2c.c	2004-09-28 16:26:26.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/i2c.c	2007-05-29 16:50:52.000000000 -0500
@@ -56,7 +56,13 @@
 	writeb(0x0, I2CCCR);
 
 	/* set clock */
+#ifdef CONFIG_DEBV1	
+	writeb(0x37, I2CFDR);
+#elif defined(CONFIG_AMAZON)
+	writeb(0x37, I2CFDR);
+#else
 	writeb(0x3f, I2CFDR);
+#endif
 
 	/* set default filter */
 	writeb(0x10,I2CDFSRR);
diff -Naur u-boot-1.1.2/cpu/mpc85xx/interrupts.c uboot-1.1.2hsv/cpu/mpc85xx/interrupts.c
--- u-boot-1.1.2/cpu/mpc85xx/interrupts.c	2003-10-15 18:53:51.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/interrupts.c	2007-05-29 16:50:52.000000000 -0500
@@ -49,6 +49,22 @@
 	asm volatile("isync");
 }
 
+static __inline__ unsigned long get_dec (void)
+{
+	unsigned long val;
+
+	asm volatile ("mfdec %0":"=r" (val):);
+
+	return val;
+}
+
+
+static __inline__ void set_dec (unsigned long val)
+{
+	if (val)
+		asm volatile ("mtdec %0"::"r" (val));
+}
+
 void enable_interrupts (void)
 {
 	set_msr (get_msr() | MSR_EE);
@@ -62,9 +78,17 @@
 	return ((msr & MSR_EE) != 0);
 }
 
-/* interrupt is not supported yet */
 int interrupt_init (void)
 {
+	volatile immap_t *immr = (immap_t *)CFG_IMMR;
+
+	immr->im_pic.gcr = MPC85xx_PICGCR_RST;
+	while (immr->im_pic.gcr & MPC85xx_PICGCR_RST);
+	immr->im_pic.gcr = MPC85xx_PICGCR_M;
+	decrementer_count = get_tbclk() / CFG_HZ;
+	mtspr(SPRN_TCR, mfspr(SPRN_TCR) | TCR_PIE);
+	set_dec (decrementer_count);
+	set_msr (get_msr () | MSR_EE);
 	return (0);
 }
 
@@ -96,11 +120,11 @@
  */
 void timer_interrupt(struct pt_regs *regs)
 {
-	printf ("*** Timer Interrupt *** ");
 	timestamp++;
-
+	set_dec (decrementer_count);
+	mtspr(SPRN_TSR, TSR_PIS);
 #if defined(CONFIG_WATCHDOG)
-	if ((timestamp % 1000) == 0)
+	if ((timestamp % 1000) == 0) 
 		reset_85xx_watchdog();
 #endif /* CONFIG_WATCHDOG */
 }
diff -Naur u-boot-1.1.2/cpu/mpc85xx/pci.c uboot-1.1.2hsv/cpu/mpc85xx/pci.c
--- u-boot-1.1.2/cpu/mpc85xx/pci.c	2004-10-10 16:27:32.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/pci.c	2007-05-29 16:50:52.000000000 -0500
@@ -31,6 +31,7 @@
 
 
 #if defined(CONFIG_PCI)
+/* #define TRY_PCI2 */
 
 void
 pci_mpc85xx_init(struct pci_controller *hose)
@@ -40,37 +41,51 @@
 
 	u16 reg16;
 
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
+#ifdef CONFIG_AMAZON
+	hose->first_busno = 0;
+	hose->last_busno = 0;
+#else
 	hose->first_busno = 0;
 	hose->last_busno = 0xff;
-
+#endif
 	pci_set_region(hose->regions + 0,
+#ifndef TRY_PCI2
 		       CFG_PCI1_MEM_BASE,
 		       CFG_PCI1_MEM_PHYS,
 		       CFG_PCI1_MEM_SIZE,
+#else
+		       CFG_PCI2_MEM_BASE,
+		       CFG_PCI2_MEM_PHYS,
+		       CFG_PCI2_MEM_SIZE,
+#endif
 		       PCI_REGION_MEM);
 
 	pci_set_region(hose->regions + 1,
+#ifndef TRY_PCI2
 		       CFG_PCI1_IO_BASE,
 		       CFG_PCI1_IO_PHYS,
 		       CFG_PCI1_IO_SIZE,
+#else
+		       CFG_PCI2_IO_BASE,
+		       CFG_PCI2_IO_PHYS,
+		       CFG_PCI2_IO_SIZE,
+#endif
 		       PCI_REGION_IO);
 
 	hose->region_count = 2;
 
 	pci_setup_indirect(hose,
+#ifndef TRY_PCI2
 			   (CFG_IMMR+0x8000),
-			   (CFG_IMMR+0x8004));
-
-	pci_read_config_word (PCI_BDF(0,0,0), PCI_COMMAND, &reg16);
-	reg16 |= PCI_COMMAND_SERR | PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
-	pci_write_config_word(PCI_BDF(0,0,0), PCI_COMMAND, reg16);
-
-	/*
-	 * Clear non-reserved bits in status register.
-	 */
-	pci_write_config_word(PCI_BDF(0,0,0), PCI_STATUS, 0xffff);
-	pci_write_config_byte(PCI_BDF(0,0,0), PCI_LATENCY_TIMER,0x80);
+			   (CFG_IMMR+0x8004)
+#else
+			   (CFG_IMMR+0x9000),
+			   (CFG_IMMR+0x9004)
+#endif
+		);
 
+#ifndef TRY_PCI2
 	pcix->potar1   = (CFG_PCI1_MEM_BASE >> 12) & 0x000fffff;
 	pcix->potear1  = 0x00000000;
 	pcix->powbar1  = (CFG_PCI1_MEM_BASE >> 12) & 0x000fffff;
@@ -82,6 +97,19 @@
 	pcix->powbar2  = (CFG_PCI1_IO_BASE >> 12) & 0x000fffff;
 	pcix->powbear2 = 0x00000000;
 	pcix->powar2   = 0x80088017;	/* 16M IO space */
+#else
+	pcix->potar1   = (CFG_PCI2_MEM_BASE >> 12) & 0x000fffff;
+	pcix->potear1  = 0x00000000;
+	pcix->powbar1  = (CFG_PCI2_MEM_BASE >> 12) & 0x000fffff;
+	pcix->powbear1 = 0x00000000;
+	pcix->powar1   = 0x8004401c;	/* 512M MEM space */
+
+	pcix->potar2   = 0x00000000;
+	pcix->potear2  = 0x00000000;
+	pcix->powbar2  = (CFG_PCI2_IO_BASE >> 12) & 0x000fffff;
+	pcix->powbear2 = 0x00000000;
+	pcix->powar2   = 0x80088017;	/* 16M IO space */
+#endif
 
 	pcix->pitar1 = 0x00000000;
 	pcix->piwbar1 = 0x00000000;
@@ -93,6 +121,16 @@
 	 */
 	pci_register_hose(hose);
 
+	pci_read_config_word (PCI_BDF(0,0,0), PCI_COMMAND, &reg16);
+	reg16 |= PCI_COMMAND_SERR | PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(PCI_BDF(0,0,0), PCI_COMMAND, reg16);
+
+	/*
+	 * Clear non-reserved bits in status register.
+	 */
+	pci_write_config_word(PCI_BDF(0,0,0), PCI_STATUS, 0xffff);
+	pci_write_config_byte(PCI_BDF(0,0,0), PCI_LATENCY_TIMER,0x80);
+	
 #if defined(CONFIG_MPC8555CDS) || defined(CONFIG_MPC8541CDS)
 	/*
 	 * This is a SW workaround for an apparent HW problem
@@ -106,6 +144,7 @@
 	 *
 	 * Pick on the Tundra, Device 17, to get it right.
 	 */
+	/* cyclades: should we worry about this PCI controller HW bug? */
 	{
 		u8 header_type;
 
@@ -115,8 +154,170 @@
 					  &header_type);
 	}
 #endif
+
+#if defined(CONFIG_AMAZON)
+	/*
+	 * This is a SW workaround for an apparent HW problem
+	 * in the PCI controller on the MPC85555/41 CDS boards.
+	 * The first config cycle must be to a valid, known
+	 * device on the PCI bus in order to trick the PCI
+	 * controller state machine into a known valid state.
+	 * Without this, the first config cycle has the chance
+	 * of hanging the controller permanently, just leaving
+	 * it in a semi-working state, or leaving it working.
+	 *
+	 * Pick on the Marvel Mac/Phy , Device 11, to get it right.
+	 */
+	{
+		u8 header_type;
+
+		pci_hose_read_config_byte(hose,
+					  PCI_BDF(0,11,0),
+					  PCI_HEADER_TYPE,
+					  &header_type);
+	}
+#endif
+
+/* cyclades: seems DEB doesn't have this problem */
+/* cyclades: DEB met this PCI controller HW problem. */
+#if defined(CONFIG_DEB)
+	/*
+	 * This is a SW workaround for an apparent HW problem
+	 * in the PCI controller on the MPC85555/41 CDS boards.
+	 * The first config cycle must be to a valid, known
+	 * device on the PCI bus in order to trick the PCI
+	 * controller state machine into a known valid state.
+	 * Without this, the first config cycle has the chance
+	 * of hanging the controller permanently, just leaving
+	 * it in a semi-working state, or leaving it working.
+	 *
+	 * Pick on the Tundra, Device 17, to get it right.
+	 */
+	/*
+	 * cyclades: in DEB, pick PCMCIA controller on PCI1,
+	 * bus:0 , device:17 , function:0 
+	 */
+/* 	{ */
+/* 		u8 header_type; */
+
+/* 	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__); */
+/* 		pci_hose_read_config_byte(hose, */
+/* 					  PCI_BDF(0,17,0), */
+/* 					  PCI_HEADER_TYPE, */
+/* 					  &header_type); */
+/* 	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__); */
+/* 	} */
+#endif
 
+/* cyclades: KVMMAX should handle this PCI controller HW problem. */
+#if defined(CONFIG_KVMMAX)
+#if defined(TRY_PCI2)
+	/*
+	 * cyclades: in KVMMAX, pick PCMCIA controller on PCI2,
+	 * bus:0 , device:17 , function:0 
+	 */
+	{
+		u8 header_type;
+
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
+		pci_hose_read_config_byte(hose,
+					  PCI_BDF(0,17,0),
+					  PCI_HEADER_TYPE,
+					  &header_type);
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
+	}
+#endif
+#endif
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
 	hose->last_busno = pci_hose_scan(hose);
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
 }
 
+
+#ifdef CONFIG_AMAZON
+
+void
+pci_mpc85xx_init_2(struct pci_controller *hose)
+{
+	volatile immap_t    *immap = (immap_t *)CFG_CCSRBAR;
+	volatile ccsr_pcix_t *pcix = &immap->im_pcix;
+
+	u16 reg16;
+
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
+
+	hose->first_busno = 1;
+	hose->last_busno = 1;
+
+	pci_set_region(hose->regions + 0,
+		       CFG_PCI2_MEM_BASE,
+		       CFG_PCI2_MEM_PHYS,
+		       CFG_PCI2_MEM_SIZE,
+		       PCI_REGION_MEM);
+
+	pci_set_region(hose->regions + 1,
+		       CFG_PCI2_IO_BASE,
+		       CFG_PCI2_IO_PHYS,
+		       CFG_PCI2_IO_SIZE,
+		       PCI_REGION_IO);
+
+	hose->region_count = 2;
+
+	pci_setup_indirect(hose,
+			   (CFG_IMMR+0x9000),
+			   (CFG_IMMR+0x9004)
+		);
+
+  pcix = (((unsigned char *) pcix) + 0x1000); /* offset for PCI2 */
+
+	pcix->potar1   = (CFG_PCI2_MEM_BASE >> 12) & 0x000fffff;
+	pcix->potear1  = 0x00000000;
+	pcix->powbar1  = (CFG_PCI2_MEM_BASE >> 12) & 0x000fffff;
+	pcix->powbear1 = 0x00000000;
+	pcix->powar1   = 0x8004401c;	/* 512M MEM space */
+
+	pcix->potar2   = 0x00000000;
+	pcix->potear2  = 0x00000000;
+	pcix->powbar2  = (CFG_PCI2_IO_BASE >> 12) & 0x000fffff;
+	pcix->powbear2 = 0x00000000;
+	pcix->powar2   = 0x80088017;	/* 16M IO space */
+
+	pcix->pitar1 = 0x00000000;
+	pcix->piwbar1 = 0x00000000;
+	pcix->piwar1 = 0xa0f5501e;	/* Enable, Prefetch, Local Mem,
+					 * Snoop R/W, 2G */
+
+	/*
+	 * Hose scan.
+	 */
+	pci_register_hose(hose);
+
+	pci_read_config_word (PCI_BDF(0,0,0), PCI_COMMAND, &reg16);
+	reg16 |= PCI_COMMAND_SERR | PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(PCI_BDF(0,0,0), PCI_COMMAND, reg16);
+
+	/*
+	 * Clear non-reserved bits in status register.
+	 */
+	pci_write_config_word(PCI_BDF(0,0,0), PCI_STATUS, 0xffff);
+	pci_write_config_byte(PCI_BDF(0,0,0), PCI_LATENCY_TIMER,0x80);
+	
+#if 1 /* DHS not sure if this WORKAROUND is needed */
+	{
+		u8 header_type;
+
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
+		pci_hose_read_config_byte(hose,
+					  PCI_BDF(0,17,0),
+					  PCI_HEADER_TYPE,
+					  &header_type);
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
+	}
+#endif
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
+	hose->last_busno = pci_hose_scan(hose);
+	debug("%s:%s:%d \n", __FILE__, __FUNCTION__, __LINE__);
+}
+#endif /* CONFIG_AMAZON */
+
 #endif /* CONFIG_PCI */
diff -Naur u-boot-1.1.2/cpu/mpc85xx/spd_sdram.c uboot-1.1.2hsv/cpu/mpc85xx/spd_sdram.c
--- u-boot-1.1.2/cpu/mpc85xx/spd_sdram.c	2004-08-01 18:03:09.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/spd_sdram.c	2007-05-29 16:50:52.000000000 -0500
@@ -67,6 +67,64 @@
 	return ((row_dens >> 2) | ((row_dens & 3) << 6)) << 24;
 }
 
+static void dump_spd_eeprom(spd_eeprom_t *spd)
+{
+  if (!spd) {
+    debug("ERROR: passed in spd is NULL. \n");
+    return;
+  }
+
+  debug("info_size: 0x%02X \n",     spd->info_size);   /* # of bytes written into serial memory           */
+  debug("chip_size: 0x%02X \n",     spd->chip_size);   /* Total # of bytes of SPD memory device           */
+  debug("mem_type: 0x%02X \n",      spd->mem_type);    /* Fundamental memory type (FPM, EDO, SDRAM...)    */
+  debug("nrow_addr: 0x%02X \n",     spd->nrow_addr);   /* # of Row Addresses on this assembly             */
+  debug("ncol_addr: 0x%02X \n",     spd->ncol_addr);   /* # of Column Addresses on this assembly          */
+  debug("nrows: 0x%02X \n",         spd->nrows);       /* # of Module Rows on this assembly               */
+  debug("dataw_lsb: 0x%02X \n",     spd->dataw_lsb);   /* Data Width of this assembly                     */
+  debug("dataw_msb: 0x%02X \n",     spd->dataw_msb);   /* ... Data Width continuation                     */
+  debug("voltage: 0x%02X \n",       spd->voltage);     /* Voltage interface standard of this assembly     */
+  debug("clk_cycle: 0x%02X \n",     spd->clk_cycle);   /* SDRAM Cycle time at CL=X                        */
+  debug("clk_access: 0x%02X \n",    spd->clk_access);  /* SDRAM Access from Clock at CL=X                 */
+  debug("config: 0x%02X \n",        spd->config);      /* DIMM Configuration type (non-parity, ECC)       */
+  debug("refresh: 0x%02X \n",       spd->refresh);     /* Refresh Rate/Type                               */
+  debug("primw: 0x%02X \n",         spd->primw);       /* Primary SDRAM Width                             */
+  debug("ecw: 0x%02X \n",           spd->ecw);         /* Error Checking SDRAM width                      */
+  debug("min_delay: 0x%02X \n",     spd->min_delay);   /* Min Clock Delay for Back to Back Random Address */
+  debug("burstl: 0x%02X \n",        spd->burstl);      /* Burst Lengths Supported                         */
+  debug("nbanks: 0x%02X \n",        spd->nbanks);      /* # of Banks on Each SDRAM Device                 */
+  debug("cas_lat: 0x%02X \n",       spd->cas_lat);     /* CAS# Latencies Supported                        */
+  debug("cs_lat: 0x%02X \n",        spd->cs_lat);      /* CS# Latency                                     */
+  debug("write_lat: 0x%02X \n",     spd->write_lat);   /* Write Latency (also called Write Recovery time) */
+  debug("mod_attr: 0x%02X \n",      spd->mod_attr);    /* SDRAM Module Attributes                         */
+  debug("dev_attr: 0x%02X \n",      spd->dev_attr);    /* SDRAM Device Attributes                         */
+  debug("clk_cycle2: 0x%02X \n",    spd->clk_cycle2);  /* Min SDRAM Cycle time at CL=X-1                  */
+  debug("clk_access2: 0x%02X \n",   spd->clk_access2); /* SDRAM Access from Clock at CL=X-1               */
+  debug("clk_cycle3: 0x%02X \n",    spd->clk_cycle3);  /* Min SDRAM Cycle time at CL=X-2                  */
+  debug("clk_access3: 0x%02X \n",   spd->clk_access3); /* Max SDRAM Access from Clock at CL=X-2           */
+  debug("trp: 0x%02X \n",           spd->trp);         /* Min Row Precharge Time (tRP)                    */
+  debug("trrd: 0x%02X \n",          spd->trrd);        /* Min Row Active to Row Active (tRRD)             */
+  debug("trcd: 0x%02X \n",          spd->trcd);        /* Min RAS to CAS Delay (tRCD)                     */
+  debug("tras: 0x%02X \n",          spd->tras);        /* Minimum RAS Pulse Width (tRAS)                  */
+  debug("row_dens: 0x%02X \n",      spd->row_dens);    /* Density of each row on module                   */
+  debug("ca_setup: 0x%02X \n",      spd->ca_setup);    /* Command and Address signal input setup time     */
+  debug("ca_hold: 0x%02X \n",       spd->ca_hold);     /* Command and Address signal input hold time      */
+  debug("data_setup: 0x%02X \n",    spd->data_setup);  /* Data signal input setup time                    */
+  debug("data_hold: 0x%02X \n",     spd->data_hold);   /* Data signal input hold time                     */
+  debug("sset[26]: 0x%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X \n",      spd->sset[0], spd->sset[1], spd->sset[2], spd->sset[3], spd->sset[4], spd->sset[5], spd->sset[6], spd->sset[7], spd->sset[8], spd->sset[9], spd->sset[10], spd->sset[11], spd->sset[12], spd->sset[13], spd->sset[14], spd->sset[15], spd->sset[16], spd->sset[17], spd->sset[18], spd->sset[19], spd->sset[20], spd->sset[21], spd->sset[22], spd->sset[23], spd->sset[24], spd->sset[25]);    /* Superset Information (may be used in future)    */
+  debug("spd_rev: 0x%02X \n",       spd->spd_rev);     /* SPD Data Revision Code                          */
+  debug("cksum: 0x%02X \n",         spd->cksum);       /* Checksum for bytes 0-62                         */
+  debug("mid[8]: 0x%02X%02X%02X%02X_%02X%02X%02X%02X \n",        spd->mid[0], spd->mid[1], spd->mid[2], spd->mid[3], spd->mid[4], spd->mid[5], spd->mid[6], spd->mid[7]);      /* Manufacturer's JEDEC ID code per JEP-108E       */
+  debug("mloc: 0x%02X \n",          spd->mloc);        /* Manufacturing Location                          */
+  debug("mpart[18]: 0x%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X \n",     spd->mpart[0], spd->mpart[1], spd->mpart[2], spd->mpart[3], spd->mpart[4], spd->mpart[5], spd->mpart[6], spd->mpart[7], spd->mpart[8], spd->mpart[9], spd->mpart[10], spd->mpart[11], spd->mpart[12], spd->mpart[13], spd->mpart[14], spd->mpart[15], spd->mpart[16], spd->mpart[17]);   /* Manufacturer's Part Number                      */
+  debug("rev[2]: 0x%02X%02X \n",        spd->rev[0], spd->rev[1]);      /* Revision Code                                   */
+  debug("mdate[2]: 0x%02X%02X \n",      spd->mdate[0], spd->mdate[1]);    /* Manufacturing Date                              */
+  debug("sernum[4]: 0x%02X%02X%02X%02X \n",     spd->sernum[0], spd->sernum[1], spd->sernum[2], spd->sernum[3]);   /* Assembly Serial Number                          */
+  debug("mspec[27]: 0x%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X%02X_%02X%02X%02X \n",     spd->mspec[0], spd->mspec[1], spd->mspec[2], spd->mspec[3], spd->mspec[4], spd->mspec[5], spd->mspec[6], spd->mspec[7], spd->mspec[8], spd->mspec[9], spd->mspec[10], spd->mspec[11], spd->mspec[12], spd->mspec[13], spd->mspec[14], spd->mspec[15], spd->mspec[16], spd->mspec[17], spd->mspec[18], spd->mspec[19], spd->mspec[20], spd->mspec[21], spd->mspec[22], spd->mspec[23], spd->mspec[24], spd->mspec[25], spd->mspec[26]);   /* Manufacturer Specific Data                      */
+  debug("freq: 0x%02X \n",          spd->freq);        /* Intel specification frequency                   */
+  debug("intel_cas: 0x%02X \n",     spd->intel_cas);   /* Intel Specification CAS# Latency support        */
+
+  return;
+}
 
 long int
 spd_sdram(void)
@@ -82,8 +140,13 @@
 	unsigned char caslat;
 	unsigned int ram_tlb_index;
 	unsigned int ram_tlb_address;
+	unsigned int spd_addr;
+	spd_addr = SPD_EEPROM_ADDRESS;
 
-	CFG_READ_SPD(SPD_EEPROM_ADDRESS, 0, 1, (uchar *) & spd, sizeof (spd));
+	memset((void *)&spd, 0, sizeof(spd));
+	debug("DDR SPD EEPROM Address: 0x%02X \n", spd_addr);
+	CFG_READ_SPD(spd_addr, 0, 1, (uchar *) & spd, sizeof (spd));
+	dump_spd_eeprom(&spd);
 
 	if (spd.nrows > 2) {
 		puts("DDR:Only two chip selects are supported on ADS.\n");
@@ -157,12 +220,13 @@
 
 	/*
 	 * Configure DDR TLB1 entries.
-	 * Starting at TLB1 8, use no more than 8 TLB1 entries.
+	 * cyclades: DDR TLB1 entries: 8 to 14, entry 15 is used by bootflash
+	 * Starting at TLB1 8, use no more than 7 TLB1 entries.
 	 */
 	ram_tlb_index = 8;
 	ram_tlb_address = (unsigned int)CFG_DDR_SDRAM_BASE;
 	while (ram_tlb_address < (memsize * 1024 * 1024)
-	      && ram_tlb_index < 16) {
+	      && ram_tlb_index < 15) {
 		mtspr(MAS0, TLB1_MAS0(1, ram_tlb_index, 0));
 		mtspr(MAS1, TLB1_MAS1(1, 1, 0, 0, tlb_size));
 		mtspr(MAS2, TLB1_MAS2(E500_TLB_EPN(ram_tlb_address),
@@ -346,7 +410,10 @@
 	 * SDRAM_CLK_CNTL[0] = Source synchronous enable == 1
 	 * SDRAM_CLK_CNTL[5-7] = Clock Adjust == 3 (3/4 cycle late)
 	 */
-	ddr->sdram_clk_cntl = 0x83000000;
+/* 	ddr->sdram_clk_cntl = 0x83000000; */
+	/* cyclades: seems this setting works for both DEB and MAX */
+	ddr->sdram_clk_cntl = 0x82000000;
+	debug("DDR:sdram_clk_cntl=0x%08x\n", ddr->sdram_clk_cntl);
 #endif
 
 	/*
diff -Naur u-boot-1.1.2/cpu/mpc85xx/speed.c uboot-1.1.2hsv/cpu/mpc85xx/speed.c
--- u-boot-1.1.2/cpu/mpc85xx/speed.c	2004-08-01 17:48:20.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/speed.c	2007-05-29 16:50:52.000000000 -0500
@@ -31,6 +31,11 @@
 
 /* --------------------------------------------------------------- */
 
+#if defined(CONFIG_KVMMAX) || defined(CONFIG_DEB) || defined(CONFIG_AMAZON)
+extern unsigned long get_pci1_clock_freq(void);
+extern unsigned long get_pci2_clock_freq(void);
+#endif
+
 void get_sys_info (sys_info_t * sysInfo)
 {
 	volatile immap_t    *immap = (immap_t *)CFG_IMMR;
@@ -82,7 +87,7 @@
 {
 	DECLARE_GLOBAL_DATA_PTR;
 	sys_info_t sys_info;
-#if defined(CONFIG_MPC8560)
+#if defined(CONFIG_MPC8560) || defined(CONFIG_MPC8555) || defined(CONFIG_MPC8541)
 	volatile immap_t *immap = (immap_t *) CFG_IMMR;
 	uint sccr, dfbrg;
 
@@ -94,7 +99,11 @@
 	get_sys_info (&sys_info);
 	gd->cpu_clk = sys_info.freqProcessor;
 	gd->bus_clk = sys_info.freqSystemBus;
-#if defined(CONFIG_MPC8560)
+#if defined(CONFIG_KVMMAX) || defined(CONFIG_DEB) || defined(CONFIG_AMAZON)
+	gd->pci1_clk = get_pci1_clock_freq();
+	gd->pci2_clk = get_pci2_clock_freq();
+#endif
+#if defined(CONFIG_MPC8560) || defined(CONFIG_MPC8555) || defined(CONFIG_MPC8541)
 	gd->vco_out = 2*sys_info.freqSystemBus;
 	gd->cpm_clk = gd->vco_out / 2;
 	gd->scc_clk = gd->vco_out / 4;
diff -Naur u-boot-1.1.2/cpu/mpc85xx/start.S uboot-1.1.2hsv/cpu/mpc85xx/start.S
--- u-boot-1.1.2/cpu/mpc85xx/start.S	2004-08-01 18:03:10.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/start.S	2007-05-29 16:50:52.000000000 -0500
@@ -115,8 +115,8 @@
 	 * BookE: isync after MSR,PID; msync_isync after tlbivax & tlbwe
 	 * E500:  msync,isync before L1CSR0
 	 * E500:  isync after BBEAR,BBTAR,BUCSR,DBCR0,DBCR1,HID0,HID1,
-	 *        L1CSR0, L1CSR1, MAS[0,1,2,3,4,6],MMUCSR0, PID[0,1,2],
-	 *        SPEFCSR
+	 *	  L1CSR0, L1CSR1, MAS[0,1,2,3,4,6],MMUCSR0, PID[0,1,2],
+	 *	  SPEFCSR
 	 */
 
 	/* invalidate d-cache */
@@ -155,6 +155,17 @@
 	mtspr	MCSR,r0
 	mtspr	DEAR,r0
 
+#ifdef CONFIG_BDI_SWITCH
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+#else		
 	mtspr	DBCR0,r0
 	mtspr	DBCR1,r0
 	mtspr	DBCR2,r0
@@ -165,6 +176,7 @@
 
 	mfspr	r1,DBSR
 	mtspr	DBSR,r1		/* Clear all valid bits */
+#endif	
 
 	mtspr	PID0,r0
 	mtspr	PID1,r0
@@ -172,21 +184,21 @@
 	mtspr	TCR,r0
 
 	mtspr	BUCSR,r0	/* disable branch prediction */
-	mtspr   MAS4,r0
-	mtspr   MAS6,r0
+	mtspr	MAS4,r0
+	mtspr	MAS6,r0
 	isync
 
 	/* Setup interrupt vectors */
-	lis     r1,0xfff8
+	lis	r1,TEXT_BASE@h
 	mtspr IVPR, r1
 
-	li      r1,0x0100
+	li	r1,0x0100
 	mtspr	IVOR0,r1	/* 0: Critical input */
-	li      r1,0x0200
+	li	r1,0x0200
 	mtspr	IVOR1,r1	/* 1: Machine check */
-	li      r1,0x0300
+	li	r1,0x0300
 	mtspr	IVOR2,r1	/* 2: Data storage */
-	li      r1,0x0400
+	li	r1,0x0400
 	mtspr	IVOR3,r1	/* 3: Instruction storage */
 	li	r1,0x0500
 	mtspr	IVOR4,r1	/* 4: External interrupt */
@@ -196,16 +208,20 @@
 	mtspr	IVOR6,r1	/* 6: Program check */
 	li	r1,0x0800
 	mtspr	IVOR7,r1	/* 7: floating point unavailable */
-	li	r1,0x0c00
+	li	r1,0x0900
 	mtspr	IVOR8,r1	/* 8: System call */
 	/* 9: Auxiliary processor unavailable(unsupported) */
-	li	r1,0x1000
+	li	r1,0x0a00
 	mtspr	IVOR10,r1	/* 10: Decrementer */
-	li	r1,0x1400
+	li	r1,0x0b00
+	mtspr	IVOR11,r1	/* 11: Interval timer */
+	li	r1,0x0c00
+	mtspr	IVOR12,r1	/* 11: Watchdog timer */
+	li	r10,0x0d00
 	mtspr	IVOR13,r1	/* 13: Data TLB error */
-	li	r1,0x1300
+	li	r1,0x0e00
 	mtspr	IVOR14,r1	/* 14: Instruction TLB error */
-	li	r1,0x2000
+	li	r1,0x0f00
 	mtspr	IVOR15,r1	/* 15: Debug */
 
 	/*
@@ -214,16 +230,16 @@
 	 * Note: There is a fixup earlier for Errata CPU4 on
 	 * Rev 1 parts that must precede this MMU invalidation.
 	 */
-	li      r2, 0x001e
-	mtspr   MMUCSR0, r2
+	li	r2, 0x001e
+	mtspr	MMUCSR0, r2
 	isync
 
 	/*
 	 * Invalidate all TLB0 entries.
 	 */
-	li 	r3,4
+	li	r3,4
 	li	r4,0
-	tlbivax	r4,r3
+	tlbivax r4,r3
 	/*
 	 * To avoid REV1 Errata CPU6 issues, make sure
 	 * the instruction following tlbivax is not a store.
@@ -240,7 +256,7 @@
 	 * (e.g. board/<yourboard>/init.S)
 	 *
 	 */
-	bl 	tlb1_entry
+	bl	tlb1_entry
 	mr	r5,r0
 	li	r1,0x0020	/* max 16 TLB1 plus some TLB0 entries */
 	mtctr	r1
@@ -269,8 +285,8 @@
 	lis	r4, CFG_CCSRBAR_DEFAULT@h
 	ori	r4, r4, CFG_CCSRBAR_DEFAULT@l
 
-	lis   	r5, CFG_CCSRBAR@h
-	ori   	r5, r5, CFG_CCSRBAR@l
+	lis	r5, CFG_CCSRBAR@h
+	ori	r5, r5, CFG_CCSRBAR@l
 	srwi	r6,r5,12
 	stw	r6, 0(r4)
 	isync
@@ -284,13 +300,44 @@
 	lwz	r5, CFG_CCSRBAR@l(r3)
 	isync
 #endif
+
+#ifdef CONFIG_AMAZON
+       /*
+        * 2nd phase of TLB configuration. This phase is performed following relocation of CCSRBAR. 
+        * A 16M boot flash will overlay the default postion of CCSRBAR. 
+        */
+	bl	tlb2_entry
+	mr	r5,r0
+	li	r1,0x0020	/* max 16 TLB1 plus some TLB0 entries */
+	mtctr	r1
+	lwzu	r4,0(r5)	/* how many TLB1 entries we actually use */
+
+2:	cmpwi	r4,0
+	beq	3f
+	lwzu	r0,4(r5)
+	lwzu	r1,4(r5)
+	lwzu	r2,4(r5)
+	lwzu	r3,4(r5)
+	mtspr	MAS0,r0
+	mtspr	MAS1,r1
+	mtspr	MAS2,r2
+	mtspr	MAS3,r3
+	isync
+	msync
+	tlbwe
+	isync
+	addi	r4,r4,-1
+	bdnz	2b
+
+3:
+#endif
 
 
 	/* set up local access windows, defined at board/<boardname>/init.S */
 	lis	r7,CFG_CCSRBAR@h
 	ori	r7,r7,CFG_CCSRBAR@l
 
-	bl 	law_entry
+	bl	law_entry
 	mr	r6,r0
 	li	r1,0x0007	/* 8 LAWs, but reserve one for boot-over-rio-or-pci */
 	mtctr	r1
@@ -314,7 +361,12 @@
 1:	bl	3f
 	b	_start
 
-3:	li	r0,0
+3:
+#ifdef CONFIG_BDI_SWITCH
+	mfmsr	r0
+#else
+	li	r0,0
+#endif
 	mtspr	SRR1,r0		/* Keep things disabled for now */
 	mflr	r1
 	mtspr	SRR0,r1
@@ -351,6 +403,7 @@
 	mtmsr	r1			/* change MSR */
 	isync
 
+	/* cyclades:	Should we use RTC as Time Base Clock? */
 	/* Enable Time Base and Select Time Base Clock */
 	lis	r0,HID0_EMCP@h		/* Enable machine check */
 	ori	r0,r0,0x4000		/* time base is processor clock */
@@ -380,35 +433,35 @@
 
 /* L1 DCache is used for initial RAM */
 	mfspr	r2, L1CSR0
-	ori    	r2, r2, 0x0003
-	oris   	r2, r2, 0x0001
-	mtspr  	L1CSR0, r2	/* enable/invalidate L1 Dcache */
+	ori	r2, r2, 0x0003
+	oris	r2, r2, 0x0001
+	mtspr	L1CSR0, r2	/* enable/invalidate L1 Dcache */
 	isync
 
 	/* Allocate Initial RAM in data cache.
 	 */
-	lis     r3, CFG_INIT_RAM_ADDR@h
-	ori     r3, r3, CFG_INIT_RAM_ADDR@l
-	li      r2, 512 /* 512*32=16K */
-	mtctr   r2
+	lis	r3, CFG_INIT_RAM_ADDR@h
+	ori	r3, r3, CFG_INIT_RAM_ADDR@l
+	li	r2, 512 /* 512*32=16K */
+	mtctr	r2
 	li	r0, 0
 1:
 	dcbz	r0, r3
-	dcbtls  0,r0, r3
-	addi    r3, r3, 32
-	bdnz    1b
+	dcbtls	0,r0, r3
+	addi	r3, r3, 32
+	bdnz	1b
 
 #ifndef CFG_RAMBOOT
-	/* Calculate absolute address in FLASH and jump there           */
+	/* Calculate absolute address in FLASH and jump there		*/
 	/*--------------------------------------------------------------*/
-	lis     r3, CFG_MONITOR_BASE@h
-	ori     r3, r3, CFG_MONITOR_BASE@l
-	addi    r3, r3, in_flash - _start + EXC_OFF_SYS_RESET
-	mtlr    r3
+	lis	r3, CFG_MONITOR_BASE@h
+	ori	r3, r3, CFG_MONITOR_BASE@l
+	addi	r3, r3, in_flash - _start + EXC_OFF_SYS_RESET
+	mtlr	r3
 	blr
 
 in_flash:
-#endif  /* CFG_RAMBOOT */
+#endif	/* CFG_RAMBOOT */
 
 	/* Setup the stack in initial RAM,could be L2-as-SRAM or L1 dcache*/
 	lis	r1,CFG_INIT_RAM_ADDR@h
@@ -439,7 +492,8 @@
 	CRIT_EXCEPTION(0x0100, CritcalInput, CritcalInputException)
 #endif
 /* Machine check --FIXME-- Should be MACH_EXCEPTION */
-	CRIT_EXCEPTION(0x0200, MachineCheck, MachineCheckException)
+/*	CRIT_EXCEPTION(0x0200, MachineCheck, MachineCheckException) */
+	MACH_EXCEPTION(0x0200, MachineCheck, MachineCheckException)
 
 /* Data Storage exception. */
 	STD_EXCEPTION(0x0300, DataStorage, UnknownException)
@@ -485,105 +539,86 @@
 	/* No FPU on MPC85xx.  This exception is not supposed to happen.
 	*/
 	STD_EXCEPTION(0x0800, FPUnavailable, UnknownException)
-	STD_EXCEPTION(0x0900, Decrementer, timer_interrupt)
-	STD_EXCEPTION(0x0a00, Trap_0a, UnknownException)
-	STD_EXCEPTION(0x0b00, Trap_0b, UnknownException)
 
-	. = 0x0c00
+	. = 0x0900
 /*
  * r0 - SYSCALL number
  * r3-... arguments
  */
 SystemCall:
-	addis   r11,r0,0                /* get functions table addr */
-	ori     r11,r11,0               /* Note: this code is patched in trap_init */
-	addis   r12,r0,0                /* get number of functions */
-	ori     r12,r12,0
-
-	cmplw   0, r0, r12
-	bge     1f
-
-	rlwinm  r0,r0,2,0,31            /* fn_addr = fn_tbl[r0] */
-	add     r11,r11,r0
-	lwz     r11,0(r11)
-
-	li      r20,0xd00-4             /* Get stack pointer */
-	lwz     r12,0(r20)
-	subi    r12,r12,12              /* Adjust stack pointer */
-	li      r0,0xc00+_end_back-SystemCall
-	cmplw   0, r0, r12              /* Check stack overflow */
-	bgt     1f
-	stw     r12,0(r20)
-
-	mflr    r0
-	stw     r0,0(r12)
-	mfspr   r0,SRR0
-	stw     r0,4(r12)
-	mfspr   r0,SRR1
-	stw     r0,8(r12)
-
-	li      r12,0xc00+_back-SystemCall
-	mtlr    r12
-	mtspr   SRR0,r11
+	addis	r11,r0,0		/* get functions table addr */
+	ori	r11,r11,0		/* Note: this code is patched in trap_init */
+	addis	r12,r0,0		/* get number of functions */
+	ori	r12,r12,0
+
+	cmplw	0, r0, r12
+	bge	1f
+
+	rlwinm	r0,r0,2,0,31		/* fn_addr = fn_tbl[r0] */
+	add	r11,r11,r0
+	lwz	r11,0(r11)
+
+	li	r20,0xd00-4		/* Get stack pointer */
+	lwz	r12,0(r20)
+	subi	r12,r12,12		/* Adjust stack pointer */
+	li	r0,0xc00+_end_back-SystemCall
+	cmplw	0, r0, r12		/* Check stack overflow */
+	bgt	1f
+	stw	r12,0(r20)
+
+	mflr	r0
+	stw	r0,0(r12)
+	mfspr	r0,SRR0
+	stw	r0,4(r12)
+	mfspr	r0,SRR1
+	stw	r0,8(r12)
+
+	li	r12,0xc00+_back-SystemCall
+	mtlr	r12
+	mtspr	SRR0,r11
 
-1:      SYNC
+1:	SYNC
 	rfi
 _back:
 
-	mfmsr   r11                     /* Disable interrupts */
-	li      r12,0
-	ori     r12,r12,MSR_EE
-	andc    r11,r11,r12
-	SYNC                            /* Some chip revs need this... */
-	mtmsr   r11
+	mfmsr	r11			/* Disable interrupts */
+	li	r12,0
+	ori	r12,r12,MSR_EE
+	andc	r11,r11,r12
+	SYNC				/* Some chip revs need this... */
+	mtmsr	r11
 	SYNC
 
-	li      r12,0xd00-4             /* restore regs */
-	lwz     r12,0(r12)
+	li	r12,0xd00-4		/* restore regs */
+	lwz	r12,0(r12)
 
-	lwz     r11,0(r12)
-	mtlr    r11
-	lwz     r11,4(r12)
-	mtspr   SRR0,r11
-	lwz     r11,8(r12)
-	mtspr   SRR1,r11
-
-	addi    r12,r12,12              /* Adjust stack pointer */
-	li      r20,0xd00-4
-	stw     r12,0(r20)
+	lwz	r11,0(r12)
+	mtlr	r11
+	lwz	r11,4(r12)
+	mtspr	SRR0,r11
+	lwz	r11,8(r12)
+	mtspr	SRR1,r11
+
+	addi	r12,r12,12		/* Adjust stack pointer */
+	li	r20,0xd00-4
+	stw	r12,0(r20)
 
 	SYNC
 	rfi
 _end_back:
 
-	STD_EXCEPTION(0xd00, SingleStep, UnknownException)
-
-	STD_EXCEPTION(0xe00, Trap_0e, UnknownException)
-	STD_EXCEPTION(0xf00, Trap_0f, UnknownException)
-
-	STD_EXCEPTION(0x1000, PIT, PITException)
+	STD_EXCEPTION(0x0a00, Decrementer, timer_interrupt)
+	STD_EXCEPTION(0x0b00, IntervalTimer, UnknownException)
+/* cyclades:	watchdog timer is a critical exception */
+/*	STD_EXCEPTION(0x0c00, WatchdogTimer, UnknownException) */
+	CRIT_EXCEPTION(0x0c00, WatchdogTimer, UnknownException)
 
-	STD_EXCEPTION(0x1100, InstructionTLBMiss, UnknownException)
-	STD_EXCEPTION(0x1200, DataTLBMiss, UnknownException)
-	STD_EXCEPTION(0x1300, InstructionTLBError, UnknownException)
-	STD_EXCEPTION(0x1400, DataTLBError, UnknownException)
-
-	STD_EXCEPTION(0x1500, Reserved5, UnknownException)
-	STD_EXCEPTION(0x1600, Reserved6, UnknownException)
-	STD_EXCEPTION(0x1700, Reserved7, UnknownException)
-	STD_EXCEPTION(0x1800, Reserved8, UnknownException)
-	STD_EXCEPTION(0x1900, Reserved9, UnknownException)
-	STD_EXCEPTION(0x1a00, ReservedA, UnknownException)
-	STD_EXCEPTION(0x1b00, ReservedB, UnknownException)
-
-	STD_EXCEPTION(0x1c00, DataBreakpoint, UnknownException)
-	STD_EXCEPTION(0x1d00, InstructionBreakpoint, UnknownException)
-	STD_EXCEPTION(0x1e00, PeripheralBreakpoint, UnknownException)
-	STD_EXCEPTION(0x1f00, DevPortBreakpoint, UnknownException)
+	STD_EXCEPTION(0x0d00, DataTLBError, UnknownException)
+	STD_EXCEPTION(0x0e00, InstructionTLBError, UnknownException)
 
-	CRIT_EXCEPTION(0x2000, DebugBreakpoint, DebugException )
+	CRIT_EXCEPTION(0x0f00, DebugBreakpoint, DebugException )
 
-	.globl  _end_of_vectors
+	.globl	_end_of_vectors
 _end_of_vectors:
 
 
@@ -672,14 +707,44 @@
 	REST_GPR(31, r1)
 	lwz	r2,_NIP(r1)	/* Restore environment */
 	lwz	r0,_MSR(r1)
-	mtspr	990,r2		/* SRR2 */
-	mtspr	991,r0		/* SRR3 */
+	mtspr	CSRR0,r2	/* CSRR0 */
+	mtspr	CSRR1,r0	/* CSRR1 */
 	lwz	r0,GPR0(r1)
 	lwz	r2,GPR2(r1)
 	lwz	r1,GPR1(r1)
 	SYNC
 	rfci
 
+mach_return:
+	mfmsr	r28		/* Disable interrupts */
+	li	r4,0
+	ori	r4,r4,MSR_EE
+	andc	r28,r28,r4
+	SYNC			/* Some chip revs need this... */
+	mtmsr	r28
+	SYNC
+	lwz	r2,_CTR(r1)
+	lwz	r0,_LINK(r1)
+	mtctr	r2
+	mtlr	r0
+	lwz	r2,_XER(r1)
+	lwz	r0,_CCR(r1)
+	mtspr	XER,r2
+	mtcrf	0xFF,r0
+	REST_10GPRS(3, r1)
+	REST_10GPRS(13, r1)
+	REST_8GPRS(23, r1)
+	REST_GPR(31, r1)
+	lwz	r2,_NIP(r1)	/* Restore environment */
+	lwz	r0,_MSR(r1)
+	mtspr	MCSRR0,r2	/* MCSRR0 */
+	mtspr	MCSRR1,r0	/* MCSRR1 */
+	lwz	r0,GPR0(r1)
+	lwz	r2,GPR2(r1)
+	lwz	r1,GPR1(r1)
+	SYNC
+	rfmci
+
 /* Cache functions.
 */
 invalidate_icache:
@@ -1077,72 +1142,69 @@
 	 * r3: dest_addr
 	 * r7: source address, r8: end address, r9: target address
 	 */
-	.globl  trap_init
+	.globl	trap_init
 trap_init:
-	lwz     r7, GOT(_start)
-	lwz     r8, GOT(_end_of_vectors)
+	lwz	r7, GOT(_start)
+	lwz	r8, GOT(_end_of_vectors)
 
 	li	r9, 0x100		/* reset vector always at 0x100 */
 
-	cmplw   0, r7, r8
-	bgelr                           /* return if r7>=r8 - just in case */
+	cmplw	0, r7, r8
+	bgelr				/* return if r7>=r8 - just in case */
 
-	mflr    r4                      /* save link register           */
+	mflr	r4			/* save link register		*/
 1:
-	lwz     r0, 0(r7)
-	stw     r0, 0(r9)
-	addi    r7, r7, 4
-	addi    r9, r9, 4
-	cmplw   0, r7, r8
-	bne     1b
+	lwz	r0, 0(r7)
+	stw	r0, 0(r9)
+	addi	r7, r7, 4
+	addi	r9, r9, 4
+	cmplw	0, r7, r8
+	bne	1b
 
 	/*
 	 * relocate `hdlr' and `int_return' entries
 	 */
-	li      r7, .L_MachineCheck - _start + EXC_OFF_SYS_RESET
-	li      r8, Alignment - _start + EXC_OFF_SYS_RESET
+	li	r7, .L_MachineCheck - _start + EXC_OFF_SYS_RESET
+	bl	trap_reloc
+	li	r7, .L_DataStorage - _start + EXC_OFF_SYS_RESET
+	bl	trap_reloc
+	li	r7, .L_InstStorage - _start + EXC_OFF_SYS_RESET
+	bl	trap_reloc
+	li	r7, .L_ExtInterrupt - _start + EXC_OFF_SYS_RESET
+	bl	trap_reloc
+	li	r7, .L_Alignment - _start + EXC_OFF_SYS_RESET
+	bl	trap_reloc
+	li	r7, .L_ProgramCheck - _start + EXC_OFF_SYS_RESET
+	bl	trap_reloc
+	li	r7, .L_FPUnavailable - _start + EXC_OFF_SYS_RESET
+	bl	trap_reloc
+	li	r7, .L_Decrementer - _start + EXC_OFF_SYS_RESET
+	bl	trap_reloc
+	li	r7, .L_IntervalTimer - _start + EXC_OFF_SYS_RESET
+	li	r8, _end_of_vectors - _start + EXC_OFF_SYS_RESET
 2:
-	bl      trap_reloc
-	addi    r7, r7, 0x100           /* next exception vector        */
-	cmplw   0, r7, r8
-	blt     2b
-
-	li      r7, .L_Alignment - _start + EXC_OFF_SYS_RESET
-	bl      trap_reloc
-
-	li      r7, .L_ProgramCheck - _start + EXC_OFF_SYS_RESET
-	bl      trap_reloc
+	bl	trap_reloc
+	addi	r7, r7, 0x100		/* next exception vector	*/
+	cmplw	0, r7, r8
+	blt	2b
 
-	li      r7, .L_FPUnavailable - _start + EXC_OFF_SYS_RESET
-	li      r8, SystemCall - _start + EXC_OFF_SYS_RESET
-3:
-	bl      trap_reloc
-	addi    r7, r7, 0x100           /* next exception vector        */
-	cmplw   0, r7, r8
-	blt     3b
-
-	li      r7, .L_SingleStep - _start + EXC_OFF_SYS_RESET
-	li      r8, _end_of_vectors - _start + EXC_OFF_SYS_RESET
-4:
-	bl      trap_reloc
-	addi    r7, r7, 0x100           /* next exception vector        */
-	cmplw   0, r7, r8
-	blt     4b
+	lis	r7,0x0
+	mtspr	IVPR, r7
 
-	mtlr    r4                      /* restore link register        */
+	mtlr	r4			/* restore link register	*/
 	blr
 
 	/*
 	 * Function: relocate entries for one exception vector
 	 */
 trap_reloc:
-	lwz     r0, 0(r7)               /* hdlr ...                     */
-	add     r0, r0, r3              /*  ... += dest_addr            */
-	stw     r0, 0(r7)
-
-	lwz     r0, 4(r7)               /* int_return ...               */
-	add     r0, r0, r3              /*  ... += dest_addr            */
-	stw     r0, 4(r7)
+	lwz	r0, 0(r7)		/* hdlr ...			*/
+	add	r0, r0, r3		/*  ... += dest_addr		*/
+	stw	r0, 0(r7)
+
+	lwz	r0, 4(r7)		/* int_return ...		*/
+	add	r0, r0, r3		/*  ... += dest_addr		*/
+	stw	r0, 4(r7)
 
 	blr
 
@@ -1158,7 +1220,7 @@
 	dcbi	r0, r3
 	addi	r3, r3, 32
 	bdnz	1b
-	sync			/* Wait for all icbi to complete on bus	*/
+	sync			/* Wait for all icbi to complete on bus */
 	isync
 	blr
 #endif
diff -Naur u-boot-1.1.2/cpu/mpc85xx/tsec.c uboot-1.1.2hsv/cpu/mpc85xx/tsec.c
--- u-boot-1.1.2/cpu/mpc85xx/tsec.c	2004-07-10 16:45:55.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/tsec.c	2007-05-29 16:50:52.000000000 -0500
@@ -37,6 +37,7 @@
 	unsigned int phyaddr;
 	unsigned int gigabit;
 	unsigned int phyregidx;
+	unsigned int real_phyaddr; /* if phyaddr>MAX_PHY_ADDR, then use this one */
 };
 
 
@@ -71,15 +72,21 @@
 static struct tsec_info_struct tsec_info[] = {
 #ifdef CONFIG_MPC85XX_TSEC1
 	{TSEC1_PHY_ADDR, 1, TSEC1_PHYIDX},
+#else
+	{ 0, 0, 0},
 #endif
 #ifdef CONFIG_MPC85XX_TSEC2
 	{TSEC2_PHY_ADDR, 1, TSEC2_PHYIDX},
+#else
+	{ 0, 0, 0},
 #endif
 #ifdef CONFIG_MPC85XX_FEC
 	{FEC_PHY_ADDR, 0, FEC_PHYIDX},
+#else
+	{ 0, 0, 0},
 #endif
 };
-
+
 #define MAXCONTROLLERS 3
 
 static int relocated = 0;
@@ -115,6 +122,14 @@
 	int i;
 	struct tsec_private *priv;
 
+#ifdef CONFIG_DEBV1
+	/* when board_model DISable sw6095, we dont init TSEC2 */
+	if (index == 1) {
+		extern unsigned int get_board_model(void);
+		if (get_board_model() & 0x10) /* DISabled SW6095 */
+			return 0;
+	}
+#endif
 	dev = (struct eth_device*) malloc(sizeof *dev);
 
 	if(NULL == dev)
@@ -126,6 +141,8 @@
 
 	if(NULL == priv)
 		return 0;
+
+printf( "\nTSEC_INITIALIZE(%d), priv=%08X\n", index, priv );
 
 	privlist[index] = priv;
 	priv->regs = (volatile tsec_t *)(TSEC_BASE_ADDR + index*TSEC_SIZE);
@@ -134,6 +151,8 @@
 
 	priv->phyaddr = tsec_info[index].phyaddr;
 	priv->gigabit = tsec_info[index].gigabit;
+	priv->tsecinfo = &tsec_info[index];
+	priv->index = index;
 
 	sprintf(dev->name, "MOTO ENET%d", index);
 	dev->iobase = 0;
@@ -147,6 +166,34 @@
 	for(i=0;i<6;i++)
 		dev->enetaddr[i] = 0;
 
+#if 0 /* NOT USED */
+	/*
+	 * Should not allow booting from TSEC1 in U-Boot. We just
+	 * don't register it.
+	 */
+	if (index == 0) {
+		/* Reset the MAC */
+		priv->regs->maccfg1 |= MACCFG1_SOFT_RESET;
+		priv->regs->maccfg1 &= ~(MACCFG1_SOFT_RESET);
+
+		/* Try to initialize PHY here, and return */
+		return init_phy(dev);
+	}
+#endif
+#if defined(CONFIG_DEBV1) || defined(CONFIG_AMAZON)
+	/*
+	 * Should not allow booting from TSEC2 in U-Boot. We just
+	 * don't register it.
+	 */
+	if (index == 1) {
+		/* Reset the MAC */
+		priv->regs->maccfg1 |= MACCFG1_SOFT_RESET;
+		priv->regs->maccfg1 &= ~(MACCFG1_SOFT_RESET);
+
+		/* Try to initialize PHY here, and return */
+		return init_phy(dev);
+	}
+#endif
 	eth_register(dev);
 
 
@@ -185,11 +232,11 @@
 	for(i=0;i<MAC_ADDR_LEN;i++) {
 		tmpbuf[MAC_ADDR_LEN - 1 - i] = dev->enetaddr[i];
 	}
-	(uint)(regs->macstnaddr1) = *((uint *)(tmpbuf));
+	regs->macstnaddr1 = *((uint *)(tmpbuf));
 
 	tempval = *((uint *)(tmpbuf +4));
 
-	(uint)(regs->macstnaddr2) = tempval;
+	regs->macstnaddr2 = tempval;
 
 	/* reset the indices to zero */
 	rxIdx = 0;
@@ -218,6 +265,9 @@
 	uint phyid = priv->phyaddr;
 	int timeout=1000000;
 
+	if(phyid > MAX_PHY_ADDR)
+		phyid=priv->tsecinfo->real_phyaddr;
+
 	regbase->miimadd = (phyid << 8) | regnum;
 	regbase->miimcon = value;
 	asm("msync");
@@ -239,6 +289,9 @@
 	volatile tsec_t *regbase = priv->phyregs;
 	uint phyid = priv->phyaddr;
 
+	if(phyid > MAX_PHY_ADDR)
+		phyid=priv->tsecinfo->real_phyaddr;
+
 	/* Put the address of the phy, and the register
 	 * number into MIIMADD */
 	regbase->miimadd = (phyid << 8) | regnum;
@@ -271,7 +324,21 @@
 	struct phy_info *curphy;
 
 	/* Assign a Physical address to the TBI */
-	priv->regs->tbipa=TBIPA_VALUE;
+
+	{
+		volatile tsec_t *regs = (volatile tsec_t *)(TSEC_BASE_ADDR);
+		regs->tbipa = TBIPA_VALUE;
+		regs = (volatile tsec_t *)(TSEC_BASE_ADDR + TSEC_SIZE);
+		regs->tbipa = TBIPA_VALUE;
+		asm("msync");
+	}
+
+	/* Reset MII (due to new addresses) */
+	priv->phyregs->miimcfg = MIIMCFG_RESET;
+	asm("msync");
+	priv->phyregs->miimcfg = MIIMCFG_INIT_VALUE;
+	asm("msync");
+	while(priv->phyregs->miimind & MIIMIND_BUSY);
 
 	if(0 == relocated)
 		relocate_cmds();
@@ -290,9 +357,56 @@
 
 	phy_run_commands(priv, priv->phyinfo->config);
 
+	/* Fine tune the PHY immediately after config, default config
+	 * is ANEG enabled, in finetune() we can force
+	 * speed/duplexity */
+	phy_run_commands(priv, priv->phyinfo->finetune);
+	
 	return 1;
 }
 
+/* For fake PHY, the config handler */
+uint mii_fake_config(uint mii_reg, struct tsec_private *priv)
+{
+	return 0;
+}
+
+/* For fake PHY, the startup handler */
+uint mii_fake_startup(uint mii_reg, struct tsec_private *priv)
+{
+	struct tsec_info_struct *tsecinfo = priv->tsecinfo;
+
+	if(tsecinfo->phyaddr <=MAX_PHY_ADDR) {
+		printf("%s:%d Error, fake PHY's phyaddr should > %d, but we got %d\n", __FILE__, __LINE__, MAX_PHY_ADDR, tsecinfo->phyaddr);
+		return 0;
+	}
+  
+	if(tsecinfo->phyaddr & ALWAYS_LINK_UP_FAKE_PHY_ADDR)
+		priv->link = 1;
+	else
+		priv->link = 0;
+
+	if(tsecinfo->phyaddr & FULL_DPLX_FAKE_PHY_ADDR)
+		priv->duplexity = 1;
+	else
+		priv->duplexity = 0;
+  
+	if(tsecinfo->phyaddr & _1000MBPS_FAKE_PHY_ADDR)
+		priv->speed = 1000;
+	else if(tsecinfo->phyaddr & _100MBPS_FAKE_PHY_ADDR)
+		priv->speed = 100;
+	else
+		priv->speed = 10;
+
+	return 0;
+}
+
+/* For fake PHY, the shutdown handler */
+uint mii_fake_shutdown(uint mii_reg, struct tsec_private *priv)
+{
+	return 0;
+}
+
 
 /* Returns which value to write to the control register. */
 /* For 10/100, the value is slightly different */
@@ -305,6 +419,7 @@
 }
 
 
+#define BRIEF_TSEC_ERRORS
 /* Parse the status register for link, and then do
  * auto-negotiation */
 uint mii_parse_sr(uint mii_reg, struct tsec_private *priv)
@@ -316,9 +431,21 @@
 	else
 		priv->link = 0;
 
+	if(!(read_phy_reg(priv, MIIM_CONTROL) & MIIM_ANEN))
+		/* Not ANEG, so no need to check AN_DONE */
+		return 0;
+
 	if(priv->link) {
 		while((!(mii_reg & MIIM_STATUS_AN_DONE)) && timeout--)
 			mii_reg = read_phy_reg(priv, MIIM_STATUS);
+#if defined(BRIEF_TSEC_ERRORS)
+		if (mii_reg & MIIM_STATUS_AN_DONE)
+			printf("TSEC%d: Auto-negotiation done\n",
+			       priv->index+1);
+		else
+			printf("TSEC%d: Auto-negotiation timed out\n",
+			       priv->index+1);
+#endif
 	}
 
 	return 0;
@@ -351,7 +478,95 @@
 
 	return 0;
 }
+
+/* Parse the 88E3015's status register for speed and duplex
+ * information */
+uint mii_parse_88E3015_psr(uint mii_reg, struct tsec_private *priv)
+{
+	uint speed;
+
+	if(mii_reg & MIIM_88E3015_PHYSTAT_DUPLEX)
+		priv->duplexity = 1;
+	else
+		priv->duplexity = 0;
+
+	speed = (mii_reg &MIIM_88E3015_PHYSTAT_SPEED);
+
+	switch(speed) {
+		case MIIM_88E3015_PHYSTAT_100:
+			priv->speed = 100;
+			break;
+		default:
+			priv->speed = 10;
+	}
+
+	return 0;
+}
+
+/* fine tune PHY setting after its default ANEG. */
+uint mii_88E1011_finetune(uint mii_reg, struct tsec_private *priv)
+{
+#ifdef CONFIG_CYCLADES
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
 
+	if (priv->index == 0) {
+		/* TSEC1, fecmode1 */
+		switch (bd->mii_operation[0]) {
+		case 0:		/* auto */
+		default:
+			break;
+		case 1:		/* 1000F */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_1000F);
+			break;
+		case 2:		/* 1000H */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_1000H);
+			break;
+		case 3:		/* 100F */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_100F);
+			break;
+		case 4:		/* 100H */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_100H);
+			break;
+		case 5:		/* 10F */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_10F);
+			break;
+		case 6:		/* 10H */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_10H);
+			break;
+		}
+	}
+
+	if (priv->index == 1) {
+		/* TSEC2, fecmode2 */
+		switch (bd->mii_operation[1]) {
+		case 0:		/* auto */
+		default:
+			break;
+		case 1:		/* 1000F */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_1000F);
+			break;
+		case 2:		/* 1000H */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_1000H);
+			break;
+		case 3:		/* 100F */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_100F);
+			break;
+		case 4:		/* 100H */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_100H);
+			break;
+		case 5:		/* 10F */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_10F);
+			break;
+		case 6:		/* 10H */
+			write_phy_reg(priv, MIIM_CONTROL, MIIM_CONTROL_10H);
+			break;
+		}
+	}
+#endif /* CONFIG_CYCLADES */
+
+	return 0;
+}
 
 /* Parse the cis8201's status register for speed and duplex
  * information */
@@ -533,6 +748,7 @@
 	/* Start up the PHY */
 	phy_run_commands(priv, priv->phyinfo->startup);
 	adjust_link(dev);
+	if(!priv->link) return;
 
 	/* Enable Transmit and Receive */
 	regs->maccfg1 |= (MACCFG1_RX_EN | MACCFG1_TX_EN);
@@ -568,7 +784,7 @@
 
 	/* Tell the DMA to go */
 	regs->tstat = TSTAT_CLEAR_THALT;
-
+
 	/* Wait for buffer to be transmitted */
 	for(i=0; rtx.txbd[txIdx].status & TXBD_READY; i++) {
 		if (i >= TOUT_LOOP) {
@@ -577,8 +793,8 @@
 		}
 	}
 
-	txIdx = (txIdx + 1) % TX_BUF_CNT;
 	result = rtx.txbd[txIdx].status & TXBD_STATS;
+	txIdx = (txIdx + 1) % TX_BUF_CNT;
 
 	return result;
 }
@@ -669,6 +885,95 @@
 	},
 };
 
+struct phy_info phy_info_M88E1111S = {
+	0x01410cc,
+	"Marvell 88E1111S",
+	4,
+	(struct phy_cmd[]) { /* config */
+	  /* Reset and configure the PHY */
+		{MIIM_CONTROL, MIIM_CONTROL_RESET, NULL},
+		{0x1d, 0x1f, NULL},
+		{0x1e, 0x200c, NULL},
+		{0x1d, 0x5, NULL},
+		{0x1e, 0x0, NULL},
+		{0x1e, 0x100, NULL},
+		{MIIM_GBIT_CONTROL, MIIM_GBIT_CONTROL_INIT, NULL},
+		{MIIM_ANAR, MIIM_ANAR_INIT, NULL},
+		{MIIM_CONTROL, MIIM_CONTROL_RESET, NULL},
+		{MIIM_CONTROL, MIIM_CONTROL_INIT, &mii_cr_init},
+		{miim_end,}
+	},
+	(struct phy_cmd[]) { /* startup */
+	  /* Status is read once to clear old link state */
+		{MIIM_STATUS, miim_read, NULL},
+		/* Auto-negotiate */
+		{MIIM_STATUS, miim_read, &mii_parse_sr},
+		/* Read the status */
+		{MIIM_88E1011_PHY_STATUS, miim_read, &mii_parse_88E1011_psr},
+		{miim_end,}
+	},
+	(struct phy_cmd[]) { /* shutdown */
+		{miim_end,}
+	},
+	(struct phy_cmd[]) { /* finetune */
+		/* just dumb read, real job is in finetune() */
+		{MIIM_CONTROL, miim_read, &mii_88E1011_finetune},
+		{miim_end,}
+	},
+};
+
+struct phy_info phy_info_M88E3015 = {
+	0x01410E2,
+	"Marvell 88E3015",
+	4,
+	(struct phy_cmd[]) { /* config */
+	  /* Reset and configure the PHY */
+		{MIIM_CONTROL, MIIM_CONTROL_RESET, NULL},
+		{0x1d, 0x1f, NULL},
+		{0x1e, 0x200c, NULL},
+		{0x1d, 0x5, NULL},
+		{0x1e, 0x0, NULL},
+		{0x1e, 0x100, NULL},
+		{MIIM_ANAR, MIIM_ANAR_INIT, NULL},
+		{MIIM_CONTROL, MIIM_CONTROL_RESET, NULL},
+		{MIIM_CONTROL, MIIM_CONTROL_INIT, &mii_cr_init},
+		{miim_end,}
+	},
+	(struct phy_cmd[]) { /* startup */
+	  /* Status is read once to clear old link state */
+		{MIIM_STATUS, miim_read, NULL},
+		/* Auto-negotiate */
+		{MIIM_STATUS, miim_read, &mii_parse_sr},
+		/* Read the status */
+		{MIIM_88E3015_PHY_STATUS, miim_read, &mii_parse_88E3015_psr},
+		{miim_end,}
+	},
+	(struct phy_cmd[]) { /* shutdown */
+		{miim_end,}
+	},
+	(struct phy_cmd[]) { /* finetune */
+		{miim_end,}
+	},
+};
+
+struct phy_info phy_info_fakePHY = {
+	0x0,
+	"Fake PHY",
+	0,
+	(struct phy_cmd[]) { /* config */
+	  {0, miim_fake, &mii_fake_config},
+		{miim_end,}
+	},
+	(struct phy_cmd[]) { /* startup */
+	  {0, miim_fake, &mii_fake_startup},
+		{miim_end,}
+	},
+	(struct phy_cmd[]) { /* shutdown */
+	  {0, miim_fake, &mii_fake_shutdown},
+		{miim_end,}
+	},
+};
+
 struct phy_info phy_info_cis8204 = {
 	0x3f11,
 	"Cicada Cis8204",
@@ -761,7 +1066,10 @@
 #endif
 	&phy_info_cis8204,
 	&phy_info_M88E1011S,
+	&phy_info_M88E1111S,
+	&phy_info_M88E3015,
 	&phy_info_dm9161,
+	&phy_info_fakePHY,
 	NULL
 };
 
@@ -776,13 +1084,18 @@
 	int i;
 	struct phy_info *theInfo = NULL;
 
-	/* Grab the bits from PHYIR1, and put them in the upper half */
-	phy_reg = read_phy_reg(priv, MIIM_PHYIR1);
-	phy_ID = (phy_reg & 0xffff) << 16;
-
-	/* Grab the bits from PHYIR2, and put them in the lower half */
-	phy_reg = read_phy_reg(priv, MIIM_PHYIR2);
-	phy_ID |= (phy_reg & 0xffff);
+	/* For fake PHY purpose */
+	if(priv->tsecinfo->phyaddr > MAX_PHY_ADDR) {
+		phy_ID=0;
+	} else {
+		/* Grab the bits from PHYIR1, and put them in the upper half */
+		phy_reg = read_phy_reg(priv, MIIM_PHYIR1);
+		phy_ID = (phy_reg & 0xffff) << 16;
+
+		/* Grab the bits from PHYIR2, and put them in the lower half */
+		phy_reg = read_phy_reg(priv, MIIM_PHYIR2);
+		phy_ID |= (phy_reg & 0xffff);
+	}
 
 	/* loop through all the known PHY types, and find one that */
 	/* matches the ID we read from the PHY. */
@@ -818,13 +1131,17 @@
 
 	while(phyregs->miimind & MIIMIND_BUSY);
 
-	for(i=0;cmd->mii_reg != miim_end;i++) {
+	for(i=0;cmd && cmd->mii_reg != miim_end;i++) {
 		if(cmd->mii_data == miim_read) {
 			result = read_phy_reg(priv, cmd->mii_reg);
 
 			if(cmd->funct != NULL)
 				(*(cmd->funct))(result, priv);
 
+		} else if(cmd->mii_data == miim_fake) {
+			result = 0;
+			if(cmd->funct != NULL)
+				(*(cmd->funct))(result, priv);
 		} else {
 			if(cmd->funct != NULL)
 				result = (*(cmd->funct))(cmd->mii_reg, priv);
@@ -862,12 +1179,18 @@
 		phy_info[i]->shutdown =
 			(struct phy_cmd *)((uint)phy_info[i]->shutdown
 					   + gd->reloc_off);
+		if (phy_info[i]->finetune) {
+			/* only relocate if finetune phy_cmd supplied */
+			phy_info[i]->finetune =
+				(struct phy_cmd *)((uint)phy_info[i]->finetune
+						   + gd->reloc_off);
+		}
 
 		cmdlistptr = &phy_info[i]->config;
 		j=0;
-		for(;cmdlistptr <= &phy_info[i]->shutdown;cmdlistptr++) {
+		for(;cmdlistptr <= &phy_info[i]->finetune;cmdlistptr++) {
 			k=0;
-			for(cmd=*cmdlistptr;cmd->mii_reg != miim_end;cmd++) {
+			for(cmd=*cmdlistptr;cmd && cmd->mii_reg != miim_end;cmd++) {
 				/* Only relocate non-NULL pointers */
 				if(cmd->funct)
 					cmd->funct += gd->reloc_off;
@@ -893,6 +1216,16 @@
 			return privlist[i];
 	}
 
+	/* cyclades: for DEB, we want to use MDC/MDIO to also control marvell
+	   6095 switches, so the phyaddr for tsec controller isn't confined to
+	   MAXCONTROLLERS (=3)*/
+	for(i=0;i<MAXCONTROLLERS;i++) {
+		if(privlist[i]->phyaddr > MAX_PHY_ADDR) {
+			privlist[i]->tsecinfo->real_phyaddr=phyaddr;
+			return privlist[i];
+		}
+	}
+
 	return NULL;
 }
 
diff -Naur u-boot-1.1.2/cpu/mpc85xx/tsec.h uboot-1.1.2hsv/cpu/mpc85xx/tsec.h
--- u-boot-1.1.2/cpu/mpc85xx/tsec.h	2004-06-08 19:34:47.000000000 -0500
+++ uboot-1.1.2hsv/cpu/mpc85xx/tsec.h	2007-05-29 16:50:52.000000000 -0500
@@ -25,6 +25,17 @@
 
 #define MAC_ADDR_LEN 6
 
+/* used for TSEC not directly connecting to an external PHY, but an MAC */
+#define MAX_PHY_ADDR                 0x001f
+#define ALWAYS_LINK_UP_FAKE_PHY_ADDR 0x8000
+#define _1000MBPS_FAKE_PHY_ADDR      0x4000
+#define _100MBPS_FAKE_PHY_ADDR       0x2000
+#define _10MBPS_FAKE_PHY_ADDR        0x1000
+#define FULL_DPLX_FAKE_PHY_ADDR      0x0800
+#define HALF_DPLX_FAKE_PHY_ADDR      0x0400
+#define FLOW_CTRL_FAKE_PHY_ADDR      0x0200
+
+
 /* #define TSEC_TIMEOUT 	1000000 */
 #define TSEC_TIMEOUT 1000
 #define TOUT_LOOP 	1000000
@@ -53,6 +64,7 @@
 #define ECNTRL_TBI_MODE         0x00000020
 
 #define miim_end -2
+#define miim_fake -3
 #define miim_read -1
 
 #define TBIPA_VALUE		0x1f
@@ -66,6 +78,12 @@
 #define MIIM_CONTROL_RESET	0x00009140
 #define MIIM_CONTROL_INIT       0x00001140
 #define MIIM_ANEN               0x00001000
+#define MIIM_CONTROL_10H	0x00008000
+#define MIIM_CONTROL_10F	0x00008100
+#define MIIM_CONTROL_100H	0x0000a000
+#define MIIM_CONTROL_100F	0x0000a100
+#define MIIM_CONTROL_1000H	0x00008040
+#define MIIM_CONTROL_1000F	0x00008140
 
 #define MIIM_CR                 0x00
 #define MIIM_CR_RST		0x00008000
@@ -123,6 +141,14 @@
 #define MIIM_88E1011_PHYSTAT_DUPLEX     0x2000
 #define MIIM_88E1011_PHYSTAT_SPDDONE	0x0800
 #define MIIM_88E1011_PHYSTAT_LINK	0x0400
+
+/* 88E3015 PHY Status Register */
+#define MIIM_88E3015_PHY_STATUS         0x11
+#define MIIM_88E3015_PHYSTAT_SPEED      0x4000
+#define MIIM_88E3015_PHYSTAT_100        0x4000
+#define MIIM_88E3015_PHYSTAT_DUPLEX     0x2000
+#define MIIM_88E3015_PHYSTAT_SPDDONE	0x0800
+#define MIIM_88E3015_PHYSTAT_LINK	0x0400
 
 /* DM9161 Control register values */
 #define MIIM_DM9161_CR_STOP	0x0400
@@ -416,15 +442,19 @@
 	uint	resc00[256];
 } tsec_t;
 
+struct tsec_info_struct;
+
 struct tsec_private {
 	volatile tsec_t *regs;
 	volatile tsec_t *phyregs;
 	struct phy_info *phyinfo;
+	struct tsec_info_struct *tsecinfo;
 	uint phyaddr;
 	uint gigabit;
 	uint link;
 	uint duplexity;
 	uint speed;
+	int  index; 		/* 0 for TSEC1, 1 for TSEC2 */
 };
 
 
@@ -473,6 +503,14 @@
 
     /* Called when bringing down the controller */
     struct phy_cmd *shutdown;
+
+    /* Called just after *config phy_cmd to fine tune PHY setting. In
+     * the *config phy_cmd ANEG is normally the default setting,
+     * while we can change to user specified mode in *finetune
+     * phy_cmd.
+     *
+     * This field could be left undefined. */
+    struct phy_cmd *finetune;
 };
 
 #endif /* __TSEC_H */
diff -Naur u-boot-1.1.2/doc/README.debv1 uboot-1.1.2hsv/doc/README.debv1
--- u-boot-1.1.2/doc/README.debv1	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/doc/README.debv1	2007-05-29 16:50:54.000000000 -0500
@@ -0,0 +1,186 @@
+Motorola MPC85xxCDS boards
+--------------------------
+
+The CDS family of boards consists of a PCI backplane called the
+"Arcadia", a PCI-form-factor carrier card that plugs into a PCI slot,
+and a CPU daughter card that bolts onto the daughter card.
+
+Much of the content of the README.mpc85xxads for the 85xx ADS boards
+applies to the 85xx CDS boards as well.	 In particular the toolchain,
+the switch nomenclature, and the basis for the memory map.  There are
+some differences, though.
+
+
+Building U-Boot
+---------------
+
+The Binutils in current ELDK toolchain will not support MPC85xx
+chip.  You need to use binutils-2.14.tar.bz2 (or newer) from
+    http://ftp.gnu.org/gnu/binutils.
+
+The 85xx CDS code base is known to compile using:
+    gcc (GCC) 3.2.2 20030217 (Yellow Dog Linux 3.0 3.2.2-2a)
+
+
+Memory Map
+----------
+
+The memory map for u-boot and linux has been extended w.r.t. the ADS
+platform to allow for utilization of all 85xx CDS devices.  The memory
+map is setup for linux to operate properly.  The linux source when
+configured for MPC85xx CDS has been updated to reflect the new memory
+map.
+
+The mapping is:
+
+   0x0000_0000	   0x7fff_ffff	   DDR			   2G
+   0x8000_0000	   0x9fff_ffff	   PCI1 MEM		   512M
+   0xa000_0000	   0xbfff_ffff	   PCI2 MEM		   512M
+   0xe000_0000	   0xe00f_ffff	   CCSR			   1M
+   0xe200_0000	   0xe2ff_ffff	   PCI1 IO		   16M
+   0xe300_0000	   0xe3ff_ffff	   PCI2 IO		   16M
+   0xf000_0000	   0xf7ff_ffff	   SDRAM		   128M
+   0xf800_0000	   0xf80f_ffff	   NVRAM/CADMUS (*)	   1M
+   0xff00_0000	   0xff7f_ffff	   FLASH (2nd bank)	   8M
+   0xff80_0000	   0xffff_ffff	   FLASH (boot bank)	   8M
+
+   (*) The system control registers (CADMUS) start at offset 0xfdb0_4000
+   within the NVRAM/CADMUS region of memory.
+
+
+Using Flash
+-----------
+
+The CDS board  has two flash banks, each 8MB in size (2^23 = 0x00800000).
+There is a switch which allows the boot-bank to be selected.  The switch
+settings for updating flash are given below.
+
+The u-boot commands for copying the boot-bank into the secondary bank are
+as follows:
+
+     erase ff780000 ff7fffff
+     cp.b fff80000 ff780000 80000
+
+
+U-boot/kermit commands for downloading an image, then copying
+it into the secondary bank:
+
+     loadb
+     [Drop to kermit:
+	^\c
+	send <u-boot-bin-image>
+	c
+     ]
+
+     erase ff780000 ff7fffff
+     cp.b $loadaddr ff780000 80000
+
+
+U-boot commands for downloading an image via tftp and flashing
+it into the second bank:
+
+     tftp 10000 <u-boot.bin.image>
+     erase ff780000 ff7fffff
+     cp.b 10000 ff780000 80000
+
+
+After copying the image into the second bank of flash, be sure to toggle
+SW2[2] on the carrier card before resetting the board in order to set the
+secondary bank as the boot-bank.
+
+
+Carrier Board Switches
+----------------------
+
+As a reminder, you should read the README.mpc85xxads too.
+
+Most switches on the carrier board should not be changed.  The only
+user-settable switches on the carrier board are used to configure
+the flash banks and determining the PCI slot.
+
+The first two bits of SW2 control how flash is used on the board:
+
+      12345678
+      --------
+  SW2=00XXXXXX	   FLASH:  Boot bank 1, bank 2 available.
+      01XXXXXX	   FLASH:  Boot bank 2, bank 1 available (swapped).
+      10XXXXXX	   FLASH:  Boot promjet, bank 1 available
+      11XXXXXX	   FLASH:  Boot promjet, bank 2 available
+
+The boot bank is always mapped to FF80_0000 and listed first by
+the "flinfo" command.  The secondary bank is always FF00_0000.
+
+When using PCI, linux needs to know to which slot the CDS carrier is
+connected..  By convention, the user-specific bits of SW2 are used to
+convey this information:
+
+      12345678
+      --------
+  SW2=xxxxxx00	   PCI SLOT INFORM: The CDS carrier is in slot0 of the Arcadia
+      xxxxxx01	   PCI SLOT INFORM: The CDS carrier is in slot1 of the Arcadia
+      xxxxxx10	   PCI SLOT INFORM: The CDS carrier is in slot2 of the Arcadia
+      xxxxxx11	   PCI SLOT INFORM: The CDS carrier is in slot3 of the Arcadia
+
+These are cleverly, er, clearly silkscreened as Slot 1 through 4,
+respectively, on the Arcadia near the support posts.
+
+
+The default setting of all switches on the carrier board is:
+
+      12345678
+      --------
+  SW1=01101100
+  SW2=0x1111yy	   x=Flash bank, yy=PCI slot
+  SW3=11101111
+  SW4=10001000
+
+
+CPU Card Switches
+-----------------
+
+Most switches on the CPU Card should not be changed.  However, the
+frequency can be changed by setting SW3:
+
+      12345678
+      --------
+  SW3=XX00XXXX == CORE:CCB 2:1
+      XX01XXXX == CORE:CCB 5:2
+      XX10XXXX == CORE:CCB 3:1
+      XX11XXXX == CORE:CCB 7:2
+      XXXX1000 == CCB:SYSCLK 8:1
+      XXXX1010 == CCB:SYSCLK 10:1
+
+A safe default setting for all switches on the CPU board is:
+
+      12345678
+      --------
+  SW1=10001111
+  SW2=01000111
+  SW3=00001000
+  SW4=11111110
+
+
+eDINK Info
+----------
+
+One bank of flash may contain an eDINK image.
+
+Memory Map:
+
+   CCSRBAR @ 0xe0000000
+   Flash Bank 1 @ 0xfe000000
+   Flash Bank 2 @ 0xff000000
+   Ram @ 0
+
+Commands for downloading a u-boot image to memory from edink:
+
+   env -c
+   time -s 4/8/2004 4:30p
+   dl -k -b -o 100000
+   [Drop to kermit:
+	^\c
+	transmit /binary <u-boot-bin-image>
+	c
+   ]
+
+   fu -l 100000 fe780000 80000
diff -Naur u-boot-1.1.2/doc/README.kvmmaxv1 uboot-1.1.2hsv/doc/README.kvmmaxv1
--- u-boot-1.1.2/doc/README.kvmmaxv1	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/doc/README.kvmmaxv1	2007-05-29 16:50:54.000000000 -0500
@@ -0,0 +1,192 @@
+2/10/2005
+-------
+Modified for Cyclades KVMMAX V1 board
+changed parts are prepended with "cyclades"
+
+Motorola MPC85xxCDS boards
+--------------------------
+
+The CDS family of boards consists of a PCI backplane called the
+"Arcadia", a PCI-form-factor carrier card that plugs into a PCI slot,
+and a CPU daughter card that bolts onto the daughter card.
+
+Much of the content of the README.mpc85xxads for the 85xx ADS boards
+applies to the 85xx CDS boards as well.	 In particular the toolchain,
+the switch nomenclature, and the basis for the memory map.  There are
+some differences, though.
+
+
+Building U-Boot
+---------------
+
+The Binutils in current ELDK toolchain will not support MPC85xx
+chip.  You need to use binutils-2.14.tar.bz2 (or newer) from
+    http://ftp.gnu.org/gnu/binutils.
+
+The 85xx CDS code base is known to compile using:
+    gcc (GCC) 3.2.2 20030217 (Yellow Dog Linux 3.0 3.2.2-2a)
+
+
+Memory Map
+----------
+
+The memory map for u-boot and linux has been extended w.r.t. the ADS
+platform to allow for utilization of all 85xx CDS devices.  The memory
+map is setup for linux to operate properly.  The linux source when
+configured for MPC85xx CDS has been updated to reflect the new memory
+map.
+
+The mapping is:
+
+   0x0000_0000	   0x7fff_ffff	   DDR			   2G
+   0x8000_0000	   0x9fff_ffff	   PCI1 MEM		   512M
+   0xa000_0000	   0xbfff_ffff	   PCI2 MEM		   512M
+   0xe000_0000	   0xe00f_ffff	   CCSR			   1M
+   0xe200_0000	   0xe2ff_ffff	   PCI1 IO		   16M
+   0xe300_0000	   0xe3ff_ffff	   PCI2 IO		   16M
+	cyclades: do we have SDRAM on kvmmaxv1 board?
+   0xf000_0000	   0xf7ff_ffff	   SDRAM		   128M
+   0xf800_0000	   0xf80f_ffff	   NVRAM/CADMUS (*)	   1M
+   0xff00_0000	   0xff7f_ffff	   FLASH (2nd bank)	   8M
+   0xff80_0000	   0xffff_ffff	   FLASH (boot bank)	   8M
+
+   (*) The system control registers (CADMUS) start at offset 0xfdb0_4000
+   within the NVRAM/CADMUS region of memory.
+
+
+Using Flash
+-----------
+
+The CDS board  has two flash banks, each 8MB in size (2^23 = 0x00800000).
+There is a switch which allows the boot-bank to be selected.  The switch
+settings for updating flash are given below.
+
+The u-boot commands for copying the boot-bank into the secondary bank are
+as follows:
+
+     erase ff780000 ff7fffff
+     cp.b fff80000 ff780000 80000
+
+
+U-boot/kermit commands for downloading an image, then copying
+it into the secondary bank:
+
+     loadb
+     [Drop to kermit:
+	^\c
+	send <u-boot-bin-image>
+	c
+     ]
+
+     erase ff780000 ff7fffff
+     cp.b $loadaddr ff780000 80000
+
+
+U-boot commands for downloading an image via tftp and flashing
+it into the second bank:
+
+     tftp 10000 <u-boot.bin.image>
+     erase ff780000 ff7fffff
+     cp.b 10000 ff780000 80000
+
+
+After copying the image into the second bank of flash, be sure to toggle
+SW2[2] on the carrier card before resetting the board in order to set the
+secondary bank as the boot-bank.
+
+
+Carrier Board Switches
+----------------------
+
+As a reminder, you should read the README.mpc85xxads too.
+
+Most switches on the carrier board should not be changed.  The only
+user-settable switches on the carrier board are used to configure
+the flash banks and determining the PCI slot.
+
+The first two bits of SW2 control how flash is used on the board:
+
+      12345678
+      --------
+  SW2=00XXXXXX	   FLASH:  Boot bank 1, bank 2 available.
+      01XXXXXX	   FLASH:  Boot bank 2, bank 1 available (swapped).
+      10XXXXXX	   FLASH:  Boot promjet, bank 1 available
+      11XXXXXX	   FLASH:  Boot promjet, bank 2 available
+
+The boot bank is always mapped to FF80_0000 and listed first by
+the "flinfo" command.  The secondary bank is always FF00_0000.
+
+When using PCI, linux needs to know to which slot the CDS carrier is
+connected..  By convention, the user-specific bits of SW2 are used to
+convey this information:
+
+      12345678
+      --------
+  SW2=xxxxxx00	   PCI SLOT INFORM: The CDS carrier is in slot0 of the Arcadia
+      xxxxxx01	   PCI SLOT INFORM: The CDS carrier is in slot1 of the Arcadia
+      xxxxxx10	   PCI SLOT INFORM: The CDS carrier is in slot2 of the Arcadia
+      xxxxxx11	   PCI SLOT INFORM: The CDS carrier is in slot3 of the Arcadia
+
+These are cleverly, er, clearly silkscreened as Slot 1 through 4,
+respectively, on the Arcadia near the support posts.
+
+
+The default setting of all switches on the carrier board is:
+
+      12345678
+      --------
+  SW1=01101100
+  SW2=0x1111yy	   x=Flash bank, yy=PCI slot
+  SW3=11101111
+  SW4=10001000
+
+
+CPU Card Switches
+-----------------
+
+Most switches on the CPU Card should not be changed.  However, the
+frequency can be changed by setting SW3:
+
+      12345678
+      --------
+  SW3=XX00XXXX == CORE:CCB 2:1
+      XX01XXXX == CORE:CCB 5:2
+      XX10XXXX == CORE:CCB 3:1
+      XX11XXXX == CORE:CCB 7:2
+      XXXX1000 == CCB:SYSCLK 8:1
+      XXXX1010 == CCB:SYSCLK 10:1
+
+A safe default setting for all switches on the CPU board is:
+
+      12345678
+      --------
+  SW1=10001111
+  SW2=01000111
+  SW3=00001000
+  SW4=11111110
+
+
+eDINK Info
+----------
+
+One bank of flash may contain an eDINK image.
+
+Memory Map:
+
+   CCSRBAR @ 0xe0000000
+   Flash Bank 1 @ 0xfe000000
+   Flash Bank 2 @ 0xff000000
+   Ram @ 0
+
+Commands for downloading a u-boot image to memory from edink:
+
+   env -c
+   time -s 4/8/2004 4:30p
+   dl -k -b -o 100000
+   [Drop to kermit:
+	^\c
+	transmit /binary <u-boot-bin-image>
+	c
+   ]
+
+   fu -l 100000 fe780000 80000
diff -Naur u-boot-1.1.2/doc/README.sbc8560 uboot-1.1.2hsv/doc/README.sbc8560
--- u-boot-1.1.2/doc/README.sbc8560	2004-07-10 16:45:57.000000000 -0500
+++ uboot-1.1.2hsv/doc/README.sbc8560	1969-12-31 18:00:00.000000000 -0600
@@ -1,53 +0,0 @@
-The port was tested on Wind River System Sbc8560 board <www.windriver.com>.
-U-Boot was installed on the flash memory of the CPU card (no the SODIMM).
-
-NOTE: Please configure uboot compile to the proper PCI frequency and
-setup the appropriate DIP switch settings.
-
-SBC8560 board:
-
-Make sure boards switches are set to their appropriate conditions.
-Refer to the Engineering Reference Guide ERG-00300-002. Of particular
-importance are: 1)Tthe settings for JP4 (JP4 1-3 and 2-4), which
-select the on-board FLASH device (Intel 28F128Jx); 2) The settings
-for the Clock SW9 (33 MHz or 66 MHz).
-
-	Note:	SW9 Settings: 66 MHz
-		4:1 ratio CCB clocks:SYSCLK
-		3:1 ration e500 Core:CCB
-		pos1 - on, pos2 - on, pos3 - off, pos4 - on, pos5 - off, pos6 - on
-	Note:	SW9 Settings: 33 MHz
-		8:1 ratio CCB clocks:SYSCLK
-		3:1 ration e500 Core:CCB
-		pos1 - on, pos2 - on, pos3 - on, pos4 - off, pos5 - off, pos6 - on
-
-
-Flashing the FLASH device with the "Wind River ICE":
-
-1) Properly connect and configure the Wind River ICE to the
-   target JTAG port. This includes running the SBC8560 register script.
-   Make sure target memory can be read and written.
-
-2) Build the u-boot image:
-	make distclean
-	make SBC8560_66_config or SBC8560_33_config
-	make CROSS_COMPILE=.../ELDK3.0/ppc_8xx-/ all
-
-   Note: reference is made to the ELDK3.0 compiler but any 85xx cross-compiler
-	 should suffice.
-
-3) Convert the uboot (.elf) file to a uboot.bin file (using visionClick converter).
-   The bin file should be converted from fffc0000 to ffffffff
-
-4) Setup the Flash Utility (tools menu) for:
-
-   Determine the clock speed of the PCI bus and set SW9 accordingly
-	Note: the speed of the PCI bus defaults to the slowest PCI card
-   PlayBack the "default" register file for the SBC8560
-   Select the uboot.bin file with zero bias
-   Select the initialize Target prior to programming
-   Select the V28F640Jx (8192 x 8) 1 device FLASH Algorithm
-   Select the erase base address from FFFC0000 to FFFFFFFF
-   Select the start address from 0 with size of 4000
-
-5) Erase and Program
diff -Naur u-boot-1.1.2/drivers/cfi_flash.c uboot-1.1.2hsv/drivers/cfi_flash.c
--- u-boot-1.1.2/drivers/cfi_flash.c	2004-12-18 16:35:45.000000000 -0600
+++ uboot-1.1.2hsv/drivers/cfi_flash.c	2007-05-29 16:51:25.000000000 -0500
@@ -42,7 +42,7 @@
  */
 
 /* The DEBUG define must be before common to enable debugging */
-/* #define DEBUG	*/
+/* #define DEBUG */
 
 #include <common.h>
 #include <asm/processor.h>
@@ -816,6 +816,7 @@
 	cfiword_t cword;
 
 	addr.cp = flash_make_addr (info, sect, offset);
+
 	flash_make_cmd (info, cmd, &cword);
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
@@ -1108,7 +1109,6 @@
 	ctladdr.cp = flash_make_addr (info, 0, 0);
 	cptr.cp = (uchar *) dest;
 
-
 	/* Check if Flash is (sufficiently) erased */
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
@@ -1136,7 +1136,7 @@
 	case CFI_CMDSET_INTEL_EXTENDED:
 	case CFI_CMDSET_INTEL_STANDARD:
 		flash_write_cmd (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
-		flash_write_cmd (info, 0, 0, FLASH_CMD_WRITE);
+		flash_write_cmd (info, 0, 0, FLASH_CMD_WRITE);
 		break;
 	case CFI_CMDSET_AMD_EXTENDED:
 	case CFI_CMDSET_AMD_STANDARD:
diff -Naur u-boot-1.1.2/drivers/eepro100.c uboot-1.1.2hsv/drivers/eepro100.c
--- u-boot-1.1.2/drivers/eepro100.c	2004-01-02 18:43:20.000000000 -0600
+++ uboot-1.1.2hsv/drivers/eepro100.c	2007-05-29 16:51:25.000000000 -0500
@@ -668,6 +668,7 @@
 	return retval;
 }
 
+/* cyclades: should define this CONFIG_EEPRO100_SROM_WRITE in DEB.h to program eeprom. */
 #ifdef CONFIG_EEPRO100_SROM_WRITE
 int eepro100_write_eeprom (struct eth_device* dev, int location, int addr_len, unsigned short data)
 {
@@ -794,6 +795,9 @@
 	}
 }
 
+/* cyclades: for DEB, 82559ER PCI eth's eeprom needs programing. */
+/* cyclades: have a CMD to call eepro100_write_eeprom() when  */
+/* cyclades: defined CONFIG_EEPRO100_SROM_WRITE */
 static void read_hw_addr (struct eth_device *dev, bd_t * bis)
 {
 	u16 eeprom[0x40];
diff -Naur u-boot-1.1.2/drivers/marvell/gtBrgFdb.c uboot-1.1.2hsv/drivers/marvell/gtBrgFdb.c
--- u-boot-1.1.2/drivers/marvell/gtBrgFdb.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtBrgFdb.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,1733 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtBrgFdb.c
+*
+* DESCRIPTION:
+*       API definitions for Multiple Forwarding Databases 
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtSem.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+
+/****************************************************************************/
+/* Forward function declaration.                                            */
+/****************************************************************************/
+static GT_STATUS atuOperationPerform
+(
+    IN      GT_QD_DEV           *dev,
+    IN      GT_ATU_OPERATION    atuOp,
+	INOUT	GT_EXTRA_OP_DATA	*opData,
+    INOUT 	GT_ATU_ENTRY    	*atuEntry
+);
+
+/*******************************************************************************
+* gfdbSetAtuSize
+*
+* DESCRIPTION:
+*       Sets the Mac address table size.
+*
+* INPUTS:
+*       size    - Mac address table size.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetAtuSize
+(
+    IN GT_QD_DEV    *dev,
+    IN ATU_SIZE     size
+)
+{
+    GT_U16          data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gfdbSetAtuSize Called.\n"));
+
+	switch(size)
+	{
+		case ATU_SIZE_256:
+			if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
+				data = 0;
+			else
+				return GT_NOT_SUPPORTED;
+			break;
+    	case ATU_SIZE_512:
+    	case ATU_SIZE_1024:
+    	case ATU_SIZE_2048:
+			if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
+				data = (GT_U16)size;
+			else
+				data = (GT_U16)size - 1;
+			break;
+
+    	case ATU_SIZE_4096:
+			if ((IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))||(IS_IN_DEV_GROUP(dev,DEV_ATU_562_2048)))
+				return GT_NOT_SUPPORTED;
+			else
+				data = 3;
+			break;
+		default:
+			return GT_NOT_SUPPORTED;
+	}
+	
+	/* Gigabit Switch supports fixed 4096 mac addresses. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+    	if(size != ATU_SIZE_4096)
+			return GT_BAD_PARAM;
+		return GT_OK;
+    }
+    /* Set the Software reset bit.                  */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Make sure the reset operation is completed.  */
+    data = 0;
+    while(data == 0)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,11,1,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetAgingTimeRange
+*
+* DESCRIPTION:
+*       Gets the maximal and minimum age times that the hardware can support.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       maxTimeout - max aging time in secounds.
+*       minTimeout - min aging time in secounds.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAgingTimeRange
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_U32 *maxTimeout,
+    OUT GT_U32 *minTimeout
+)
+{
+    DBG_INFO(("gfdbGetAgingTimeRange Called.\n"));
+    if((maxTimeout == NULL) || (minTimeout == NULL))
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		*minTimeout = 15;
+		*maxTimeout = 3825;
+	}
+	else
+	{
+		*minTimeout = 16;
+		*maxTimeout = 4080;
+	}
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbSetAgingTimeout
+*
+* DESCRIPTION:
+*       Sets the timeout period in seconds for aging out dynamically learned
+*       forwarding information. The standard recommends 300 sec.
+*
+* INPUTS:
+*       timeout - aging time in seconds.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetAgingTimeout
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32 timeout
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+	GT_U16			timeBase;
+
+    DBG_INFO(("gfdbSetAgingTimeout Called.\n"));
+ 
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+		timeBase = 15;
+	else
+		timeBase = 16;
+
+	if((timeout < timeBase) && (timeout != 0))
+	{	
+ 	   data = 1;
+	}
+	else
+	{
+ 	   data = (GT_U16)(timeout/timeBase);
+	   if (data & 0xFF00)
+			data = 0xFF;
+	}
+
+    /* Set the Time Out value.              */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,4,8,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetLearn2All
+*
+* DESCRIPTION:
+*		When more than one Marvell device is used to form a single 'switch', it
+*		may be desirable for all devices in the 'switch' to learn any address this 
+*		device learns. When this bit is set to a one all other devices in the 
+*		'switch' learn the same addresses this device learns. When this bit is 
+*		cleared to a zero, only the devices that actually receive frames will learn
+*		from those frames. This mode typically supports more active MAC addresses 
+*		at one time as each device in the switch does not need to learn addresses 
+*		it may nerver use.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetLearn2All
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetLearn2All Called.\n"));
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Learn2All. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gfdbSetLearn2All
+*
+* DESCRIPTION:
+*		Enable or disable Learn2All mode.
+*
+* INPUTS:
+*		mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetLearn2All
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gprtSetLearn2All Called.\n"));
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Learn2All. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gfdbGetAtuDynamicCount
+*
+* DESCRIPTION:
+*       Gets the current number of dynamic unicast entries in this
+*       Filtering Database.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numDynEntries - number of dynamic entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuDynamicCount
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_U32 *numDynEntries
+)
+{
+    GT_U32          dbNum, maxDbNum, numOfEntries;
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbGetAtuDynamicCount Called.\n"));
+
+    numOfEntries = 0;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL))
+		maxDbNum = 16;
+	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+		maxDbNum = 256;
+	else
+		maxDbNum = 1;
+		
+
+	for(dbNum=0; dbNum<maxDbNum; dbNum++)
+	{
+		entry.DBNum = (GT_U8)dbNum;
+
+		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+		    gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+		else
+    		gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+	    while(1)
+    	{
+	        retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+        	if(retVal != GT_OK)
+	        {
+    	        DBG_INFO(("Failed.\n"));
+        	    return retVal;
+	        }
+
+    	    if(IS_BROADCAST_MAC(entry.macAddr))
+        	    break;
+
+	        if((IS_MULTICAST_MAC(entry.macAddr)) || (entry.entryState.ucEntryState == GT_UC_STATIC))
+    	    {
+	            continue;
+    	    }
+
+        	numOfEntries++;
+	    }
+	}
+
+    *numDynEntries = numOfEntries;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic MAC address entry from the ATU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from Mac[00:00:00:00:00:00]
+*
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuEntryFirst
+(
+    IN GT_QD_DEV    *dev,
+    OUT GT_ATU_ENTRY    *atuEntry
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbGetAtuEntryFirst Called.\n"));
+
+	if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+	    gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+	else
+    	gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+	entry.DBNum = atuEntry->DBNum;
+
+    DBG_INFO(("DBNum : %i\n",entry.DBNum));
+
+    retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    if(IS_BROADCAST_MAC(entry.macAddr))
+    {
+		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+		{
+	        DBG_INFO(("Failed (Invalid Mac).\n"));
+    	    return GT_NO_SUCH;
+		}
+		else if(entry.entryState.ucEntryState == 0)
+		{
+	        DBG_INFO(("Failed (Invalid Mac).\n"));
+    	    return GT_NO_SUCH;
+		}
+    }
+
+    gtMemCpy(atuEntry->macAddr.arEther,entry.macAddr.arEther,6);
+    atuEntry->portVec   = entry.portVec;
+    atuEntry->prio      = entry.prio;
+    atuEntry->trunkMember = entry.trunkMember;
+
+    if(IS_MULTICAST_MAC(entry.macAddr))
+    {
+        if(dev->deviceId == GT_88E6051)
+        {
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+        }
+
+        atuEntry->entryState.mcEntryState = entry.entryState.ucEntryState;
+    }
+    else
+    {
+		atuEntry->entryState.ucEntryState = entry.entryState.ucEntryState;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic MAC address from the specified Mac Addr.
+*
+* INPUTS:
+*       atuEntry - the Mac Address to start the search.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
+*       user.
+*
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuEntryNext
+(
+    IN GT_QD_DEV    *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbGetAtuEntryNext Called.\n"));
+    gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+
+	entry.DBNum = atuEntry->DBNum;
+    DBG_INFO(("DBNum : %i\n",entry.DBNum));
+
+    retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    if(IS_BROADCAST_MAC(entry.macAddr))
+    {
+		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+		{
+	        DBG_INFO(("Failed (Invalid Mac).\n"));
+    	    return GT_NO_SUCH;
+		}
+		else if(entry.entryState.ucEntryState == 0)
+		{
+	        DBG_INFO(("Failed (Invalid Mac).\n"));
+    	    return GT_NO_SUCH;
+		}
+    }
+
+    gtMemCpy(atuEntry->macAddr.arEther,entry.macAddr.arEther,6);
+    atuEntry->portVec   = entry.portVec;
+    atuEntry->prio      = entry.prio;
+    atuEntry->trunkMember = entry.trunkMember;
+
+    if(IS_MULTICAST_MAC(entry.macAddr))
+    {
+        if(dev->deviceId == GT_88E6051)
+        {
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+        }
+
+        atuEntry->entryState.mcEntryState = entry.entryState.ucEntryState;
+    }
+    else
+    {
+        atuEntry->entryState.ucEntryState = entry.entryState.ucEntryState;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gfdbFindAtuMacEntry
+*
+* DESCRIPTION:
+*       Find FDB entry for specific MAC address from the ATU.
+*
+* INPUTS:
+*       atuEntry - the Mac address to search.
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       atuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbFindAtuMacEntry
+(
+    IN GT_QD_DEV    *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry,
+    OUT GT_BOOL         *found
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+    int           i;
+
+    DBG_INFO(("gfdbFindAtuMacEntry Called.\n"));
+    *found = GT_FALSE;
+    gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+	entry.DBNum = atuEntry->DBNum;
+
+    /* Decrement 1 from mac address.    */
+    for(i=5; i >= 0; i--)
+    {
+        if(entry.macAddr.arEther[i] != 0)
+        {
+            entry.macAddr.arEther[i] -= 1;
+            break;
+        }
+		else
+            entry.macAddr.arEther[i] = 0xFF;
+    }
+
+    /* Check if the given mac equals zero   */
+    if(i == -1)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_NO_SUCH;
+    }
+
+    retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(IS_BROADCAST_MAC(entry.macAddr))
+    {
+		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+		{
+	        DBG_INFO(("Failed (Invalid Mac).\n"));
+    	    return GT_NO_SUCH;
+		}
+		else if(entry.entryState.ucEntryState == 0)
+		{
+	        DBG_INFO(("Failed (Invalid Mac).\n"));
+    	    return GT_NO_SUCH;
+		}
+    }
+
+	if(gtMemCmp(atuEntry->macAddr.arEther,entry.macAddr.arEther,ETHERNET_HEADER_SIZE))
+	{
+        DBG_INFO(("Failed.\n"));
+        return GT_NO_SUCH;
+	}
+
+    atuEntry->portVec   = entry.portVec;
+    atuEntry->prio      = entry.prio;
+    atuEntry->trunkMember = entry.trunkMember;
+
+    if(IS_MULTICAST_MAC(entry.macAddr))
+    {
+        if(dev->deviceId == GT_88E6051)
+        {
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+        }
+
+        atuEntry->entryState.mcEntryState = entry.entryState.ucEntryState;
+    }
+    else
+    {
+		atuEntry->entryState.ucEntryState = entry.entryState.ucEntryState;
+    }
+
+    *found = GT_TRUE;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gfdbFlush
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the MAC Address
+*       Table.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbFlush
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_FLUSH_CMD flushCmd
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbFlush Called.\n"));
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	entry.DBNum = 0;
+	entry.entryState.ucEntryState = 0;
+
+    if(flushCmd == GT_FLUSH_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL,NULL,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED,NULL,&entry);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbFlushInDB
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the particular
+*       ATU Database (DBNum). If multiple address databases are being used, this
+*		API can be used to flush entries in a particular DBNum database.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*		DBNum	 - ATU MAC Address Database Number. 
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbFlushInDB
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_FLUSH_CMD flushCmd,
+	IN GT_U8 DBNum
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbFlush Called.\n"));
+    DBG_INFO(("gfdbFush: dev=%x, dev->atuRegsSem=%d \n",dev, dev->atuRegsSem));
+
+    /* check if device supports this feature */
+	if ((!IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL)) && (!IS_IN_DEV_GROUP(dev,DEV_DBNUM_256)))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	entry.DBNum = DBNum;
+	entry.entryState.ucEntryState = 0;
+
+    if(flushCmd == GT_FLUSH_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL_IN_DB,NULL,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED_IN_DB,NULL,&entry);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbMove
+*
+* DESCRIPTION:
+*       This routine moves all or unblocked addresses from a port to another.
+*
+* INPUTS:
+* 		moveCmd  - the move operation type.
+*		moveFrom - port where moving from
+*		moveTo   - port where moving to
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMove
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_MOVE_CMD  moveCmd,
+	IN GT_LPORT		moveFrom,
+	IN GT_LPORT		moveTo
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+	GT_EXTRA_OP_DATA	opData;
+
+    DBG_INFO(("gfdbMove Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	entry.DBNum = 0;
+	entry.entryState.ucEntryState = 0xF;
+	opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
+	opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
+
+    if(moveCmd == GT_MOVE_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL,&opData,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED,&opData,&entry);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbMoveInDB
+*
+* DESCRIPTION:
+*       This routine move all or unblocked addresses which are in the particular
+*       ATU Database (DBNum) from a port to another.
+*
+* INPUTS:
+*       moveCmd  - the move operation type.
+*		DBNum	 - ATU MAC Address Database Number.
+*		moveFrom - port where moving from
+*		moveTo   - port where moving to
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMoveInDB
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD 	moveCmd,
+	IN GT_U8 		DBNum,
+	IN GT_LPORT		moveFrom,
+	IN GT_LPORT		moveTo
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+	GT_EXTRA_OP_DATA	opData;
+
+    DBG_INFO(("gfdbMoveInDB Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	entry.DBNum = DBNum;
+	entry.entryState.ucEntryState = 0xF;
+	opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
+	opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
+
+    if(moveCmd == GT_MOVE_ALL)
+        retVal = atuOperationPerform(dev,FLUSH_ALL_IN_DB,&opData,&entry);
+    else
+        retVal = atuOperationPerform(dev,FLUSH_UNLOCKED_IN_DB,&opData,&entry);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbRemovePort
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port.
+*
+* INPUTS:
+*       moveCmd - the move operation type.
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbRemovePort
+(
+	IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD 	moveCmd,
+    IN GT_LPORT		port
+)
+{
+    DBG_INFO(("gfdbRemovePort Called.\n"));
+
+	/* Only 88E6093 Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	return gfdbMove(dev,moveCmd,port,(GT_LPORT)0xF);
+}
+
+
+/*******************************************************************************
+* gfdbRemovePortInDB
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port in the
+*       particular ATU Database (DBNum).
+*
+* INPUTS:
+*       moveCmd  - the move operation type.
+*       port - the logical port number.
+*		DBNum	 - ATU MAC Address Database Number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbRemovePortInDB
+(
+	IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD 	moveCmd,
+    IN GT_LPORT		port,
+	IN GT_U8 		DBNum
+)
+{
+    DBG_INFO(("gfdbRemovePortInDB Called.\n"));
+
+	/* Only 88E6093 Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+	return gfdbMoveInDB(dev,moveCmd,DBNum,port,(GT_LPORT)0xF);
+}
+
+
+/*******************************************************************************
+* gfdbAddMacEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in MAC address table.
+*
+* INPUTS:
+*       macEntry    - mac address entry to insert to the ATU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_NO_RESOURCE    - failed to allocate a t2c struct
+*       GT_OUT_OF_CPU_MEM - oaMalloc failed
+*
+* COMMENTS:
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbAddMacEntry
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ATU_ENTRY *macEntry
+)
+{
+    GT_STATUS       retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbAddMacEntry Called.\n"));
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    gtMemCpy(entry.macAddr.arEther,macEntry->macAddr.arEther,6);
+	entry.DBNum		= macEntry->DBNum;
+    entry.prio	    = macEntry->prio;
+    entry.portVec     = macEntry->portVec;
+	if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+	{
+	    entry.trunkMember = macEntry->trunkMember;
+	}
+	else
+	{
+	    entry.trunkMember = GT_FALSE;
+	}
+
+    if(IS_MULTICAST_MAC(entry.macAddr))
+    {
+        entry.entryState.ucEntryState = macEntry->entryState.mcEntryState;
+    }
+    else
+        entry.entryState.ucEntryState = macEntry->entryState.ucEntryState;
+
+	if (entry.entryState.ucEntryState == 0)
+	{
+        DBG_INFO(("Entry State should not be ZERO.\n"));
+		return GT_BAD_PARAM;
+	}
+
+    retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gfdbDelMacEntry
+*
+* DESCRIPTION:
+*       Deletes MAC address entry.
+*
+* INPUTS:
+*       macAddress - mac address.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbDelMacEntry
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR  *macAddress
+)
+{
+    GT_STATUS retVal;
+    GT_ATU_ENTRY    entry;
+
+    DBG_INFO(("gfdbDelMacEntry Called.\n"));
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    gtMemCpy(entry.macAddr.arEther,macAddress->arEther,6);
+	entry.DBNum = 0;
+	entry.prio = 0;
+	entry.portVec = 0;
+	entry.entryState.ucEntryState = 0;
+	entry.trunkMember = GT_FALSE;
+
+    retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbDelAtuEntry
+*
+* DESCRIPTION:
+*       Deletes ATU entry.
+*
+* INPUTS:
+*       atuEntry - the ATU entry to be deleted.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbDelAtuEntry
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ATU_ENTRY  *atuEntry
+)
+{
+    GT_ATU_ENTRY    entry;
+    GT_STATUS retVal;
+
+    DBG_INFO(("gfdbDelMacEntry Called.\n"));
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
+	entry.DBNum = atuEntry->DBNum;
+	entry.prio = 0;
+	entry.portVec = 0;
+    entry.entryState.ucEntryState = 0;
+    entry.trunkMember = GT_FALSE;
+
+    retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gfdbLearnEnable
+*
+* DESCRIPTION:
+*       Enable/disable automatic learning of new source MAC addresses on port
+*       ingress.
+*
+* INPUTS:
+*       en - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbLearnEnable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL  en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+	GT_LPORT	port;
+	GT_BOOL		mode;
+
+    DBG_INFO(("gfdbLearnEnable Called.\n"));
+    BOOL_2_BIT(en,data);
+    data = 1 - data;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		mode = (en)?GT_FALSE:GT_TRUE;
+
+		for (port=GT_LPORT_2_PORT(0); port<GT_LPORT_2_PORT(dev->numOfPorts); port++)
+		{
+			retVal = gprtSetLearnDisable(dev,port,mode);
+		    if(retVal != GT_OK)
+    		{
+	    	    DBG_INFO(("Failed.\n"));
+    	    	return retVal;
+		    }
+		}
+	}
+	else
+	{
+	    /* Set the Learn Enable bit.            */
+    	retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,14,1,data);
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+	}	
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* gatuGetViolation
+*
+* DESCRIPTION:
+*       Get ATU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*		This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gatuGetViolation
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_ATU_INT_STATUS *atuIntStatus
+)
+{
+    GT_U16              intCause;
+    GT_STATUS       	retVal;
+    GT_ATU_ENTRY    	entry;
+	GT_EXTRA_OP_DATA	opData;
+
+    DBG_INFO(("gatuGetViolation Called.\n"));
+
+	/* check which Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,3,1,&intCause);
+    if(retVal != GT_OK)
+    {
+	    DBG_INFO(("ERROR to read ATU OPERATION Register.\n"));
+        return retVal;
+    }
+
+	if (!intCause)
+	{
+		/* No Violation occurred. */
+		atuIntStatus->atuIntCause = 0;
+		return GT_OK;
+	}
+
+    retVal = atuOperationPerform(dev,SERVICE_VIOLATIONS,&opData,&entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (atuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	atuIntStatus->atuIntCause = opData.intCause;
+	atuIntStatus->spid = entry.entryState.ucEntryState;
+    gtMemCpy(atuIntStatus->macAddr.arEther,entry.macAddr.arEther,6);
+	
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* atuOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all ATU control functions, and is responsible
+*       to write the required operation into the ATU registers.
+*
+* INPUTS:
+*       atuOp       - The ATU operation bits to be written into the ATU
+*                     operation register.
+*       DBNum       - ATU Database Number for CPU accesses
+*       entryPri    - The EntryPri field in the ATU Data register.
+*       portVec     - The portVec field in the ATU Data register.
+*       entryState  - The EntryState field in the ATU Data register.
+*       atuMac      - The Mac address to be written to the ATU Mac registers.
+*
+* OUTPUTS:
+*       entryPri    - The EntryPri field in case the atuOp is GetNext.
+*       portVec     - The portVec field in case the atuOp is GetNext.
+*       entryState  - The EntryState field in case the atuOp is GetNext.
+*       atuMac      - The returned Mac address in case the atuOp is GetNext.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  if atuMac == NULL, nothing needs to be written to ATU Mac registers.
+*
+*******************************************************************************/
+static GT_STATUS atuOperationPerform
+(
+    IN      GT_QD_DEV           *dev,
+    IN      GT_ATU_OPERATION    atuOp,
+	INOUT	GT_EXTRA_OP_DATA	*opData,
+    INOUT 	GT_ATU_ENTRY    	*entry
+)
+/*
+    IN      GT_U8               DBNum,
+    INOUT   GT_U8               *entryPri,
+    INOUT   GT_U32              *portVec,
+    INOUT   GT_U8               *entryState,
+    INOUT   GT_ETHERADDR        *atuMac
+*/
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U16          opcodeData;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           i;
+    GT_U16			portMask;
+
+    gtSemTake(dev,dev->atuRegsSem,OS_WAIT_FOREVER);
+
+	portMask = (1 << dev->numOfPorts) - 1;
+
+    /* Wait until the ATU in ready. */
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+    }
+
+	opcodeData = 0;
+
+	switch (atuOp)
+	{
+		case LOAD_PURGE_ENTRY:
+				if(!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+				{
+		        data = ( (((entry->prio) & 0x3) << 14) | (((entry->portVec) & portMask) << 4) |
+        		         (((entry->entryState.ucEntryState) & 0xF)) );
+				}
+				else
+				{
+					if (IS_IN_DEV_GROUP(dev,DEV_TRUNK) && entry->trunkMember)
+					{
+						/* portVec represents trunk ID */
+				        data = ( 0x8000 | (((entry->portVec) & 0xF) << 4) |
+        			         (((entry->entryState.ucEntryState) & 0xF)) );
+					}
+					else
+					{
+				        data = ( (((entry->portVec) & portMask) << 4) |
+        			         (((entry->entryState.ucEntryState) & 0xF)) );
+					}
+					opcodeData = (entry->prio & 0x7) << 8;
+				}
+		        retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
+        		if(retVal != GT_OK)
+		        {
+        		    gtSemGive(dev,dev->atuRegsSem);
+		            return retVal;
+        		}
+				/* pass thru */
+
+		case GET_NEXT_ENTRY:
+		        for(i = 0; i < 3; i++)
+        		{
+		            data=(entry->macAddr.arEther[2*i] << 8)|(entry->macAddr.arEther[1 + 2*i]);
+        		    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),data);
+		            if(retVal != GT_OK)
+        		    {
+		                gtSemGive(dev,dev->atuRegsSem);
+        		        return retVal;
+		            }
+        		}
+				break;
+
+		case FLUSH_ALL:
+		case FLUSH_UNLOCKED:
+		case FLUSH_ALL_IN_DB:
+		case FLUSH_UNLOCKED_IN_DB:
+				if (entry->entryState.ucEntryState == 0xF)
+				{
+			        data = 0xF | ((opData->moveFrom & 0xF) << 4) | ((opData->moveTo & 0xF) << 8);
+				}
+				else
+				{
+			        data = 0;
+				}
+		        retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
+       			if(retVal != GT_OK)
+	        	{
+       		    	gtSemGive(dev,dev->atuRegsSem);
+		            return retVal;
+   	    		}
+				break;
+
+		case SERVICE_VIOLATIONS:
+
+				break;
+
+		default :
+				return GT_FAIL;
+	}
+
+    /* Set the ATU Operation register   */
+	if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+	{
+	    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,4,(entry->DBNum & 0xF0) >> 4);
+    	if(retVal != GT_OK)
+	    {
+    	    gtSemGive(dev,dev->atuRegsSem);
+        	return retVal;
+	    }
+	}
+
+    opcodeData |= ((1 << 15) | (atuOp << 12) | (entry->DBNum & 0xF));
+    retVal = hwWriteGlobalReg(dev,QD_REG_ATU_OPERATION,opcodeData);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->atuRegsSem);
+        return retVal;
+    }
+
+	/* If the operation is to service violation operation wait for the response   */
+	if(atuOp == SERVICE_VIOLATIONS)
+	{
+		/* Wait until the VTU in ready. */
+		data = 1;
+		while(data == 1)
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->atuRegsSem);
+				return retVal;
+			}
+		}
+
+		/* get the Interrupt Cause */
+		retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,4,3,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+	
+		switch (data)
+		{
+			case 4:	/* Member Violation */
+				opData->intCause = GT_MEMBER_VIOLATION;
+				break;
+			case 2:	/* Miss Violation */
+				opData->intCause = GT_MISS_VIOLATION;
+				break;
+			case 1:	/* Full Violation */
+				opData->intCause = GT_FULL_VIOLATION;
+				break;
+			default:
+				opData->intCause = 0;
+				gtSemGive(dev,dev->atuRegsSem);
+				return GT_OK;
+		}
+
+		/* get the DBNum that was involved in the violation */
+		retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,0,4,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+
+		entry->DBNum = (GT_U8)(data & 0xF);
+
+		/* get the Source Port ID that was involved in the violation */
+
+		retVal = hwReadGlobalReg(dev,QD_REG_ATU_DATA_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->atuRegsSem);
+			return retVal;
+		}
+
+		entry->entryState.ucEntryState = data & 0xF;
+
+        /* Get the Mac address  */
+        for(i = 0; i < 3; i++)
+        {
+            retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->macAddr.arEther[2*i] = data >> 8;
+            entry->macAddr.arEther[1 + 2*i] = data & 0xFF;
+        }
+
+
+	} /* end of service violations */
+    /* If the operation is a gen next operation wait for the response   */
+    if(atuOp == GET_NEXT_ENTRY)
+    {
+        /* Wait until the ATU in ready. */
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+        }
+
+        /* Get the Mac address  */
+        for(i = 0; i < 3; i++)
+        {
+            retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->macAddr.arEther[2*i] = data >> 8;
+            entry->macAddr.arEther[1 + 2*i] = data & 0xFF;
+        }
+
+        retVal = hwReadGlobalReg(dev,QD_REG_ATU_DATA_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+
+        /* Get the Atu data register fields */
+		if(!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+		{
+        entry->prio = data >> 14;
+        entry->portVec = (data >> 4) & portMask;
+        entry->entryState.ucEntryState = data & 0xF;
+		}
+		else
+		{
+			if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+			{
+				entry->trunkMember = (data & 0x8000)?GT_TRUE:GT_FALSE;
+			}
+			else
+			{
+				entry->trunkMember = GT_FALSE;
+			}
+
+			entry->portVec = (data >> 4) & portMask;
+			entry->entryState.ucEntryState = data & 0xF;
+			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,8,3,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->atuRegsSem);
+				return retVal;
+			}
+			entry->prio = data;
+		}
+    }
+
+    gtSemGive(dev,dev->atuRegsSem);
+    return GT_OK;
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtBrgStp.c uboot-1.1.2hsv/drivers/marvell/gtBrgStp.c
--- u-boot-1.1.2/drivers/marvell/gtBrgStp.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtBrgStp.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,308 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtBrgStp.c
+*
+* DESCRIPTION:
+*       API definitions to handle port spanning tree state.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+static GT_STATUS enhancedBPDUSet(GT_QD_DEV *dev,GT_BOOL en)
+{
+    GT_STATUS       retVal = GT_OK; /* Functions return value.      */
+	GT_U16			enBits;
+
+	/* If disable, reset the BPDU bit(bit0) from Rsvd2CpuEnables register */
+   	if(en == GT_FALSE)
+	{
+		if((retVal = gsysGetRsvd2CpuEnables(dev,&enBits)) != GT_OK)
+		{
+	        DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+			return retVal;
+		}
+		enBits &= ~0x1;
+
+		if((retVal = gsysSetRsvd2CpuEnables(dev,enBits)) != GT_OK)
+		{
+    	    DBG_INFO(("gsysSetRsvd2CpuEnables failed.\n"));
+			return retVal;
+		}
+
+		return retVal;
+	}
+
+	/* 
+		If enable, 
+		1) Set MGMT Pri bits, 
+		2) Set BPDU bit(bit0) from Rsvd2CpuEnables register,
+		3) Enable Rsvd2Cpu
+	*/
+	if((retVal = gsysSetMGMTPri(dev,7)) != GT_OK)
+	{
+        DBG_INFO(("gsysSetMGMTPri failed.\n"));
+		return retVal;
+	}
+
+	if((retVal = gsysGetRsvd2CpuEnables(dev,&enBits)) != GT_OK)
+	{
+        DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+		return retVal;
+	}
+	if((retVal = gsysSetRsvd2CpuEnables(dev,enBits|0x1)) != GT_OK)
+	{
+        DBG_INFO(("gsysSetRsvd2CpuEnables failed.\n"));
+		return retVal;
+	}
+
+	if((retVal = gsysSetRsvd2Cpu(dev,GT_TRUE)) != GT_OK)
+	{
+        DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+		return retVal;
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+* gstpSetMode
+*
+* DESCRIPTION:
+*       This routine Enable the Spanning tree.
+*
+* INPUTS:
+*       en - GT_TRUE for enable, GT_FALSE for disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       when enabled, this function sets all port to blocking state, and inserts
+*       the BPDU MAC into the ATU to be captured to CPU, on disable all port are
+*       being modified to be in forwarding state.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpSetMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_BOOL  en
+)
+{
+    GT_STATUS       retVal = GT_OK; /* Functions return value.      */
+    GT_ATU_ENTRY        atuEntry;   /* The ATU entry data to be set */
+    GT_U32          i, dbNum;
+
+    DBG_INFO(("gstpSetMode Called.\n"));
+    if(dev->deviceId == GT_88E6051)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    if((en == GT_TRUE) && (dev->stpMode == 1))
+    {
+        DBG_INFO(("OK.\n"));
+        return GT_OK;
+    }
+
+	switch(dev->deviceId)
+	{
+		case GT_88E6051:
+		case GT_88E6052:
+			dbNum = 1;
+			break;
+		case GT_FF_HG:
+		case GT_FF_EG:
+		case GT_88E6021:
+		case GT_88E6060:
+		case GT_88E6063:
+		case GT_FH_VPN:
+		case GT_88E6083:
+		case GT_88E6153:
+		case GT_88E6181:
+		case GT_88E6183:
+		case GT_88E6093:
+			dbNum = 16;
+			break;
+		case GT_88E6092:
+		case GT_88E6095:
+		case GT_88E6152:
+		case GT_88E6155:
+		case GT_88E6182:
+		case GT_88E6185:
+			/* 
+				No need to add BPDU entry to the fdb table.
+				Set or reset bit 0 of Rsvd2Cpu register.
+			*/
+			dbNum = 0;
+			retVal = enhancedBPDUSet(dev,en);
+			break;
+		default:
+			dbNum = 16;
+			break;
+	}
+
+	for (i=0; i<dbNum; i++)
+	{
+	    /* Set the Atu entry parameters.    */
+    	atuEntry.macAddr.arEther[0] = 0x01;
+	    atuEntry.macAddr.arEther[1] = 0x80;
+    	atuEntry.macAddr.arEther[2] = 0xC2;
+	    atuEntry.macAddr.arEther[3] = 0x00;
+    	atuEntry.macAddr.arEther[4] = 0x00;
+	    atuEntry.macAddr.arEther[5] = 0x00;
+    	atuEntry.portVec = ( 1 << dev->cpuPortNum);
+	    atuEntry.prio    = 3;
+		atuEntry.DBNum = (GT_U8)i;
+	    atuEntry.entryState.mcEntryState = GT_MC_PRIO_MGM_STATIC;
+
+    	if(en == GT_TRUE)
+	    {
+    	    retVal = gfdbAddMacEntry(dev,&atuEntry);
+	    }
+    	else
+		{
+			if(dev->stpMode == 0)
+				break;
+        	retVal = gfdbDelAtuEntry(dev,&atuEntry);
+		}
+
+		if (retVal != GT_OK)
+			break;
+	}
+
+    if(retVal == GT_OK)
+	{
+	    if(en == GT_TRUE)
+    	    dev->stpMode = 1;
+	    else
+    	    dev->stpMode = 2;
+        DBG_INFO(("OK.\n"));
+	}
+    else
+	{
+   	    dev->stpMode = 0;
+        DBG_INFO(("Failed.\n"));
+	}
+
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gstpSetPortState
+*
+* DESCRIPTION:
+*       This routine set the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       state - the port state to set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpSetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT           port,
+    IN GT_PORT_STP_STATE  state
+)
+{
+    GT_U8           phyPort;        /* Physical port                */
+    GT_U16          data;           /* Data to write to register.   */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gstpSetPortState Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    data    = state;
+
+    /* Set the port state bits.             */
+    retVal= hwSetPortRegField(dev,phyPort, QD_REG_PORT_CONTROL,0,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gstpGetPortState
+*
+* DESCRIPTION:
+*       This routine returns the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       state - the current port state.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpGetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT           port,
+    OUT GT_PORT_STP_STATE  *state
+)
+{
+    GT_U8           phyPort;        /* Physical port                */
+    GT_U16          data;           /* Data read from register.     */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gstpGetPortState Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* Get the port state bits.             */
+    retVal = hwGetPortRegField(dev,phyPort, QD_REG_PORT_CONTROL,0,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *state = data & 0x3;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtBrgVlan.c uboot-1.1.2hsv/drivers/marvell/gtBrgVlan.c
--- u-boot-1.1.2/drivers/marvell/gtBrgVlan.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtBrgVlan.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,1011 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtBrgVlan.c
+*
+* DESCRIPTION:
+*       API definitions to handle port-based vlan configuration.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gprtSetEgressMode
+*
+* DESCRIPTION:
+*       This routine set the egress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the egress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressMode
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_EGRESS_MODE  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gprtSetEgressMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_TAGGING)) != GT_OK ) 
+      return retVal;
+	
+    switch (mode)
+    {
+        case (GT_UNMODIFY_EGRESS):
+            data = 0;
+            break;
+
+        case (GT_TAGGED_EGRESS):
+            data = 2;
+            break;
+
+        case (GT_UNTAGGED_EGRESS):
+            data = 1;
+            break;
+
+        case (GT_ADD_TAG):
+			if(!IS_IN_DEV_GROUP(dev,DEV_EGRESS_DOUBLE_TAGGING))
+			{
+		        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+				return GT_NOT_SUPPORTED;
+			}
+            data = 3;
+            break;
+        default:
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+    }
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,12,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetEgressMode
+*
+* DESCRIPTION:
+*       This routine get the egress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the egress mode.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressMode
+(
+    IN GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_EGRESS_MODE  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    if(mode == NULL)
+        return GT_BAD_PARAM;
+
+    DBG_INFO(("gprtGetEgressMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,12,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    switch (data)
+    {
+        case (0):
+            *mode = GT_UNMODIFY_EGRESS;
+            break;
+
+        case (2):
+            *mode = GT_TAGGED_EGRESS;
+            break;
+
+        case (1):
+            *mode = GT_UNTAGGED_EGRESS;
+            break;
+
+        case (3):
+            *mode = GT_ADD_TAG;
+            break;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtSetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine sets the vlan tunnel mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the vlan tunnel mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gprtSetVlanTunnel Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    BOOL_2_BIT(mode,data);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,7,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine get the vlan tunnel mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the vlan tunnel mode..
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gprtGetVlanTunnel Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL,7,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnSetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*       memPorts    - array of logical ports in the same vlan.
+*       memPortsLen - number of members in memPorts array
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_LPORT  memPorts[],
+    IN GT_U8     memPortsLen
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U8           i;
+
+    DBG_INFO(("gvlnSetPortVlanPorts Called.\n"));
+    if(memPorts == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+    data = 0;
+
+	if(memPortsLen > dev->numOfPorts)
+    {
+        DBG_INFO(("Failed (PortsLen Too Big).\n"));
+        return GT_BAD_PARAM;
+    }
+
+    for(i = 0; i < memPortsLen; i++)
+        data |= (1 << GT_LPORT_2_PORT(memPorts[i]));
+
+    /* numOfPorts = 3 for fullsail, = 10 for octane, = 7 for others */
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,0,dev->numOfPorts,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine gets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*
+* OUTPUTS:
+*       memPorts    - array of logical ports in the same vlan.
+*       memPortsLen - number of members in memPorts array
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_LPORT memPorts[],
+    OUT GT_U8    *memPortsLen
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U8           i;
+
+    DBG_INFO(("gvlnGetPortVlanPorts Called.\n"));
+    if((memPorts == NULL) || (memPortsLen == NULL))
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* memPortsLen = 3 for fullsail, =7 for others */
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,0,dev->numOfPorts,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    i = 0;
+    for(phyPort = 0; phyPort < dev->numOfPorts; phyPort++)
+    {
+        if(((1 << phyPort) & data) != 0)
+        {
+            memPorts[i] = GT_PORT_2_LPORT(phyPort);
+            i++;
+        }
+    }
+    *memPortsLen = i;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvlnSetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine Set the user priority (VPT) LSB bit, to be added to the
+*       user priority on the egress.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortUserPriLsb
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   userPriLsb
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnSetPortUserPriLsb Called.\n"));
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+    BOOL_2_BIT(userPriLsb,data);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,13,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnGetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine gets the user priority (VPT) LSB bit.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*
+* OUTPUTS:
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortUserPriLsb
+(
+    IN GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *userPriLsb
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnGetPortUserPriLsb Called.\n"));
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    if(userPriLsb == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*userPriLsb);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvlnSetPortVid
+*
+* DESCRIPTION:
+*       This routine Set the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*       vid  - the port vlan id.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVid
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_U16       vid
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnSetPortVid Called.\n"));
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,0,12, vid);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvlnGetPortVid
+*
+* DESCRIPTION:
+*       This routine Get the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*
+* OUTPUTS:
+*       vid  - the port vlan id.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVid
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U16   *vid
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnGetPortVid Called.\n"));
+    if(vid == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,0,12, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *vid = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/* the following api's are added for fullsail and clippership */
+
+/*******************************************************************************
+* gvlnSetPortVlanDBNum
+*
+* DESCRIPTION:
+*       This routine sets the port's default VLAN database number (DBNum).
+*
+* INPUTS:
+*       port	- logical port number to set.
+*       DBNum 	- database number for this port 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_U8     DBNum
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnSetPortVlanDBNum Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+	if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4,(GT_U16)((DBNum & 0xF0) >> 4));
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+	}
+	else
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+	}
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanDBNum
+*
+* DESCRIPTION:
+*       This routine gets the port's default VLAN database number (DBNum).
+*
+* INPUTS:
+*       port 	- logical port number to get.
+*
+* OUTPUTS:
+*       DBNum 	- database number for this port 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U8    *DBNum
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data,dataH;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnGetPortVlanDBNum Called.\n"));
+
+    if(DBNum == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+	if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4, &dataH);
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+	}
+	else
+	{
+		dataH = 0;
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *DBNum = (GT_U8)(data | (dataH << 4));
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/********************************************************************
+* gvlnSetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine sets the IEEE 802.1q mode for this port (11:10) 
+*
+* INPUTS:
+*       port	- logical port number to set.
+*       mode 	- 802.1q mode for this port 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanDot1qMode
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT 	port,
+    IN GT_DOT1Q_MODE	mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnSetPortVlanDot1qMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
+      return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2,(GT_U16)mode );
+	}
+	else
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2,(GT_U16)mode );
+	}
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvlnGetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine gets the IEEE 802.1q mode for this (bit 11:10).
+*
+* INPUTS:
+*       port 	- logical port number to get.
+*
+* OUTPUTS:
+*       mode 	- 802.1q mode for this port 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanDot1qMode
+(
+    IN GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_DOT1Q_MODE   *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gvlnGetPortVlanDot1qMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
+      return retVal;
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2, &data);
+	}
+	else
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2, &data);
+	}
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/********************************************************************
+* gvlnSetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine sets the mode for forcing to use default VID
+*
+* INPUTS:
+*       port    - logical port number to set.
+*       mode    - GT_TRUE, force to use default VID
+*                 GT_FAULSE, otherwise 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT 	port,
+    IN GT_BOOL  	mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U16          data;           /* Data to be set into the      */
+
+    DBG_INFO(("gvlnSetPortForceDefaultVID Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
+      return retVal;
+
+    BOOL_2_BIT(mode,data);
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PVID,12,1,data );
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine gets the port mode for ForceDefaultVID (bit 12).
+*
+* INPUTS:
+*       port 	- logical port number to get.
+*
+* OUTPUTS:
+*       mode 	- ForceDefaultVID mode for this port 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV        *dev,
+    IN  GT_LPORT 	port,
+    OUT GT_BOOL    	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+
+    DBG_INFO(("gvlnGetPortVlanDot1qMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
+      return retVal;
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PVID,12,1, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtBrgVtu.c uboot-1.1.2hsv/drivers/marvell/gtBrgVtu.c
--- u-boot-1.1.2/drivers/marvell/gtBrgVtu.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtBrgVtu.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,1149 @@
+#include <marvell/Copyright.h>
+
+/*******************************************************************************
+* gtBrgVtu.c
+*
+* DESCRIPTION:
+*       API definitions for Vlan Translation Unit for 802.1Q.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtSem.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* Forward function declaration.                                            */
+/****************************************************************************/
+#define MEMBER_TAG_CONV_FOR_APP(_dev,_tag)	memberTagConversionForApp(_dev,_tag)
+#define MEMBER_TAG_CONV_FOR_DEV(_dev,_tag)	memberTagConversionForDev(_dev,_tag)
+
+static GT_U8 memberTagConversionForApp
+(
+    IN	GT_QD_DEV           *dev,
+    IN	GT_U8               tag
+)
+{
+	GT_U8 convTag;
+
+	/* check if memberTag needs to be converted */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+		return tag;
+
+	switch(tag)
+	{
+		case 0:
+				convTag = MEMBER_EGRESS_UNMODIFIED;
+				break;
+		case 1:
+				convTag = MEMBER_EGRESS_UNTAGGED;
+				break;
+		case 2:
+				convTag = MEMBER_EGRESS_TAGGED;
+				break;
+		case 3:
+				convTag = NOT_A_MEMBER;
+				break;
+		default:
+				DBG_INFO(("Unknown Tag (%#x) from Device !!!.\n",tag));
+				convTag = 0xFF;
+				break;
+			
+	}
+
+	return convTag;
+}
+
+static GT_U8 memberTagConversionForDev
+(
+    IN	GT_QD_DEV           *dev,
+    IN	GT_U8               tag
+)
+{
+	GT_U8 convTag;
+
+	/* check if memberTag needs to be converted */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+		return tag;
+
+	switch(tag)
+	{
+		case MEMBER_EGRESS_UNMODIFIED:
+				convTag = 0;
+				break;
+		case NOT_A_MEMBER:
+				convTag = 3;
+				break;
+		case MEMBER_EGRESS_UNTAGGED:
+				convTag = 1;
+				break;
+		case MEMBER_EGRESS_TAGGED:
+				convTag = 2;
+				break;
+		default:
+				DBG_INFO(("Unknown Tag (%#x) from App. !!!.\n",tag));
+				convTag = 0xFF;
+				break;
+			
+	}
+
+	return convTag;
+}
+
+static GT_STATUS vtuOperationPerform
+(
+    IN	    GT_QD_DEV           *dev,
+    IN      GT_VTU_OPERATION    vtuOp,
+    INOUT   GT_U8               *valid,
+    INOUT 	GT_VTU_ENTRY    	*vtuEntry
+);
+
+/*******************************************************************************
+* gvtuGetEntryCount
+*
+* DESCRIPTION:
+*       Gets the current number of valid entries in the VTU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numEntries - number of VTU entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryCount
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_U32    *numEntries
+)
+{
+    GT_U8               valid;
+    GT_U32		numOfEntries;
+    GT_STATUS       	retVal;
+    GT_VTU_ENTRY    	entry;
+
+    DBG_INFO(("gvtuGetEntryCount Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+      return retVal;
+
+    entry.vid = 0xFFF;
+    entry.DBNum = 0;
+
+    numOfEntries = 0;
+    while(1)
+    {
+		retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid,&entry);
+		if(retVal != GT_OK)
+		{
+		    DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+	    	return retVal;
+		}
+
+		if( entry.vid==0xFFF )
+		{
+			if (valid==1) numOfEntries++;
+			break;
+		}
+
+        numOfEntries++;
+    }
+
+    *numEntries = numOfEntries;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gvtuGetEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic entry from the VTU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from vid of all one's
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryFirst
+(
+    IN  GT_QD_DEV       *dev,
+    OUT GT_VTU_ENTRY    *vtuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS       	retVal;
+    GT_U8       	i; 
+    GT_VTU_ENTRY    	entry;
+
+    DBG_INFO(("gvtuGetEntryFirst Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+      return retVal;
+
+    entry.vid = 0xFFF;
+    entry.DBNum = 0;
+
+    retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrive the value from the operation */ 
+
+    if((entry.vid == 0xFFF) && (valid == 0))
+	return GT_NO_SUCH;
+
+    vtuEntry->DBNum = entry.DBNum;
+    vtuEntry->vid   = entry.vid;
+	vtuEntry->vidPriOverride = entry.vidPriOverride;
+	vtuEntry->vidPriority = entry.vidPriority;
+    for( i =0; i< dev->numOfPorts;i++)
+    {
+      vtuEntry->vtuData.memberTagP[i]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[i]);
+      vtuEntry->vtuData.portStateP[i]=entry.vtuData.portStateP[i];
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvtuGetEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic VTU entry from the specified VID.
+*
+* INPUTS:
+*       vtuEntry - the VID to start the search.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU  entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from the VID specified by the user.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryNext
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS       	retVal;
+    GT_U8       	i; 
+    GT_VTU_ENTRY    	entry;
+
+    DBG_INFO(("gvtuGetEntryNext Called.\n"));
+    
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+      return retVal;
+
+    entry.DBNum = vtuEntry->DBNum;
+    entry.vid   = vtuEntry->vid;
+    valid = 0;
+
+    retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrive the value from the operation */ 
+
+	if((entry.vid == 0xFFF) && (valid == 0))
+		return GT_NO_SUCH;
+
+    vtuEntry->DBNum = entry.DBNum;
+    vtuEntry->vid   = entry.vid;
+	vtuEntry->vidPriOverride = entry.vidPriOverride;
+	vtuEntry->vidPriority = entry.vidPriority;
+    for( i =0; i< dev->numOfPorts;i++)
+    {
+      vtuEntry->vtuData.memberTagP[i]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[i]);
+      vtuEntry->vtuData.portStateP[i]=entry.vtuData.portStateP[i];
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvtuFindVidEntry
+*
+* DESCRIPTION:
+*       Find VTU entry for a specific VID, it will return the entry, if found, 
+*       along with its associated data 
+*
+* INPUTS:
+*       vtuEntry - contains the VID to searche for 
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       vtuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuFindVidEntry
+(
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry,
+    OUT GT_BOOL         *found
+)
+{
+    GT_U8               valid;
+    GT_STATUS       	retVal;
+    GT_U8               i;
+    GT_VTU_ENTRY    	entry;
+
+    DBG_INFO(("gvtuFindVidEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+      return retVal;
+
+    *found = GT_FALSE;
+
+    /* Decrement 1 from vid    */
+    entry.vid   = vtuEntry->vid-1;
+    valid = 0; /* valid is not used as input in this operation */
+    entry.DBNum = vtuEntry->DBNum;
+
+    retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* retrive the value from the operation */ 
+
+    if( (entry.vid !=vtuEntry->vid) | (valid !=1) )
+    {
+          DBG_INFO(("Failed.\n"));
+          return GT_NO_SUCH;
+    }
+
+    vtuEntry->DBNum = entry.DBNum;
+	vtuEntry->vidPriOverride = entry.vidPriOverride;
+	vtuEntry->vidPriority = entry.vidPriority;
+
+    for( i =0; i< dev->numOfPorts;i++)
+    {
+      vtuEntry->vtuData.memberTagP[i]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[i]);
+      vtuEntry->vtuData.portStateP[i]=entry.vtuData.portStateP[i];
+    }
+
+    *found = GT_TRUE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvtuFlush
+*
+* DESCRIPTION:
+*       This routine removes all entries from VTU Table.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuFlush
+(
+    IN  GT_QD_DEV       *dev
+)
+{
+    GT_STATUS       retVal;
+
+    DBG_INFO(("gvtuFlush Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+      return retVal;
+
+    retVal = vtuOperationPerform(dev,FLUSH_ALL,NULL,NULL);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvtuAddEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in VTU table based on user input.
+*
+* INPUTS:
+*       vtuEntry    - vtu entry to insert to the VTU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_FULL			  - vtu table is full
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuAddEntry
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_VTU_ENTRY *vtuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS       	retVal;
+    GT_U8       	i; 
+    GT_VTU_ENTRY 	tmpVtuEntry;
+	GT_BOOL		 	found;
+	int				count = 50000;
+    GT_VTU_ENTRY    	entry;
+
+    DBG_INFO(("gvtuAddEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+      return retVal;
+
+    entry.DBNum = vtuEntry->DBNum;
+    entry.vid   = vtuEntry->vid;
+	entry.vidPriOverride = vtuEntry->vidPriOverride;
+	entry.vidPriority = vtuEntry->vidPriority;
+
+    valid = 1; /* for load operation */
+
+    for( i =0; i< dev->numOfPorts;i++)
+    {
+		entry.vtuData.memberTagP[i] = MEMBER_TAG_CONV_FOR_DEV(dev,vtuEntry->vtuData.memberTagP[i]);
+		if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+			entry.vtuData.portStateP[i] = vtuEntry->vtuData.portStateP[i];
+		else
+			entry.vtuData.portStateP[i] = 0;
+    }
+
+    retVal = vtuOperationPerform(dev,LOAD_PURGE_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	/* verify that the given entry has been added */
+	tmpVtuEntry.vid = vtuEntry->vid;
+	tmpVtuEntry.DBNum = vtuEntry->DBNum;
+
+	if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
+	{
+		while(count--);
+		if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
+		{
+			DBG_INFO(("Added entry cannot be found\n"));
+			return retVal;
+		}
+	}
+	if(found == GT_FALSE)
+	{
+		DBG_INFO(("Added entry cannot be found\n"));
+		return GT_FAIL;
+	}
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvtuDelEntry
+*
+* DESCRIPTION:
+*       Deletes VTU entry specified by user.
+*
+* INPUTS:
+*       vtuEntry - the VTU entry to be deleted 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuDelEntry
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_VTU_ENTRY *vtuEntry
+)
+{
+    GT_U8               valid;
+    GT_STATUS       	retVal;
+    GT_VTU_ENTRY    	entry;
+
+    DBG_INFO(("gvtuDelEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK) 
+      return retVal;
+    
+    entry.DBNum = vtuEntry->DBNum;
+    entry.vid   = vtuEntry->vid;
+    valid = 0; /* for delete operation */
+
+    retVal = vtuOperationPerform(dev,LOAD_PURGE_ENTRY,&valid, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* gvtuGetViolation
+*
+* DESCRIPTION:
+*       Get VTU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*		This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+)
+{
+    GT_U8               spid;
+    GT_U16               vid;
+    GT_U16               intCause;
+    GT_STATUS       	retVal;
+    GT_VTU_ENTRY    	entry;
+
+    DBG_INFO(("gvtuGetViolation Called.\n"));
+
+	/* check which Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,4,3,&intCause);
+    if(retVal != GT_OK)
+    {
+	    DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        return retVal;
+    }
+
+	if (intCause == 0)
+	{
+		/* No Violation occurred. */
+		vtuIntStatus->vtuIntCause = 0;
+		return GT_OK;
+	}
+
+    entry.DBNum = 0;
+
+    retVal = vtuOperationPerform(dev,SERVICE_VIOLATIONS,NULL, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	spid = entry.DBNum & 0xF;
+	vid = entry.vid;
+
+	if(spid == 0xF)
+	{
+		vtuIntStatus->vtuIntCause = GT_VTU_FULL_VIOLATION;
+		vtuIntStatus->spid = spid;
+		vtuIntStatus->vid = 0;
+	}
+	else
+	{
+		vtuIntStatus->vtuIntCause = intCause & (GT_MEMBER_VIOLATION | GT_MISS_VIOLATION);
+		vtuIntStatus->spid = spid;
+		vtuIntStatus->vid = vid;
+	}
+	
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gvtuGetViolation2
+*
+* DESCRIPTION:
+*       Get VTU Violation data (for Gigabit Device)
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*		This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation2
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+)
+{
+    GT_U16               intCause;
+    GT_STATUS       	retVal;
+    GT_VTU_ENTRY    	entry;
+
+    DBG_INFO(("gvtuGetViolation2 Called.\n"));
+
+	/* check if Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,5,1,&intCause);
+    if(retVal != GT_OK)
+    {
+	    DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        return retVal;
+    }
+
+	if (intCause == 0)
+	{
+		/* No Violation occurred. */
+		vtuIntStatus->vtuIntCause = 0;
+		return GT_OK;
+	}
+
+    entry.DBNum = 0;
+
+    retVal = vtuOperationPerform(dev,SERVICE_VIOLATIONS,NULL, &entry);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+	/* check which Violation occurred */
+    retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,5,2,&intCause);
+    if(retVal != GT_OK)
+    {
+	    DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        return retVal;
+    }
+
+	switch (intCause)
+	{
+		case 0:
+			/* No Violation occurred. */
+			vtuIntStatus->vtuIntCause = 0;
+			return GT_OK;
+		case 1:
+			/* Miss Violation */
+			vtuIntStatus->vtuIntCause = GT_MISS_VIOLATION;
+			break;
+		case 2:
+			/* Member Violation */
+			vtuIntStatus->vtuIntCause = GT_MEMBER_VIOLATION;
+			break;
+		default :
+			return GT_FAIL;
+	}
+
+	vtuIntStatus->spid = entry.DBNum & 0xF;
+	vtuIntStatus->vid = entry.vid;
+	
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* vtuOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all VTU control functions, and is responsible
+*       to write the required operation into the VTU registers.
+*
+* INPUTS:
+*       vtuOp       - The VTU operation bits to be written into the VTU
+*                     operation register.
+*       DBNum       - DBNum where the given vid belongs to
+*       vid         - vlan id
+*       valid       - valid bit
+*       vtuData     - VTU Data with memberTag information
+*
+* OUTPUTS:
+*       DBNum       - DBNum where the given vid belongs to
+*       vid         - vlan id
+*       valid       - valid bit
+*       vtuData     - VTU Data with memberTag information
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static GT_STATUS vtuOperationPerform
+(
+    IN	    GT_QD_DEV           *dev,
+    IN      GT_VTU_OPERATION    vtuOp,
+    INOUT   GT_U8               *valid,
+	INOUT	GT_VTU_ENTRY    	*entry
+)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16          data;           /* Data to be set into the      */
+                                /* register.                    */
+
+	gtSemTake(dev,dev->vtuRegsSem,OS_WAIT_FOREVER);
+
+	/* Wait until the VTU in ready. */
+	data = 1;
+    while(data == 1)
+    {
+		retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+	}
+
+	/* Set the VTU data register    */
+	/* There is no need to setup data reg. on flush, get next, or service violation */
+	if((vtuOp != FLUSH_ALL) && (vtuOp != GET_NEXT_ENTRY) && (vtuOp != SERVICE_VIOLATIONS))
+	{
+		/* get data from data register for ports 0 to 3 */
+
+		data =  (entry->vtuData.memberTagP[0] & 3)     |
+				((entry->vtuData.memberTagP[1] & 3))<<4 | 
+				((entry->vtuData.memberTagP[2] & 3))<<8 ;
+		data |= ((entry->vtuData.portStateP[0] & 3)<<2|
+				((entry->vtuData.portStateP[1] & 3))<<6 | 
+				((entry->vtuData.portStateP[2] & 3))<<10) ;
+			
+		/****************** if this is for CliperShip *******************/
+		if(dev->numOfPorts > 3)
+		{
+			/* fullsail has 3 ports(0,1,2), clippership has 7 prots(3 to 6)      */
+			/* port 3 is set on VTU_DATA1_REG, port 4-6 are set on VTU_DATA2_REG */
+			data |= ((entry->vtuData.memberTagP[3] & 3)<<12) ;
+			data |= ((entry->vtuData.portStateP[3] & 3)<<14) ;
+		}
+		/****************** end of  CliperShip **************************/
+
+		retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA1_REG,data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		/****************** if this is for CliperShip *******************/
+
+		if(dev->numOfPorts > 4)
+		{
+			/* also need to set data register  ports 4 to 6 */
+
+			data =  (entry->vtuData.memberTagP[4] & 3)   |
+					((entry->vtuData.memberTagP[5] & 3))<<4 |
+					((entry->vtuData.memberTagP[6] & 3))<<8 ;
+			data |= ((entry->vtuData.portStateP[4] & 3)<<2|
+					((entry->vtuData.portStateP[5] & 3))<<6 | 
+					((entry->vtuData.portStateP[6] & 3))<<10) ;
+
+			if(dev->numOfPorts > 7)
+			{
+				/* octane has 10 ports */
+				/* port 7 are set on VTU_DATA2_REG */
+				data |= ((entry->vtuData.memberTagP[7] & 3)<<12) ;
+				data |= ((entry->vtuData.portStateP[7] & 3)<<14) ;
+			}
+
+			retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA2_REG,data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+		}
+		/****************** end of  CliperShip *******************/
+
+		/****************** if this is for Octane *******************/
+
+		if(dev->numOfPorts > 7)
+		{
+			/* also need to set data register  ports 8 to 9 */
+
+			data =  (entry->vtuData.memberTagP[8] & 3)   |
+					((entry->vtuData.memberTagP[9] & 3))<<4;
+			data |= ((entry->vtuData.portStateP[8] & 3)<<2|
+					((entry->vtuData.portStateP[9] & 3))<<6);
+
+			if(dev->numOfPorts > 10)
+			{
+				data |= (((entry->vtuData.memberTagP[10] & 3)<<8) |
+							((entry->vtuData.portStateP[10] & 3)<<10));
+			}
+			
+			if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+			{
+				if(entry->vidPriOverride == GT_TRUE)
+					data |= ((1 << 15) | ((entry->vidPriority & 0x7) << 12));
+			}
+
+			retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+		}
+		/****************** end of Octane *******************/
+    }
+
+	/* Set the Vtu VID registers    */
+	/* There is no need to setup VID reg. on flush and service violation */
+	if((vtuOp != FLUSH_ALL) && (vtuOp != SERVICE_VIOLATIONS) )
+	{
+    	data= ( (entry->vid) & 0xFFF ) | ( (*valid) << 12 );
+	    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_VID_REG),data);
+    	if(retVal != GT_OK)
+	    {
+    		gtSemGive(dev,dev->vtuRegsSem);
+	    	return retVal;
+    	}		
+	}
+
+	/* Start the VTU Operation by defining the DBNum, vtuOp and VTUBusy    */
+	/* 
+	 * Flush operation will skip the above two setup (for data and vid), and 
+	 * come to here directly
+	 */
+
+	if ( entry == NULL )
+		data = (1 << 15) | (vtuOp << 12);
+	else
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+		{
+			/* Since DBNum is defined as GT_U8, it cannot be >= 256. */
+			#if 0
+			if(entry->DBNum >= 256)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return GT_BAD_PARAM;
+			}	
+			#endif
+			data = (1 << 15) | (vtuOp << 12) | ((entry->DBNum & 0xF0) << 4) | (entry->DBNum & 0x0F);
+		}
+		else
+		{
+			if(entry->DBNum >= 16)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return GT_BAD_PARAM;
+			}	
+			data = (1 << 15) | (vtuOp << 12) | entry->DBNum;
+		}
+	}
+
+	retVal = hwWriteGlobalReg(dev,QD_REG_VTU_OPERATION,data);
+	if(retVal != GT_OK)
+	{
+		gtSemGive(dev,dev->vtuRegsSem);
+		return retVal;
+	}
+
+	/* only two operations need to go through the mess below to get some data 
+	 * after the operations -  service violation and get next entry
+	 */
+
+	/* If the operation is to service violation operation wait for the response   */
+	if(vtuOp == SERVICE_VIOLATIONS)
+	{
+		/* Wait until the VTU in ready. */
+		data = 1;
+		while(data == 1)
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+		}
+
+		/* get the Source Port ID that was involved in the violation */
+		retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		entry->DBNum = (GT_U8)(data & 0xF);
+
+		/* get the VID that was involved in the violation */
+
+		retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		/* Get the vid - bits 0-11 */
+		entry->vid   = data & 0xFFF;
+
+
+	} /* end of service violations */
+
+	/* If the operation is a get next operation wait for the response   */
+	if(vtuOp == GET_NEXT_ENTRY)
+	{
+		/* Wait until the VTU in ready. */
+		data = 1;
+		while(data == 1)
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+		}
+
+		/****************** get the DBNum *******************/
+		retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		entry->DBNum = data & 0xF;
+
+		if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+		{
+			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,8,4,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+
+			entry->DBNum |= ((data & 0xF) << 4);
+		}
+
+
+		/****************** get the vid *******************/
+
+		retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+
+		/* the vid is bits 0-11 */
+		entry->vid   = data & 0xFFF;
+
+		/* the vid valid is bits 12 */
+		*valid   = (data >> 12) & 1;
+
+
+		/****************** get the MemberTagP *******************/
+		retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA1_REG,&data);
+		if(retVal != GT_OK)
+		{
+			gtSemGive(dev,dev->vtuRegsSem);
+			return retVal;
+		}
+		/* get data from data register for ports 0 to 3 */
+		entry->vtuData.memberTagP[0]  =  data & 3 ;
+		entry->vtuData.memberTagP[1]  = (data >> 4) & 3 ;
+		entry->vtuData.memberTagP[2]  = (data >> 8) & 3 ;
+		entry->vtuData.portStateP[0]  = (data >> 2) & 3 ;
+		entry->vtuData.portStateP[1]  = (data >> 6) & 3 ;
+		entry->vtuData.portStateP[2]  = (data >> 10) & 3 ;
+
+		/****************** for the switch more than 3 ports *****************/
+
+		if(dev->numOfPorts > 3)
+		{
+			/* fullsail has 3 ports, clippership has 7 prots */
+			entry->vtuData.memberTagP[3]  = (data >>12) & 3 ;
+			entry->vtuData.portStateP[3]  = (data >>14) & 3 ;
+
+			/* get data from data register for ports 4 to 6 */
+			retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA2_REG,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+			entry->vtuData.memberTagP[4]  = data & 3 ;
+			entry->vtuData.memberTagP[5]  = (data >> 4) & 3 ;
+			entry->vtuData.memberTagP[6]  = (data >> 8) & 3 ;
+			entry->vtuData.portStateP[4]  = (data >> 2) & 3 ;
+			entry->vtuData.portStateP[5]  = (data >> 6) & 3 ;
+			entry->vtuData.portStateP[6]  = (data >> 10) & 3 ;
+		}
+		/****************** upto 7 port switch *******************/
+
+		/****************** for the switch more than 7 ports *****************/
+
+		if(dev->numOfPorts > 7)
+		{
+			/* fullsail has 3 ports, clippership has 7 prots */
+			entry->vtuData.memberTagP[7]  = (data >>12) & 3 ;
+			entry->vtuData.portStateP[7]  = (data >>14) & 3 ;
+
+			/* get data from data register for ports 4 to 6 */
+			retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->vtuRegsSem);
+				return retVal;
+			}
+			entry->vtuData.memberTagP[8]  = data & 3 ;
+			entry->vtuData.memberTagP[9]  = (data >> 4) & 3 ;
+			entry->vtuData.portStateP[8]  = (data >> 2) & 3 ;
+			entry->vtuData.portStateP[9]  = (data >> 6) & 3 ;
+
+			if(dev->numOfPorts > 10)
+			{
+				entry->vtuData.memberTagP[10]  = (data >> 8) & 3 ;
+				entry->vtuData.portStateP[10]  = (data >> 10) & 3 ;
+			}
+
+			if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+			{
+				if (data & 0x8000)
+				{
+					entry->vidPriOverride = GT_TRUE;
+					entry->vidPriority = (data >> 12) & 0x7;
+				}
+				else
+				{
+					entry->vidPriOverride = GT_FALSE;
+					entry->vidPriority = 0;
+				}
+			}
+
+		}
+		/****************** upto 11 ports switch *******************/
+
+	} /* end of get next entry */
+
+	gtSemGive(dev,dev->vtuRegsSem);
+	return GT_OK;
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtDebug.c uboot-1.1.2hsv/drivers/marvell/gtDebug.c
--- u-boot-1.1.2/drivers/marvell/gtDebug.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtDebug.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,76 @@
+#include <marvell/Copyright.h>
+/********************************************************************************
+* debug.c
+*
+* DESCRIPTION:
+*       Debug message display routine
+*
+* DEPENDENCIES:
+*       OS Dependent
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#ifdef DEBUG_QD
+#ifdef _VXWORKS
+#include "vxWorks.h"
+#include "logLib.h"
+#include "stdarg.h"
+#elif defined(WIN32)
+#include "windows.h"
+/* #include "wdm.h" */
+#elif defined(LINUX)
+#include "stdarg.h"
+#endif
+
+/*******************************************************************************
+* gtDbgPrint
+*
+* DESCRIPTION:
+*       .
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+#if defined(_VXWORKS) || defined(WIN32) || defined(LINUX)
+void gtDbgPrint(char* format, ...)
+{
+    va_list argP;
+    char dbgStr[1000] = "";
+
+    va_start(argP, format);
+
+    vsprintf(dbgStr, format, argP);
+
+#ifdef _VXWORKS
+	printf(dbgStr);
+/*	logMsg(dbgStr,0,1,2,3,4,5); */
+#elif defined(WIN32)
+	printf(dbgStr);
+/*	DbgPrint(dbgStr);*/
+#elif defined(LINUX)
+	printk(dbgStr);
+#endif
+	return;
+}
+#else
+void gtDbgPrint(char* format, ...)
+{
+}
+#endif
+#else /* DEBUG_QD not defined */
+void gtDbgPrint(char* format, ...)
+{
+}
+#endif /* DEBUG_QD */
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtDrvConfig.c uboot-1.1.2hsv/drivers/marvell/gtDrvConfig.c
--- u-boot-1.1.2/drivers/marvell/gtDrvConfig.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtDrvConfig.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,156 @@
+#include <marvell/Copyright.h>
+/********************************************************************************
+* gtDrvConfig.h
+*
+* DESCRIPTION:
+*       Includes driver level configuration and initialization function.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#include <marvell/gtDrvSwRegs.h>
+#include <marvell/gtDrvConfig.h>
+#include <marvell/gtMiiSmiIf.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/msApiDefs.h>
+
+/*******************************************************************************
+* driverConfig
+*
+* DESCRIPTION:
+*       This function initializes the driver level of the quarterDeck software.
+*
+* INPUTS:
+*		None.
+* OUTPUTS:
+*		None.
+* RETURNS:
+*       GT_OK               - on success, or
+*       GT_OUT_OF_CPU_MEM   - if failed to allocate CPU memory,
+*       GT_FAIL             - otherwise.
+*
+* COMMENTS:
+*       1.  This function should perform the following:
+*           -   Initialize the global switch configuration structure.
+*           -   Initialize Mii Interface
+*           -   Set the CPU port into trailer mode (Ingress and Egress).
+*
+*******************************************************************************/
+GT_STATUS driverConfig
+(
+    IN GT_QD_DEV    *dev
+)
+{
+    GT_U16          deviceId;
+    GT_BOOL         highSmiDevAddr;
+    GT_U32	    portsCount;
+
+	if(dev->accessMode == SMI_AUTO_SCAN_MODE)
+	{	
+	    /* Initialize the MII / SMI interface, search for the device */
+    	if((deviceId = miiSmiIfInit(dev,&highSmiDevAddr)) == 0)
+	    {
+    	    return GT_FAIL;
+	    }
+
+		dev->baseRegAddr = (highSmiDevAddr)?0x10:0;
+	}
+	else
+	{
+    	if((deviceId = miiSmiManualIfInit(dev,(GT_U32)dev->baseRegAddr)) == 0)
+	    {
+    	    return GT_FAIL;
+	    }
+	}
+	
+    /* Init the device's config struct.             */
+    dev->deviceId       = deviceId >> 4;
+    dev->revision       = (GT_U8)deviceId & 0xF; 
+
+    /* Get the number of active ports               */
+
+	switch (dev->deviceId)
+	{
+		case GT_88E6051:
+	                portsCount = 5;
+			break;
+		case GT_88E6021:
+	                portsCount = 3; 
+			break;
+		case GT_FF_EG:
+		case GT_88E6060:
+	                portsCount = 6; 
+			break;
+
+		case GT_88E6052:
+		case GT_88E6063:
+		case GT_FF_HG:
+		case GT_FH_VPN:
+	                portsCount = 7; 
+			break;
+		case GT_88E6083:
+	                portsCount = 10; 
+			break;
+		case GT_88E6152:
+		case GT_88E6155:
+		case GT_88E6153:
+	                portsCount = 6;
+			break;
+		case GT_88E6181:
+	                portsCount = 8;
+			break;
+		case GT_88E6182:
+		case GT_88E6183:
+		case GT_88E6185:
+	                portsCount = 10;
+			break;
+		case GT_88E6092:
+		case GT_88E6093:
+		case GT_88E6095:
+	                portsCount = 11;
+			break;
+		default:
+	                portsCount = 7; 
+			break;
+    }
+
+    dev->numOfPorts = (GT_U8)portsCount;
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* driverEnable
+*
+* DESCRIPTION:
+*       This function enables the switch for full operation, after the driver
+*       Config function was called.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverEnable
+(
+	IN GT_QD_DEV    *dev
+)
+{
+    return GT_OK;
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtDrvEvents.c uboot-1.1.2hsv/drivers/marvell/gtDrvEvents.c
--- u-boot-1.1.2/drivers/marvell/gtDrvEvents.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtDrvEvents.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,92 @@
+#include <marvell/Copyright.h>
+/********************************************************************************
+* gtDrvEvents.c
+*
+* DESCRIPTION:
+*       This file includes function declarations for QuarterDeck interrupts
+*       configuration and handling.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#include <marvell/gtDrvSwRegs.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvEvents.h>
+
+/*******************************************************************************
+* drvEventsInit
+*
+* DESCRIPTION:
+*       This function initializes the driver's interrupt handling mechanism.
+*
+* INPUTS:
+*       intVecNum   - The interrupt vector the switch is connected to.
+*       isrFunc     - A pointer to the Interrupt Service Routine to be
+*                     connected to the given interrupt vector.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success,
+*       GT_FAIL - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS drvEventsInit
+(
+    IN  GT_QD_DEV       *dev,
+    IN GT_U32           intVecNum,
+    IN GT_VOIDFUNCPTR   isrFunc
+)
+{
+#if 0
+    return osInterruptConnect(intVecNum,isrFunc,0);
+#endif
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* eventQdSr
+*
+* DESCRIPTION:
+*       QuarterDeck interrupt service routine.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL eventQdSr
+(
+	IN  GT_QD_DEV* dev,
+	OUT GT_U16* intCause
+)
+{
+    GT_STATUS       retVal;         /* Function calls return value.     */
+
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,0,4,intCause);
+
+    if(retVal != GT_OK)
+        return GT_FALSE;
+
+    return (*intCause)?GT_TRUE:GT_FALSE;
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtEvents.c uboot-1.1.2hsv/drivers/marvell/gtEvents.c
--- u-boot-1.1.2/drivers/marvell/gtEvents.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtEvents.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,239 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtEvents.c
+*
+* DESCRIPTION:
+*       API definitions for system interrupt events handling.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+* eventSetActive
+*
+* DESCRIPTION:
+*       This routine enables/disables the receive of an hardware driven event.
+*
+* INPUTS:
+*       eventType - the event type. any combination of the folowing: 
+*       	GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+*       	GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS eventSetActive
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U32 	 eventType
+)
+{
+    GT_STATUS   retVal;   
+    GT_U16 	data;
+	GT_U16	intMask;
+
+    DBG_INFO(("eventSetActive Called.\n"));
+
+	data = (GT_U16) eventType;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY_ONLY))
+    {
+		intMask = GT_NO_INTERNAL_PHY_INT_MASK;
+    }
+	else
+	{
+		intMask = GT_INT_MASK;
+	}
+	
+	if(data & ~intMask)
+	{
+	    DBG_INFO(("Invalid event type.\n"));
+		return GT_FAIL;
+	}
+
+    /* Set the IntEn bit.               */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,0,7,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* eventGetIntStatus
+*
+* DESCRIPTION:
+*       This routine reads an hardware driven event status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       intCause -  It provides the source of interrupt of the following:
+*       GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+*       GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT. 
+*		For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_PROB and 
+*		if there is no internal phy, GT_PHY_INTERRUPT is not supported.
+*
+* RETURNS:
+*       GT_TRUE - read success and there is a pending event.
+*       GT_FAIL - otherwise
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS eventGetIntStatus
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_U16   *intCause
+)
+{
+    GT_STATUS       retVal;         /* Function calls return value.     */
+
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,0,7,intCause);
+
+    if(retVal != GT_OK)
+        return GT_FALSE;
+
+    return (*intCause)?GT_TRUE:GT_FALSE;
+}
+
+
+/*******************************************************************************
+* gvtuGetIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of VTU interrupt occured
+*
+* INPUTS:
+*       	intType - the type of interrupt which causes an interrupt.
+*			any combination of 
+*			GT_MEMEBER_VIOLATION,
+*			GT_MISS_VIOLATION,
+*			GT_FULL_VIOLATION
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* FULL_VIOLATION is only for Fast Ethernet Switch (not for Gigabit Switch).
+*
+*******************************************************************************/
+
+GT_STATUS gvtuGetIntStatus
+(
+    IN GT_QD_DEV          *dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+)
+{
+    GT_STATUS       retVal;      
+
+    DBG_INFO(("gvtuGetIntStatus Called.\n"));
+   
+    /* check if device supports this feature */
+    if((IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK ) 
+      return GT_FAIL; 
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+	    retVal = gvtuGetViolation(dev,vtuIntStatus);
+	}
+	else
+	{
+	    retVal = gvtuGetViolation2(dev,vtuIntStatus);
+	}
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    
+    return retVal;
+}
+
+/*******************************************************************************
+* gatuGetIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of ATU interrupt occured
+*
+* INPUTS:
+*       	intType - the type of interrupt which causes an interrupt.
+*			any combination of 
+*			GT_MEMEBER_VIOLATION,
+*			GT_MISS_VIOLATION,
+*			GT_FULL_VIOLATION 
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gatuGetIntStatus
+(
+    IN GT_QD_DEV          *dev,
+    OUT GT_ATU_INT_STATUS *atuIntStatus
+)
+{
+    GT_STATUS       retVal;      
+
+    DBG_INFO(("gatuGetIntStatus Called.\n"));
+   
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    retVal = gatuGetViolation(dev,atuIntStatus);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    
+    return retVal;
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtHwCntl.c uboot-1.1.2hsv/drivers/marvell/gtHwCntl.c
--- u-boot-1.1.2/drivers/marvell/gtHwCntl.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtHwCntl.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,1132 @@
+#include <marvell/Copyright.h>
+/********************************************************************************
+* gtHwCntl.c
+*
+* DESCRIPTION:
+*       Functions declarations for Hw accessing quarterDeck phy, internal and
+*       global registers.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtMiiSmiIf.h>
+
+/*******************************************************************************
+* portToSmiMapping
+*
+* DESCRIPTION:
+*       This function mapps port to smi address
+*
+* INPUTS:
+*		dev - device context
+*       portNum - Port number to read the register for.
+*		accessType - type of register (Phy, Port, or Global)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       smiAddr    - smi address.
+*
+*******************************************************************************/
+GT_U8 portToSmiMapping
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8	portNum,
+	IN GT_U32	accessType
+)
+{
+	GT_U8 smiAddr;
+
+	if(IS_IN_DEV_GROUP(dev,DEV_8PORT_SWITCH))
+	{
+		switch(accessType)
+		{
+			case PHY_ACCESS:
+					if (dev->maxPhyNum <= portNum)
+						smiAddr = 0xFF;
+					else
+						smiAddr = PHY_REGS_START_ADDR_8PORT + portNum;
+					break;
+			case PORT_ACCESS:
+					if (dev->numOfPorts <= portNum)
+						smiAddr = 0xFF;
+					else
+						smiAddr = PORT_REGS_START_ADDR_8PORT + portNum;
+					break;
+			case GLOBAL_REG_ACCESS:
+					smiAddr = GLOBAL_REGS_START_ADDR_8PORT;
+					break;
+			default:
+					smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 1;
+					break;
+		}
+	}
+	else
+	{
+		smiAddr = dev->baseRegAddr;
+		switch(accessType)
+		{
+			case PHY_ACCESS:
+					if (dev->maxPhyNum <= portNum)
+						smiAddr = 0xFF;
+					else
+						smiAddr += PHY_REGS_START_ADDR + portNum;
+					break;
+			case PORT_ACCESS:
+					if (dev->numOfPorts <= portNum)
+						smiAddr = 0xFF;
+					else
+						smiAddr += PORT_REGS_START_ADDR + portNum;
+					break;
+			default:
+					smiAddr += GLOBAL_REGS_START_ADDR;
+					break;
+		}
+	}
+
+    return smiAddr;
+}
+
+
+/****************************************************************************/
+/* Phy registers related functions.                                         */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadPhyReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port phy register.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPhyReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	OUT GT_U16   *data
+)
+{
+	GT_U8       phyAddr;
+	GT_STATUS   retVal, retPPU;
+	GT_U16		orgPPU;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+	if (phyAddr == 0xFF)
+	{
+		return GT_BAD_PARAM;
+	}
+
+	if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+	{
+		if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+		{
+			return retPPU;
+		}
+
+		if(orgPPU)
+		{
+			/* Disable PPU so that External Phy can be accessible */
+			if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+			{
+				return retPPU;
+			}
+		}
+	}
+
+	retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+	DBG_INFO(("Read from phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+				portNum,phyAddr,regAddr));
+
+	if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+	{
+		if(orgPPU)
+		{
+			if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+			{
+				return retPPU;
+			}
+		}
+	}
+
+	return retVal;
+
+}
+
+
+/*******************************************************************************
+* hwWritePhyReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port phy register.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePhyReg
+(
+	IN GT_QD_DEV *dev,
+	IN  GT_U8    portNum,
+	IN  GT_U8    regAddr,
+	IN  GT_U16   data
+)
+{
+	GT_U8   		phyAddr;
+	GT_STATUS   retVal, retPPU;
+	GT_U16		orgPPU;
+
+	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+	if (phyAddr == 0xFF)
+	{
+		return GT_BAD_PARAM;
+	}
+
+	if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+	{
+		if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+		{
+			return retPPU;
+		}
+
+		if(orgPPU)
+		{
+			/* Disable PPU so that External Phy can be accessible */
+			if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+			{
+				return retPPU;
+			}
+		}
+	}
+
+	DBG_INFO(("Write to phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+				portNum,phyAddr,regAddr));
+	DBG_INFO(("data 0x%x.\n",data));
+
+	retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+	if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+	{
+		if(orgPPU)
+		{
+			if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+			{
+				return retPPU;
+			}
+		}
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* hwGetPhyRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port phy register.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPhyRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+    if((retVal=hwReadPhyReg(dev,portNum,regAddr,&tmpData)) != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+
+    DBG_INFO(("Read from phy(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetPhyRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port phy register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPhyRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+    if((retVal=hwReadPhyReg(dev,portNum,regAddr,&tmpData)) != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+    return hwWritePhyReg(dev,portNum,regAddr,tmpData);
+}
+
+
+/****************************************************************************/
+/* Per port registers related functions.                                    */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadPortReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port register.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPortReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+	if (phyAddr == 0xFF)
+	{
+		return GT_BAD_PARAM;
+	}
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+    DBG_INFO(("Read from port(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+              portNum,phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWritePortReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port register.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePortReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8   phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
+	if (phyAddr == 0xFF)
+	{
+		return GT_BAD_PARAM;
+	}
+
+    DBG_INFO(("Write to port(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+              portNum,phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    return miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+}
+
+
+/*******************************************************************************
+* hwGetPortRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPortRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+    if((retVal=hwReadPortReg(dev,portNum,regAddr,&tmpData)) != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+    DBG_INFO(("Read from port(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetPortRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPortRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+    if((retVal=hwReadPortReg(dev,portNum,regAddr,&tmpData)) != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+    DBG_INFO(("Write to port(%d) register: regAddr 0x%x, ",
+              portNum,regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+
+    return hwWritePortReg(dev,portNum,regAddr,tmpData);
+}
+
+
+/****************************************************************************/
+/* Global registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadGlobalReg
+*
+* DESCRIPTION:
+*       This function reads a switch's global register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobalReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+    DBG_INFO(("read from global register: phyAddr 0x%x, regAddr 0x%x, ",
+              phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWriteGlobalReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobalReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8   phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+
+    DBG_INFO(("Write to global register: phyAddr 0x%x, regAddr 0x%x, ",
+              phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    return miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+}
+
+
+/*******************************************************************************
+* hwGetGlobalRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobalRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+    if((retVal=hwReadGlobalReg(dev,regAddr,&tmpData)) != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+    DBG_INFO(("Read from global register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetGlobalRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobalRegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+    if((retVal=hwReadGlobalReg(dev,regAddr,&tmpData)) != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+
+    DBG_INFO(("Write to global register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+
+    return hwWriteGlobalReg(dev,regAddr,tmpData);
+}
+
+/*******************************************************************************
+* hwReadGlobal2Reg
+*
+* DESCRIPTION:
+*       This function reads a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobal2Reg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+    DBG_INFO(("read from global 2 register: phyAddr 0x%x, regAddr 0x%x, ",
+              phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWriteGlobal2Reg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobal2Reg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8   phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+
+    DBG_INFO(("Write to global 2 register: phyAddr 0x%x, regAddr 0x%x, ",
+              phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    return miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+}
+
+
+/*******************************************************************************
+* hwGetGlobal2RegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobal2RegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
+)
+{
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+    if((retVal=hwReadGlobal2Reg(dev,regAddr,&tmpData)) != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+    DBG_INFO(("Read from global 2 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* hwSetGlobal2RegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal2RegField
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
+)
+{
+    GT_U16 mask;
+    GT_U16 tmpData;
+	GT_STATUS   retVal;
+
+    if((retVal=hwReadGlobal2Reg(dev,regAddr,&tmpData)) != GT_OK)
+        return retVal;
+
+    CALC_MASK(fieldOffset,fieldLength,mask);
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
+
+    DBG_INFO(("Write to global 2 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
+
+    return hwWriteGlobal2Reg(dev,regAddr,tmpData);
+}
+
+/*******************************************************************************
+* hwReadQDReg
+*
+* DESCRIPTION:
+*       This function reads a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadMiiReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+)
+{
+    GT_STATUS   retVal;
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+    DBG_INFO(("Read from phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
+              phyAddr,regAddr,*data));
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWriteMiiReg
+*
+* DESCRIPTION:
+*       This function writes a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteMiiReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    phyAddr,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_STATUS   retVal;
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    DBG_INFO(("Write to phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
+              phyAddr,regAddr,data));
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwReadPPU
+*
+* DESCRIPTION:
+*			This function reads PPU bit in Global Register
+*
+* INPUTS:
+*			None.
+*
+* OUTPUTS:
+*			data    - The read register's data.
+*
+* RETURNS:
+*			GT_OK on success, or
+*			GT_FAIL otherwise.
+*
+* COMMENTS:
+*			This function can be used to access PHY register connected to Gigabit
+*			Switch.
+*
+*******************************************************************************/
+GT_STATUS hwReadPPU
+(
+	IN  GT_QD_DEV *dev,
+	OUT GT_U16    *data
+)
+{
+	GT_STATUS   retVal;
+
+	retVal = hwGetGlobalRegField(dev,4,14,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
+
+/*******************************************************************************
+* hwWritePPU
+*
+* DESCRIPTION:
+*			This function writes PPU bit in Global Register
+*
+* INPUTS:
+*			data - The value to write into PPU bit
+*
+* OUTPUTS:
+*			None.
+*
+* RETURNS:
+*			GT_OK on success, or
+*			GT_FAIL otherwise.
+*
+* COMMENTS:
+*			This function can be used to access PHY register connected to Gigabit
+*			Switch.
+*
+*******************************************************************************/
+GT_STATUS hwWritePPU
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U16    data
+)
+{
+	GT_STATUS   retVal;
+	GT_U32      retryCount;
+	GT_U16      ppuState;
+
+	retVal = hwSetGlobalRegField(dev,4,14,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+	/* busy wait - till PPU is actually disabled */
+	if (data == 0) /* disable PPU */
+	{
+		for (retryCount = 0x100; retryCount > 0; retryCount--)
+		{
+			retVal = hwGetGlobalRegField(dev,0,14,2, &ppuState);
+			if(retVal != GT_OK)
+			{
+				DBG_INFO(("Failed.\n"));
+				return retVal;
+			}
+			if (ppuState == 2)
+				break;
+		}
+
+		if (retryCount == 0)
+		{
+			DBG_INFO(("Failed.\n"));
+			return GT_FAIL;
+		}
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtMiiSmiIf.c uboot-1.1.2hsv/drivers/marvell/gtMiiSmiIf.c
--- u-boot-1.1.2/drivers/marvell/gtMiiSmiIf.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtMiiSmiIf.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,482 @@
+#include <marvell/Copyright.h>
+/********************************************************************************
+* gtMiiSmiIf.c
+*
+* DESCRIPTION:
+*       Includes functions prototypes for initializing and accessing the
+*       MII / SMI interface.
+*       This is the only file to be included from upper layers.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#include <marvell/gtDrvSwRegs.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtMiiSmiIf.h>
+#include <marvell/platformDeps.h>
+#include <marvell/gtSem.h>
+
+#define QD_SMI_ACCESS_LOOP		1000
+#define QD_SMI_TIMEOUT			2
+
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MIIReg,
+                        unsigned int* value);
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MIIReg,
+                       unsigned int value);
+/*******************************************************************************
+* miiSmiIfInit
+*
+* DESCRIPTION:
+*       This function initializes the MII / SMI interface.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       highSmiDevAddr - Indicates whether to use the high device register
+*                     addresses when accessing switch's registers (of all kinds)
+*                     i.e, the devices registers range is 0x10 to 0x1F, or to
+*                     use the low device register addresses (range 0x0 to 0xF).
+*                       GT_TRUE     - use high addresses (0x10 to 0x1F).
+*                       GT_FALSE    - use low addresses (0x0 to 0xF).
+*
+* RETURNS:
+*       DEVICE_ID       - on success
+*       0    - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U16 miiSmiIfInit
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL * highSmiDevAddr
+)
+{
+	GT_STATUS status;
+	GT_U16 data, data1;
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR,QD_REG_SWITCH_ID,&data)) != GT_OK)
+	{
+		return 0;
+	}
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+1,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+	{
+		return 0;
+	}
+
+	switch(data & 0xFF00)
+	{
+		case 0x0200:
+		case 0x0500:
+		case 0x0600:
+		case 0x1500:
+		case 0xF500:
+		case 0xF900:
+			if (data == data1)
+			{
+				*highSmiDevAddr = GT_FALSE;
+				return data;
+			}
+			break;
+		default:
+			break;
+	}
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x10,QD_REG_SWITCH_ID,&data)) != GT_OK)
+	{
+		return 0;
+	}
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x11,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+	{
+		return 0;
+	}
+
+	switch(data & 0xFF00)
+	{
+		case 0x0200:
+		case 0x0500:
+		case 0x0600:
+		case 0x1500:
+		case 0xF500:
+		case 0xF900:
+			if (data == data1)
+			{
+				*highSmiDevAddr = GT_TRUE;
+				return data;
+			}
+			break;
+		case 0x0800:
+		case 0x1A00:
+		case 0x0900:
+			if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0xF,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+			{
+				return 0;
+			}
+
+			if (data == data1)
+			{
+				*highSmiDevAddr = GT_FALSE;
+				return data;
+			}
+			break;
+		default:
+			break;
+	}
+
+    return 0;
+}
+
+
+/*******************************************************************************
+* miiSmiManualIfInit
+*
+* DESCRIPTION:
+*       This function returns Device ID from the given base address
+*
+* INPUTS:
+*       baseAddr - either 0x0 or 0x10. Indicates whether to use the low device 
+*					register address or high device register address.
+*					The device register range is from 0x0 to 0xF or from 0x10 
+*					to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port 
+*					switchs.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       DEVICE_ID       - on success
+*       0    - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U16 miiSmiManualIfInit
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_U32		baseAddr
+)
+{
+	GT_STATUS status;
+	GT_U16 data;
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+baseAddr,QD_REG_SWITCH_ID,&data)) != GT_OK)
+	{
+		return 0;
+	}
+
+	switch(data & 0xFF00)
+	{
+		case 0x0200:
+		case 0x0500:
+		case 0x0600:
+		case 0x1500:
+		case 0xF500:
+		case 0xF900:
+			return data;
+		default:
+			break;
+	}
+	if(baseAddr != 0)
+		return 0;
+
+	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR_8PORT+baseAddr,QD_REG_SWITCH_ID,&data)) != GT_OK)
+	{
+		return 0;
+	}
+
+	switch(data & 0xFF00)
+	{
+		case 0x0800:
+		case 0x1A00:
+		case 0x0900:
+			return data;
+		default:
+			break;
+	}
+
+    return 0;
+}
+
+
+/*******************************************************************************
+* miiSmiIfReadRegister
+*
+* DESCRIPTION:
+*       This function reads a register throw the SMI / MII interface, to be used
+*       by upper layers.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*
+* OUTPUTS:
+*       data        - The register's data.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS miiSmiIfReadRegister
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U8        phyAddr,
+    IN  GT_U8        regAddr,
+    OUT GT_U16       *data
+)
+{
+    unsigned int tmpData;
+
+	if(dev->accessMode == SMI_MULTI_ADDR_MODE)
+	{
+		if(dev->devEnabled)
+			gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+     	if(qdMultiAddrRead(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
+	    {
+			if(dev->devEnabled)
+				gtSemGive(dev,dev->multiAddrSem);
+    	    return GT_FAIL;
+	    }
+		if(dev->devEnabled)
+			gtSemGive(dev,dev->multiAddrSem);
+	}
+    else
+	{
+     	if(dev->fgtReadMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
+	    {
+    	    return GT_FAIL;
+	    }
+	}
+    *data = (GT_U16)tmpData;
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* miiSmiIfWriteRegister
+*
+* DESCRIPTION:
+*       This function writes to a register throw the SMI / MII interface, to be
+*       used by upper layers.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       data        - The data to be written to the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS miiSmiIfWriteRegister
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U8        phyAddr,
+    IN  GT_U8        regAddr,
+    IN  GT_U16       data
+)
+{
+	if(dev->accessMode == SMI_MULTI_ADDR_MODE)
+	{
+		if(dev->devEnabled)
+			gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+     	if(qdMultiAddrWrite(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
+	    {
+			if(dev->devEnabled)
+				gtSemGive(dev,dev->multiAddrSem);
+    	    return GT_FAIL;
+	    }
+
+		if(dev->devEnabled)
+			gtSemGive(dev,dev->multiAddrSem);
+	}
+    else
+	{
+	    if(dev->fgtWriteMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
+	    {
+    	    return GT_FAIL;
+	    }
+	}
+	return GT_OK;
+}
+
+
+/*****************************************************************************
+* qdMultiAddrRead
+*
+* DESCRIPTION:
+*       This function reads data from a device in the secondary MII bus.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The storage where register date to be saved.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
+                        unsigned int* value)
+{
+	unsigned int smiReg;
+	volatile unsigned int timeOut; /* in 100MS units */
+	volatile int i;
+
+	/* first check that it is not busy */
+    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+
+    if(smiReg & QD_SMI_BUSY) 
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+        do 
+        {
+            if(timeOut-- < 1 ) 
+            {
+    	        return GT_FALSE;
+    	    }
+		    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+		    {
+		        return GT_FALSE;
+		    }
+        } while (smiReg & QD_SMI_BUSY);
+    }
+
+    smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) | 
+    		(regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+    if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+
+    if(smiReg & QD_SMI_BUSY) 
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+		do 
+		{
+            if(timeOut-- < 1 ) 
+            {
+    	        return GT_FALSE;
+    	    }
+		    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+		    {
+		        return GT_FALSE;
+		    }
+        } while (smiReg & QD_SMI_BUSY);
+	}
+    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, &smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+	*value = smiReg;
+    
+	return GT_TRUE;
+}
+
+/*****************************************************************************
+* qdMultiAddrWrite
+*
+* DESCRIPTION:
+*       This function writes data to the device in the secondary MII bus.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The data to be written into the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
+                       unsigned int value)
+{
+	unsigned int smiReg;
+	volatile unsigned int timeOut; /* in 100MS units */
+	volatile int i;
+
+	/* first check that it is not busy */
+    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
+
+    if(smiReg & QD_SMI_BUSY) 
+    {
+        for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
+        do 
+        {
+            if(timeOut-- < 1 ) 
+            {
+    	        return GT_FALSE;
+    	    }
+		    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+		    {
+		        return GT_FALSE;
+		    }
+        } while (smiReg & QD_SMI_BUSY);
+    }
+
+    if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, value) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+    smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) | 
+			(regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+    if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
+    {
+        return GT_FALSE;
+    }
+
+    return GT_TRUE;
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtPCSCtrl.c uboot-1.1.2hsv/drivers/marvell/gtPCSCtrl.c
--- u-boot-1.1.2/drivers/marvell/gtPCSCtrl.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPCSCtrl.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,1706 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtPCSCtrl.c
+*
+* DESCRIPTION:
+*       API implementation for 1000BASE-X PCS block register access.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gpcsGetCommaDet
+*
+* DESCRIPTION:
+*		This routine retrieves Comma Detection status in PCS
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetCommaDet
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetCommaDet Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	if (IS_IN_DEV_GROUP(dev,DEV_PCS_LINK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the CommaDet bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,15,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetPCSLink
+*
+* DESCRIPTION:
+*		This routine retrieves Link up status in PCS
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSLink
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetPCSLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_PCS_LINK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the PCS Link bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,15,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetSyncOK
+*
+* DESCRIPTION:
+*		This routine retrieves SynOK bit. It is set to a one when the PCS has
+*		detected a few comma patterns and is synchronized with its peer PCS 
+*		layer.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if synchronized or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetSyncOK
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetSyncOK Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SyncOK bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,14,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsGetSyncFail
+*
+* DESCRIPTION:
+*		This routine retrieves SynFail bit.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetSyncFail
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetSyncFail Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SyncFail bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,13,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsGetAnBypassed
+*
+* DESCRIPTION:
+*		This routine retrieves Inband Auto-Negotiation bypass status.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetAnBypassed
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetAnBypassed Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the AnBypassed bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,12,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetAnBypassMode
+*
+* DESCRIPTION:
+*		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetAnBypassMode
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetAnBypassMode Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the AnBypass bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,11,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsSetAnBypassMode
+*
+* DESCRIPTION:
+*		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetAnBypassMode
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetAnBypassMode Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the AnBypass bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,11,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetPCSAnEn
+*
+* DESCRIPTION:
+*		This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSAnEn
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetPCSAnEn Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the PCSAnEn bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,10,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsSetPCSAnEn
+*
+* DESCRIPTION:
+*		This routine sets Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetPCSAnEn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetPCSAnEn Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the PCSAnEn bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,10,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gpcsSetRestartPCSAn
+*
+* DESCRIPTION:
+*		This routine restarts PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetRestartPCSAn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetRestartPCSAn Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    data = 1;	/* to set RestartPCSAn bit */
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the RestartPCSAn bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,9,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetPCSAnDone
+*
+* DESCRIPTION:
+*		This routine retrieves completion information of PCS Auto-Negotiation.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE if PCS AN is done or never done
+*			    GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSAnDone
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetPCSAnDone Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given port supports PCS */
+	if (!DOES_DEVPORT_SUPPORT_PCS(dev,hwPort))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the PCSAnDone bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,8,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetFCValue
+*
+* DESCRIPTION:
+*		This routine sets Flow Control's force value
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetFCValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetFCValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the FCValue bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,7,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetFCValue
+*
+* DESCRIPTION:
+*		This routine retrieves Flow Control Value which will be used for Forcing 
+*		Flow Control enabled or disabled.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if FC Force value is one (flow control enabled)
+*			     GT_FALSE otherwise (flow control disabled)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetFCValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetFCValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the FCValue bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,7,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetForcedFC
+*
+* DESCRIPTION:
+*		This routine forces Flow Control. If FCValue is set to one, calling this 
+*		routine with GT_TRUE will force Flow Control to be enabled.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedFC
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetForcedFC Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedFC bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetForcedFC
+*
+* DESCRIPTION:
+*		This routine retrieves Forced Flow Control bit
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if ForcedFC bit is one,
+*			     GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedFC
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedLink bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gpcsSetLinkValue
+*
+* DESCRIPTION:
+*		This routine sets Link's force value
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force link up, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetLinkValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetLinkValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the LinkValue bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,5,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetLinkValue
+*
+* DESCRIPTION:
+*		This routine retrieves Link Value which will be used for Forcing Link 
+*		up or down.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if Link Force value is one (link up)
+*			     GT_FALSE otherwise (link down)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetLinkValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetLinkValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the LinkValue bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,5,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetForcedLink
+*
+* DESCRIPTION:
+*		This routine forces Link. If LinkValue is set to one, calling this 
+*		routine with GT_TRUE will force Link to be up.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force link (up or down), GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedLink
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetForcedLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedLink bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,4,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetForcedLink
+*
+* DESCRIPTION:
+*		This routine retrieves Forced Link bit
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if ForcedLink bit is one,
+*			     GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedLink
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedLink bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,4,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetDpxValue
+*
+* DESCRIPTION:
+*		This routine sets Duplex's Forced value. This function needs to be
+*		called prior to gpcsSetForcedDpx.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force full duplex, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetDpxValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetDpxValue Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the DpxValue bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,3,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetDpxValue
+*
+* DESCRIPTION:
+*		This routine retrieves Duplex's Forced value
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if Duplex's Forced value is set to Full duplex,
+*			     GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetDpxValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForcedLink Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the DpxValue bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,3,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetForcedDpx
+*
+* DESCRIPTION:
+*		This routine forces duplex mode. If DpxValue is set to one, calling this 
+*		routine with GT_TRUE will force duplex mode to be full duplex.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force duplex mode, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedDpx
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetForcedDpx Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(state, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedDpx bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,2,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetForcedDpx
+*
+* DESCRIPTION:
+*		This routine retrieves Forced Duplex.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if ForcedDpx bit is one,
+*			     GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedDpx
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForcedDpx Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForcedDpx bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,2,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsSetForceSpeed
+*
+* DESCRIPTION:
+*		This routine forces Speed.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForceSpeed
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_PORT_FORCED_SPEED_MODE  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsSetForceSpeed Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the Force Speed bits.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,0,2,mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gpcsGetForceSpeed
+*
+* DESCRIPTION:
+*		This routine retrieves Force Speed value
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForceSpeed
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_PORT_FORCED_SPEED_MODE   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gpcsGetForceSpeed Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the ForceSpeed bits.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,0,2,&data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+	
+	*mode = data;
+
+    /* return */
+    return retVal;
+}
+
+
+
+
+
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtPhyCtrl.c uboot-1.1.2hsv/drivers/marvell/gtPhyCtrl.c
--- u-boot-1.1.2/drivers/marvell/gtPhyCtrl.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPhyCtrl.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,2202 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtPhyCtrl.h
+* 
+* DESCRIPTION:
+* API definitions for PHY control facility.
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+#include <marvell/gtVct.h>
+
+/*******************************************************************************
+* phySetAutoMode
+*
+* DESCRIPTION:
+*       This routine will write the given mode to Autonegotiation Advertisement
+*		Register. Supported mode is as follows:
+*		- Auto for both speed and duplex.
+*		- Auto for speed only and Full duplex.
+*		- Auto for speed only and Half duplex.
+*		- Auto for duplex only and speed 100Mbps.
+*		- Auto for duplex only and speed 10Mbps.
+*		
+*
+* INPUTS:
+* port - The logical port number
+* mode - Auto Mode to be written
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement Register
+*******************************************************************************/
+
+static
+GT_STATUS phyIsGigabitCapable
+(
+	IN  GT_QD_DEV 	*dev,
+	IN  GT_U8 		hwPort,
+	OUT GT_U32		*capability
+)
+{
+	GT_U16 u16Data;
+
+    if(hwGetPhyRegField(dev,hwPort,15,12,4,&u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,15));
+   	    return GT_FAIL;
+	}
+
+	*capability = (GT_U32)u16Data;
+	return GT_OK;
+}
+
+#if 0
+static
+GT_BOOL phyIsValidMode
+(
+	IN GT_U32 			capability,
+	IN GT_PHY_AUTO_MODE mode
+)
+{
+	GT_BOOL isValid = GT_TRUE;
+
+	switch(mode)
+	{
+		case SPEED_AUTO_DUPLEX_AUTO:
+				isValid = GT_TRUE				
+				break;
+		case SPEED_1000_DUPLEX_AUTO:
+				if(capability == 0)
+				{
+					isValid = GT_FALSE;
+				}
+				break;
+		case SPEED_100_DUPLEX_AUTO:
+				if(capability & QD_GIGPHY_1000X_CAP)
+				{
+					isValid = GT_FALSE;
+				}
+				break;
+		case SPEED_10_DUPLEX_AUTO:
+				break;
+		case SPEED_AUTO_DUPLEX_FULL:
+				break;
+		case SPEED_AUTO_DUPLEX_HALF:
+				break;
+		case SPEED_1000_DUPLEX_FULL:
+				break;
+		case SPEED_100_DUPLEX_FULL:
+				break;
+		case SPEED_100_DUPLEX_HALF:
+				break;
+		case SPEED_10_DUPLEX_FULL:
+				break;
+		case SPEED_10_DUPLEX_HALF:
+				break;
+		default:
+	 	       DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+				return GT_FAIL;
+
+		}
+	}
+}
+#endif
+
+static 
+GT_STATUS gigCopperSetAutoMode
+(
+	IN GT_QD_DEV *dev,
+	IN GT_U8 hwPort,
+	IN GT_PHY_AUTO_MODE mode,
+	IN GT_U32 capability
+)
+{
+    GT_U16 			u16Data;
+	GT_U8			regOffset;
+	GT_U8			fieldOffset;
+
+    DBG_INFO(("gigCopperSetAutoMode Called.\n"));
+
+	fieldOffset = 8;
+	regOffset = 9;
+
+	switch(mode)
+	{
+		case SPEED_AUTO_DUPLEX_AUTO:
+		case SPEED_1000_DUPLEX_AUTO:
+				u16Data = 2;	/* 1000 Half Duplex is not supported. */
+				break;
+		case SPEED_AUTO_DUPLEX_FULL:
+				if(capability & QD_GIGPHY_1000T_FULL_CAP)
+					u16Data = 2;
+				else
+					u16Data = 0;
+				break;
+		case SPEED_1000_DUPLEX_FULL:
+				if(capability & QD_GIGPHY_1000T_FULL_CAP)
+					u16Data = 2;
+				else
+					return GT_FAIL;
+				break;
+		case SPEED_AUTO_DUPLEX_HALF:
+				u16Data = 0;	/* 1000 Half Duplex is not supported. */
+				break;
+		case SPEED_100_DUPLEX_AUTO:
+		case SPEED_10_DUPLEX_AUTO:
+		case SPEED_100_DUPLEX_FULL:
+		case SPEED_100_DUPLEX_HALF:
+		case SPEED_10_DUPLEX_FULL:
+		case SPEED_10_DUPLEX_HALF:
+				u16Data = 0;
+				break;
+		default:
+	 	       DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+				return GT_FAIL;
+	}
+
+    /* Write to Phy AutoNegotiation Advertisement Register.  */
+    if(hwSetPhyRegField(dev,hwPort,regOffset,fieldOffset,2,u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,regOffset,u16Data));
+   	    return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+static 
+GT_STATUS gigFiberSetAutoMode
+(
+	IN GT_QD_DEV *dev,
+	IN GT_U8 hwPort,
+	IN GT_PHY_AUTO_MODE mode,
+	IN GT_U32 capability
+)
+{
+    GT_U16 			u16Data;
+	GT_U8			regOffset;
+	GT_U8			fieldOffset;
+
+    DBG_INFO(("gigPhySetAutoMode Called.\n"));
+
+	fieldOffset = 5;
+	regOffset = 4;
+
+#if 0
+	fieldOffset = 8;
+	regOffset = 9;
+#endif
+
+	switch(mode)
+	{
+		case SPEED_AUTO_DUPLEX_AUTO:
+		case SPEED_1000_DUPLEX_AUTO:
+				u16Data = 3;
+				break;
+		case SPEED_AUTO_DUPLEX_FULL:
+		case SPEED_1000_DUPLEX_FULL:
+				if(capability & QD_GIGPHY_1000X_FULL_CAP)
+					u16Data = 1;
+				else
+					return GT_FAIL;
+				break;
+		case SPEED_AUTO_DUPLEX_HALF:
+		case SPEED_1000_DUPLEX_HALF:
+				return GT_FAIL;	/* 1000 Half Duplex is not supported. */
+		case SPEED_100_DUPLEX_AUTO:
+		case SPEED_10_DUPLEX_AUTO:
+		case SPEED_100_DUPLEX_FULL:
+		case SPEED_100_DUPLEX_HALF:
+		case SPEED_10_DUPLEX_FULL:
+		case SPEED_10_DUPLEX_HALF:
+		default:
+	 	       DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+				return GT_FAIL;
+	}
+
+    /* Write to Phy AutoNegotiation Advertisement Register.  */
+    if(hwSetPhyRegField(dev,hwPort,regOffset,fieldOffset,2,u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,regOffset,u16Data));
+   	    return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+static 
+GT_STATUS phySetAutoMode
+(
+IN GT_QD_DEV *dev,
+IN GT_U8 hwPort,
+IN GT_PHY_AUTO_MODE mode
+)
+{
+    GT_U16 			u16Data;
+	GT_U32			capability;
+
+    DBG_INFO(("phySetAutoMode Called.\n"));
+
+	if(phyIsGigabitCapable(dev, hwPort, &capability) != GT_OK)
+	{
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+   	    return GT_FAIL;
+	}
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,&u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+   	    return GT_FAIL;
+	}
+
+	/* Mask out all auto mode related bits. */
+	u16Data &= ~QD_PHY_MODE_AUTO_AUTO;
+
+	switch(mode)
+	{
+		case SPEED_AUTO_DUPLEX_AUTO:
+				u16Data |= QD_PHY_MODE_AUTO_AUTO;
+				break;
+		case SPEED_1000_DUPLEX_AUTO:
+				u16Data |= 0;
+				break;
+		case SPEED_100_DUPLEX_AUTO:
+				u16Data |= QD_PHY_MODE_100_AUTO;
+				break;
+		case SPEED_10_DUPLEX_AUTO:
+				u16Data |= QD_PHY_MODE_10_AUTO;
+				break;
+		case SPEED_AUTO_DUPLEX_FULL:
+				u16Data |= QD_PHY_MODE_AUTO_FULL;
+				break;
+		case SPEED_AUTO_DUPLEX_HALF:
+				u16Data |= QD_PHY_MODE_AUTO_HALF;
+				break;
+		case SPEED_1000_DUPLEX_FULL:
+				u16Data |= 0;
+				break;
+		case SPEED_100_DUPLEX_FULL:
+				u16Data |= QD_PHY_100_FULL;
+				break;
+		case SPEED_100_DUPLEX_HALF:
+				u16Data |= QD_PHY_100_HALF;
+				break;
+		case SPEED_10_DUPLEX_FULL:
+				u16Data |= QD_PHY_10_FULL;
+				break;
+		case SPEED_10_DUPLEX_HALF:
+				u16Data |= QD_PHY_10_HALF;
+				break;
+		default:
+	 	       DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+				return GT_FAIL;
+	}
+
+	if(capability & QD_GIGPHY_1000X_CAP)
+	{
+		if(gigFiberSetAutoMode(dev, hwPort, mode, capability) != GT_OK)
+		{
+   		    return GT_FAIL;
+		}
+	}
+	else if(capability & QD_GIGPHY_1000T_CAP)
+	{
+		if(gigCopperSetAutoMode(dev, hwPort, mode, capability) != GT_OK)
+		{
+   		    return GT_FAIL;
+		}
+	}
+
+    /* Write to Phy AutoNegotiation Advertisement Register.  */
+    if(hwWritePhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+   	    return GT_FAIL;
+	}
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+* gprtPhyReset
+*
+* DESCRIPTION:
+*       This routine preforms PHY reset.
+*		After reset, phy will be in Autonegotiation mode.
+*
+* INPUTS:
+* port - The logical port number
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 0.15 - Reset
+* data sheet register 0.13 - Speed
+* data sheet register 0.12 - Autonegotiation
+* data sheet register 0.8  - Duplex Mode
+*******************************************************************************/
+
+GT_STATUS gprtPhyReset
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16 			u16Data;
+
+    DBG_INFO(("gprtPhyReset Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(phySetAutoMode(dev,hwPort,SPEED_AUTO_DUPLEX_AUTO) != GT_OK)
+	{
+	    DBG_INFO(("Setting AutoMode Failed.\n"));
+		return GT_FAIL;
+	}
+
+	u16Data = QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortLoopback
+*
+* DESCRIPTION:
+* Enable/Disable Internal Port Loopback. Enabling Loopback will disable the 
+* Autonegotiation and set the phy mode to 10 Half duplex.
+* To test Loopback on a different mode, such as 100 Full duplex, 
+* user may need to call gprtSetPortSpeed and gprtSetPortDuplexMode.
+* Disabling Loopback does not enable the Autonegotiation, so user may need to call
+* gprtPortAutoNegEnable in order to enable Autonegotiation.
+*
+* INPUTS:
+* port - logical port number
+* enable - If GT_TRUE, enable loopback mode
+* If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortLoopback
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   enable
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16 			u16Data;
+
+    DBG_INFO(("gprtSetPortLoopback Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        return GT_FAIL;
+	}
+
+	if(enable)
+	{
+		u16Data = QD_PHY_LOOPBACK | QD_PHY_RESET;
+	}
+	else
+	{
+		u16Data &= ~QD_PHY_LOOPBACK;
+	}
+
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortSpeed
+*
+* DESCRIPTION:
+* 		Sets speed for a specific logical port. This function will keep the duplex 
+*		mode and loopback mode to the previous value, but disable others, such as 
+*		Autonegotiation.
+*
+* INPUTS:
+* 		port  - logical port number
+* 		speed - port speed. 	GT_TRUE=100Mb/s, GT_FALSE=10Mb/s
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.13 - Speed Selection (LSB)
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortSpeed
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   speed
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16 			u16Data;
+
+    DBG_INFO(("gprtSetPortSpeed Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        return GT_FAIL;
+	}
+
+	if(speed)
+	{
+		u16Data = QD_PHY_RESET | (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX)) | QD_PHY_SPEED;
+	}
+	else
+	{
+		u16Data = QD_PHY_RESET | (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX));
+	}
+
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtPortAutoNegEnable
+*
+* DESCRIPTION:
+* 		Enable/disable an Auto-Negotiation for duplex mode on specific
+* 		logical port. When Autonegotiation is disabled, phy will be in 10Mbps Half 
+*		Duplex mode. Enabling Autonegotiation will set 100BASE-TX Full Duplex, 
+*		100BASE-TX Full Duplex, 100BASE-TX Full Duplex, and 100BASE-TX Full Duplex
+*		in AutoNegotiation Advertisement register.
+*
+* INPUTS:
+* 		port - logical port number
+* 		state - GT_TRUE for enable Auto-Negotiation for duplex mode,
+* 					GT_FALSE otherwise
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.12 - Auto-Negotiation Enable
+* 		data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortAutoNegEnable
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   state
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16 			u16Data;
+
+    DBG_INFO(("gprtPortAutoNegEnable Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(state)
+	{
+		if(phySetAutoMode(dev,hwPort,SPEED_AUTO_DUPLEX_AUTO) != GT_OK)
+		{
+		    DBG_INFO(("Setting AutoMode Failed.\n"));
+			return GT_FAIL;
+		}
+
+		u16Data = QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+	}
+	else
+	{
+		u16Data = QD_PHY_RESET;
+	}
+
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtPortPowerDown
+*
+* DESCRIPTION:
+* 		Enable/disable (power down) on specific logical port. When this function 
+*		is called with normal operation request, phy will set to Autonegotiation 
+*		mode.
+*
+* INPUTS:
+* 		port	- logical port number
+* 		state	-  GT_TRUE: power down
+* 					GT_FALSE: normal operation
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortPowerDown
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   state
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16 			u16Data;
+
+    DBG_INFO(("gprtPortPowerDown Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(state)
+	{
+		if(phySetAutoMode(dev, hwPort,SPEED_AUTO_DUPLEX_AUTO) != GT_OK)
+		{
+		    DBG_INFO(("Setting AutoMode Failed.\n"));
+			return GT_FAIL;
+		}
+
+		u16Data = QD_PHY_POWER;
+	}
+	else
+	{
+		u16Data = QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+	}
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtPortRestartAutoNeg
+*
+* DESCRIPTION:
+* 		Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
+*		it. Loopback and Power Down will be disabled by this routine.
+*
+* INPUTS:
+* 		port - logical port number
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.9 - Restart Auto-Negotiation
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortRestartAutoNeg
+( 
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port
+)
+{
+    GT_STATUS       retVal;      
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16 			u16Data;
+
+    DBG_INFO(("gprtPortRestartAutoNeg Called.\n"));
+  
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        return GT_FAIL;
+	}
+
+	u16Data &= (QD_PHY_DUPLEX | QD_PHY_SPEED);
+	u16Data |= (QD_PHY_RESTART_AUTONEGO | QD_PHY_AUTONEGO);
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetPortDuplexMode
+*
+* DESCRIPTION:
+* 		Sets duplex mode for a specific logical port. This function will keep 
+*		the speed and loopback mode to the previous value, but disable others,
+*		such as Autonegotiation.
+*
+* INPUTS:
+* 		port 	- logical port number
+* 		dMode	- dulpex mode
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.8 - Duplex Mode
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortDuplexMode
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   dMode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16 			u16Data;
+
+    DBG_INFO(("gprtSetPortDuplexMode Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+    if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
+	{
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        return GT_FAIL;
+	}
+
+	if(dMode)
+	{
+		u16Data = QD_PHY_RESET | (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED)) | QD_PHY_DUPLEX;
+	}
+	else
+	{
+		u16Data = QD_PHY_RESET | (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED));
+	}
+
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortAutoMode
+*
+* DESCRIPTION:
+* 		This routine sets up the port with given Auto Mode.
+*		Supported mode is as follows:
+*		- Auto for both speed and duplex.
+*		- Auto for speed only and Full duplex.
+*		- Auto for speed only and Half duplex.
+*		- Auto for duplex only and speed 1000Mbps.
+*		- Auto for duplex only and speed 100Mbps.
+*		- Auto for duplex only and speed 10Mbps.
+*		- Speed 1000Mbps and Full duplex.
+*		- Speed 1000Mbps and Half duplex.
+*		- Speed 100Mbps and Full duplex.
+*		- Speed 100Mbps and Half duplex.
+*		- Speed 10Mbps and Full duplex.
+*		- Speed 10Mbps and Half duplex.
+*		
+*
+* INPUTS:
+* 		port - The logical port number
+* 		mode - Auto Mode to be written
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+* COMMENTS:
+* 		data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+* 		data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+* 		data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+
+GT_STATUS gprtSetPortAutoMode
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_AUTO_MODE mode
+)
+{
+
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+
+	DBG_INFO(("gprtSetPortAutoMode Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(phySetAutoMode(dev,hwPort,mode) != GT_OK)
+	{
+		DBG_INFO(("Setting AutoMode Failed.\n"));
+		return GT_FAIL;
+	}
+
+	u16Data = QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+
+	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+	/* Write to Phy Control Register.  */
+	retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPause
+*
+* DESCRIPTION:
+*       This routine will set the pause bit in Autonegotiation Advertisement
+*		Register. And restart the autonegotiation.
+*
+* INPUTS:
+* port - The logical port number
+* state - either GT_TRUE(for enable) or GT_FALSE(for disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+
+GT_STATUS gprtSetPause
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   state
+)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+
+	DBG_INFO(("phySetPause Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(hwReadPhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,&u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+		return GT_FAIL;
+	}
+
+	if(state == GT_TRUE)
+	{
+		/* Set the Pause bit. */
+		u16Data |= QD_PHY_PAUSE;
+	}
+	else
+	{
+		/* Reset the Pause bit. */
+		u16Data &= ~QD_PHY_PAUSE;
+	}
+
+	/* Write to Phy AutoNegotiation Advertisement Register.  */
+	if(hwWritePhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data) != GT_OK)
+	{
+		DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+		return GT_FAIL;
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* doesDeviceSupportDTE
+*
+* DESCRIPTION:
+*       This routine check if the given device supports DTE.
+*
+* INPUTS:
+*       hwPort - port number to be checked.
+*
+* OUTPUTS:
+*		phyType - PHY_1000M, PHY_1000M_MP, or PHY_100M
+*
+* RETURNS:
+*       GT_OK   			- if the device supports VCT
+*       GT_NOT_SUPPORTED 	- otherwise
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static 
+GT_STATUS doesDeviceSupportDTE
+(
+    IN  GT_QD_DEV *dev,
+	IN	GT_U8 hwPort,
+    OUT GT_U16* phyType
+)
+{
+	GT_STATUS status = GT_OK;
+	GT_U16 ouiMsb, ouiLsb;
+
+    DBG_INFO(("doesDeviceSupportVCT Called.\n"));
+
+	if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if(ouiMsb != MARVELL_OUI_MSb)
+		return GT_NOT_SUPPORTED;
+
+	*phyType = PHY_1000M;
+
+	switch(ouiLsb & PHY_MODEL_MASK)
+	{
+		case DEV_E3082:
+			*phyType = PHY_100M;
+		    DBG_INFO(("Phy is E3082.\n"));
+			break;
+		case DEV_E1111:
+			if((ouiLsb & PHY_REV_MASK) < 2)
+			{
+				*phyType = PHY_1000M_B;
+			}
+			break;
+		case DEV_E114X:
+			if((ouiLsb & PHY_REV_MASK) < 4)
+			{
+				*phyType = PHY_1000M_B;
+			}
+			break;
+		case DEV_E1180:
+		case DEV_EC010:
+			*phyType = PHY_1000M_B;
+		    DBG_INFO(("Gigabit Phy.\n"));
+			break;
+		case DEV_E1149:
+		case DEV_E1112:
+			*phyType = PHY_1000M_MP;
+		    DBG_INFO(("Gigabit Phy with Multi Page mode.\n"));
+			break;
+		default:
+			status = GT_NOT_SUPPORTED;
+		    DBG_INFO(("Unknown Device.\n"));
+			break;
+	}
+
+	return status;
+}
+
+static
+GT_STATUS dteWorkAround_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort
+)
+{
+	GT_STATUS status = GT_OK;
+	GT_U32 threshold[] = {0x000B,0x0000,0x8780,0x0000,0x8F80,0x0000,
+						  0x9780,0x0000,0x9F80,0x0000,0xA780,0x0000,
+						  0xAF80,0x0000,0xB780,0x0000,0xBF80,0x0000,
+						  0xC780,0x0000,0xCF80,0x0000,0xD780,0x0000,
+						  0xDF80,0x0000,0xE780,0x0000,0xEF80,0x0000,
+						  0xF780,0x0000,0xFF80,0x0000};
+	int i, thresholdSize;
+
+	/* force r125 clock */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x807f)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* write thresholds */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000B)) != GT_OK)
+	{
+		return status;
+	}
+
+	thresholdSize = sizeof(threshold)/sizeof(GT_U32);
+
+	for(i=0; i<thresholdSize; i++)
+	{
+		if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	/* setting adc Masking */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0001)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4000)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* setting noise level */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0005)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xA000)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* 
+		offseting cable length measurement by 6.72m(2*4*0.84m)
+		set 30_10.14:11 to 0x1001 for cable length measure.
+	*/ 
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000a)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4840)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* release force r125 clock */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x0000)) != GT_OK)
+	{
+		return status;
+	}
+
+
+	return status;
+}
+
+static
+GT_STATUS dteWorkAround_Phy1000M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort
+)
+{
+	GT_STATUS status = GT_OK;
+	GT_U32 threshold[] = {0x0000,0x8780,0x0000,0x8F80,0x0000,0x9780,
+						  0x0000,0x9F80,0x0000,0xA780,0x0000,0xAF80,
+						  0x0000,0xB780,0x0000,0xBF80,0x0000,0xC780,
+						  0x0000,0xCF80,0x0000,0xD780,0x0000,0xDF80,
+						  0x0000,0xE780,0x0000,0xEF80,0x0000,0xF780,
+						  0x0000,0xFF80,0x0000};
+	int i, thresholdSize;
+
+	/*  */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001B)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x43FF)) != GT_OK)
+	{
+		return status;
+	}
+
+	/*  */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001C)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x9999)) != GT_OK)
+	{
+		return status;
+	}
+
+	/*  */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001F)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xE00C)) != GT_OK)
+	{
+		return status;
+	}
+
+	/*  */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0018)) != GT_OK)
+	{
+		return status;
+	}
+	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xFFA1)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* write thresholds */
+	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0010)) != GT_OK)
+	{
+		return status;
+	}
+
+	thresholdSize = sizeof(threshold)/sizeof(GT_U32);
+
+	for(i=0; i<thresholdSize; i++)
+	{
+		if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	return status;
+}
+
+static
+GT_STATUS feSetDTE
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort,
+	IN  GT_BOOL   state
+)
+{
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+
+	if((retVal = hwReadPhyReg(dev,hwPort,0x10,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	u16Data = state?(u16Data|0x8000):(u16Data&(~0x8000));
+
+	if((retVal = hwWritePhyReg(dev,hwPort,0x10,u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	if((retVal = hwReadPhyReg(dev,hwPort,0x0,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+	if((retVal = hwWritePhyReg(dev,hwPort,0x0,u16Data|0x8000)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	return retVal;
+}
+
+static
+GT_STATUS gigSetDTE
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort,
+	IN  GT_BOOL   state
+)
+{
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+
+	if((retVal = hwReadPhyReg(dev,hwPort,20,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	u16Data = state?(u16Data|0x4):(u16Data&(~0x4));
+
+	if((retVal = hwWritePhyReg(dev,hwPort,20,u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	if((retVal = hwReadPhyReg(dev,hwPort,0x0,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+	if((retVal = hwWritePhyReg(dev,hwPort,0x0,u16Data|0x8000)) != GT_OK)
+	{
+		return retVal;
+	}
+	return retVal;
+}
+
+static
+GT_STATUS gigMPSetDTE
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort,
+	IN  GT_BOOL   state
+)
+{
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+
+	if((retVal = gprtGetPagedPhyReg(dev,hwPort,26,0,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	u16Data = state?(u16Data|0x100):(u16Data&(~0x100));
+
+	if((retVal = gprtSetPagedPhyReg(dev,hwPort,26,0,u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	if((retVal = gprtGetPagedPhyReg(dev,hwPort,0x0,0,&u16Data)) != GT_OK)
+	{
+		return retVal;
+	}
+	if((retVal = gprtSetPagedPhyReg(dev,hwPort,0x0,0,u16Data|0x8000)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+* gprtSetDTEDetect
+*
+* DESCRIPTION:
+*       This routine enables/disables DTE.
+*
+* INPUTS:
+* 		port - The logical port number
+* 		mode - either GT_TRUE(for enable) or GT_FALSE(for disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetect
+(
+	IN GT_QD_DEV *dev,
+	IN GT_LPORT  port,
+	IN GT_BOOL   state
+)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_STATUS		retVal = GT_OK;
+	GT_U16 			phyType;
+
+	DBG_INFO(("phySetDTE Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port supports DTE */
+	if(doesDeviceSupportDTE(dev,hwPort,&phyType) != GT_OK)
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch(phyType)
+	{
+		case PHY_100M:
+			/* FE Phy needs work-around */
+			if((retVal = feSetDTE(dev,hwPort,state)) != GT_OK)
+			{
+				return retVal;
+			}
+
+			if(state == GT_FALSE)
+				break;
+
+			if((retVal = dteWorkAround_Phy100M(dev,hwPort)) != GT_OK)
+			{
+				return retVal;
+			}
+			break;
+		case PHY_1000M_B:
+			/* Gigabit Phy with work-around required */
+			if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
+			{
+				return retVal;
+			}
+
+			if(state == GT_FALSE)
+				break;
+
+			if((retVal = dteWorkAround_Phy1000M(dev,hwPort)) != GT_OK)
+			{
+				return retVal;
+			}
+			break;
+
+		case PHY_1000M:
+			/* no workaround required */
+			if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
+			{
+				return retVal;
+			}
+
+			break;
+		case PHY_1000M_MP:
+			/* no workaround required */
+			if((retVal = gigMPSetDTE(dev,hwPort,state)) != GT_OK)
+			{
+				return retVal;
+			}
+			break;
+		default:
+			return GT_NOT_SUPPORTED;
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectStatus
+*
+* DESCRIPTION:
+*       This routine gets DTE status.
+*
+* INPUTS:
+* 		port - The logical port number
+*
+* OUTPUTS:
+*       status - GT_TRUE, if link partner needs DTE power.
+*				 GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectStatus
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_BOOL   *state
+)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+	GT_U16 			phyType;
+
+	DBG_INFO(("gprtGetDTEStatus Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port supports DTE */
+	if(doesDeviceSupportDTE(dev,hwPort,&phyType) != GT_OK)
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch(phyType)
+	{
+		case PHY_100M:
+			/* FE Phy needs work-around */
+			if((retVal = hwReadPhyReg(dev,hwPort,17,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			*state = (u16Data & 0x8000)?GT_TRUE:GT_FALSE;
+
+			break;
+		case PHY_1000M_B:
+		case PHY_1000M:
+			if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			*state = (u16Data & 0x10)?GT_TRUE:GT_FALSE;
+			
+			break;
+		case PHY_1000M_MP:
+			/* no workaround required */
+			if((retVal = gprtGetPagedPhyReg(dev,hwPort,17,0,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			*state = (u16Data & 0x4)?GT_TRUE:GT_FALSE;
+			break;
+		default:
+			return GT_NOT_SUPPORTED;
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDTEDetectDropWait
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*		will wait a period of time before clearing the power over Ethernet 
+*		detection status bit. The wait time is 5 seconds multiplied by the 
+*		given value.
+*
+* INPUTS:
+* 		port - The logical port number
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetectDropWait
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	IN  GT_U16    waitTime
+)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+	GT_U16 			phyType;
+
+	DBG_INFO(("gprtSetDTEDropWait Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port supports DTE */
+	if(doesDeviceSupportDTE(dev,hwPort,&phyType) != GT_OK)
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch(phyType)
+	{
+		case PHY_100M:
+			if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			u16Data = (u16Data & ~(0xF<<12)) | ((waitTime & 0xF) << 12);
+
+			if((retVal = hwWritePhyReg(dev,hwPort,22,u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			break;
+		case PHY_1000M_B:
+		case PHY_1000M:
+			if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			u16Data = (u16Data & ~(0xF<<5)) | ((waitTime & 0xF) << 5);
+
+			if((retVal = hwWritePhyReg(dev,hwPort,27,u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			
+			break;
+		case PHY_1000M_MP:
+			/* no workaround required */
+			if((retVal = gprtGetPagedPhyReg(dev,hwPort,26,0,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			u16Data = (u16Data & ~(0xF<<4)) | ((waitTime & 0xF) << 4);
+			if((retVal = gprtSetPagedPhyReg(dev,hwPort,26,0,u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			break;
+		default:
+			return GT_NOT_SUPPORTED;
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectDropWait
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*		will wait a period of time before clearing the power over Ethernet 
+*		detection status bit. The wait time is 5 seconds multiplied by the 
+*		returned value.
+*
+* INPUTS:
+* 		port - The logical port number
+*
+* OUTPUTS:
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectDropWait
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_LPORT  port,
+	OUT GT_U16    *waitTime
+)
+{
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16 			u16Data;
+	GT_STATUS		retVal = GT_OK;
+	GT_U16 			phyType;
+
+	DBG_INFO(("gprtSetDTEDropWait Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port supports DTE */
+	if(doesDeviceSupportDTE(dev,hwPort,&phyType) != GT_OK)
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	switch(phyType)
+	{
+		case PHY_100M:
+			if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			u16Data = (u16Data >> 12) & 0xF;
+
+			break;
+		case PHY_1000M_B:
+		case PHY_1000M:
+			if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			u16Data = (u16Data >> 5) & 0xF;
+
+			break;
+		case PHY_1000M_MP:
+			/* no workaround required */
+			if((retVal = gprtGetPagedPhyReg(dev,hwPort,26,0,&u16Data)) != GT_OK)
+			{
+				return retVal;
+			}
+			u16Data = (u16Data >> 4) & 0xF;
+
+			break;
+		default:
+			return GT_NOT_SUPPORTED;
+	}
+
+	*waitTime = u16Data;
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSet1000TMasterMode
+*
+* DESCRIPTION:
+*       This routine set the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_1000T_MASTER_SLAVE structure
+*				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*				masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_1000T_MASTER_SLAVE   *mode
+)
+{
+	GT_STATUS	retVal;         /* Functions return value.      */
+	GT_U8			hwPort;         /* the physical port number     */
+	GT_U16		data;
+	GT_U32		capability;
+
+	DBG_INFO(("gprtSet1000TMasterMode Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(phyIsGigabitCapable(dev, hwPort, &capability) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+		return GT_FAIL;
+	}
+
+	if(!(capability & QD_GIGPHY_1000T_CAP))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(mode->autoConfig == GT_TRUE)
+	{
+		if(mode->masterPrefer == GT_TRUE)
+		{
+			data = 0x1;
+		}
+		else
+		{
+			data = 0x0;
+		}
+	}
+	else
+	{
+		if(mode->masterPrefer == GT_TRUE)
+		{
+			data = 0x6;
+		}
+		else
+		{
+			data = 0x4;
+		}
+	}
+
+	/* Set the Master Mode.    */
+	retVal = hwSetPhyRegField(dev,hwPort, 9,10,3,data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGet1000TMasterMode
+*
+* DESCRIPTION:
+*       This routine set the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_1000T_MASTER_SLAVE structure
+*				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*				masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_1000T_MASTER_SLAVE   *mode
+)
+{
+	GT_STATUS	retVal;         /* Functions return value.      */
+	GT_U8			hwPort;         /* the physical port number     */
+	GT_U16		data;
+	GT_U32		capability;
+
+	DBG_INFO(("gprtGet1000TMasterMode Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	if(phyIsGigabitCapable(dev, hwPort, &capability) != GT_OK)
+	{
+		DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+		return GT_FAIL;
+	}
+
+	if(!(capability & QD_GIGPHY_1000T_CAP))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Set the Master Mode.    */
+	retVal = hwGetPhyRegField(dev,hwPort, 9,10,3,&data);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	if(data & 0x4)	/* Manual Mode */
+	{
+		mode->autoConfig = GT_FALSE;
+
+		if(data & 0x2)
+		{
+			mode->masterPrefer = GT_TRUE;
+		}
+		else
+		{
+			mode->masterPrefer = GT_FALSE;
+		}
+	}
+	else	/* Auto Mode */
+	{
+		mode->autoConfig = GT_TRUE;
+
+		if(data & 0x1)
+		{
+			mode->masterPrefer = GT_TRUE;
+		}
+		else
+		{
+			mode->masterPrefer = GT_FALSE;
+		}
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetPhyReg
+*
+* DESCRIPTION:
+*       This routine reads Phy Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32	     regAddr,
+    OUT GT_U16	     *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPhyReg Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get Phy Register. */
+    if(hwReadPhyReg(dev,hwPort,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	*data = u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPhyReg
+*
+* DESCRIPTION:
+*       This routine writes Phy Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPhyReg
+(
+    IN  GT_QD_DEV		*dev,
+    IN  GT_LPORT		port,
+    IN  GT_U32			regAddr,
+    IN  GT_U16			data
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    
+    DBG_INFO(("gprtSetPhyReg Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the Scheduling bit.              */
+    if(hwWritePhyReg(dev,hwPort,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*		port 	- port to be read
+*		regAddr	- register offset to be read
+*		page	- page number to be read
+*
+* OUTPUTS:
+*		data	- value of the read register
+*
+* RETURNS:
+*       GT_OK   			- if read successed
+*       GT_FAIL   			- if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtGetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+	IN	GT_U32  regAddr,
+	IN	GT_U32  page,
+    OUT GT_U16* data
+)
+{
+	GT_U32 pageReg;
+	GT_U16 orgReg, u16Data;
+
+	if (regAddr < 29)
+	{
+		pageReg = 22;
+		page &= 0xFF;
+	}
+	else
+	{
+		pageReg = 29;
+		page &= 0x3F;
+	}
+
+    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&orgReg) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	do
+	{
+	    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,(GT_U16)page) != GT_OK)
+    	{
+        	DBG_INFO(("Failed.\n"));
+	        return GT_FAIL;
+    	}
+
+	    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&u16Data) != GT_OK)
+    	{
+        	DBG_INFO(("Failed.\n"));
+	        return GT_FAIL;
+    	}
+	} while (u16Data != page);
+
+    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)regAddr, &u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	*data = u16Data;
+
+    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,orgReg) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*		port 	- port to be read
+*		regAddr	- register offset to be read
+*		page	- page number to be read
+*		data	- value of the read register
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*       GT_OK   			- if read successed
+*       GT_FAIL   			- if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtSetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+	IN	GT_U32 regAddr,
+	IN	GT_U32 page,
+    IN  GT_U16 data
+)
+{
+	GT_U32 pageReg;
+	GT_U16 orgReg,u16Data;
+
+	if (regAddr < 29)
+	{
+		pageReg = 22;
+		page &= 0xFF;
+	}
+	else
+	{
+		pageReg = 29;
+		page &= 0x3F;
+	}
+
+    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&orgReg) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	do
+	{
+	    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,(GT_U16)page) != GT_OK)
+    	{
+        	DBG_INFO(("Failed.\n"));
+	        return GT_FAIL;
+    	}
+
+	    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&u16Data) != GT_OK)
+    	{
+        	DBG_INFO(("Failed.\n"));
+	        return GT_FAIL;
+    	}
+	} while (u16Data != page);
+
+    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)regAddr, data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,orgReg) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	return GT_OK;
+}
+
+
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtPhyInt.c uboot-1.1.2hsv/drivers/marvell/gtPhyInt.c
--- u-boot-1.1.2/drivers/marvell/gtPhyInt.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPhyInt.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,222 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtPhyInt.h
+* 
+* DESCRIPTION:
+* API definitions for PHY interrupt handling 
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gprtPhyIntEnable
+*
+* DESCRIPTION:
+* Enable/Disable one PHY Interrupt
+* This register determines whether the INT# pin is asserted when an interrupt 
+* event occurs. When an interrupt occurs, the corresponding bit is set and
+* remains set until register 19 is read via the SMI. When interrupt enable
+* bits are not set in register 18, interrupt status bits in register 19 are 
+* still set when the corresponding interrupt events occur. However, the INT# 
+* is not asserted.
+*
+* INPUTS:
+* port    - logical port number
+* intType - the type of interrupt to enable/disable. any combination of 
+*			GT_SPEED_CHANGED,
+*			GT_DUPLEX_CHANGED,
+*			GT_PAGE_RECEIVED,
+*			GT_AUTO_NEG_COMPLETED,
+*			GT_LINK_STATUS_CHANGED,
+*			GT_SYMBOL_ERROR,
+*			GT_FALSE_CARRIER,
+*			GT_FIFO_FLOW,
+*			GT_CROSSOVER_CHANGED,
+*			GT_POLARITY_CHANGED, and
+*			GT_JABBER
+*
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 18
+*
+*******************************************************************************/
+
+
+GT_STATUS gprtPhyIntEnable
+(
+IN GT_QD_DEV    *dev,
+IN GT_LPORT	port,
+IN GT_U16	intType
+)
+{
+    GT_STATUS       retVal;      
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtPhyIntEnable Called.\n"));
+    
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = hwWritePhyReg(dev,hwPort, QD_PHY_INT_ENABLE_REG, intType);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    
+    return retVal;
+
+}
+
+/*******************************************************************************
+* gprtGetPhyIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of interrupt occured
+*
+* INPUTS:
+* port - logical port number
+* intType - the type of interrupt which causes an interrupt.
+*			any combination of 
+*			GT_SPEED_CHANGED,
+*			GT_DUPLEX_CHANGED,
+*			GT_PAGE_RECEIVED,
+*			GT_AUTO_NEG_COMPLETED,
+*			GT_LINK_STATUS_CHANGED,
+*			GT_SYMBOL_ERROR,
+*			GT_FALSE_CARRIER,
+*			GT_FIFO_FLOW,
+*			GT_CROSSOVER_CHANGED,
+*			GT_POLARITY_CHANGED, and
+*			GT_JABBER
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 19
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntStatus
+(
+IN   GT_QD_DEV  *dev,
+IN   GT_LPORT   port,
+OUT  GT_U16*    intType
+)
+{
+    GT_STATUS       retVal;      
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPhyIntStatus Called.\n"));
+   
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    
+	/* check if the port is configurable */
+	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+	retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_STATUS_REG, intType);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPhyIntPortSummary
+*
+* DESCRIPTION:
+* Lists the ports that have active interrupts. It provides a quick way to 
+* isolate the interrupt so that the MAC or switch does not have to poll the
+* interrupt status register (19) for all ports. Reading this register does not
+* de-assert the INT# pin
+*
+* INPUTS:
+* none
+*
+* OUTPUTS:
+* GT_U8 *intPortMask - bit Mask with the bits set for the corresponding 
+* phys with active interrupt. E.g., the bit number 0 and 2 are set when 
+* port number 0 and 2 have active interrupt
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 20
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntPortSummary
+(
+IN  GT_QD_DEV  *dev,
+OUT GT_U16     *intPortMask
+)
+{
+    GT_STATUS       retVal;      
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPhyIntPortSummary Called.\n"));
+   
+    /* translate LPORT 0 to hardware port */
+    hwPort = GT_LPORT_2_PORT(0);
+
+    *intPortMask=0;
+
+    /* get the interrupt port summary from port 0 */
+	retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_PORT_SUMMARY_REG, intPortMask);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtPortCtrl.c uboot-1.1.2hsv/drivers/marvell/gtPortCtrl.c
--- u-boot-1.1.2/drivers/marvell/gtPortCtrl.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPortCtrl.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,4125 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtPortCtrl.c
+*
+* DESCRIPTION:
+*       API implementation for switch port control.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gprtSetForceFc
+*
+* DESCRIPTION:
+*       This routine set the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetForceFc
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    force
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PORT_STP_STATE  state;
+
+    DBG_INFO(("gprtSetForceFc Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device allows to force a flowcontrol disabled */
+	if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+	{
+		if(force)
+			data = 3;
+		else
+			data = 0;
+			
+		retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+		}
+		else
+		{
+			DBG_INFO(("OK.\n"));
+		}
+		return retVal;		
+	}
+
+	/* Port should be disabled before Set Force Flow Control bit */
+	retVal = gstpGetPortState(dev,port, &state);
+    if(retVal != GT_OK)
+	{
+	    DBG_INFO(("gstpGetPortState failed.\n"));
+		return retVal;
+	}
+
+	retVal = gstpSetPortState(dev,port, GT_PORT_DISABLE);
+    if(retVal != GT_OK)
+	{
+	    DBG_INFO(("gstpSetPortState failed.\n"));
+		return retVal;
+	}
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(force, data);
+
+    /* Set the force flow control bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+	/* Restore original stp state. */
+	if(gstpSetPortState(dev,port, state) != GT_OK)
+	{
+	    DBG_INFO(("gstpSetPortState failed.\n"));
+		return GT_FAIL;
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetForceFc
+*
+* DESCRIPTION:
+*       This routine get the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetForceFc
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *force
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetForceFc Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device allows to force a flowcontrol disabled */
+	if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+	{
+		retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,&data);
+		if(retVal != GT_OK)
+		{
+			DBG_INFO(("Failed.\n"));
+		}
+		else
+		{
+			DBG_INFO(("OK.\n"));
+		}
+
+		if(data & 0x1)
+			*force = GT_TRUE;
+		else
+			*force = GT_FALSE;
+			
+		return retVal;		
+	}
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *force);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetUseCoreTag
+*
+* DESCRIPTION:
+*		This routine set the UseCoreTag bit in Port Control Register.
+*		When this bit is cleared to a zero, ingressing frames are considered
+*		Tagged if the 16-bits following the frame's Source Address is 0x8100.
+*		When this bit is set to a one, ingressing frames are considered Tagged
+*		if the 16-bits following the frame's Source Address is equal to the 
+*		CoreTag register value.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetUseCoreTag
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    force
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetUseCoreTag Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if device allows to force a flowcontrol disabled */
+	if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(force, data);
+
+    /* Set the UseCoreTag bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetUseCoreTag
+*
+* DESCRIPTION:
+*       This routine get the Use Core Tag state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetUseCoreTag
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *force
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetUseCoreTag Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* Get the UseCoreTag bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *force);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetTrailerMode
+*
+* DESCRIPTION:
+*       This routine set the egress trailer mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetTrailerMode
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetTrailerMode Called.\n"));
+
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+	}
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if(hwPort < 4)
+	{
+	    /* check if device supports this feature for this port */
+		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5|DEV_TRAILER_P4P5))
+		{
+	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+    	    return GT_NOT_SUPPORTED;
+		}
+	}
+	else if(hwPort == 4)
+	{
+	    /* check if device supports this feature for this port*/
+		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
+		{
+	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+    	    return GT_NOT_SUPPORTED;
+		}
+	}
+
+    /* Set the trailer mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetTrailerMode
+*
+* DESCRIPTION:
+*       This routine get the egress trailer mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTrailerMode
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetTrailerMode Called.\n"));
+
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if(hwPort < 4)
+	{
+	    /* check if device supports this feature for this port */
+		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5|DEV_TRAILER_P4P5))
+		{
+	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+    	    return GT_NOT_SUPPORTED;
+		}
+	}
+	else if(hwPort == 4)
+	{
+	    /* check if device supports this feature for this port */
+		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
+		{
+	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+    	    return GT_NOT_SUPPORTED;
+		}
+	}
+
+    /* Get the Trailer mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gprtSetIngressMode
+*
+* DESCRIPTION:
+*       This routine set the ingress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIngressMode
+(
+    IN  GT_QD_DEV      *dev,
+    IN GT_LPORT        port,
+    IN GT_INGRESS_MODE mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIngressMode Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* check if device supports this feature */
+    switch (mode)
+    {
+        case (GT_UNMODIFY_INGRESS):
+            break;
+
+        case (GT_TRAILER_INGRESS):
+		    if(!(IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5)))
+			{
+			    DBG_INFO(("Given ingress mode is not supported by this device\n"));
+				return GT_NOT_SUPPORTED;
+			}
+            break;
+
+        case (GT_UNTAGGED_INGRESS):
+		    if(!(IS_IN_DEV_GROUP(dev,DEV_TAGGING)))
+			{
+			    DBG_INFO(("Given ingress mode is not supported by this device\n"));
+				return GT_NOT_SUPPORTED;
+			}
+            break;
+
+        case (GT_CPUPORT_INGRESS):
+		    if(!(IS_IN_DEV_GROUP(dev,DEV_IGMP_SNOOPING)))
+			{
+			    DBG_INFO(("Given ingress mode is not supported by this device\n"));
+				return GT_NOT_SUPPORTED;
+			}
+
+			if(hwPort != dev->cpuPortNum)
+			{
+			    DBG_INFO(("Given ingress mode is supported by CPU port only\n"));
+				return GT_NOT_SUPPORTED;
+			}
+
+            break;
+
+        default:
+            DBG_INFO(("Failed.\n"));
+            return GT_FAIL;
+    }
+
+    /* Set the Ingress Mode.        */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,2,(GT_U16)mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetIngressMode
+*
+* DESCRIPTION:
+*       This routine get the ingress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the ingress mode.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIngressMode
+(
+    IN  GT_QD_DEV      *dev,
+    IN  GT_LPORT        port,
+    OUT GT_INGRESS_MODE *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIngressMode Called.\n"));
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the Ingress Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 2,&data);
+    *mode = data;
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine set the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMcRateLimit
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_MC_RATE   rate
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetMcRateLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* this feature only exits in 6051, 6052, and 6012. It is replace with
+     * Rate Cotrol Register in the future products, starting from clippership
+     */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MC_RATE_PERCENT)) != GT_OK)
+        return retVal;
+
+    /* Set the multicast rate limit.    */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,2,(GT_U16)rate);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine Get the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMcRateLimit
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_MC_RATE  *rate
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read data        */
+
+    DBG_INFO(("gprtGetMcRateLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* this feature only exits in 6051, 6052, and 6012. It is replace with
+     * Rate Cotrol Register in the future products, starting from clippership
+     */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MC_RATE_PERCENT)) != GT_OK)
+        return retVal;
+
+    /* Get the multicast rate limit.    */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 2, 2,&data);
+    *rate = data;
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/* the following two APIs are added to support fullsail and clippership */
+
+/*******************************************************************************
+* gprtSetIGMPSnoop
+*
+* DESCRIPTION:
+* 		This routine set the IGMP Snoop. When set to one and this port receives
+*		IGMP frame, the frame is switched to the CPU port, overriding all other 
+*		switching decisions, with exception for CPU's Trailer.
+*		CPU port is determined by the Ingress Mode bits. A port is considered 
+*		the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or 
+*		GT_CPUPORT_INGRESS.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIGMPSnoop
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIGMPSnoop Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_IGMP_SNOOPING)) != GT_OK)
+      return retVal;
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the IGMP Snooping mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,10,1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetIGMPSnoop
+*
+* DESCRIPTION:
+*       This routine get the IGMP Snoop mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: IGMP Snoop enabled
+*	       GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIGMPSnoop
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIGMPSnoop Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_IGMP_SNOOPING)) != GT_OK)
+      return retVal;
+
+    /* Get the Ingress Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 10, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+/* the following two APIs are added to support clippership */
+
+/*******************************************************************************
+* gprtSetHeaderMode
+*
+* DESCRIPTION:
+*       This routine set ingress and egress header mode of a switch port. 
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for header mode  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetHeaderMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetHeaderMode Called.\n"));
+
+    /* only devices beyond quarterdeck (6052) has this feature */
+    /* Fullsail (DEV_QD_88E6502) is an exception, and does not support this feature */
+    if(IS_VALID_API_CALL(dev,port, DEV_HEADER|DEV_HEADER_P5|DEV_HEADER_P4P5) != GT_OK)
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+	}
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if(hwPort < 4)
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5|DEV_HEADER_P4P5))
+		{
+	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+    	    return GT_NOT_SUPPORTED;
+		}
+	}
+	else if(hwPort == 4)
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
+		{
+	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+    	    return GT_NOT_SUPPORTED;
+		}
+	}
+
+    /* Set the header mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,11,1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetHeaderMode
+*
+* DESCRIPTION:
+*       This routine gets ingress and egress header mode of a switch port. 
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: header mode enabled
+*	       GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHeaderMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetHeaderMode Called.\n"));
+
+    /* only devices beyond quarterdeck (6052) has this feature */
+    /* Fullsail (DEV_QD_88E602) is an exception, and does not support this feature */
+    if(IS_VALID_API_CALL(dev,port, DEV_HEADER|DEV_HEADER_P5|DEV_HEADER_P4P5) != GT_OK)
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if(hwPort < 4)
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5|DEV_HEADER_P4P5))
+		{
+	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+    	    return GT_NOT_SUPPORTED;
+		}
+	}
+	else if(hwPort == 4)
+	{
+		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
+		{
+	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+    	    return GT_NOT_SUPPORTED;
+		}
+	}
+
+    /* Get the Header Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 11, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+/* the following four APIs are added to support Octane */
+
+/*******************************************************************************
+* gprtSetProtectedMode
+*
+* DESCRIPTION:
+*       This routine set protected mode of a switch port. 
+*		When this mode is set to GT_TRUE, frames are allowed to egress port
+*		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*		by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*		allow the frame to Egress.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetProtectedMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetProtectedMode Called.\n"));
+
+	/* Check if this feature is supported */
+    if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the protected mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,3,1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetProtectedMode
+*
+* DESCRIPTION:
+*       This routine gets protected mode of a switch port. 
+*		When this mode is set to GT_TRUE, frames are allowed to egress port
+*		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*		by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*		allow the frame to Egress.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: header mode enabled
+*	       GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetProtectedMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetProtectedMode Called.\n"));
+
+    if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the protected Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetForwardUnknown
+*
+* DESCRIPTION:
+*       This routine set Forward Unknown mode of a switch port. 
+*		When this mode is set to GT_TRUE, normal switch operation occurs.
+*		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*		will not egress out this port.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetForwardUnknown
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetForwardUnknown Called.\n"));
+
+    if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+	}
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the forward unknown mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetForwardUnknown
+*
+* DESCRIPTION:
+*       This routine gets Forward Unknown mode of a switch port. 
+*		When this mode is set to GT_TRUE, normal switch operation occurs.
+*		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*		will not egress out this port.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: header mode enabled
+*	       GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetForwardUnknown
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetForwardUnknown Called.\n"));
+
+    if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the forward unknown Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 2, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDropOnLock
+*
+* DESCRIPTION:
+*		This routine set the Drop on Lock. When set to one, Ingress frames will
+*		be discarded if their SA field is not in the ATU's address database.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDropOnLock
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDropOnLock Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the DropOnLock mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetDropOnLock
+*
+* DESCRIPTION:
+*		This routine gets DropOnLock mode.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: DropOnLock enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDropOnLock
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetDropOnLock Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the DropOnLock Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 14, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+* gprtSetDoubleTag
+*
+* DESCRIPTION:
+*		This routine set the Ingress Double Tag Mode. When set to one, 
+*		ingressing frames are examined to see if they contain an 802.3ac tag.
+*		If they do, the tag is removed and then the frame is processed from
+*		there (i.e., removed tag is ignored). Essentially, untagged frames
+*		remain untagged, single tagged frames become untagged and double tagged
+*		frames become single tagged.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDoubleTag
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetDoubleTag Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the DoubleTag mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,9,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetDoubleTag
+*
+* DESCRIPTION:
+*		This routine gets DoubleTag mode.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: DoubleTag enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDoubleTag
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetDoubleTag Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the DoubleTag Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 9, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetInterswitchPort
+*
+* DESCRIPTION:
+*		This routine set Interswitch Port. When set to one, 
+*		it indicates this port is a interswitch port used to communicated with
+*		CPU or to cascade with another switch device.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetInterswitchPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetInterswitchPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the InterswitchPort.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetInterswithPort
+*
+* DESCRIPTION:
+*		This routine gets InterswitchPort.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: This port is interswitch port,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetInterswitchPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetInterswitchPort Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the InterswitchPort Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+* gprtSetLearnDisable
+*
+* DESCRIPTION:
+*		This routine enables/disables automatic learning of new source MAC
+*		addresses on the given port ingress
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for disable or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLearnDisable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetLearnDisable Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the LearnDisable mode.            */
+	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,11,1,data);
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetLearnDisable
+*
+* DESCRIPTION:
+*		This routine gets LearnDisable setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: Learning disabled on the given port ingress frames,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLearnDisable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+)
+{
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+	GT_U16          data;           /* to keep the read valve       */
+
+	DBG_INFO(("gprtGetLearnDisable Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* Get the LearnDisable Mode.            */
+	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 11, 1, &data);
+
+	/* translate binary to BOOL  */
+	BIT_2_BOOL(data, *mode);
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+
+	return retVal;
+}
+
+/*******************************************************************************
+* gprtSetIgnoreFCS
+*
+* DESCRIPTION:
+*		This routine sets FCS Ignore mode. When this bit is set to a one,
+*		the last four bytes of frames received on this port are overwritten with
+*		a good CRC and the frames will be accepted by the switch.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreFCS
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL 		mode
+)
+{
+	GT_U16          data;           /* Used to poll the SWReset bit */
+	GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8           hwPort;         /* the physical port number     */
+
+	DBG_INFO(("gprtSetIgnoreFCS Called.\n"));
+
+	/* translate LPORT to hardware port */
+	hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	/* translate BOOL to binary */
+	BOOL_2_BIT(mode, data);
+
+	/* Set the IgnoreFCS mode.            */
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,data );
+	}
+	else
+	{
+		retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,10,1,data);
+	}
+
+	if(retVal != GT_OK)
+	{
+		DBG_INFO(("Failed.\n"));
+	}
+	else
+	{
+		DBG_INFO(("OK.\n"));
+	}
+	return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetIgnoreFCS
+*
+* DESCRIPTION:
+*		This routine gets Ignore FCS setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreFCS
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIgnoreFCS Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IgnoreFCS Mode.            */
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,&data );
+	}
+	else
+	{
+		retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 1, &data);
+	}
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetVTUPriOverride
+*
+* DESCRIPTION:
+*		This routine sets VTU Priority Override. When this bit is set to a one,
+*		VTU priority overrides can occur on this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for VTU Priority Override or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetVTUPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetVTUPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the IgnoreFCS mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetVTUPriOverride
+*
+* DESCRIPTION:
+*		This routine gets VTU Priority Override setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: VTU Priority Override enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetVTUPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetVTUPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the VTUPriOverride Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 14, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetSAPriOverride
+*
+* DESCRIPTION:
+*		This routine sets SA Priority Override. When this bit is set to a one,
+*		SA priority overrides can occur on this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for SA Priority Override or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetSAPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetSAPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the SAPriOverride mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetSAPriOverride
+*
+* DESCRIPTION:
+*		This routine gets SA Priority Override setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: SA Priority Override enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSAPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetSAPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the SAPriOverride Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 13, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetDAPriOverride
+*
+* DESCRIPTION:
+*		This routine sets DA Priority Override. When this bit is set to a one,
+*		DA priority overrides can occur on this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for DA Priority Override or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDAPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDAPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the DAPriOverride mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDAPriOverride
+*
+* DESCRIPTION:
+*		This routine gets DA Priority Override setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: DA Priority Override enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDAPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDAPriOverride Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DAPriOverride Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 12, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetCPUPort
+*
+* DESCRIPTION:
+*		This routine sets CPU Port number. When Snooping is enabled on this port
+*		or when this port is configured as an Interswitch Port and it receives a 
+*		To_CPU frame, the switch needs to know what port on this device the frame 
+*		should egress.
+*
+* INPUTS:
+*		port - the logical port number.
+*		cpuPort - CPU Port number or interswitch port where CPU Port is connected
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetCPUPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_LPORT 	cpuPort
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetCPUPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    data = (GT_U16)GT_LPORT_2_PORT(cpuPort);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Set the CPU Port.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,0,4,data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetCPUPort
+*
+* DESCRIPTION:
+*		This routine gets CPU Logical Port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		cpuPort - CPU Port's logical number
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetCPUPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_LPORT 	*cpuLPort
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetCPUPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the CPUPort.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 0, 4, &data);
+
+    *cpuLPort = GT_PORT_2_LPORT((GT_LPORT)data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetLockedPort
+*
+* DESCRIPTION:
+*		This routine sets LockedPort. When it's set to one, CPU directed 
+*		learning for 802.1x MAC authentication is enabled on this port. In this
+*		mode, an ATU Miss Violation interrupt will occur when a new SA address
+*		is received in a frame on this port. Automatically SA learning and 
+*		refreshing is disabled in this mode.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLockedPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetLockedPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Locked Port.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 13, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetLockedPort
+*
+* DESCRIPTION:
+*		This routine gets Locked Port mode for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLockedPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL  	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetLockedPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the LockedPort. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 13, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetIgnoreWrongData
+*
+* DESCRIPTION:
+*		This routine sets Ignore Wrong Data. If the frame's SA address is found 
+*		in the database and if the entry is 'static' or if the port is 'locked'
+*		the source port's bit is checked to insure the SA has been assigned to 
+*		this port. If the SA is NOT assigned to this port, it is considered an 
+*		ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+*		Member Violation interrupt will be generated. If it's set to GT_TRUE,
+*		the ATU Member Violation error will be masked and ignored.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreWrongData
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIgnoreWrongData Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set IgnoreWrongData.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 12, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetIgnoreWrongData
+*
+* DESCRIPTION:
+*		This routine gets Ignore Wrong Data mode for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreWrongData
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIgnoreWrongData Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IgnoreWrongData. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 12, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDiscardTagged
+*
+* DESCRIPTION:
+*		When this bit is set to a one, all non-MGMT frames that are processed as 
+*		Tagged will be discarded as they enter this switch port. Priority only 
+*		tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardTagged
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDiscardTagged Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set DiscardTagged. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 9, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDiscardTagged
+*
+* DESCRIPTION:
+*		This routine gets DiscardTagged bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardTagged
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDiscardTagged Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DiscardTagged. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 9, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDiscardUntagged
+*
+* DESCRIPTION:
+*		When this bit is set to a one, all non-MGMT frames that are processed as 
+*		Untagged will be discarded as they enter this switch port. Priority only 
+*		tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardUntagged
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDiscardUntagged Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set DiscardUnTagged. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 8, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDiscardUntagged
+*
+* DESCRIPTION:
+*		This routine gets DiscardUntagged bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardUntagged
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDiscardUnTagged Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DiscardUnTagged. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 8, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetMapDA
+*
+* DESCRIPTION:
+*		When this bit is set to a one, normal switch operation will occur where a 
+*		frame's DA address is used to direct the frame out the correct port.
+*		When this be is cleared to a zero, the frame will be sent out the port(s) 
+*		defined by ForwardUnknown bits or the DefaultForward bits even if the DA 
+*		is ound in the address database.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMapDA
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetMapDA Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set MapDA. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 7, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetMapDA
+*
+* DESCRIPTION:
+*		This routine gets MapDA bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMapDA
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetMapDA Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the MapDA. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 7, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDefaultForward
+*
+* DESCRIPTION:
+*		When this bit is set to a one, normal switch operation will occurs and 
+*		multicast frames with unknown DA addresses are allowed to egress out this 
+*		port (assuming the VLAN settings allow the frame to egress this port too).
+*		When this be is cleared to a zero, multicast frames with unknown DA 
+*		addresses will not egress out this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDefaultForward
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDefaultForward Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set DefaultForward. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDefaultForward
+*
+* DESCRIPTION:
+*		This routine gets DefaultForward bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDefaultForward
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDefaultForward Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DefaultForward. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetEgressMonitorSource
+*
+* DESCRIPTION:
+*		When this be is cleared to a zero, normal network switching occurs.
+*		When this bit is set to a one, any frame that egresses out this port will
+*		also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressMonitorSource
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetEgressMonitorSource Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set EgressMonitorSource. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 5, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetEgressMonitorSource
+*
+* DESCRIPTION:
+*		This routine gets EgressMonitorSource bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressMonitorSource
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetEgressMonitorSource Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the EgressMonitorSource. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 5, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetIngressMonitorSource
+*
+* DESCRIPTION:
+*		When this be is cleared to a zero, normal network switching occurs.
+*		When this bit is set to a one, any frame that egresses out this port will
+*		also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIngressMonitorSource
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIngressMonitorSource Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set IngressMonitorSource. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 4, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetIngressMonitorSource
+*
+* DESCRIPTION:
+*		This routine gets IngressMonitorSource bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIngressMonitorSource
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetIngressMonitorSource Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IngressMonitorSource. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 4, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetMessagePort
+*
+* DESCRIPTION:
+*		When the Learn2All bit is set to one, learning message frames are 
+*		generated. These frames will be sent out all ports whose Message Port is 
+*		set to one.
+* 		If this feature is used, it is recommended that all Marvell Tag ports, 
+*		except for the CPU's port, have their MessagePort bit set to one. 
+*		Ports that are not Marvell Tag ports should not have their Message Port
+*		bit set to one.
+*		
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+*******************************************************************************/
+GT_STATUS gprtSetMessagePort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetMessagePort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set IngressMonitorSource. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 15, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetMessagePort
+*
+* DESCRIPTION:
+*		When the Learn2All bit is set to one, learning message frames are 
+*		generated. These frames will be sent out all ports whose Message Port is 
+*		set to one.
+* 		If this feature is used, it is recommended that all Marvell Tag ports, 
+*		except for the CPU's port, have their MessagePort bit set to one. 
+*		Ports that are not Marvell Tag ports should not have their Message Port
+*		bit set to one.
+*
+*		
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMessagePort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetMessagePort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IngressMonitorSource. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 15, 1, &data);
+
+    BIT_2_BOOL(data, *mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetTrunkPort
+*
+* DESCRIPTION:
+*		This function enables/disables and sets the trunk ID.
+*		
+* INPUTS:
+*		port - the logical port number.
+*		en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+*			 GT_FALSE, otherwise.
+*		trunkId - valid ID is 0 ~ 15.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+*******************************************************************************/
+GT_STATUS gprtSetTrunkPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL 		en,
+	IN GT_U32		trunkId
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetTrunkPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(en, data);
+
+	if(en == GT_TRUE)
+	{
+		/* need to enable trunk. so check the trunkId */
+		if (!IS_TRUNK_ID_VALID(dev, trunkId))
+		{
+	        DBG_INFO(("GT_BAD_PARAM\n"));
+			return GT_BAD_PARAM;
+		}
+
+	}
+	else
+	{
+		/* 
+		   Need to reset trunkId for 88E6095 rev0 and it gives no harm to
+		   any other device. So just apply to every device.
+		*/
+		trunkId = 0;
+	}
+
+    /* Set TrunkId. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, (GT_U16)trunkId);
+    if(retVal != GT_OK)
+	{
+       	DBG_INFO(("Failed.\n"));
+		return retVal;	
+	}
+
+    /* Set TrunkPort bit. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 14, 1, data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetTrunkPort
+*
+* DESCRIPTION:
+*		This function returns trunk state of the port.
+*		When trunk is disabled, trunkId field won't have valid value.
+*		
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		en - GT_TRUE, if the port is a member of a trunk,
+*			 GT_FALSE, otherwise.
+*		trunkId - 0 ~ 15, valid only if en is GT_TRUE
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+*******************************************************************************/
+GT_STATUS gprtGetTrunkPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	OUT GT_BOOL 	*en,
+	OUT GT_U32		*trunkId
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetTrunkPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* check if the given Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	data = 0;
+
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 14, 1, &data);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+		return retVal;
+	}
+
+    BIT_2_BOOL(data, *en);
+
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, &data);
+	*trunkId = (GT_U32)data;
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gprtGetSwitchReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSwitchReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32	     regAddr,
+    OUT GT_U16	     *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetSwitchReg Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get Phy Register. */
+    if(hwReadPortReg(dev,hwPort,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	*data = u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetSwitchReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetSwitchReg
+(
+    IN  GT_QD_DEV		*dev,
+    IN  GT_LPORT		port,
+    IN  GT_U32			regAddr,
+    IN  GT_U16			data
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    
+    DBG_INFO(("gprtSetSwitchReg Called.\n"));
+
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the Scheduling bit.              */
+    if(hwWritePortReg(dev,hwPort,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGetGlobalReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobalReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32	     regAddr,
+    OUT GT_U16	     *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+
+    DBG_INFO(("gprtGetGlobalReg Called.\n"));
+
+    /* Get Phy Register. */
+    if(hwReadGlobalReg(dev,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	*data = u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetGlobalReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobalReg
+(
+    IN  GT_QD_DEV		*dev,
+    IN  GT_U32			regAddr,
+    IN  GT_U16			data
+)
+{
+    DBG_INFO(("gprtSetGlobalReg Called.\n"));
+
+    /* Get the Scheduling bit.              */
+    if(hwWriteGlobalReg(dev,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+* gprtGetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global 2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobal2Reg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32	     regAddr,
+    OUT GT_U16	     *data
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+
+    DBG_INFO(("gprtGetGlobal2Reg Called.\n"));
+
+    /* Get Phy Register. */
+    if(hwReadGlobal2Reg(dev,(GT_U8)regAddr,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	*data = u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobal2Reg
+(
+    IN  GT_QD_DEV		*dev,
+    IN  GT_U32			regAddr,
+    IN  GT_U16			data
+)
+{
+    DBG_INFO(("gprtSetGlobal2Reg Called.\n"));
+
+    /* Get the Scheduling bit.              */
+    if(hwWriteGlobal2Reg(dev,(GT_U8)regAddr,data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	return GT_OK;
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtPortPav.c uboot-1.1.2hsv/drivers/marvell/gtPortPav.c
--- u-boot-1.1.2/drivers/marvell/gtPortPav.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPortPav.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,294 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtPortPav.c
+*
+* DESCRIPTION:
+*       API definitions to handle Port Association Vector (0xB).
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gpavSetPAV
+*
+* DESCRIPTION:
+*       This routine sets the Port Association Vector 
+*
+* INPUTS:
+*       port	- logical port number.
+*       pav 	- Port Association Vector 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpavSetPAV
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT	 port,
+    IN GT_U16	 pav
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U16	    hwPav,portNum, hwPortNum;
+
+    DBG_INFO(("gpavSetPAV Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK ) 
+      return retVal;
+	
+	/*
+	 * translate Logical Port Vector to Physical Port Vector.
+	 */
+	hwPav = 0;
+
+	for(portNum=0; portNum<dev->numOfPorts; portNum++)
+	{
+		if (pav & 0x1)
+		{
+			hwPortNum = GT_LPORT_2_PORT(portNum);
+			hwPav |= (1 << hwPortNum);
+		}
+		pav >>= 1;
+	}
+		
+    /* there are 7 ports in the switch */
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,0,dev->numOfPorts,hwPav);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gpavGetPAV
+*
+* DESCRIPTION:
+*       This routine gets the Port Association Vector 
+*
+* INPUTS:
+*       port	- logical port number.
+*
+* OUTPUTS:
+*       pav 	- Port Association Vector 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpavGetPAV
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U16   *pav
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort, swPort;        /* Physical port.               */
+	GT_U16			lPav,portNum, lPortNum;
+
+    DBG_INFO(("gpavGetPAV Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK ) 
+      return retVal;
+	
+    if(pav == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+	swPort = dev->numOfPorts;
+
+    retVal = hwGetPortRegField(dev,phyPort,(GT_U8)QD_REG_PORT_ASSOCIATION,0,swPort,&data );
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+	/*
+	 * translate Physical Port Vector to Logical Port Vector.
+	 */
+	lPav = 0;
+	for(portNum=0; portNum<swPort; portNum++)
+	{
+		if (data & 0x1)
+		{
+			lPortNum = (GT_U16)GT_PORT_2_LPORT(portNum);
+			lPav |= (1 << lPortNum);
+		}
+		data >>= 1;
+	}
+		
+    *pav = lPav;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gpavSetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine sets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled 
+*              GT_TRUE:  Ingress Monitor disabled 
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpavSetIngressMonitor
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("gpavSetIngressMonitorCalled.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    BOOL_2_BIT(mode,data);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK ) 
+      return retVal;
+	
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENABLE_MONITORING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,15,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gpavGetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine gets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled 
+*              GT_TRUE:  Ingress Monitor disabled 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpavGetIngressMonitor
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetIngressMonitor Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_PORT_MONITORING)) != GT_OK ) 
+      return retVal;
+	
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENABLE_MONITORING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_ASSOCIATION,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtPortRateCtrl.c uboot-1.1.2hsv/drivers/marvell/gtPortRateCtrl.c
--- u-boot-1.1.2/drivers/marvell/gtPortRateCtrl.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPortRateCtrl.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,1251 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtPortRateCtrl.c
+*
+* DESCRIPTION:
+*       API definitions to handle port rate control registers (0xA).
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/*
+ Convert given hw Rate Limit to sw defined Rate Limit.
+ This routine is only for Gigabit Managed Switch Device.
+ If the given device is not an accepted device, it'll simply copy the hw limit 
+ to sw limit.
+*/
+static GT_STATUS cRateLimit(GT_QD_DEV *dev, GT_U32 hwLimit, GT_U32* swLimit)
+{
+	GT_U32 sLimit, hLimit, startLimit, endLimit, i;
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		*swLimit = hwLimit;
+		return GT_OK;
+	}
+
+	if(hwLimit == 0)
+	{
+		*swLimit = GT_NO_LIMIT;
+		return GT_OK;
+	}
+		
+	sLimit = 1000;
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+		hLimit = GT_GET_RATE_LIMIT2(sLimit);
+	else
+		hLimit = GT_GET_RATE_LIMIT(sLimit);
+	if(hLimit == hwLimit)
+	{
+		*swLimit = GT_1M;
+		return GT_OK;
+	}
+	
+	if(hLimit > hwLimit)
+	{
+		startLimit = 2000;
+		endLimit = 256000;
+		*swLimit = GT_2M;
+	}
+	else
+	{
+		startLimit = 128;
+		endLimit = 512;
+		*swLimit = GT_128K;
+	}
+	
+	i = 0;
+	for(sLimit=startLimit;sLimit<=endLimit;sLimit *= 2, i++)
+	{
+		if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+			hLimit = GT_GET_RATE_LIMIT2(sLimit);
+		else
+			hLimit = GT_GET_RATE_LIMIT(sLimit);
+
+		if(hLimit == 0)
+			hLimit = 1;
+
+		if(hLimit == hwLimit)
+		{
+			*swLimit += i;
+			return GT_OK;
+		}
+
+		if(hLimit < hwLimit)
+			break;
+	}
+
+	*swLimit = hwLimit;
+	return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetLimitMode
+*
+* DESCRIPTION:
+*       This routine sets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port	- logical port number.
+*       mode 	- rate control ingress limit mode. 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetLimitMode
+(
+    IN GT_QD_DEV             *dev,
+    IN GT_LPORT 	     port,
+    IN GT_RATE_LIMIT_MODE    mode
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetLimitMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+      return retVal;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,(GT_U16)mode );
+	}
+	else
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,(GT_U16)mode );
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetLimitMode
+*
+* DESCRIPTION:
+*       This routine gets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port	- logical port number.
+*
+* OUTPUTS:
+*       mode 	- rate control ingress limit mode. 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetLimitMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_RATE_LIMIT_MODE    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetLimitMode Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+      return retVal;
+	
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,&data );
+	}
+	else
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,&data );
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetPri3Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetPri3Rate
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetPri3Rate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+      return retVal;
+	
+    BOOL_2_BIT(mode,data);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,data );
+	}
+	else
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,data);
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetPri3Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetPri3Rate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetPri3Rate Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+      return retVal;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,&data );
+	}
+	else
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,&data);
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetPri2Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetPri2Rate
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetPri2Rate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+      return retVal;
+	
+    BOOL_2_BIT(mode,data);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,data );
+	}
+	else
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,data);
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetPri2Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetPri2Rate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetPri2Rate Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+      return retVal;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,&data );
+	}
+	else
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,&data);
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetPri1Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetPri1Rate
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcSetPri1Rate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+      return retVal;
+	
+    BOOL_2_BIT(mode,data);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,data );
+	}
+	else
+	{
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,data);
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetPri1Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetPri1Rate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetPri1Rate Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
+      return retVal;
+	
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,&data );
+	}
+	else
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,&data);
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* grcSetPri0Rate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port	- logical port number.
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*       	  will be discarded after the ingress rate selected is reached 
+*       	  or exceeded. 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
+*			are supported only by Gigabit Ethernet Switch.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetPri0Rate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_PRI0_RATE    rate
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+	GT_U32			rateLimit, tmpLimit;
+
+    DBG_INFO(("grcSetPri0Rate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+      return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+	{
+		switch(rate)
+		{
+			case GT_NO_LIMIT :
+					rateLimit = 0; /* MAX_RATE_LIMIT; */
+					break;
+			case GT_128K :
+					rateLimit = 128;
+					break;
+			case GT_256K :
+					rateLimit = 256;
+					break;
+			case GT_512K :
+					rateLimit = 512;
+					break;
+			case GT_1M :
+					rateLimit = 1000;
+					break;
+			case GT_2M :
+					rateLimit = 2000;
+					break;
+			case GT_4M :
+					rateLimit = 4000;
+					break;
+			case GT_8M :
+					rateLimit = 8000;
+					break;
+			case GT_16M :
+					rateLimit = 16000;
+					break;
+			case GT_32M :
+					rateLimit = 32000;
+					break;
+			case GT_64M :
+					rateLimit = 64000;
+					break;
+			case GT_128M :
+					rateLimit = 128000;
+					break;
+			case GT_256M :
+					rateLimit = 256000;
+					break;
+			default :
+					return GT_BAD_PARAM;
+/*
+					rateLimit = (GT_U32)rate;
+					break;					
+*/
+		}
+
+		if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+			tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
+		else
+			tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
+
+		if((tmpLimit == 0) && (rateLimit != 0))
+			rateLimit = 1;
+		else
+			rateLimit = tmpLimit;
+
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+	}
+	else
+	{
+		switch(rate)
+		{
+			case GT_NO_LIMIT :
+			case GT_128K :
+			case GT_256K :
+			case GT_512K :
+			case GT_1M :
+			case GT_2M :
+			case GT_4M :
+			case GT_8M :
+					break;
+			default :
+					return GT_BAD_PARAM;
+		}
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,(GT_U16)rate );
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+	}
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetPri0Rate
+*
+* DESCRIPTION:
+*       This routine gets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port	- logical port number to set.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*       	  will be discarded after the ingress rate selected is reached 
+*       	  or exceeded. 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
+*			are supported only by Gigabit Ethernet Switch.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetPri0Rate
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_PRI0_RATE    *rate
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+	GT_U32			tmpLimit;
+
+    DBG_INFO(("grcGetPri0Rate Called.\n"));
+
+    if(rate == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+      return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		tmpLimit = 0;
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,(GT_U16*)&tmpLimit );
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+
+		cRateLimit(dev, tmpLimit, (GT_U32*)rate);
+	}
+	else
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,&data );
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+	    *rate = data;
+	}
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetBytesCount
+*
+* DESCRIPTION:
+*       This routine sets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port	  - logical port number to set.
+*    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*    		    GT_FALSE: otherwise
+*    	countIFG  - GT_TRUE: To count IFG bytes
+*    		    GT_FALSE: otherwise
+*    	countPre  - GT_TRUE: To count Preamble bytes
+*    		    GT_FALSE: otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetBytesCount
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL 	 limitMGMT,
+    IN GT_BOOL 	 countIFG,
+    IN GT_BOOL 	 countPre
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U16          data;           /* data for bytes count         */
+
+    DBG_INFO(("grcSetBytesCount Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+      return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+	    BOOL_2_BIT(limitMGMT,data);
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,data );
+		if (retVal != GT_OK)
+			return retVal;
+
+		data = 0;
+		if( countIFG == GT_TRUE ) data |= 2;
+		if( countPre == GT_TRUE ) data |= 1;
+
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,data );
+	}
+	else
+	{
+		data = 0;
+	    if(	limitMGMT == GT_TRUE ) data |=4;
+    	if(	 countIFG == GT_TRUE ) data |=2;
+	    if(	 countPre == GT_TRUE ) data |=1;
+
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,data );
+	}
+
+   	if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetBytesCount
+*
+* DESCRIPTION:
+*       This routine gets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port	- logical port number 
+*
+* OUTPUTS:
+*    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*    		    GT_FALSE: otherwise
+*    	countIFG  - GT_TRUE: To count IFG bytes
+*    		    GT_FALSE: otherwise
+*    	countPre  - GT_TRUE: To count Preamble bytes
+*    		    GT_FALSE: otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcGetBytesCount
+(	
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL 	 *limitMGMT,
+    IN GT_BOOL 	 *countIFG,
+    IN GT_BOOL 	 *countPre
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+
+    DBG_INFO(("grcGetBytesCount Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+      return retVal;
+
+    if (limitMGMT == NULL || countIFG == NULL || countPre == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+   	*limitMGMT = *countIFG = *countPre = GT_FALSE;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,&data );
+		if (retVal != GT_OK)
+		{
+    	    DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+
+	    BIT_2_BOOL(data,*limitMGMT);
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,&data );
+		if (retVal != GT_OK)
+		{
+    	    DBG_INFO(("Failed.\n"));
+			return retVal;
+		}
+
+		if( data & 0x2 ) *countIFG = GT_TRUE;
+		if( data & 0x1 ) *countPre = GT_TRUE;
+
+	}
+	else
+	{
+
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,&data );
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+
+	    if ( data & 4 ) *limitMGMT = GT_TRUE;
+    	if ( data & 2 ) *countIFG  = GT_TRUE;
+	    if ( data & 1 ) *countPre  = GT_TRUE;
+	
+	}
+	    
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* grcSetEgressRate
+*
+* DESCRIPTION:
+*       This routine sets the port's egress data limit.
+*
+* INPUTS:
+*       port	- logical port number.
+*       rate    - egress data rate limit.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*			are supported only by Gigabit Ethernet Switch.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS grcSetEgressRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_EGRESS_RATE  rate
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+	GT_U32			rateLimit, tmpLimit;
+
+    DBG_INFO(("grcSetEgressRate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_EGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+      return retVal;
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		switch(rate)
+		{
+			case GT_NO_LIMIT :
+					rateLimit = 0; /* MAX_RATE_LIMIT; */
+					break;
+			case GT_128K :
+					rateLimit = 128;
+					break;
+			case GT_256K :
+					rateLimit = 256;
+					break;
+			case GT_512K :
+					rateLimit = 512;
+					break;
+			case GT_1M :
+					rateLimit = 1000;
+					break;
+			case GT_2M :
+					rateLimit = 2000;
+					break;
+			case GT_4M :
+					rateLimit = 4000;
+					break;
+			case GT_8M :
+					rateLimit = 8000;
+					break;
+			case GT_16M :
+					rateLimit = 16000;
+					break;
+			case GT_32M :
+					rateLimit = 32000;
+					break;
+			case GT_64M :
+					rateLimit = 64000;
+					break;
+			case GT_128M :
+					rateLimit = 128000;
+					break;
+			case GT_256M :
+					rateLimit = 256000;
+					break;
+			default :
+					return GT_BAD_PARAM;
+/*
+					rateLimit = (GT_U32)rate;
+					break;					
+*/
+		}
+
+		if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+			tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
+		else
+			tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
+
+		if((tmpLimit == 0) && (rateLimit != 0))
+			rateLimit = 1;
+		else
+			rateLimit = tmpLimit;
+
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+	}
+	else
+	{
+		switch(rate)
+		{
+			case GT_NO_LIMIT :
+			case GT_128K :
+			case GT_256K :
+			case GT_512K :
+			case GT_1M :
+			case GT_2M :
+			case GT_4M :
+			case GT_8M :
+					break;
+			default :
+					return GT_BAD_PARAM;
+		}
+	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,(GT_U16)rate );
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+	}
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* grcGetEgressRate
+*
+* DESCRIPTION:
+*       This routine gets the port's egress data limit.
+*
+* INPUTS:
+*       port	- logical port number.
+*
+* OUTPUTS:
+*       rate    - egress data rate limit.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*			are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+GT_STATUS grcGetEgressRate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_EGRESS_RATE  *rate
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U8           phyPort;        /* Physical port.               */
+	GT_U32			tmpLimit;
+
+    DBG_INFO(("grcGetEgressRate Called.\n"));
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_EGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
+      return retVal;
+	
+    if(rate == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		tmpLimit = 0;
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16*)&tmpLimit );
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+
+		cRateLimit(dev, tmpLimit, (GT_U32*)rate);
+	}
+	else
+	{
+	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,&data );
+	    if(retVal != GT_OK)
+    	{
+	        DBG_INFO(("Failed.\n"));
+    	    return retVal;
+	    }
+		
+	    *rate = data;
+	}
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtPortRmon.c uboot-1.1.2hsv/drivers/marvell/gtPortRmon.c
--- u-boot-1.1.2/drivers/marvell/gtPortRmon.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPortRmon.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,943 @@
+#include <marvell/Copyright.h>
+
+/*******************************************************************************
+* gtPortCounter.c
+*
+* DESCRIPTION:
+*       API definitions for RMON counters
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtSem.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* STATS operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS statsOperationPerform
+(
+    IN   GT_QD_DEV            *dev,
+    IN   GT_STATS_OPERATION   statsOp,
+    IN   GT_U8                port,
+    IN   GT_STATS_COUNTERS    counter,
+    OUT  GT_VOID              *statsData
+);
+
+static GT_STATUS statsCapture
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_U8      port
+);
+
+static GT_STATUS statsReadCounter
+(
+    IN   GT_QD_DEV		*dev,
+    IN   GT_U32			counter,
+    OUT  GT_U32			*statsData
+);
+
+
+/*******************************************************************************
+* gstatsFlushAll
+*
+* DESCRIPTION:
+*       Flush All counters for all ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushAll
+(
+        IN GT_QD_DEV  *dev
+)
+{
+	GT_STATUS       	retVal;
+
+	DBG_INFO(("gstatsFlushAll Called.\n"));
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,1, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_FLUSH_ALL,0,0,NULL);
+	if(retVal != GT_OK)
+	{
+	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+    	return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsFlushPort
+*
+* DESCRIPTION:
+*       Flush All counters for a given port.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushPort
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT	  port
+)
+{
+	GT_STATUS	retVal;
+    GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsFlushPort Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	retVal = statsOperationPerform(dev,STATS_FLUSH_PORT,hwPort,0,NULL);
+	if(retVal != GT_OK)
+	{
+	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+    	return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsGetPortCounter
+*
+* DESCRIPTION:
+*		This routine gets a specific counter of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*		counter - the counter which will be read
+*
+* OUTPUTS:
+*		statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS	counter,
+	OUT GT_U32			*statsData
+)
+{
+    GT_STATUS	retVal;
+    GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsFlushPort Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Gigabit Switch does not support this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+	if(retVal != GT_OK)
+	{
+	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+    	return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters
+*
+* DESCRIPTION:
+*       This routine gets all counters of the given port
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters
+(
+    IN  GT_QD_DEV               *dev,
+    IN  GT_LPORT		port,
+    OUT GT_STATS_COUNTER_SET	*statsCounterSet
+)
+{
+	GT_STATUS	retVal;
+    GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsFlushPort Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Gigabit Switch does not support this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+	if(retVal != GT_OK)
+	{
+	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+    	return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsGetPortCounter2
+*
+* DESCRIPTION:
+*		This routine gets a specific counter of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*		counter - the counter which will be read
+*
+* OUTPUTS:
+*		statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter2
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS2	counter,
+	OUT GT_U32			*statsData
+)
+{
+    GT_STATUS	retVal;
+    GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsGetPortCounters2 Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+	if(retVal != GT_OK)
+	{
+	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+    	return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters2
+*
+* DESCRIPTION:
+*		This routine gets all counters of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters2
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	OUT GT_STATS_COUNTER_SET2	*statsCounterSet
+)
+{
+	GT_STATUS	retVal;
+    GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsGetPortAllCounters2 Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+	if(retVal != GT_OK)
+	{
+	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+    	return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsGetPortCounter3
+*
+* DESCRIPTION:
+*		This routine gets a specific counter of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*		counter - the counter which will be read
+*
+* OUTPUTS:
+*		statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter3
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS3	counter,
+	OUT GT_U32			*statsData
+)
+{
+    GT_STATUS	retVal;
+    GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsGetPortCounters3 Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Only 88E6093 Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+	if(retVal != GT_OK)
+	{
+	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+    	return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters3
+*
+* DESCRIPTION:
+*		This routine gets all counters of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters3
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	OUT GT_STATS_COUNTER_SET3	*statsCounterSet
+)
+{
+	GT_STATUS	retVal;
+    GT_U8		hwPort;         /* physical port number         */
+
+	DBG_INFO(("gstatsGetPortAllCounters3 Called.\n"));
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+	if(retVal != GT_OK)
+	{
+	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+    	return retVal;
+	}
+
+	DBG_INFO(("OK.\n"));
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+* gstatsGetHistogramMode
+*
+* DESCRIPTION:
+*		This routine gets the Histogram Counters Mode.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+*					and GT_COUNT_RX_TX)
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_BAD_PARAM    - on bad parameter
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetHistogramMode
+(
+	IN  GT_QD_DEV				*dev,
+	OUT GT_HISTOGRAM_MODE	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gstatsGetHistogramMode Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the Histogram mode bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,10,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+	*mode = data - 1; /* Software definition starts from 0 ~ 2, 
+						while hardware supports the values from 1 to 3 */
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gstatsSetHistogramMode
+*
+* DESCRIPTION:
+*		This routine sets the Histogram Counters Mode.
+*
+* INPUTS:
+*		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+*					and GT_COUNT_RX_TX)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_BAD_PARAM    - on bad parameter
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsSetHistogramMode
+(
+	IN GT_QD_DEV 				*dev,
+	IN GT_HISTOGRAM_MODE		mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gstatsSetHistogramMode Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	switch (mode)
+	{
+		case GT_COUNT_RX_ONLY:
+		case GT_COUNT_TX_ONLY:
+		case GT_COUNT_RX_TX:
+			break;
+		default:
+	        DBG_INFO(("Failed.\n"));
+    	    return GT_BAD_PARAM;
+    }
+
+	data = (GT_U16)mode + 1;
+
+    /* Set the Histogram mode bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_STATS_OPERATION,10,2,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/****************************************************************************/
+/* Internal use functions.                                                  */
+/****************************************************************************/
+
+/*******************************************************************************
+* statsOperationPerform
+*
+* DESCRIPTION:
+*       This function is used by all stats control functions, and is responsible
+*       to write the required operation into the stats registers.
+*
+* INPUTS:
+*       statsOp       - The stats operation bits to be written into the stats
+*                     operation register.
+*       port        - port number
+*       counter     - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       statsData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static GT_STATUS statsOperationPerform
+(
+    IN   GT_QD_DEV            *dev,
+    IN   GT_STATS_OPERATION   statsOp,
+    IN   GT_U8                port,
+    IN   GT_STATS_COUNTERS    counter,
+    OUT  GT_VOID              *statsData
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data,histoData; /* Data to be set into the      */
+                                    /* register.                    */
+	GT_U32 statsCounter;
+	GT_U32 lastCounter;
+
+    gtSemTake(dev,dev->statsRegsSem,OS_WAIT_FOREVER);
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+		lastCounter = (GT_U32)STATS_OutDiscards;
+    }
+	else
+	{
+		lastCounter = (GT_U32)STATS2_Late;
+	}
+
+    /* Wait until the stats in ready. */
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->statsRegsSem);
+            return retVal;
+        }
+    }
+
+    /* Get the Histogram mode bit.                */
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->statsRegsSem);
+        return retVal;
+    }
+	
+	histoData &= 0xC00;
+
+    /* Set the STAT Operation register */
+	switch (statsOp)
+	{
+		case STATS_FLUSH_ALL:
+			data = (1 << 15) | (GT_STATS_FLUSH_ALL << 12) | histoData;
+			retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+			gtSemGive(dev,dev->statsRegsSem);
+			return retVal;
+
+		case STATS_FLUSH_PORT:
+			data = (1 << 15) | (GT_STATS_FLUSH_PORT << 12) | port | histoData;
+			retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+			gtSemGive(dev,dev->statsRegsSem);
+			return retVal;
+
+		case STATS_READ_COUNTER:
+			retVal = statsCapture(dev,port);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->statsRegsSem);
+				return retVal;
+			}
+
+			retVal = statsReadCounter(dev,counter,(GT_U32*)statsData);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->statsRegsSem);
+				return retVal;
+			}
+			break;
+
+		case STATS_READ_ALL:
+			retVal = statsCapture(dev,port);
+			if(retVal != GT_OK)
+			{
+				gtSemGive(dev,dev->statsRegsSem);
+				return retVal;
+			}
+
+			for(statsCounter=0; statsCounter<=lastCounter; statsCounter++)
+			{
+				retVal = statsReadCounter(dev,statsCounter,((GT_U32*)statsData + statsCounter));
+				if(retVal != GT_OK)
+				{
+					gtSemGive(dev,dev->statsRegsSem);
+					return retVal;
+				}
+			}
+			break;
+
+		default:
+			
+			gtSemGive(dev,dev->statsRegsSem);
+			return GT_FAIL;
+	}
+
+    gtSemGive(dev,dev->statsRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* statsCapture
+*
+* DESCRIPTION:
+*       This function is used to capture all counters of a port.
+*
+* INPUTS:
+*       port        - port number
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*		If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsCapture
+(
+    IN GT_QD_DEV            *dev,
+    IN GT_U8 		    port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data, histoData;/* Data to be set into the      */
+                                    /* register.                    */
+
+    /* Get the Histogram mode bit.                */
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->statsRegsSem);
+        return retVal;
+    }
+	
+	histoData &= 0xC00;
+
+    data = 1;
+   	while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+   	    {
+           	return retVal;
+        }
+   	}
+
+	data = (1 << 15) | (GT_STATS_CAPTURE_PORT << 12) | port | histoData;
+	retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+	if(retVal != GT_OK)
+	{
+		return retVal;
+	}
+
+	return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* statsReadCounter
+*
+* DESCRIPTION:
+*       This function is used to read a captured counter.
+*
+* INPUTS:
+*       counter     - counter to be read if it's read operation
+*
+* OUTPUTS:
+*       statsData   - points to the data storage where the MIB counter will be saved.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*		If Semaphore is used, Semaphore should be acquired before this function call.
+*******************************************************************************/
+static GT_STATUS statsReadCounter
+(
+    IN   GT_QD_DEV      *dev,
+    IN   GT_U32			counter,
+    OUT  GT_U32		    *statsData
+)
+{
+    GT_STATUS   retVal;         /* Functions return value.            */
+    GT_U16      data, histoData;/* Data to be set into the  register. */ 
+    GT_U16	counter3_2;     /* Counter Register Bytes 3 & 2       */
+    GT_U16	counter1_0;     /* Counter Register Bytes 1 & 0       */
+
+    /* Get the Histogram mode bit.                */
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->statsRegsSem);
+        return retVal;
+    }
+	
+	histoData &= 0xC00;
+
+    data = 1;
+   	while(data == 1)
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+   	    {
+           	return retVal;
+        }
+   	}
+
+	data = (1 << 15) | (GT_STATS_READ_COUNTER << 12) | counter | histoData;
+	retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+	if(retVal != GT_OK)
+	{
+		return retVal;
+	}
+
+    data = 1;
+   	while(data == 1)
+    {
+   	 retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+   	    {
+           	return retVal;
+        }
+   	}
+
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
+	if(retVal != GT_OK)
+	{
+		return retVal;
+	}
+
+	retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
+	if(retVal != GT_OK)
+	{
+		return retVal;
+	}
+
+	*statsData = (counter3_2 << 16) | counter1_0;
+
+	return GT_OK;
+
+}
diff -Naur u-boot-1.1.2/drivers/marvell/gtPortStat.c uboot-1.1.2hsv/drivers/marvell/gtPortStat.c
--- u-boot-1.1.2/drivers/marvell/gtPortStat.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPortStat.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,342 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtPortStat.c
+*
+* DESCRIPTION:
+*       API implementation for switch port rx/tx counters.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gprtSetCtrMode
+*
+* DESCRIPTION:
+*       This routine sets the port rx/tx counters mode of operation.
+*
+* INPUTS:
+*       mode  - the counter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetCtrMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_CTR_MODE  mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gprtSetCtrMode Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,(GT_U16)mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("gprtSetCtrMode Failed .\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("gprtSetCtrMode OK .\n"));
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtClearAllCtr
+*
+* DESCRIPTION:
+*       This routine clears all port rx/tx counters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtClearAllCtr
+(
+    IN GT_QD_DEV    *dev
+)
+{
+    IN GT_STATUS     retVal;         /* Functions return value.      */
+    IN GT_U16        mode;           /* hold counters current mode   */
+
+    DBG_INFO(("gprtClearAllCtr Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* get counter current mode  */
+    if(hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,&mode) != GT_OK)
+    {
+        DBG_INFO(("Failed (Get field).\n"));
+        return GT_FAIL;
+    }
+    /* write opposite value to reset counter */
+    if(hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,(GT_U16)(1 - mode)) != GT_OK)
+    {
+        DBG_INFO(("Failed (Get field).\n"));
+        return GT_FAIL;
+    }
+    /* restore counters mode */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,mode);
+
+    DBG_INFO(("OK.\n"));
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPortCtr
+*
+* DESCRIPTION:
+*       This routine gets the port rx/tx counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortCtr
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT    *ctr
+)
+{
+    GT_U16          count;          /* counters current value       */
+    GT_U8           hwPort;         /* physical port number         */
+
+    DBG_INFO(("gprtGetPortCtr Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    if(ctr  == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* get rx counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_RX_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read Rx).\n"));
+        return GT_FAIL;
+    }
+    ctr->rxCtr = count;
+    /* get tx counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_TX_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read Tx).\n"));
+        return GT_FAIL;
+    }
+    ctr->txCtr = count;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGetPortCtr2
+*
+* DESCRIPTION:
+*       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortCtr2
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT2   *ctr
+)
+{
+    GT_U16          count;          /* counters current value       */
+    GT_U8           hwPort;         /* physical port number         */
+
+    DBG_INFO(("gprtGetPortCtr2 Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    if(ctr  == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* get InDiscard Low counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_INDISCARD_LO_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read inDiscardLo).\n"));
+        return GT_FAIL;
+    }
+    ctr->inDiscardLo = count;
+    /* get InDiscard High counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_INDISCARD_HI_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read inDiscardHi).\n"));
+        return GT_FAIL;
+    }
+    ctr->inDiscardHi = count;
+
+    /* get InFiltered counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_INFILTERED_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read inFiltered).\n"));
+        return GT_FAIL;
+    }
+    ctr->inFiltered = count;
+
+    /* get OutFiltered counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_OUTFILTERED_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read outFiltered).\n"));
+        return GT_FAIL;
+    }
+    ctr->outFiltered = count;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+#ifdef DEBUG_FEATURE /* this is a debug feature*/
+/*******************************************************************************
+* gprtGetPortQueueCtr
+*
+* DESCRIPTION:
+*       This routine gets the port queue counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS: 
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortQueueCtr
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_Q_STAT  *ctr
+)
+{
+    GT_U16          count;          /* counters current value       */
+    GT_U8           hwPort;         /* physical port number         */
+
+    DBG_INFO(("gprtGetPortQueueCtr Called.\n"));
+
+    if(ctr  == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* translate logical port to physical port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* get queue counter value  */
+    if(hwReadPortReg(dev,hwPort, QD_REG_Q_COUNTER, &count) != GT_OK)
+    {
+        DBG_INFO(("Failed (Read Rx).\n"));
+        return GT_FAIL;
+    }
+
+    /* the fist 5 bits(4:0) are OutQ_Size */
+    ctr->OutQ_Size = count & 0x1F;
+
+    /* the Rsv_Size are bits 15:8 */
+    ctr->Rsv_Size  = count >> 8;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+#endif 
diff -Naur u-boot-1.1.2/drivers/marvell/gtPortStatus.c uboot-1.1.2hsv/drivers/marvell/gtPortStatus.c
--- u-boot-1.1.2/drivers/marvell/gtPortStatus.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtPortStatus.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,1385 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtPortCtrl.c
+*
+* DESCRIPTION:
+*       API implementation for switch port status.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gprtGetPartnerLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link partner pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPartnerLinkPause
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPartnerLinkPause Called.\n"));
+
+	/* Gigabit Switch does not support this status. gprtGetPauseEn is supported instead. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,15,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPauseEn
+*
+* DESCRIPTION:
+*		This routine retrives the link pause state.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		If set MAC Pause (for Full Duplex flow control) is implemented in the
+*		link partner and in MyPause
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPauseEn
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPauseEn Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,15,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetSelfLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSelfLinkPause
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetSelfLinkPause Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,14,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetResolve
+*
+* DESCRIPTION:
+*       This routine retrives the resolve state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Done  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetResolve
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetResolve Called.\n"));
+
+	/* Gigabit Switch does not support this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,13,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetHdFlow
+*
+* DESCRIPTION:
+*		This routine retrives the half duplex flow control value.
+*		If set, Half Duplex back pressure will be used on this port if this port
+*		is in a half duplex mode.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHdFlow
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetHdFlow Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,13,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetPHYDetect
+*
+* DESCRIPTION:
+*		This routine retrives the information regarding PHY detection.
+*		If set, An 802.3 PHY is attached to this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if connected or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPHYDetect
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPHYDetect Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,12,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetPHYDetect
+*
+* DESCRIPTION:
+*		This routine sets PHYDetect bit which make PPU change its polling.
+*		PPU's pool routine uses these bits to determine which port's to poll
+*		PHYs on for Link, Duplex, Speed, and Flow Control.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		This function should not be called if gsysGetPPUState returns 
+*		PPU_STATE_ACTIVE.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPHYDetect
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_BOOL  	state
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetPHYDetect Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the PHY Detect bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,12,1,(GT_U16)state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetLinkState
+*
+* DESCRIPTION:
+*       This routine retrives the link state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Up  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLinkState
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+	GT_U8			bitNumber;
+
+    DBG_INFO(("gprtGetLinkState Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		bitNumber = 11;
+	}
+	else
+	{
+		bitNumber = 12;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,bitNumber,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetPortMode
+*
+* DESCRIPTION:
+*       This routine retrives the port mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPortMode Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,11,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPhyMode
+*
+* DESCRIPTION:
+*       This routine retrives the PHY mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII PHY  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPhyMode Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,10,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetDuplex
+*
+* DESCRIPTION:
+*       This routine retrives the port duplex mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for Full  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDuplex
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+	GT_U8			bitNumber;
+
+    DBG_INFO(("gprtGetDuplex Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		bitNumber = 10;
+	}
+	else
+	{
+		bitNumber = 9;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,bitNumber,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetSpeed
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       speed - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for 100Mb/s  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSpeed
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *speed
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetSpeed Called.\n"));
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    /* Get the force flow control bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,1,&data);
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *speed);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetSpeedMode
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_PORT_SPEED_MODE type.
+*					(PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, or PORT_SPEED_10_MBPS)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSpeedMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_PORT_SPEED_MODE   *speed
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetSpeed Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+	    /* Get the force flow control bit.  */
+    	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,2,&data);
+	}
+	else
+	{
+    	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,8,1,&data);
+	}
+
+	*speed = (GT_PORT_SPEED_MODE)data;
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtSetDuplex
+*
+* DESCRIPTION:
+*       This routine sets the duplex mode of MII/SNI/RMII ports.
+*
+* INPUTS:
+*       port - 	the logical port number.
+*				(for FullSail, it will be port 2, and for ClipperShip, 
+*				it could be either port 5 or port 6.)
+*       mode -  GT_TRUE for Full Duplex,
+*				GT_FALSE for Half Duplex.
+*
+* OUTPUTS: None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDuplex
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDuplex Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_MII_DUPLEX_CONFIG)) != GT_OK)
+	{
+		return retVal;
+	}
+
+	/* check if phy is not configurable. */
+	if(IS_CONFIGURABLE_PHY(dev, hwPort))
+	{
+		/* 
+		 * phy is configurable. this function is not for the port where phy 
+		 * can be configured.
+		 */
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* Set the duplex mode. */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,9,1,(GT_U16)mode);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetHighErrorRate
+*
+* DESCRIPTION:
+*		This routine retrives the PCS High Error Rate.
+*		This routine returns GT_TRUE if the rate of invalid code groups seen by
+*		PCS has exceeded 10 to the power of -11.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHighErrorRate
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetHighErrorRate Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the high error rate bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetMGMII
+*
+* DESCRIPTION:
+*		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+*		detected connected to this port, the SERDES interface between this port
+*		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*		detected connected to this port, the SERDES interface between this port 
+*		and the PHY will be MGMII. When no PHY is detected on this port and the 
+*		SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMGMII
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetMGMII Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the high error rate bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetMGMII
+*
+* DESCRIPTION:
+*		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+*		detected connected to this port, the SERDES interface between this port
+*		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*		detected connected to this port, the SERDES interface between this port 
+*		and the PHY will be MGMII. When no PHY is detected on this port and the 
+*		SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMGMII
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_BOOL  	state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetMGMII Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_MGMII_STATUS))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    BOOL_2_BIT(state,data);
+
+    /* Get the high error rate bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gprtGetTxPaused
+*
+* DESCRIPTION:
+*		This routine retrives Transmit Pause state.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
+*				  GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTxPaused
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetTxPaused Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the TxPaused bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,5,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetFlowCtrl
+*
+* DESCRIPTION:
+*		This routine retrives Flow control state.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if Rx MAC determines that no more data should be 
+*					entering this port.
+*				  GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFlowCtrl
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetFlowCtrl Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the FlowCtrl bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,4,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetC_Duplex
+*
+* DESCRIPTION:
+*		This routine retrives Port 9's duplex configuration mode determined
+*		at reset.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if configured as Full duplex operation
+*				  GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetC_Duplex
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetC_Duplex Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the C_Duplex bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,3,1,&data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *state);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtGetC_Mode
+*
+* DESCRIPTION:
+*		This routine retrives port's interface type configuration mode 
+*		determined at reset.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - one of value in GT_PORT_CONFIG_MODE enum type
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetC_Mode
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_PORT_CONFIG_MODE   *state
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetC_Mode Called.\n"));
+
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Get the C_Mode bits.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,0,3,&data);
+
+    /* translate binary to BOOL  */
+    *state = (GT_PORT_CONFIG_MODE)data;
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    /* return */
+    return retVal;
+}
+
+
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtQosMap.c uboot-1.1.2hsv/drivers/marvell/gtQosMap.c
--- u-boot-1.1.2/drivers/marvell/gtQosMap.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtQosMap.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,910 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtQosMap.c
+*
+* DESCRIPTION:
+*       API implementation for qos mapping.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gcosSetPortDefaultTc
+*
+* DESCRIPTION:
+*       Sets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*       trafClass - default traffic class of a port.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
+*		family supports 3 bits (0 ~ 7)
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosSetPortDefaultTc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN GT_U8      trafClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gcosSetPortDefaultTc Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+      return retVal;
+	
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+	    /* Set the default port pri.  */
+    	retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,13,3,trafClass);
+    }
+	else
+	{
+	    /* Set the default port pri.  */
+    	retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,14,2,trafClass);
+	}
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gcosGetPortDefaultTc
+*
+* DESCRIPTION:
+*       Gets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*
+* OUTPUTS:
+*       trafClass - default traffic class of a port.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
+*		family supports 3 bits (0 ~ 7)
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosGetPortDefaultTc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    OUT GT_U8     *trafClass
+)
+{
+	GT_U16			data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gcosSetPortDefaultTc Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+      return retVal;
+	
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+	    /* Get the default port pri.  */
+	    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,13,3,&data);
+    }
+	else
+	{
+	    /* Get the default port pri.  */
+	    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,14,2,&data);
+	}
+
+	*trafClass = (GT_U8)data;
+	
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gqosSetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine sets priority mapping rule.
+*		If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6, 
+*		and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are 
+*		enabled, then priority selection is made based on this setup.
+*		If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
+*		If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetPrioMapRule
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    mode
+)
+{
+    GT_U16          data;           /* temporary data buffer */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosSetPrioMapRule Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(mode, data);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+      return retVal;
+	
+    /* Set the TagIfBoth.  */
+    retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,6,1,data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gqosGetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine gets priority mapping rule.
+*		If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6, 
+*		and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are 
+*		enabled, then priority selection is made based on this setup.
+*		If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
+*		If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetPrioMapRule
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetPrioMapRule Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+      return retVal;
+	
+    /* get the TagIfBoth.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,6,1,&data);
+    /* translate bool to binary */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gqosIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the IP priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosIpPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    en
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosIpPrioMapEn Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(en, data);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+      return retVal;
+	
+    /* Set the useIp.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,5,1,data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gqosGetIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the IP priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetIpPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *en
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetIpPrioMapEn Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+      return retVal;
+	
+    /* Get the UseIp.  */
+    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,5,1,&data);
+    /* translate bool to binary */
+    BIT_2_BOOL(data, *en);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gqosUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the user priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosUserPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    en
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosUserPrioMapEn Called.\n"));
+    /* translate bool to binary */
+    BOOL_2_BIT(en, data);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+      return retVal;
+	
+    /* Set the useTag.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,4,1,data);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gqosGetUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the user priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetUserPrioMapEn
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *en
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gqosGetUserPrioMapEn Called.\n"));
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
+      return retVal;
+	
+    /* Get the UseTag.  */
+    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,4,1,&data);
+    /* translate bool to binary */
+    BIT_2_BOOL(data, *en);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+
+/*******************************************************************************
+* gcosGetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Gets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosGetUserPrio2Tc
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     userPrior,
+    OUT GT_U8     *trClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+    GT_U16          data;           /* store the read data          */
+
+    DBG_INFO(("gcosGetUserPrio2Tc Called.\n"));
+
+    /* check if device supports this feature */
+    if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+		return GT_NOT_SUPPORTED;
+	
+    /* calc the bit offset */
+    bitOffset = ((userPrior & 0x7) * 2);
+    /* Get the traffic class for the VPT.  */
+    retVal = hwGetGlobalRegField(dev,QD_REG_IEEE_PRI,bitOffset,2,&data);
+    *trClass = (GT_U8)data;
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gcosSetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Sets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority of a port.
+*       trClass   - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosSetUserPrio2Tc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_U8      userPrior,
+    IN GT_U8      trClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+
+    DBG_INFO(("gcosSetUserPrio2Tc Called.\n"));
+    /* check if device supports this feature */
+    if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+		return GT_NOT_SUPPORTED;
+	
+    /* calc the bit offset */
+    bitOffset = ((userPrior & 0x7) * 2);
+    /* Set the traffic class for the VPT.  */
+    retVal = hwSetGlobalRegField(dev,QD_REG_IEEE_PRI, bitOffset,2,trClass);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gcosGetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine retrieves the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to query.
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosGetDscp2Tc
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     dscp,
+    OUT GT_U8     *trClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+    GT_U8           regOffset;      /* the reg offset in the IP tbl */
+    GT_U16          data;           /* store the read data          */
+
+    DBG_INFO(("gcosGetDscp2Tc Called.\n"));
+    /* check if device supports this feature */
+    if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+		return GT_NOT_SUPPORTED;
+	
+    /* calc the bit offset */
+    bitOffset = (((dscp & 0x3f) % 8) * 2);
+    regOffset = ((dscp & 0x3f) / 8);
+    /* Get the traffic class for the IP dscp.  */
+    retVal = hwGetGlobalRegField(dev,(GT_U8)(QD_REG_IP_PRI_BASE+regOffset),
+                                 bitOffset, 2, &data);
+    *trClass = (GT_U8)data;
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gcosSetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine sets the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to map.
+*       trClass - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosSetDscp2Tc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_U8      dscp,
+    IN GT_U8      trClass
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+    GT_U8           regOffset;      /* the reg offset in the IP tbl */
+
+    DBG_INFO(("gcosSetDscp2Tc Called.\n"));
+    /* check if device supports this feature */
+    if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
+		return GT_NOT_SUPPORTED;
+	
+    /* calc the bit offset */
+    bitOffset = (((dscp & 0x3f) % 8) * 2);
+    regOffset = ((dscp & 0x3f) / 8);
+    /* Set the traffic class for the IP dscp.  */
+    retVal = hwSetGlobalRegField(dev,(GT_U8)(QD_REG_IP_PRI_BASE+regOffset),
+                                 bitOffset, 2, trClass);
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+
+/*******************************************************************************
+* gqosGetTagRemap
+*
+* DESCRIPTION:
+*		Gets the remapped priority value for a specific 802.1p priority on a
+*		given port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*		pri   - 802.1p priority
+*
+* OUTPUTS:
+*		remappedPri - remapped Priority
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetTagRemap
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_U8    	pri,
+	OUT GT_U8   	*remappedPri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* store the read data          */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U8           regAddr;        /* register address.            */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+	
+    DBG_INFO(("gqosGetTagRemap Called.\n"));
+
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+	if (pri <= 3)
+	{
+		regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
+	}
+	else
+	{
+		regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
+	}
+
+    /* calc the bit offset */
+    bitOffset = 4 * (pri % 4);
+	
+    retVal = hwGetPortRegField(dev,phyPort,regAddr,bitOffset,3,&data );
+
+    *remappedPri = (GT_U8)data;
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gqosSetTagRemap
+*
+* DESCRIPTION:
+*		Sets the remapped priority value for a specific 802.1p priority on a
+*		given port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*		pri   - 802.1p priority
+*		remappedPri - remapped Priority
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetTagRemap
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_U8    	pri,
+	IN GT_U8    	remappedPri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           phyPort;        /* Physical port.               */
+    GT_U8           regAddr;        /* register address.            */
+    GT_U8           bitOffset;      /* the bit offset in the reg    */
+	
+    DBG_INFO(("gqosSetTagRemap Called.\n"));
+
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
+	{
+		return GT_NOT_SUPPORTED;
+	}
+
+    phyPort = GT_LPORT_2_PORT(port);
+
+	if (pri <= 3)
+	{
+		regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
+	}
+	else
+	{
+		regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
+	}
+
+    /* calc the bit offset */
+    bitOffset = 4 * (pri % 4);
+	
+    retVal = hwSetPortRegField(dev,phyPort,regAddr,bitOffset,3,remappedPri);
+
+    if(retVal != GT_OK)
+	{
+        DBG_INFO(("Failed.\n"));
+	}
+    else
+	{
+        DBG_INFO(("OK.\n"));
+	}
+
+    return retVal;
+}
+
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtSem.c uboot-1.1.2hsv/drivers/marvell/gtSem.c
--- u-boot-1.1.2/drivers/marvell/gtSem.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtSem.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,149 @@
+#include <marvell/Copyright.h>
+/********************************************************************************
+* gtOs.c
+*
+* DESCRIPTION:
+*       Semaphore related routines
+*
+* DEPENDENCIES:
+*       OS Dependent.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtSem.h>
+
+
+/*******************************************************************************
+* gtSemCreate
+*
+* DESCRIPTION:
+*       Create semaphore.
+*
+* INPUTS:
+*		state - beginning state of the semaphore, either GT_SEM_EMPTY or GT_SEM_FULL
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_SEM if success. Otherwise, NULL
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_SEM gtSemCreate
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM_BEGIN_STATE state
+)
+{
+	if(dev->semCreate)
+		return dev->semCreate(state);
+
+	return 1; /* should return any value other than 0 to let it keep going */
+}
+
+/*******************************************************************************
+* gtSemDelete
+*
+* DESCRIPTION:
+*       Delete semaphore.
+*
+* INPUTS:
+*       smid - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemDelete
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM smid
+)
+{
+	if((dev->semDelete) && (smid))
+		return dev->semDelete(smid);
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtSemTake
+*
+* DESCRIPTION:
+*       Wait for semaphore.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*       timeOut - time out in miliseconds or 0 to wait forever
+*
+* OUTPUTS:
+*       None
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       OS_TIMEOUT - on time out
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemTake
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM smid, 
+	IN GT_U32 timeOut
+)
+{
+	if(dev->semTake)
+		return dev->semTake(smid, timeOut);
+
+	return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtSemGive
+*
+* DESCRIPTION:
+*       release the semaphore which was taken previously.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemGive
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM       smid
+)
+{
+	if(dev->semGive)
+		return dev->semGive(smid);
+
+	return GT_OK;
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtSysConfig.c uboot-1.1.2hsv/drivers/marvell/gtSysConfig.c
--- u-boot-1.1.2/drivers/marvell/gtSysConfig.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtSysConfig.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,426 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtSysConfig.c
+*
+* DESCRIPTION:
+*       API definitions for system configuration, and enabling.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtDrvConfig.h>
+#include <marvell/gtSem.h>
+#include <marvell/platformDeps.h>
+
+static GT_BOOL gtRegister(GT_QD_DEV *dev, BSP_FUNCTIONS* pBSPFunctions);
+
+/*******************************************************************************
+* qdLoadDriver
+*
+* DESCRIPTION:
+*       QuarterDeck Driver Initialization Routine. 
+*       This is the first routine that needs be called by system software. 
+*       It takes *cfg from system software, and retures a pointer (*dev) 
+*       to a data structure which includes infomation related to this QuarterDeck
+*       device. This pointer (*dev) is then used for all the API functions. 
+*
+* INPUTS:
+*       cfg  - Holds device configuration parameters provided by system software.
+*
+* OUTPUTS:
+*       dev  - Holds device information to be used for each API call.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_ALREADY_EXIST    - if device already started
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+* 	qdUnloadDriver is also provided to do driver cleanup.
+*
+*******************************************************************************/
+GT_STATUS qdLoadDriver
+(
+    IN  GT_SYS_CONFIG   *cfg,
+    OUT GT_QD_DEV	*dev
+)
+{
+    GT_STATUS   retVal;
+	GT_LPORT	port;
+
+    DBG_INFO(("qdLoadDriver Called.\n"));
+
+    /* Check for parameters validity        */
+    if(dev == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Check for parameters validity        */
+    if(cfg == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* The initialization was already done. */
+    if(dev->devEnabled)
+    {
+        DBG_INFO(("QuarterDeck already started.\n"));
+        return GT_ALREADY_EXIST;
+    }
+
+    if(gtRegister(dev,&(cfg->BSPFunctions)) != GT_TRUE)
+    {
+       DBG_INFO(("gtRegister Failed.\n"));
+       return GT_FAIL;
+    }
+	dev->accessMode = cfg->mode.scanMode;
+	if (dev->accessMode == SMI_MULTI_ADDR_MODE)
+	{
+		dev->baseRegAddr = 0;
+		dev->phyAddr = cfg->mode.baseAddr;
+	}
+	else
+	{
+		dev->baseRegAddr = cfg->mode.baseAddr;
+		dev->phyAddr = 0;
+	}
+
+    /* Initialize the driver    */
+    retVal = driverConfig(dev);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("driverConfig Failed.\n"));
+        return retVal;
+    }
+
+    /* Initialize dev fields.         */
+    dev->cpuPortNum = cfg->cpuPortNum;
+    dev->maxPhyNum = 5;
+	dev->devGroup = 0;
+
+    /* Assign Device Name */
+    switch(dev->deviceId)
+    {
+		case GT_88E6021:
+		     dev->maxPhyNum = 2;
+	             dev->devName = DEV_88E6021;
+		     break;
+
+		case GT_88E6051:
+	             dev->devName = DEV_88E6051;
+		     break;
+
+		case GT_88E6052:
+	             dev->devName = DEV_88E6052;
+		     break;
+
+		case GT_88E6060:
+		     if((dev->cpuPortNum != 4)&&(dev->cpuPortNum != 5))
+		     {
+			dev = NULL;
+        		return GT_FAIL;
+		     }
+	             dev->devName = DEV_88E6060;
+		     break;
+
+		case GT_88E6063:
+	             dev->devName = DEV_88E6063;
+		     break;
+
+		case GT_FH_VPN:
+	             dev->devName = DEV_FH_VPN;
+		     break;
+
+		case GT_FF_EG:
+		    if(dev->cpuPortNum != 5)
+		    {
+			dev = NULL;
+        		return GT_FAIL;
+		    }
+	            dev->devName = DEV_FF_EG;
+		    break;
+
+		case GT_FF_HG:
+	             dev->devName = DEV_FF_HG;
+		     break;
+
+		case GT_88E6083:
+			     dev->maxPhyNum = 8;
+	             dev->devName = DEV_88E6083;
+		     break;
+		case GT_88E6153:
+                dev->maxPhyNum = 6;
+	             dev->devName = DEV_88E6183;
+		     break;
+		case GT_88E6181:
+                dev->maxPhyNum = 8;
+	             dev->devName = DEV_88E6181;
+		     break;
+		case GT_88E6183:
+                dev->maxPhyNum = 10;
+	             dev->devName = DEV_88E6183;
+		     break;
+		case GT_88E6093:
+                dev->maxPhyNum = 11;
+	             dev->devName = DEV_88E6093;
+		     break;
+		case GT_88E6092:
+                dev->maxPhyNum = 11;
+	             dev->devName = DEV_88E6092;
+		     break;
+		case GT_88E6095:
+                dev->maxPhyNum = 11;
+	             dev->devName = DEV_88E6095;
+		     break;
+		case GT_88E6152:
+                dev->maxPhyNum = 6;
+	             dev->devName = DEV_88E6182;
+		     break;
+		case GT_88E6155:
+                dev->maxPhyNum = 6;
+	             dev->devName = DEV_88E6185;
+		     break;
+		case GT_88E6182:
+                dev->maxPhyNum = 10;
+	             dev->devName = DEV_88E6182;
+		     break;
+		case GT_88E6185:
+                dev->maxPhyNum = 10;
+	             dev->devName = DEV_88E6185;
+		     break;
+		default:
+		     DBG_INFO(("Unknown Device. Initialization failed\n"));
+		     dev = NULL;
+		     return GT_FAIL;
+    }
+
+    /* Initialize the MultiAddress Register Access semaphore.    */
+    if((dev->multiAddrSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the ATU semaphore.    */
+    if((dev->atuRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the VTU semaphore.    */
+    if((dev->vtuRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+		qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the STATS semaphore.    */
+    if((dev->statsRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+		qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
+    /* Initialize the ports states to forwarding mode. */
+    if(cfg->initPorts == GT_TRUE)
+    {
+		for (port=GT_LPORT_2_PORT(0); port<GT_LPORT_2_PORT(dev->numOfPorts); port++)
+		{
+			if((retVal = gstpSetPortState(dev,port,GT_PORT_FORWARDING)) != GT_OK)
+    		{
+	    	    DBG_INFO(("Failed.\n"));
+				qdUnloadDriver(dev);
+    	    	return retVal;
+		    }
+		}
+    }
+
+	if(IS_IN_DEV_GROUP(dev,DEV_ENHANCED_CPU_PORT))
+	{
+		if((retVal = gsysSetRsvd2CpuEnables(dev,0)) != GT_OK)
+		{
+	        DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+			qdUnloadDriver(dev);
+			return retVal;
+		}
+
+		if((retVal = gsysSetRsvd2Cpu(dev,GT_FALSE)) != GT_OK)
+		{
+	        DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+			qdUnloadDriver(dev);
+			return retVal;
+		}
+	}
+
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		for (port=GT_LPORT_2_PORT(0); port<GT_LPORT_2_PORT(dev->numOfPorts); port++)
+		{
+			retVal = gprtSetCPUPort(dev,port,GT_LPORT_2_PORT(dev->cpuPortNum));
+		    if((retVal != GT_OK) && (retVal != GT_NOT_SUPPORTED))
+    		{
+	    	    DBG_INFO(("Failed.\n"));
+				qdUnloadDriver(dev);
+	   	    	return retVal;
+		    }
+		}
+	}
+
+    dev->devEnabled = 1;
+    dev->devNum = cfg->devNum;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* sysEnable
+*
+* DESCRIPTION:
+*       This function enables the system for full operation.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       1.  This function should be called only after successful execution of
+*           qdLoadDriver().
+*
+*******************************************************************************/
+GT_STATUS sysEnable( GT_QD_DEV *dev)
+{
+    DBG_INFO(("sysEnable Called.\n"));
+    DBG_INFO(("OK.\n"));
+    return driverEnable(dev);
+}
+
+
+/*******************************************************************************
+* qdUnloadDriver
+*
+* DESCRIPTION:
+*       This function unloads the QuaterDeck Driver.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       1.  This function should be called only after successful execution of
+*           qdLoadDriver().
+*
+*******************************************************************************/
+GT_STATUS qdUnloadDriver
+(
+    IN GT_QD_DEV* dev
+)
+{
+    DBG_INFO(("qdUnloadDriver Called.\n"));
+
+    /* Delete the MultiAddress mode reagister access semaphore.    */
+    if(gtSemDelete(dev,dev->multiAddrSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+ 
+    /* Delete the ATU semaphore.    */
+    if(gtSemDelete(dev,dev->atuRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the VTU semaphore.    */
+    if(gtSemDelete(dev,dev->vtuRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    /* Delete the STATS semaphore.    */
+    if(gtSemDelete(dev,dev->statsRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	gtMemSet(dev,0,sizeof(GT_QD_DEV));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtRegister
+*
+* DESCRIPTION:
+*       BSP should register the following functions:
+*		1) MII Read - (Input, must provide)
+*			allows QuarterDeck driver to read QuarterDeck device registers.
+*		2) MII Write - (Input, must provice)
+*			allows QuarterDeck driver to write QuarterDeck device registers.
+*		3) Semaphore Create - (Input, optional)
+*			OS specific Semaphore Creat function.
+*		4) Semaphore Delete - (Input, optional)
+*			OS specific Semaphore Delete function.
+*		5) Semaphore Take - (Input, optional)
+*			OS specific Semaphore Take function.
+*		6) Semaphore Give - (Input, optional)
+*			OS specific Semaphore Give function.
+*		Notes: 3) ~ 6) should be provided all or should not be provided at all.
+*
+* INPUTS:
+*		pBSPFunctions - pointer to the structure for above functions.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*       GT_TRUE, if input is valid. GT_FALSE, otherwise.
+*
+* COMMENTS:
+*       This function should be called only once.
+*
+*******************************************************************************/
+static GT_BOOL gtRegister(GT_QD_DEV *dev, BSP_FUNCTIONS* pBSPFunctions)
+{
+	dev->fgtReadMii =  pBSPFunctions->readMii;
+	dev->fgtWriteMii = pBSPFunctions->writeMii;
+	
+	dev->semCreate = pBSPFunctions->semCreate;
+	dev->semDelete = pBSPFunctions->semDelete;
+	dev->semTake   = pBSPFunctions->semTake  ;
+	dev->semGive   = pBSPFunctions->semGive  ;
+	
+	return GT_TRUE;
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtSysCtrl.c uboot-1.1.2hsv/drivers/marvell/gtSysCtrl.c
--- u-boot-1.1.2/drivers/marvell/gtSysCtrl.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtSysCtrl.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,3779 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtSysCtrl.c
+*
+* DESCRIPTION:
+*       API definitions for system global control.
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+/*******************************************************************************
+* gsysSwReset
+*
+* DESCRIPTION:
+*       This routine preforms switch software reset.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSwReset
+(
+    IN  GT_QD_DEV *dev
+)
+{
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U8			regOffset;
+
+    DBG_INFO(("gsysSwReset Called.\n"));
+
+    /* Set the Software reset bit.                  */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		regOffset = QD_REG_GLOBAL_CONTROL;
+	}
+	else
+	{
+		regOffset = QD_REG_ATU_CONTROL;
+	}
+
+    retVal = hwSetGlobalRegField(dev,regOffset,15,1,1);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Make sure the reset operation is completed.  */
+    data = 1;
+    while(data != 0)
+    {
+   	    retVal = hwGetGlobalRegField(dev,regOffset,15,1,&data);
+
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+	
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetPPUEn
+*
+* DESCRIPTION:
+*		This routine enables/disables Phy Polling Unit.
+*
+* INPUTS:
+*		en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPPUEn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL 		en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetPPUEn Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set the PPUEn bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetPPUEn
+*
+* DESCRIPTION:
+*		This routine get the PPU state.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_BAD_PARAM    - on bad parameter
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPPUEn
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetPPUEn Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the GetPPUEn bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine set the Discard Excessive state.
+*
+* INPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDiscardExcessive
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetDiscardExcessive Called.\n"));
+    BOOL_2_BIT(en,data);
+
+    /* Set the Discard Exissive bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,13,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine get the Discard Excessive state.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDiscardExcessive
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL    *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetDiscardExcessive Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the Discard Exissive bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine set the Scheduling Mode.
+*
+* INPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetSchedulingMode
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL    mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetSchedulingMode Called.\n"));
+    BOOL_2_BIT(mode,data);
+    data = 1 - data;
+
+    /* Set the Schecduling bit.             */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,11,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine get the Scheduling Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSchedulingMode
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetSchedulingMode Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* Get the Scheduling bit.              */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(1 - data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed.
+*
+* INPUTS:
+*       mode - GT_TRUE max size 1522, 
+*			   GT_FALSE max size 1535 or 1632.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*		Please refer to the device spec. to get the max frame size.
+*       88E6095 device supports upto 1632.
+*
+*******************************************************************************/
+GT_STATUS gsysSetMaxFrameSize
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetMaxFrameSize Called.\n"));
+    BOOL_2_BIT(mode,data);
+    data = 1 - data;
+
+    /* Set the Max Fram Size bit.               */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,10,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Get the max frame size allowed.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE max size 1522, 
+*			   GT_FALSE max size 1535,or 1632.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*		Please refer to the device spec. to get the max frame size.
+*       88E6095 device supports upto 1632.
+*
+*******************************************************************************/
+GT_STATUS gsysGetMaxFrameSize
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetMaxFrameSize Called.\n"));
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* Get the Max Frame Size bit.          */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,10,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(1 - data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysReLoad
+*
+* DESCRIPTION:
+*       This routine cause to the switch to reload the EEPROM.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysReLoad
+(
+    IN  GT_QD_DEV *dev
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysReLoad Called.\n"));
+    /* Set the Reload bit.                  */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,9,1,1);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Should a check for reload completion. */
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetWatchDog
+*
+* DESCRIPTION:
+*       This routine Set the the watch dog mode.
+*
+* INPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetWatchDog
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetWatchDog Called.\n"));
+    BOOL_2_BIT(en,data);
+
+    /* Set the WatchDog bit.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,7,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetWatchDog
+*
+* DESCRIPTION:
+*       This routine Get the the watch dog mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetWatchDog
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetWatchDog Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the WatchDog bit.            */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,7,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets the full duplex pause src Mac Address.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDuplexPauseMac
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetDuplexPauseMac Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Set the first Mac register with diffAddr bit reset.  */
+    data = (((*mac).arEther[0] & 0xFE) << 8) | (*mac).arEther[1];
+    retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_01,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Set the Mac23 address register.   */
+    data = ((*mac).arEther[2] << 8) | (*mac).arEther[3];
+    retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_23,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Set the Mac45 address register.   */
+    data = ((*mac).arEther[4] << 8) | (*mac).arEther[5];
+    retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_45,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets the full duplex pause src Mac Address.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDuplexPauseMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to read from register.  */
+
+    DBG_INFO(("gsysGetDuplexPauseMac Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the Mac01 register.      */
+    retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_01,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+#if 0	/* This should be always a unicast. */
+    /* The mac is allwasy a multicast mac   */
+    (*mac).arEther[0] = (data >> 8) | 0x01;
+    (*mac).arEther[1] = data & 0xFF;
+#else
+    (*mac).arEther[0] = (data >> 8) & ~0x01;
+    (*mac).arEther[1] = data & 0xFF;
+#endif
+    /* Get the Mac23 register.      */
+    retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_23,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    (*mac).arEther[2] = data >> 8;
+    (*mac).arEther[3] = data & 0xFF;
+
+    /* Get the Mac45 register.      */
+    retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_45,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    (*mac).arEther[4] = data >> 8;
+    (*mac).arEther[5] = data & 0xFF;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysSetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPerPortDuplexPauseMac
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL      en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetPerPortDuplexPauseMac Called.\n"));
+    BOOL_2_BIT(en,data);
+
+    /* Set the WatchDog bit.            */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPerPortDuplexPauseMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetPerPortDuplexPauseMac Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the Scheduling bit.              */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysReadMiiReg
+*
+* DESCRIPTION:
+*       This routine reads QuarterDeck Registers. Since this routine is only for
+*		Diagnostic Purpose, no error checking will be performed.
+*		User has to know which phy address(0 ~ 0x1F) will be read.		
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysReadMiiReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32	     phyAddr,
+    IN  GT_U32	     regAddr,
+    OUT GT_U32	     *data
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          u16Data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysReadMiiRegister Called.\n"));
+
+    /* Get the Scheduling bit.              */
+    retVal = hwReadMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,&u16Data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+	*data = (GT_U32)u16Data;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysWriteMiiReg
+*
+* DESCRIPTION:
+*       This routine writes QuarterDeck Registers. Since this routine is only for
+*		Diagnostic Purpose, no error checking will be performed.
+*		User has to know which phy address(0 ~ 0x1F) will be read.		
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysWriteMiiReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32	     phyAddr,
+    IN  GT_U32	     regAddr,
+    IN  GT_U16	     data
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    
+    DBG_INFO(("gsysWriteMiiRegister Called.\n"));
+
+    /* Get the Scheduling bit.              */
+    retVal = hwWriteMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRetransmitMode
+*
+* DESCRIPTION:
+*       This routine set the Retransmit Mode.
+*
+* INPUTS:
+*       en - GT_TRUE Retransimt Mode is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRetransmitMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetRetransmitMode Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+    BOOL_2_BIT(en,data);
+
+    /* Set the Retransmit Mode bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetRetransmitMode
+*
+* DESCRIPTION:
+*       This routine get the Retransmit Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Retransmit Mode is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRetransmitMode
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRetransmitMode Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetLimitBackoff
+*
+* DESCRIPTION:
+*       This routine set the Limit Backoff bit.
+*
+* INPUTS:
+*       en - GT_TRUE:  uses QoS half duplex backoff operation  
+*            GT_FALSE: uses normal half duplex backoff operation
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetLimitBackoff
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetLimitBackoff Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+    BOOL_2_BIT(en,data);
+
+    /* Set the bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetLimitBackoff
+*
+* DESCRIPTION:
+*       This routine set the Limit Backoff bit.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE:  uses QoS half duplex backoff operation  
+*            GT_FALSE: uses normal half duplex backoff operation
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetLimitBackoff
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetLimitBackoff Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRsvRegPri
+*
+* DESCRIPTION:
+*       This routine set the Reserved Queue's Requesting Priority 
+*
+* INPUTS:
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvReqPri
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetRsvReqPri Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+    BOOL_2_BIT(en,data);
+
+    /* Set the bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gsysGetRsvReqPri
+*
+* DESCRIPTION:
+*       This routine get the Reserved Queue's Requesting Priority 
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority 
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvReqPri
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRsvReqPri Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+	/* Only Gigabit Switch supports this status. */
+	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+		DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetCascadePort
+*
+* DESCRIPTION:
+*		This routine sets Cascade Port number.
+*		In multichip systems frames coming from a CPU need to know when they
+*		have reached their destination chip.
+*
+* INPUTS:
+*		port - Cascade Port
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetCascadePort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysSetCascadePort Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    data = (GT_U16)(GT_LPORT_2_PORT(port));
+
+    /* Set the Cascade port.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetCascadePort
+*
+* DESCRIPTION:
+*		This routine gets Cascade Port number.
+*		In multichip systems frames coming from a CPU need to know when they
+*		have reached their destination chip.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		port - Cascade Port
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetCascadePort
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT 	*port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysSetCascadePort Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Cascade port.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *port = GT_PORT_2_LPORT(data);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetDeviceNumber
+*
+* DESCRIPTION:
+*		This routine sets Device Number.
+*		In multichip systems frames coming from a CPU need to know when they
+*		have reached their destination chip. From CPU frames whose Dev_Num
+*		fieldmatches these bits have reachedtheir destination chip and are sent
+*		out this chip using the port number indicated in the frame's Trg_Port 
+*		field.
+*
+* INPUTS:
+*		devNum - Device Number (0 ~ 31)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDeviceNumber
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		devNum
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysSetDeviceNumber Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    data = ((GT_U16)devNum) & 0x1F; /* only 5 bits are valid */
+
+    /* Set the Device Number.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetDeviceNumber
+*
+* DESCRIPTION:
+*		This routine gets Device Number.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		devNum - Device Number (0 ~ 31)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDeviceNumber
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U32  	*devNum
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetDeviceNumber Called.\n"));
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Device Number.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *devNum = (GT_U32)data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetCoreTagType
+*
+* DESCRIPTION:
+*		This routine sets Ether Core Tag Type.
+*		This Ether Type is added to frames that egress the switch as Double Tagged 
+*		frames. It is also the Ether Type expected during Ingress to determine if 
+*		a frame is Tagged or not on ports configured as UseCoreTag mode.
+*
+* INPUTS:
+*		etherType - Core Tag Type (2 bytes)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetCoreTagType
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16  		etherType
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetCoreTagType Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Set the Ether Type */
+    retVal = hwWriteGlobalReg(dev,QD_REG_CORETAG_TYPE,etherType);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetCoreTagType
+*
+* DESCRIPTION:
+*		This routine gets CoreTagType
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		etherType - Core Tag Type (2 bytes)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetCoreTagType
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*etherType
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetCoreTagType Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the Device Number.                */
+    retVal = hwReadGlobalReg(dev,QD_REG_CORETAG_TYPE,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *etherType = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetIngressMonitorDest
+*
+* DESCRIPTION:
+*		This routine sets Ingress Monitor Destination Port. Frames that are 
+*		targeted toward an Ingress Monitor Destination go out the port number 
+*		indicated in these bits. This includes frames received on a Marvell Tag port
+*		with the Ingress Monitor type, and frames received on a Network port that 
+*		is enabled to be the Ingress Monitor Source Port.
+*		If the Ingress Monitor Destination Port resides in this device these bits 
+*		should point to the Network port where these frames are to egress. If the 
+*		Ingress Monitor Destination Port resides in another device these bits 
+*		should point to the Marvell Tag port in this device that is used to get 
+*		to the device that contains the Ingress Monitor Destination Port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetIngressMonitorDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetIngressMonitorDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Set the Ether Type */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, (GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetIngressMonitorDest
+*
+* DESCRIPTION:
+*		This routine gets Ingress Monitor Destination Port.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		port  - the logical port number.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetIngressMonitorDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetIngressMonitorDest Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the IngressMonitorDest. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *port = GT_PORT_2_LPORT(data);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetEgressMonitorDest
+*
+* DESCRIPTION:
+*		This routine sets Egress Monitor Destination Port. Frames that are 
+*		targeted toward an Egress Monitor Destination go out the port number 
+*		indicated in these bits. This includes frames received on a Marvell Tag port
+*		with the Egress Monitor type, and frames transmitted on a Network port that 
+*		is enabled to be the Egress Monitor Source Port.
+*		If the Egress Monitor Destination Port resides in this device these bits 
+*		should point to the Network port where these frames are to egress. If the 
+*		Egress Monitor Destination Port resides in another device these bits 
+*		should point to the Marvell Tag port in this device that is used to get 
+*		to the device that contains the Egress Monitor Destination Port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetEgressMonitorDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetEgressMonitorDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Set EgressMonitorDest */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, (GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetEgressMonitorDest
+*
+* DESCRIPTION:
+*		This routine gets Egress Monitor Destination Port.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		port  - the logical port number.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetEgressMonitorDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetEgressMonitorDest Called.\n"));
+
+	/* Only Gigabit Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the EgressMonitorDest. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *port = GT_PORT_2_LPORT(data);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetARPDest
+*
+* DESCRIPTION:
+*		This routine sets ARP Monitor Destination Port. Tagged or untagged 
+*		frames ingress Network ports that have the Broadcast Destination Address 
+*		with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+*		should point to the port that directs these frames to the switch's CPU 
+*		that will process ARPs. This target port should be a Marvell Tag port so 
+*		that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
+*		To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+*		Tag port will be sent to the port number defineded in ARPDest.
+*
+*		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP 
+*		frames will be discarded.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetARPDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetARPDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_SUPPORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Set related bit */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, (GT_U16)hwPort);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetARPDest
+*
+* DESCRIPTION:
+*		This routine gets ARP Monitor Destination Port. Tagged or untagged 
+*		frames ingress Network ports that have the Broadcast Destination Address 
+*		with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+*		should point to the port that directs these frames to the switch's CPU 
+*		that will process ARPs. This target port should be a Marvell Tag port so 
+*		that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
+*		To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+*		Tag port will be sent to the port number defineded in ARPDest.
+*
+*		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP 
+*		frames will be discarded.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		port  - the logical port number.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetARPDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetARPDest Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_SUPPORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *port = GT_PORT_2_LPORT(data);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*		Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, 
+*		the 16 reserved multicast DA addresses, whose bit in this register are 
+*		also set to a one, are treadted as MGMT frames. All the reserved DA's 
+*		take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is 
+*		tested. When x = 0x2, bit 2 of this field is tested and so on.
+*		If the tested bit in this register is cleared to a zero, the frame will 
+*		be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*		enBits - bit vector of enabled Reserved Multicast.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2CpuEnables
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		enBits
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetRsvd2CpuEnables Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_MGMT_ENABLE, (GT_U16)enBits);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*		Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, 
+*		the 16 reserved multicast DA addresses, whose bit in this register are 
+*		also set to a one, are treadted as MGMT frames. All the reserved DA's 
+*		take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is 
+*		tested. When x = 0x2, bit 2 of this field is tested and so on.
+*		If the tested bit in this register is cleared to a zero, the frame will 
+*		be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		enBits - bit vector of enabled Reserved Multicast.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2CpuEnables
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*enBits
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysGetRsvd2CpuEnables Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related register */
+    retVal = hwReadGlobal2Reg(dev, QD_REG_MGMT_ENABLE, enBits);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRsvd2Cpu
+*
+* DESCRIPTION:
+*		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+*		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+*		membership, will be considered MGMT frames and sent to the port's CPU 
+*		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+*		function) for the frames's DA is also set to a one.
+*
+* INPUTS:
+*		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2Cpu
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+    DBG_INFO(("gsysSetRsvd2Cpu Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 3, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRsvd2Cpu
+*
+* DESCRIPTION:
+*		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+*		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+*		membership, will be considered MGMT frames and sent to the port's CPU 
+*		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+*		function) for the frames's DA is also set to a one.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2Cpu
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetRsvd2Cpu Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,3,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetMGMTPri
+*
+* DESCRIPTION:
+*		These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
+*
+* INPUTS:
+*		pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - If pri is not less than 8.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetMGMTPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetMGMTPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	if (pri > 0x7)
+	{
+        DBG_INFO(("GT_BAD_PARAM\n"));
+		return GT_BAD_PARAM;
+	}
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 0, 3, pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetMGMTPri
+*
+* DESCRIPTION:
+*		These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMGMTPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    DBG_INFO(("gsysGetMGMTPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,0,3,pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetUseDoubleTagData
+*
+* DESCRIPTION:
+*		This bit is used to determine if Double Tag data that is removed from a 
+*		Double Tag frame is used or ignored when making switching decisions on 
+*		the frame.
+*
+* INPUTS:
+*		en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetUseDoubleTagData
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+    DBG_INFO(("gsysSetUseDoubleTagData Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 15, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetUseDoubleTagData
+*
+* DESCRIPTION:
+*		This bit is used to determine if Double Tag data that is removed from a 
+*		Double Tag frame is used or ignored when making switching decisions on 
+*		the frame.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetUseDoubleTagData
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetUseDoubleTagData Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetPreventLoops
+*
+* DESCRIPTION:
+*		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+*		field equals this device's Device Number, the following action will be 
+*		taken depending upon the value of this bit.
+*		GT_TRUE (1) - The frame will be discarded.
+*		GT_FALSE(0) - The frame will be prevented from going out its original 
+*						source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetPreventLoops
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+    DBG_INFO(("gsysSetPreventLoops Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 14, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetPreventLoops
+*
+* DESCRIPTION:
+*		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+*		field equals this device's Device Number, the following action will be 
+*		taken depending upon the value of this bit.
+*		GT_TRUE (1) - The frame will be discarded.
+*		GT_FALSE(0) - The frame will be prevented from going out its original 
+*						source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPreventLoops
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetPreventLoops Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetFlowControlMessage
+*
+* DESCRIPTION:
+*		When this bit is set to one, Marvell Tag Flow Control messages will be 
+*		generated when an output queue becomes congested and received Marvell Tag 
+*		Flow Control messages will pause MACs inside this device. When this bit 
+*		is cleared to a zero Marvell Tag Flow Control messages will not be 
+*		generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFlowControlMessage
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+    DBG_INFO(("gsysSetFlowControlMessage Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 13, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFlowControlMessage
+*
+* DESCRIPTION:
+*		When this bit is set to one, Marvell Tag Flow Control messages will be 
+*		generated when an output queue becomes congested and received Marvell Tag 
+*		Flow Control messages will pause MACs inside this device. When this bit 
+*		is cleared to a zero Marvell Tag Flow Control messages will not be 
+*		generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowControlMessage
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetFlowControlMessage Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetForceFlowControlPri
+*
+* DESCRIPTION:
+*		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+*		Flow Control frames will be set to the value of the FC Pri bits (set by 
+*		gsysSetFCPri function call). When this bit is cleared to a zero generated 
+*		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+*		frames that caused the congestion. This bit will have no effect if the 
+*		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+*		cleared to a zero.
+*
+* INPUTS:
+*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetForceFlowControlPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+    DBG_INFO(("gsysSetForceFlowControlPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 7, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetForceFlowControlPri
+*
+* DESCRIPTION:
+*		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+*		Flow Control frames will be set to the value of the FC Pri bits (set by 
+*		gsysSetFCPri function call). When this bit is cleared to a zero generated 
+*		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+*		frames that caused the congestion. This bit will have no effect if the 
+*		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+*		cleared to a zero.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetForceFlowControlPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetForceFlowControlPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,7,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetFCPri
+*
+* DESCRIPTION:
+*		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+*		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*		is set to a one.
+*
+* INPUTS:
+*		pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - If pri is not less than 8.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFCPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gsysSetFCPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	if (pri > 0x7)
+	{
+        DBG_INFO(("GT_BAD_PARAM\n"));
+		return GT_BAD_PARAM;
+	}
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 4, 3, pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFCPri
+*
+* DESCRIPTION:
+*		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+*		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*		is set to a one.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFCPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*pri
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    DBG_INFO(("gsysGetFCPri Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,4,3,pri);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetFlowCtrlDelay
+*
+* DESCRIPTION:
+*		This function sets Flow control delay time for 10Mbps, 100Mbps, and 
+*		1000Mbps. 
+*
+* INPUTS:
+*		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*		delayTime - actual delay time will be (this value x 2.048uS).
+*					the value cannot exceed 0x1FFF (or 8191 in decimal).
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetFlowCtrlDelay
+(
+	IN GT_QD_DEV			*dev,
+	IN GT_PORT_SPEED_MODE	sp,
+	IN GT_U32				delayTime
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+    DBG_INFO(("gsysSetFlowCtrlDelay Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	/* Check if the register can be accessed. */
+	do
+	{
+	    retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+	} while (data & 0x8000);
+
+	switch(sp)
+	{
+		case PORT_SPEED_10_MBPS:
+				data = 0;
+				break;
+		case PORT_SPEED_100_MBPS:
+				data = 1 << 13;
+				break;
+		case PORT_SPEED_1000_MBPS:
+				data = 2 << 13;
+				break;
+		default:
+		        DBG_INFO(("GT_BAD_PARAM (sp)\n"));
+				return GT_BAD_PARAM;
+	}
+
+	if (delayTime > 0x1FFF)
+	{
+		DBG_INFO(("GT_BAD_PARAM (delayTime)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data |= (GT_U16)(0x8000 | delayTime);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFlowCtrlDelay
+*
+* DESCRIPTION:
+*		This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+*		1000Mbps. 
+*
+* INPUTS:
+*		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*
+* OUTPUTS:
+*		delayTime - actual delay time will be (this value x 2.048uS).
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowCtrlDelay
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_PORT_SPEED_MODE	sp,
+	OUT GT_U32		*delayTime
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetFlowCtrlDelay Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	/* Check if the register can be accessed. */
+	do
+	{
+	    retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+	} while (data & 0x8000);
+
+	switch(sp)
+	{
+		case PORT_SPEED_10_MBPS:
+				data = 0;
+				break;
+		case PORT_SPEED_100_MBPS:
+				data = 1 << 13;
+				break;
+		case PORT_SPEED_1000_MBPS:
+				data = 2 << 13;
+				break;
+		default:
+		        DBG_INFO(("GT_BAD_PARAM (sp)\n"));
+				return GT_BAD_PARAM;
+	}
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
+   	if(retVal != GT_OK)
+    {
+   	    DBG_INFO(("Failed.\n"));
+       	return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+   	if(retVal != GT_OK)
+    {
+   	    DBG_INFO(("Failed.\n"));
+       	return retVal;
+    }
+
+	*delayTime = (GT_U32)(data & 0x1FFF);
+		
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetDevRoutingTable
+*
+* DESCRIPTION:
+*		This function sets Device to Port mapping (which device is connected to 
+*		which port of this device). 
+*
+* INPUTS:
+*		devNum - target device number.
+*		portNum - the logical port number.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDevRoutingTable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		devNum,
+	IN GT_LPORT 	port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetDevRoutingTable Called.\n"));
+
+	/* Check if Switch supports this status. */
+#if 0 /* DHS FIXME */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+#endif
+
+	/* Check if the register can be accessed. */
+	do
+	{
+	    retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+	} while (data & 0x8000);
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+	if(devNum > 0x1F)
+	{
+		DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	if(hwPort >= dev->numOfPorts)
+	{
+		DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+		hwPort = 0xF;
+	}
+
+	data = 0x8000 | (devNum << 8) | hwPort;
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetDevRoutingTable
+*
+* DESCRIPTION:
+*		This function gets Device to Port mapping (which device is connected to 
+*		which port of this device). 
+*
+* INPUTS:
+*		devNum - target device number.
+*
+* OUTPUTS:
+*		portNum - the logical port number.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDevRoutingTable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		devNum,
+	OUT GT_LPORT 	*port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetDevRoutingTable Called.\n"));
+
+	/* Check if Switch supports this status. */
+#if 0 /* DHS FIXME */
+	if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+#endif
+
+	/* Check if the register can be accessed. */
+	do
+	{
+	    retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+	} while (data & 0x8000);
+
+	if(devNum > 0x1F)
+	{
+		DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = devNum << 8;
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
+   	if(retVal != GT_OK)
+    {
+   	    DBG_INFO(("Failed.\n"));
+       	return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+   	if(retVal != GT_OK)
+    {
+   	    DBG_INFO(("Failed.\n"));
+       	return retVal;
+    }
+
+	*port = GT_PORT_2_LPORT(data & 0xF);
+		
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetTrunkMaskTable
+*
+* DESCRIPTION:
+*		This function sets routing information for the given Trunk ID.
+*
+* INPUTS:
+*		trunkNum - Trunk Number.
+*		trunkMask - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*					bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkId > 0xF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkMaskTable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		trunkNum,
+	IN GT_U32		trunkMask
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+	GT_U32			mask;
+
+    DBG_INFO(("gsysSetTrunkMaskTable Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	/* Check if the register can be accessed. */
+	do
+	{
+	    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+	} while (data & 0x8000);
+
+	if(trunkNum > 0x7)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	mask = (1 << dev->numOfPorts) - 1;
+
+	if(trunkMask > mask)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkMask)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = 0x8000 | (trunkNum << 12) | trunkMask;
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetTrunkMaskTable
+*
+* DESCRIPTION:
+*		This function retrieves routing information for the given Trunk ID.
+*
+* INPUTS:
+*		trunkNum - Trunk Number.
+*
+* OUTPUTS:
+*		trunkMask - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*					bit 1 for port 1 , etc.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkId > 0xF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkMaskTable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		trunkNum,
+	OUT GT_U32		*trunkMask
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+	GT_U32			mask;
+
+    DBG_INFO(("gsysGetTrunkMaskTable Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	/* Check if the register can be accessed. */
+	do
+	{
+	    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+	} while (data & 0x8000);
+
+	if(trunkNum > 0x7)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = trunkNum << 12;
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
+   	if(retVal != GT_OK)
+    {
+   	    DBG_INFO(("Failed.\n"));
+       	return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+   	if(retVal != GT_OK)
+    {
+   	    DBG_INFO(("Failed.\n"));
+       	return retVal;
+    }
+
+	mask = (1 << dev->numOfPorts) - 1;
+
+	*trunkMask = (GT_U32)(data & mask);
+			
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetHashTrunk
+*
+* DESCRIPTION:
+*		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+*		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+*		When this bit is set to a one the hashed computed for address table 
+*		lookups is used for the TrunkMask selection. When this bit is cleared to 
+*		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+*		select the TrunkMask to use.
+*
+* INPUTS:
+*		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetHashTrunk
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+	GT_U16			data;
+
+    DBG_INFO(("gsysSetHashTrunk Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL, 11, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetHashTrunk
+*
+* DESCRIPTION:
+*		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+*		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+*		When this bit is set to a one the hashed computed for address table 
+*		lookups is used for the TrunkMask selection. When this bit is cleared to 
+*		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+*		select the TrunkMask to use.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetHashTrunk
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetHashTrunk Called.\n"));
+
+	/* Check if Switch supports this feature. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetTrunkRouting
+*
+* DESCRIPTION:
+*		This function sets routing information for the given Trunk ID.
+*
+* INPUTS:
+*		trunkId - Trunk ID.
+*		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*					bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkId > 0xF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkRouting
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		trunkId,
+	IN GT_U32		trunkRoute
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+	GT_U32			mask;
+	GT_U32			maxTrunk;
+
+    DBG_INFO(("gsysSetTrunkRouting Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	/* Check if the register can be accessed. */
+	do
+	{
+	    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+	} while (data & 0x8000);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
+		maxTrunk = 8;
+	else
+		maxTrunk = 16;
+
+	if(trunkId >= maxTrunk)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	mask = (1 << dev->numOfPorts) - 1;
+
+	if(trunkRoute > mask)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkRoute)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = 0x8000 | (trunkId << 11) | trunkRoute;
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetTrunkRouting
+*
+* DESCRIPTION:
+*		This function retrieves routing information for the given Trunk ID.
+*
+* INPUTS:
+*		trunkId - Trunk ID.
+*
+* OUTPUTS:
+*		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*					bit 1 for port 1 , etc.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkId > 0xF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkRouting
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		trunkId,
+	OUT GT_U32		*trunkRoute
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+	GT_U32			mask;
+	GT_U32			maxTrunk;
+
+    DBG_INFO(("gsysGetTrunkRouting Called.\n"));
+
+	/* Check if Switch supports this status. */
+	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+		return GT_NOT_SUPPORTED;
+    }
+
+	/* Check if the register can be accessed. */
+	do
+	{
+	    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+    	if(retVal != GT_OK)
+	    {
+    	    DBG_INFO(("Failed.\n"));
+        	return retVal;
+	    }
+	} while (data & 0x8000);
+
+	if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
+		maxTrunk = 8;
+	else
+		maxTrunk = 16;
+
+	if(trunkId >= maxTrunk)
+	{
+		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+		return GT_BAD_PARAM;
+	}
+
+	data = trunkId << 11;
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
+   	if(retVal != GT_OK)
+    {
+   	    DBG_INFO(("Failed.\n"));
+       	return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+   	if(retVal != GT_OK)
+    {
+   	    DBG_INFO(("Failed.\n"));
+       	return retVal;
+    }
+
+	mask = (1 << dev->numOfPorts) - 1;
+
+	*trunkRoute = (GT_U32)(data & mask);
+			
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtSysStatus.c uboot-1.1.2hsv/drivers/marvell/gtSysStatus.c
--- u-boot-1.1.2/drivers/marvell/gtSysStatus.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtSysStatus.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,385 @@
+#include <marvell/Copyright.h>
+
+/*******************************************************************************
+* gtSysStatus.c
+*
+* DESCRIPTION:
+*       API definitions for system global status.
+* 	Added for fullsail
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/gtDrvSwRegs.h>
+
+
+/*******************************************************************************
+* gsysGetPPUState
+*
+* DESCRIPTION:
+*		This routine get the PPU State. These two bits return 
+*		the current value of the PPU.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		mode - GT_PPU_STATE
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_BAD_PARAM    - on bad parameter
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPPUState
+(
+	IN  GT_QD_DEV   	*dev,
+	OUT GT_PPU_STATE	*mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetPPUState Called.\n"));
+
+    /* check if device supports this feature */
+	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+	{
+        DBG_INFO(("Not Supported.\n"));
+		return GT_NOT_SUPPORTED;
+	}
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,14,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysGetSW_Mode
+*
+* DESCRIPTION:
+*       This routine get the Switch mode. These two bits returen 
+*       the current value of the SW_MODE[1:0] pins.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSW_Mode
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_SW_MODE *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetSW_Mode Called.\n"));
+
+    /* only devices beyond quarterdeck (6052) has this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+	return retVal;
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,12,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetInitReady
+*
+* DESCRIPTION:
+*       This routine get the InitReady bit. This bit is set to a one when the ATU,
+*       the Queue Controller and the Statistics Controller are done with their 
+*       initialization and are ready to accept frames.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetInitReady
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetInitReady Called.\n"));
+
+    /* only devices beyond quarterdeck (6052) has this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+	return retVal;
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+#ifdef DEBUG_FEATURE
+/*******************************************************************************
+* gsysGetPtrCollision
+*
+* DESCRIPTION:
+*       This routine get the QC Pointer Collision.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPtrCollision
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetPtrCollision Called.\n"));
+
+    /* only devices beyond quarterdeck (6052) has this feature */
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+	return retVal;
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,15,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/* the following are for clippership only - not for fullsail */
+
+/*******************************************************************************
+* gsysGetDpvCorrupt
+*
+* DESCRIPTION:
+*       This routine get the DpvCorrupt bit. This bit is set to a one when the 
+*       QC detects a destination vector error
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: destination vector corrupt, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+* 	This feature is on clippership, but not on fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDpvCorrupt
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_BOOL    *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetDpvCorrupt Called.\n"));
+
+    /* only devices beyond quarterdeck (6052) has this feature */
+    /* Fullsail (DEV_QD_88E6502) is an exception, and does not support this feature */
+
+    if((IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+      return GT_NOT_SUPPORTED; /* this is quarterdeck */
+    if(  IS_VALID_API_CALL(dev,1, DEV_88E6021 ) == GT_OK )
+      return GT_NOT_SUPPORTED; /* this is fullsail */
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,8,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetMissingPointers
+*
+* DESCRIPTION:
+*       This routine get the Missing Pointer bit. This bit is set to a one when  
+*       the Register File detects less than 64 pointers in the Link List. 
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: Missing Pointers error, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+* 	This feature is on clippership, but not on fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMissingPointers
+(
+    IN GT_QD_DEV *dev,
+    IN GT_BOOL   *mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetMissingPointers Called.\n"));
+
+  /* only devices beyond quarterdeck (6052) has this feature */
+  /* Fullsail (DEV_QD_88E6502) is an exception, and does not support this feature */
+
+  if((IS_VALID_API_CALL(dev,1, DEV_QD_PLUS)) != GT_OK )
+      return GT_NOT_SUPPORTED; /* this is quarterdeck */
+  if(  IS_VALID_API_CALL(dev,1, DEV_88E6021 ) == GT_OK )
+      return GT_NOT_SUPPORTED; /* this is fullsail */
+
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,7,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*mode);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+#endif /* DEBUG_FEATURE */
diff -Naur u-boot-1.1.2/drivers/marvell/gtUtils.c uboot-1.1.2hsv/drivers/marvell/gtUtils.c
--- u-boot-1.1.2/drivers/marvell/gtUtils.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtUtils.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,179 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtUtils.c
+*
+* DESCRIPTION:
+*       Collection of Utility functions
+*
+* DEPENDENCIES:
+*       None
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+
+/*******************************************************************************
+* gtMemSet
+*
+* DESCRIPTION:
+*       Set a block of memory
+*
+* INPUTS:
+*       start  - start address of memory block for setting
+*       simbol - character to store, converted to an unsigned char
+*       size   - size of block to be set
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to set memory block
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemSet
+(
+    IN void * start,
+    IN int    symbol,
+    IN GT_U32 size
+)
+{
+	GT_U32 i;
+	char* buf;
+	
+	buf = (char*)start;
+		
+	for(i=0; i<size; i++)
+	{
+		*buf++ = (char)symbol;
+	}
+
+	return start;
+}
+
+/*******************************************************************************
+* gtMemCpy
+*
+* DESCRIPTION:
+*       Copies 'size' characters from the object pointed to by 'source' into
+*       the object pointed to by 'destination'. If copying takes place between
+*       objects that overlap, the behavior is undefined.
+*
+* INPUTS:
+*       destination - destination of copy
+*       source      - source of copy
+*       size        - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to destination
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemCpy
+(
+    IN void *       destination,
+    IN const void * source,
+    IN GT_U32       size
+)
+{
+	GT_U32 i;
+	char* buf;
+	char* src;
+	
+	buf = (char*)destination;
+	src = (char*)source;
+		
+	for(i=0; i<size; i++)
+	{
+		*buf++ = *src++;
+	}
+
+	return destination;
+}
+
+/*******************************************************************************
+* gtMemCmp
+*
+* DESCRIPTION:
+*       Compares given memories.
+*
+* INPUTS:
+*       src1 - source 1
+*       src2 - source 2
+*       size - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0, if equal.
+*		negative number, if src1 < src2.
+*		positive number, if src1 > src2.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int gtMemCmp
+(
+    IN char src1[],
+    IN char src2[],
+    IN GT_U32 size
+)
+{
+	GT_U32 i;
+	int value;
+
+	for(i=0; i<size; i++)
+	{
+		if((value = (int)(src1[i] - src2[i])) != 0)
+			return value; 
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+* gtStrlen
+*
+* DESCRIPTION:
+*       Determine the length of a string
+* INPUTS:
+*       source  - string
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       size    - number of characters in string, not including EOS.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_U32 gtStrlen
+(
+    IN const void * source
+)
+{
+	GT_U32 i = 0;
+	char* src;
+	
+	src = (char*)source;
+		
+	while(*src++) i++;
+
+    return i;
+}
+
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtVct.c uboot-1.1.2hsv/drivers/marvell/gtVct.c
--- u-boot-1.1.2/drivers/marvell/gtVct.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtVct.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,1541 @@
+#include <marvell/Copyright.h>
+/*******************************************************************************
+* gtVct.c
+*
+* DESCRIPTION:
+*       API for Marvell Virtual Cable Tester.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+#include <marvell/msApi.h>
+#include <marvell/gtVct.h>
+#include <marvell/gtDrvSwRegs.h>
+#include <marvell/gtHwCntl.h>
+
+
+/*******************************************************************************
+* getPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*		port 	- port to be read
+*		regAddr	- register offset to be read
+*		page	- page number to be read
+*
+* OUTPUTS:
+*		data	- value of the read register
+*
+* RETURNS:
+*       GT_OK   			- if read successed
+*       GT_FAIL   			- if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static 
+GT_STATUS getPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+	IN	GT_U32  regAddr,
+	IN	GT_U32  page,
+    OUT GT_U16* data
+)
+{
+	GT_U32 pageReg;
+	GT_U16 orgReg, u16Data;
+
+	if (regAddr < 29)
+	{
+		pageReg = 22;
+		page &= 0xFF;
+	}
+	else
+	{
+		pageReg = 29;
+		page &= 0x3F;
+	}
+
+    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&orgReg) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	do
+	{
+	    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,(GT_U16)page) != GT_OK)
+    	{
+        	DBG_INFO(("Failed.\n"));
+	        return GT_FAIL;
+    	}
+
+	    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&u16Data) != GT_OK)
+    	{
+        	DBG_INFO(("Failed.\n"));
+	        return GT_FAIL;
+    	}
+	} while (u16Data != page);
+
+    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)regAddr, &u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	*data = u16Data;
+
+    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,orgReg) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	return GT_OK;
+}
+
+/*******************************************************************************
+* setPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*		port 	- port to be read
+*		regAddr	- register offset to be read
+*		page	- page number to be read
+*		data	- value of the read register
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*       GT_OK   			- if read successed
+*       GT_FAIL   			- if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static 
+GT_STATUS setPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+	IN	GT_U32 regAddr,
+	IN	GT_U32 page,
+    IN  GT_U16 data
+)
+{
+	GT_U32 pageReg;
+	GT_U16 orgReg,u16Data;
+
+	if (regAddr < 29)
+	{
+		pageReg = 22;
+		page &= 0xFF;
+	}
+	else
+	{
+		pageReg = 29;
+		page &= 0x3F;
+	}
+
+    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&orgReg) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	do
+	{
+	    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,(GT_U16)page) != GT_OK)
+    	{
+        	DBG_INFO(("Failed.\n"));
+	        return GT_FAIL;
+    	}
+
+	    if(hwReadPhyReg(dev,(GT_U8)port,(GT_U8)pageReg,&u16Data) != GT_OK)
+    	{
+        	DBG_INFO(("Failed.\n"));
+	        return GT_FAIL;
+    	}
+	} while (u16Data != page);
+
+    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)regAddr, data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+    if(hwWritePhyReg(dev,(GT_U8)port,(GT_U8)pageReg,orgReg) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
+
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* doesDeviceSupportVCT
+*
+* DESCRIPTION:
+*       This routine check if the given device supports VCT.
+*
+* INPUTS:
+*       ouiMsb - Organizationally Unique Id bits 3:18
+*       ouiLsb - Organizationally Unique Id bits 19:24
+*
+* OUTPUTS:
+*		phyType - PHY_1000M, or PHY_100M
+*
+* RETURNS:
+*       GT_OK   			- if the device supports VCT
+*       GT_NOT_SUPPORTED 	- otherwise
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static 
+GT_STATUS doesDeviceSupportVCT
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U16 ouiMsb,
+    IN  GT_U16 ouiLsb,
+    OUT GT_U16* phyType
+)
+{
+	GT_STATUS status = GT_OK;
+
+    DBG_INFO(("isDeviceSupportVCT Called.\n"));
+
+	if(ouiMsb != MARVELL_OUI_MSb)
+		return GT_NOT_SUPPORTED;
+
+	*phyType = PHY_1000M;
+
+	switch(ouiLsb & PHY_MODEL_MASK)
+	{
+		case DEV_E3082:
+			*phyType = PHY_100M;
+		    DBG_INFO(("Phy is E3082.\n"));
+			break;
+		case DEV_E104X:
+			if ((ouiLsb & PHY_REV_MASK) < 0x3)
+				status = GT_NOT_SUPPORTED;
+			if ((ouiLsb & PHY_REV_MASK) == 0x3)
+				*phyType = PHY_1000M_B;
+		    DBG_INFO(("Phy is E104X.\n"));
+			break;
+		case DEV_E1111:
+		case DEV_E114X:
+		case DEV_E1180:
+		case DEV_EC010:
+		    DBG_INFO(("Gigabit Phy.\n"));
+			break;
+		case DEV_E1149:
+		case DEV_E1112:
+			*phyType = PHY_1000M_MP;
+		    DBG_INFO(("Gigabit Phy with Multi Page mode.\n"));
+			break;
+		default:
+			status = GT_NOT_SUPPORTED;
+		    DBG_INFO(("Unknown Device.\n"));
+			break;
+	}
+
+	return status;
+}
+
+
+/*******************************************************************************
+* analizePhy100MVCTResult
+*
+* DESCRIPTION:
+*       This routine analize the virtual cable test result for 10/100M Phy
+*
+* INPUTS:
+*       regValue - test result
+*
+* OUTPUTS:
+*       cableStatus - analized test result.
+*       cableLen    - cable length or the distance where problem occurs.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static
+GT_STATUS analizePhy100MVCTResult
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U16 regValue, 
+    OUT GT_TEST_STATUS *cableStatus,
+    OUT GT_CABLE_LEN *cableLen
+)
+{
+	int len;
+
+	switch((regValue & 0x6000) >> 13)
+	{
+		case 0:
+			/* test passed. No problem found. */
+			/* check if there is impedance mismatch */
+			if ((regValue & 0xFF) == 0xFF)
+			{
+				*cableStatus = GT_NORMAL_CABLE;
+				cableLen->normCableLen = GT_UNKNOWN_LEN;
+			}
+			else
+			{
+				*cableStatus = GT_IMPEDANCE_MISMATCH;
+				len = (int)FORMULA_PHY100M(regValue & 0xFF);
+				if(len <= 0)
+					cableLen->errCableLen = 0;
+				else
+					cableLen->errCableLen = (GT_U8)len;
+			}
+				
+			break;
+		case 1:
+			/* test passed. Cable is short. */
+			*cableStatus = GT_SHORT_CABLE;
+			len = (int)FORMULA_PHY100M(regValue & 0xFF);
+			if(len <= 0)
+				cableLen->errCableLen = 0;
+			else
+				cableLen->errCableLen = (GT_U8)len;
+			break;
+		case 2:
+			/* test passed. Cable is open. */
+			*cableStatus = GT_OPEN_CABLE;
+			len = (int)FORMULA_PHY100M(regValue & 0xFF);
+			if(len <= 0)
+				cableLen->errCableLen = 0;
+			else
+				cableLen->errCableLen = (GT_U8)len;
+			break;
+		case 3:
+		default:
+			/* test failed. No result is valid. */
+			*cableStatus = GT_TEST_FAIL;
+			break;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* getCableStatus_Phy100M
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the 10/100Mbps phy,
+*       and returns the the status per Rx/Tx pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static 
+GT_STATUS getCableStatus_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+	GT_STATUS status;
+	GT_U16 reg26, reg27;
+
+    DBG_INFO(("getCableStatus_100Phy Called.\n"));
+
+	/* 
+	 * 	phy should be in 100 Full Duplex.
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,0,QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX)) != GT_OK)
+	{
+		return status;
+	}
+
+	/* 
+	 * start Virtual Cable Tester
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,26,0x8000)) != GT_OK)
+	{
+		return status;
+	}
+
+	do
+	{
+		if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
+		{
+			return status;
+		}
+		
+	} while(reg26 & 0x8000);
+
+	/*
+	 * read the test result for RX Pair
+	 */
+	if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
+	{
+		return status;
+	}
+		
+	/*
+	 * read the test result for TX Pair
+	 */
+	if((status= hwReadPhyReg(dev,hwPort,27,&reg27)) != GT_OK)
+	{
+		return status;
+	}
+		
+	cableStatus->phyType = PHY_100M;
+
+	/*
+	 * analyze the test result for RX Pair
+	 */
+	analizePhy100MVCTResult(dev, reg26, &cableStatus->cableStatus[MDI_RX_PAIR], 
+							&cableStatus->cableLen[MDI_RX_PAIR]);
+
+	/*
+	 * analyze the test result for TX Pair
+	 */
+	analizePhy100MVCTResult(dev, reg27, &cableStatus->cableStatus[MDI_TX_PAIR], 
+							&cableStatus->cableLen[MDI_TX_PAIR]);
+
+	return status;
+}
+
+static
+GT_STATUS  enable1stWorkAround_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort
+)
+{
+    GT_U16      value;
+    GT_STATUS   status;
+
+    /* enable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 3)) != GT_OK)
+       return status;
+
+    value = 0x6440;
+    if ((status = hwWritePhyReg(dev, hwPort, 30, value)) != GT_OK)
+       return status;
+
+    return GT_OK;
+}
+
+static
+GT_STATUS  disable1stWorkAround_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort
+)
+{
+    GT_STATUS status;
+
+    /* disable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 3)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0)) != GT_OK)
+       return status;
+
+    return GT_OK;
+}
+
+static
+GT_STATUS workAround_Phy100M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8            hwPort,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+	GT_STATUS status = GT_OK;
+
+	/* 
+	 * If Cable Status is OPEN and the length is less than 15m,
+	 * then apply Work Around.
+	 */
+
+	if((cableStatus->cableStatus[MDI_RX_PAIR] == GT_OPEN_CABLE) ||
+		(cableStatus->cableStatus[MDI_TX_PAIR] == GT_OPEN_CABLE))
+	{
+		/* must be disabled first and then enable again */
+        disable1stWorkAround_Phy100M(dev,hwPort);
+
+        enable1stWorkAround_Phy100M(dev,hwPort);
+
+		if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
+		{
+			return status;
+		}
+		if((status= hwWritePhyReg(dev,hwPort,30,0x0002)) != GT_OK)
+		{
+			return status;
+		}
+
+		if((status = getCableStatus_Phy100M(dev,hwPort,cableStatus)) != GT_OK)
+		{
+			return status;
+		}
+		
+		if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
+		{
+			return status;
+		}
+		if((status= hwWritePhyReg(dev,hwPort,30,0x0000)) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	return status;
+}
+
+
+static
+GT_STATUS  enable1stWorkAround_Phy1000M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort
+)
+{
+    GT_STATUS   status;
+
+    /* enable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 0x0018)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00ca)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
+       return status;
+
+    return GT_OK;
+}
+
+static
+GT_STATUS  disable1stWorkAround_Phy1000M
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     hwPort
+)
+{
+    GT_STATUS status;
+
+    /* disable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 0x0018)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x0042)) != GT_OK)
+       return status;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* analizePhy1000MVCTResult
+*
+* DESCRIPTION:
+*       This routine analize the virtual cable test result for a Gigabit Phy
+*
+* INPUTS:
+*       reg17 - original value of register 17
+*       regValue - test result
+*
+* OUTPUTS:
+*       cableStatus - analized test result.
+*       cableLen    - cable length or the distance where problem occurs.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static
+GT_STATUS analizePhy1000MVCTResult
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U16 reg17,
+    IN  GT_U16 regValue, 
+    OUT GT_TEST_STATUS *cableStatus,
+    OUT GT_CABLE_LEN *cableLen
+)
+{
+	GT_U16 u16Data;
+	int len;
+
+	switch((regValue & 0x6000) >> 13)
+	{
+		case 0:
+
+			/* Check Impedance Mismatch */
+			if ((regValue & 0xFF) < 0xFF)
+			{
+				/*  if the reflected amplitude is low it is good cable too.
+					for this registers values it is a good cable:
+					0xE23, 0xE24, 0xE25, 0xE26, 0xE27 */
+				if ((regValue < 0xE23) || (regValue > 0xE27))
+				{
+					*cableStatus = GT_IMPEDANCE_MISMATCH;
+					len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+					if(len <= 0)
+						cableLen->errCableLen = 0;
+					else
+						cableLen->errCableLen = (GT_U8)len;
+					break;
+				}
+			}
+
+			/* test passed. No problem found. */
+			*cableStatus = GT_NORMAL_CABLE;
+
+			u16Data = reg17;
+
+			/* To get Cable Length, Link should be on and Speed should be 100M or 1000M */
+			if(!(u16Data & 0x0400))
+			{
+				cableLen->normCableLen = GT_UNKNOWN_LEN;
+				break;
+			}
+
+			if((u16Data & 0xC000) != 0x8000)
+			{
+				cableLen->normCableLen = GT_UNKNOWN_LEN;
+				break;
+			}
+
+			/*
+			 * read the test result for the selected MDI Pair
+			 */
+
+			u16Data = ((u16Data >> 7) & 0x7);
+
+			switch(u16Data)
+			{
+				case 0:
+					cableLen->normCableLen = GT_LESS_THAN_50M;
+					break;
+				case 1:
+					cableLen->normCableLen = GT_50M_80M;
+					break;
+				case 2:
+					cableLen->normCableLen = GT_80M_110M;
+					break;
+				case 3:
+					cableLen->normCableLen = GT_110M_140M;
+					break;
+				case 4:
+					cableLen->normCableLen = GT_MORE_THAN_140;
+					break;
+				default:
+					cableLen->normCableLen = GT_UNKNOWN_LEN;
+					break;
+			}
+			break;
+		case 1:
+			/* test passed. Cable is short. */
+			*cableStatus = GT_SHORT_CABLE;
+			len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+			if(len <= 0)
+				cableLen->errCableLen = 0;
+			else
+				cableLen->errCableLen = (GT_U8)len;
+			break;
+		case 2:
+			/* test passed. Cable is open. */
+			*cableStatus = GT_OPEN_CABLE;
+			len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+			if(len <= 0)
+				cableLen->errCableLen = 0;
+			else
+				cableLen->errCableLen = (GT_U8)len;
+			break;
+		case 3:
+		default:
+			/* test failed. No result is valid. */
+			*cableStatus = GT_TEST_FAIL;
+			break;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* getCableStatus_Phy1000M
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the 10/100Mbps phy,
+*       and returns the the status per Rx/Tx pair.
+*
+* INPUTS:
+*       port - logical port number.
+*		reg17 - original value of reg17.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static 
+GT_STATUS getCableStatus_Phy1000M
+(	
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8			hwPort,
+    IN  GT_U16 			reg17,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+	GT_STATUS status;
+	GT_U16 reg28, u16Data;
+	int i;
+
+    DBG_INFO(("getCableStatus_Phy1000M Called.\n"));
+
+	do
+	{
+		if((status = hwWritePhyReg(dev,hwPort,22,0)) != GT_OK)
+		{
+			return status;
+		}
+		if((status = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+		{
+			return status;
+		}
+	} while ((u16Data&0x3) != 0);
+
+	/* 
+	 * start Virtual Cable Tester
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,28,0x8000)) != GT_OK)
+	{
+		return status;
+	}
+
+	do
+	{
+		if((status= hwReadPhyReg(dev,hwPort,28,&reg28)) != GT_OK)
+		{
+			return status;
+		}
+		
+	} while(reg28 & 0x8000);
+
+	cableStatus->phyType = PHY_1000M;
+
+    DBG_INFO(("Reg28 after test : %0#x.\n", reg28));
+
+	for (i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		/*
+		 * Select a MDI Pair to be read
+		 */
+		do
+		{
+			if((status = hwWritePhyReg(dev,hwPort,22,(GT_U16)i)) != GT_OK)
+			{
+				return status;
+			}
+			if((status = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+			{
+				return status;
+			}
+		} while ((GT_U16)i != (u16Data&0x3));
+			
+		/*
+		 * read the test result for the selected MDI Pair
+		 */
+		if((status = hwReadPhyReg(dev,hwPort,28,&reg28)) != GT_OK)
+		{
+			return status;
+		}
+		
+		/*
+		 * analyze the test result for RX Pair
+		 */
+		if((status = analizePhy1000MVCTResult(dev, reg17, reg28, 
+								&cableStatus->cableStatus[i], 
+								&cableStatus->cableLen[i])) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	return GT_OK;
+}
+
+static
+GT_STATUS workAround_Phy1000M
+(
+  GT_QD_DEV *dev,
+  GT_U8 hwPort
+)
+{
+	GT_STATUS status;
+
+    DBG_INFO(("workAround for Gigabit Phy Called.\n"));
+
+	if((status = hwWritePhyReg(dev,hwPort,29,0x1e)) != GT_OK)
+	{
+		return status;
+	}
+		
+	if((status = hwWritePhyReg(dev,hwPort,30,0xcc00)) != GT_OK)
+	{
+		return status;
+	}
+
+	if((status = hwWritePhyReg(dev,hwPort,30,0xc800)) != GT_OK)
+	{
+		return status;
+	}
+	if((status = hwWritePhyReg(dev,hwPort,30,0xc400)) != GT_OK)
+	{
+		return status;
+	}
+	if((status = hwWritePhyReg(dev,hwPort,30,0xc000)) != GT_OK)
+	{
+		return status;
+	}
+	if((status = hwWritePhyReg(dev,hwPort,30,0xc100)) != GT_OK)
+	{
+		return status;
+	}
+
+    DBG_INFO(("workAround for Gigabit Phy completed.\n"));
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* getCableStatus_Phy1000MPage
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the 10/100Mbps phy with
+*       multiple page mode and returns the the status per MDIP/N.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static 
+GT_STATUS getCableStatus_Phy1000MPage
+(	
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8			hwPort,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+	GT_STATUS status;
+	GT_U16 u16Data;
+	GT_U16 reg17 = 0;
+	int i;
+
+    DBG_INFO(("getCableStatus_Phy1000M Called.\n"));
+
+	/*
+	 * If Fiber is used, simply return with test fail.
+	 */
+	if((status= getPagedPhyReg(dev,(GT_U32)hwPort,17,1,&u16Data)) != GT_OK)
+	{
+		return status;
+	}
+
+	if(u16Data & 0x400)
+	{
+		for (i=0; i<GT_MDI_PAIR_NUM; i++)
+		{
+			cableStatus->cableStatus[i] = GT_TEST_FAIL;
+		}
+		return GT_OK;
+	}
+
+	/*
+	 * If Copper is used and Link is on, get DSP Distance and put it in the
+	 * old reg17 format.(bit9:7 with DSP Distance)
+	 */
+	if((status= getPagedPhyReg(dev,(GT_U32)hwPort,17,0,&u16Data)) != GT_OK)
+	{
+		return status;
+	}
+
+	if(u16Data & 0x400)
+	{
+		reg17 = (u16Data & 0xC000) | 0x400;
+
+		if((status= getPagedPhyReg(dev,(GT_U32)hwPort,26,5,&u16Data)) != GT_OK)
+		{
+			return status;
+		}
+		reg17 |= ((u16Data & 0x7) << 7);
+	}
+
+	/* 
+	 * start Virtual Cable Tester
+	 */
+	if((status= setPagedPhyReg(dev,(GT_U32)hwPort,16,5,0x8000)) != GT_OK)
+	{
+		return status;
+	}
+
+	do
+	{
+		if((status= getPagedPhyReg(dev,(GT_U32)hwPort,16,5,&u16Data)) != GT_OK)
+		{
+			return status;
+		}
+		
+	} while(u16Data & 0x8000);
+
+	cableStatus->phyType = PHY_1000M;
+
+    DBG_INFO(("Page 5 of Reg16 after test : %0#x.\n", u16Data));
+
+	for (i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		/*
+		 * read the test result for the selected MDI Pair
+		 */
+		if((status= getPagedPhyReg(dev,(GT_U32)hwPort,16+i,5,&u16Data)) != GT_OK)
+		{
+			return status;
+		}
+		
+		/*
+		 * analyze the test result for RX Pair
+		 */
+		if((status = analizePhy1000MVCTResult(dev, reg17, u16Data, 
+								&cableStatus->cableStatus[i], 
+								&cableStatus->cableLen[i])) != GT_OK)
+		{
+			return status;
+		}
+	}
+
+	return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gvctGetCableStatus
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the requested port,
+*       and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Command - vctGetCableDiag
+*
+*******************************************************************************/
+GT_STATUS gvctGetCableDiag
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+	GT_STATUS status;
+	GT_U8 hwPort;
+	GT_U16 ouiMsb, ouiLsb, phyType;
+	GT_U16 u16Data, orgReg0, orgReg17;
+	GT_BOOL ppuEn;
+	GT_PPU_STATE ppuSt;
+
+    DBG_INFO(("gvctGetCableDiag Called.\n"));
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status = doesDeviceSupportVCT(dev,ouiMsb,ouiLsb,&phyType)) != GT_OK)
+	{
+	    DBG_INFO(("Device is not supporting VCT.\n"));
+		return status;
+	}
+
+	/* Need to disable PPUEn for safe. */
+	if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+	{
+		ppuEn = GT_FALSE;
+	}
+
+	if(ppuEn != GT_FALSE)
+	{
+		if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+		{
+	    	DBG_INFO(("Not able to disable PPUEn.\n"));
+			return status;
+		}
+		do
+		{
+			if((status= gsysGetPPUState(dev,&ppuSt)) != GT_OK)
+			{
+	    		DBG_INFO(("Not able to read PPUEn.\n"));
+				return status;
+			}
+		} while(ppuSt != PPU_STATE_DISABLED_AFTER_RESET);
+	}
+		
+	/*
+	 * save original register 17 value, which will be used later depending on
+	 * test result.
+	 */
+	if((status= hwReadPhyReg(dev,hwPort,17,&orgReg17)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to reset the Phy.\n"));
+		goto cableDiagCleanup;
+	}
+
+	/*
+	 * reset the phy
+	 */
+	if((status= hwReadPhyReg(dev,hwPort,0,&orgReg0)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to reset the Phy.\n"));
+		goto cableDiagCleanup;
+	}
+
+	if((status= hwWritePhyReg(dev,hwPort,0,(GT_U16)(0x8000|orgReg0))) != GT_OK)
+	{
+	    DBG_INFO(("Not able to reset the Phy.\n"));
+		goto cableDiagCleanup;
+	}
+
+	do
+	{
+		if((status= hwReadPhyReg(dev,hwPort,0,&u16Data)) != GT_OK)
+		{
+	    	DBG_INFO(("Not able to read Phy Register.\n"));
+			goto cableDiagCleanup;
+		}
+	} while (u16Data & 0x8000);
+
+	switch(phyType)
+	{
+		case PHY_100M:
+			enable1stWorkAround_Phy100M(dev,hwPort);
+			status = getCableStatus_Phy100M(dev,hwPort,cableStatus);
+            /* every fast ethernet phy requires this work-around */
+			workAround_Phy100M(dev,hwPort,cableStatus);
+			disable1stWorkAround_Phy100M(dev,hwPort);
+			break;
+		case PHY_1000M:
+			enable1stWorkAround_Phy1000M(dev,hwPort);
+			status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
+			disable1stWorkAround_Phy1000M(dev,hwPort);
+			break;
+		case PHY_1000M_B:
+			enable1stWorkAround_Phy1000M(dev,hwPort);
+			workAround_Phy1000M(dev,hwPort);
+			status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
+			disable1stWorkAround_Phy1000M(dev,hwPort);
+			break;
+		case PHY_1000M_MP:
+			status = getCableStatus_Phy1000MPage(dev,hwPort,cableStatus);
+			break;
+		default:
+			status = GT_FAIL;
+			break;
+	}
+	
+	/*
+	 * reset the phy
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,0,(GT_U16)(0x8000|orgReg0))) != GT_OK)
+	{
+	    DBG_INFO(("Not able to reset the Phy.\n"));
+		goto cableDiagCleanup;
+	}
+
+	do
+	{
+		if((status= hwReadPhyReg(dev,hwPort,0,&u16Data)) != GT_OK)
+		{
+	    	DBG_INFO(("Not able to read Phy Register.\n"));
+			goto cableDiagCleanup;
+		}
+	} while (u16Data & 0x8000);
+
+cableDiagCleanup:
+
+	if(ppuEn != GT_FALSE)
+	{
+		if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+		{
+	    	DBG_INFO(("Not able to enable PPUEn.\n"));
+			status = GT_FAIL;
+		}
+	}
+
+	return status;	
+}
+
+
+/*******************************************************************************
+* doesDeviceSupportExtStatus
+*
+* DESCRIPTION:
+*       This routine check if the given device supports Extended Status.
+*
+* INPUTS:
+*       ouiMsb - Organizationally Unique Id bits 3:18
+*       ouiLsb - Organizationally Unique Id bits 19:24
+*
+* OUTPUTS:
+*		phyType - PHY_1000M, or PHY_1000M_MP (multi page mode)
+*
+* RETURNS:
+*       GT_OK   			- if the device supports Extended Status
+*       GT_NOT_SUPPORTED 	- otherwise
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+static 
+GT_STATUS doesDeviceSupportExtStatus
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U16 ouiMsb,
+    IN  GT_U16 ouiLsb,
+    OUT GT_U16* phyType
+)
+{
+	GT_STATUS status = GT_OK;
+
+    DBG_INFO(("isDeviceSupportExtStatus Called.\n"));
+
+	if(ouiMsb != MARVELL_OUI_MSb)
+		return GT_NOT_SUPPORTED;
+
+	*phyType = PHY_1000M;
+
+	switch(ouiLsb & PHY_MODEL_MASK)
+	{
+		case DEV_E114X:
+		case DEV_EC010:
+		    DBG_INFO(("Gigabit Phy.\n"));
+			break;
+		case DEV_E1149:
+		case DEV_E1112:
+			*phyType = PHY_1000M_MP;
+		    DBG_INFO(("Gigabit Phy with Multi Page mode.\n"));
+			break;
+		default:
+			status = GT_NOT_SUPPORTED;
+		    DBG_INFO(("Unknown Device.\n"));
+			break;
+	}
+
+	return status;
+}
+
+
+/*******************************************************************************
+* getExStatus1000M
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*		for 1000M phy
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static GT_STATUS getExStatus1000M
+(
+    IN  GT_QD_DEV 		*dev,
+    IN  GT_U8           hwPort,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+)
+{
+	GT_STATUS status;
+	GT_U16 u16Data, i;
+
+	/*
+	 * get data from 28_5 register
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,22,5)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to write to the Phy register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,28,&u16Data)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read a Phy register.\n"));
+		return status;
+	}
+
+	/* if bit 6 is not set, it's not valid. */
+	if (!(u16Data & 0x0040))
+	{
+	    DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+		extendedStatus->isValid = GT_FALSE;
+		return GT_OK;
+	}
+
+	extendedStatus->isValid = GT_TRUE;
+	
+	/* get Pair Polarity */
+	for(i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		switch((u16Data >> i) & 0x1)
+		{
+			case 0:
+				extendedStatus->pairPolarity[i] = GT_POSITIVE;
+				break;
+			default:
+				extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+				break;
+		}
+	}
+
+	/* get Pair Swap */
+	for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
+	{
+		switch((u16Data >> (i+4)) & 0x1)
+		{
+			case 0:
+				extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
+				break;
+			default:
+				extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
+				break;
+		}
+	}
+
+	/*
+	 * get data from 28_4 register
+	 */
+	if((status= hwWritePhyReg(dev,hwPort,22,4)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to write to the Phy register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,28,&u16Data)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read a Phy register.\n"));
+		return status;
+	}
+
+	/* get Pair Skew */
+	for(i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* getExStatus1000MPage
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*		for 1000M phy with multiple page mode
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static GT_STATUS getExStatus1000MPage
+(
+    IN  GT_QD_DEV 		*dev,
+    IN  GT_U8	        hwPort,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+)
+{
+	GT_STATUS status;
+	GT_U16 u16Data, i;
+
+	/*
+	 * get data from 21_5 register for pair swap
+	 */
+	if((status= getPagedPhyReg(dev,(GT_U32)hwPort,21,5,&u16Data)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read a paged Phy register.\n"));
+		return status;
+	}
+
+	/* if bit 6 is not set, it's not valid. */
+	if (!(u16Data & 0x0040))
+	{
+	    DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+		extendedStatus->isValid = GT_FALSE;
+		return GT_OK;
+	}
+
+	extendedStatus->isValid = GT_TRUE;
+	
+	/* get Pair Polarity */
+	for(i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		switch((u16Data >> i) & 0x1)
+		{
+			case 0:
+				extendedStatus->pairPolarity[i] = GT_POSITIVE;
+				break;
+			default:
+				extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+				break;
+		}
+	}
+
+	/* get Pair Swap */
+	for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
+	{
+		switch((u16Data >> (i+4)) & 0x1)
+		{
+			case 0:
+				extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
+				break;
+			default:
+				extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
+				break;
+		}
+	}
+
+	/*
+	 * get data from 20_5 register for pair skew
+	 */
+	if((status= getPagedPhyReg(dev,(GT_U32)hwPort,20,5,&u16Data)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read a paged Phy register.\n"));
+		return status;
+	}
+
+	/* get Pair Skew */
+	for(i=0; i<GT_MDI_PAIR_NUM; i++)
+	{
+		extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+	}
+
+	return GT_OK;
+}
+
+
+/*******************************************************************************
+* gvctGet1000BTExtendedStatus
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gvctGet1000BTExtendedStatus
+(
+    IN  GT_QD_DEV 		*dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+)
+{
+	GT_STATUS status;
+	GT_U8 hwPort;
+	GT_U16 ouiMsb, ouiLsb, phyType;
+	GT_BOOL ppuEn;
+	GT_PPU_STATE ppuSt;
+
+    DBG_INFO(("gvctGetCableDiag Called.\n"));
+	hwPort = GT_LPORT_2_PORT(port);
+
+	if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
+	{
+	    DBG_INFO(("Not able to read Phy Register.\n"));
+		return status;
+	}
+
+	if((status = doesDeviceSupportExtStatus(dev,ouiMsb,ouiLsb,&phyType)) != GT_OK)
+	{
+	    DBG_INFO(("Device is not supporting Extended Status.\n"));
+		return status;
+	}
+	
+	/* Need to disable PPUEn for safe. */
+	if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+	{
+		ppuEn = GT_FALSE;
+	}
+
+	if(ppuEn != GT_FALSE)
+	{
+		if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+		{
+	    	DBG_INFO(("Not able to disable PPUEn.\n"));
+			return status;
+		}
+		do
+		{
+			if((status= gsysGetPPUState(dev,&ppuSt)) != GT_OK)
+			{
+	    		DBG_INFO(("Not able to read PPUEn.\n"));
+				return status;
+			}
+		} while(ppuSt != PPU_STATE_DISABLED_AFTER_RESET);
+	}
+
+	switch(phyType)
+	{
+		case PHY_1000M:
+			status = getExStatus1000M(dev,hwPort,extendedStatus);
+			break;
+		case PHY_1000M_MP:
+			status = getExStatus1000MPage(dev,hwPort,extendedStatus);
+			break;
+		default:
+	   		DBG_INFO(("Device is not supporting Extended Cable Status.\n"));
+			status = GT_NOT_SUPPORTED;
+	}
+
+	if(ppuEn != GT_FALSE)
+	{
+		if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+		{
+	    	DBG_INFO(("Not able to enable PPUEn.\n"));
+			status = GT_FAIL;
+		}
+	}
+
+	return status;
+}
+
+
diff -Naur u-boot-1.1.2/drivers/marvell/gtVersion.c uboot-1.1.2hsv/drivers/marvell/gtVersion.c
--- u-boot-1.1.2/drivers/marvell/gtVersion.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/gtVersion.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,60 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtVersion.h
+*
+* DESCRIPTION:
+*       Includes software version information for the QuarterDeck software
+*       suite.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+
+char msApiCopyright[] = MSAPI_COPYRIGHT;
+char msApiVersion[] = MSAPI_VERSION;
+
+/*******************************************************************************
+* gtVersion
+*
+* DESCRIPTION:
+*       This function returns the version of the QuarterDeck SW suite.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       version     - QuarterDeck software version.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_BAD_PARAM on bad parameters,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gtVersion
+(
+    OUT GT_VERSION   *version
+)
+{
+    if(version == NULL)
+        return GT_BAD_PARAM;
+
+    if(gtStrlen(msApiVersion) > VERSION_MAX_LEN)
+    {
+        return GT_FAIL;
+    }
+
+    gtMemCpy(version->version,msApiVersion,gtStrlen(msApiVersion));
+    version->version[gtStrlen(msApiVersion)] = '\0';
+    return GT_OK;
+}
+
diff -Naur u-boot-1.1.2/drivers/marvell/Makefile uboot-1.1.2hsv/drivers/marvell/Makefile
--- u-boot-1.1.2/drivers/marvell/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/Makefile	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,36 @@
+# makefile - build main object file
+#
+# modification history
+# --------------------
+# 04-15-02,mj	created
+#
+#######################################################################
+
+include $(TOPDIR)/config.mk
+
+LIB :=libmarvell.a
+
+OBJS := 	gtBrgFdb.o     gtEvents.o    gtPortPav.o       gtSysConfig.o \
+		gtBrgStp.o     gtHwCntl.o    gtPortRateCtrl.o  gtSysCtrl.o \
+		gtBrgVlan.o    gtMiiSmiIf.o  gtPortRmon.o      gtSysStatus.o  platformDeps.o \
+		gtBrgVtu.o     gtPCSCtrl.o   gtPortStat.o      gtUtils.o \
+		gtDebug.o      gtPhyCtrl.o   gtPortStatus.o    gtVct.o \
+		gtDrvConfig.o  gtPhyInt.o    gtQosMap.o        gtVersion.o \
+		gtDrvEvents.o  gtPortCtrl.o  gtSem.o
+
+all:	$(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
+
+
+
diff -Naur u-boot-1.1.2/drivers/marvell/platformDeps.c uboot-1.1.2hsv/drivers/marvell/platformDeps.c
--- u-boot-1.1.2/drivers/marvell/platformDeps.c	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/drivers/marvell/platformDeps.c	2007-05-29 16:51:24.000000000 -0500
@@ -0,0 +1,86 @@
+#include <marvell/Copyright.h>
+/********************************************************************************
+* platformDeps.c
+*
+* DESCRIPTION:
+*       platform dependent functions
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#include <marvell/msApi.h>
+#include <marvell/gtDrvEvents.h>
+#include <marvell/gtHwCntl.h>
+#include <marvell/platformDeps.h>
+
+#if 0
+/*******************************************************************************
+* gtAssignFunctions
+*
+* DESCRIPTION:
+*       Exchange MII access functions and QuarterDeck Int Handler.
+*		MII access functions will be called by QuarterDeck driver and
+*		QD Int Handler should be called by BSP when BSP sees an interrupt which is related to
+*		QD (This interrupt has to be initialized by BSP, since QD has no idea which
+*		interrupt is assigned to QD)
+*
+* INPUTS:
+*       fReadMii 	- function to read MII registers
+*		fWriteMii	- functino to write MII registers
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*       GT_TRUE, if input is valid. GT_FALSE, otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL gtAssignFunctions
+(
+   GT_QD_DEV      *dev,
+   FGT_READ_MII   fReadMii,
+   FGT_WRITE_MII fWriteMii
+)
+{
+	if((fReadMii == NULL) || (fWriteMii == NULL))
+		return GT_FALSE;
+
+	dev->fgtReadMii = fReadMii;
+	dev->fgtWriteMii = fWriteMii;
+	
+	return GT_TRUE;
+}
+
+#endif
+
+GT_BOOL defaultMiiRead (unsigned int portNumber , unsigned int miiReg, unsigned int* value)
+{
+	if (portNumber > GLOBAL_REGS_START_ADDR)
+		portNumber -= GLOBAL_REGS_START_ADDR;
+
+	if (portNumber > GLOBAL_REGS_START_ADDR)
+		return GT_FALSE;
+
+	*value = 0;
+
+	return GT_TRUE;
+}
+
+GT_BOOL defaultMiiWrite (unsigned int portNumber , unsigned int miiReg, unsigned int value)
+{
+	if (portNumber > GLOBAL_REGS_START_ADDR)
+		portNumber -= GLOBAL_REGS_START_ADDR;
+
+	if (portNumber > GLOBAL_REGS_START_ADDR)
+		return GT_FALSE;
+
+	value = value;
+
+	return GT_TRUE;
+}
diff -Naur u-boot-1.1.2/drivers/natsemi.c uboot-1.1.2hsv/drivers/natsemi.c
--- u-boot-1.1.2/drivers/natsemi.c	2003-07-14 17:13:45.000000000 -0500
+++ uboot-1.1.2hsv/drivers/natsemi.c	2007-05-29 16:51:25.000000000 -0500
@@ -119,9 +119,9 @@
 	AnegEnBothBoth	= 0x0000E000,
 	AnegDis100Full	= 0x0000C000,
 	AnegEn100Both	= 0x0000A000,
-	AnegDis100Half	= 0x00008000,
+	AnegDis100Half	= 0x00004000,
 	AnegEnBothHalf	= 0x00006000,
-	AnegDis10Full	= 0x00004000,
+	AnegDis10Full	= 0x00008000,
 	AnegEn10Both	= 0x00002000,
 	DuplexMask	= 0x00008000,
 	SpeedMask	= 0x00004000,
@@ -230,7 +230,9 @@
 static void write_eeprom(struct eth_device *dev, long addr, int location,
 			 short value);
 #endif
+#ifndef CONFIG_DEBV1
 static int read_eeprom(struct eth_device *dev, long addr, int location);
+#endif
 static int mdio_read(struct eth_device *dev, int phy_id, int location);
 static int natsemi_init(struct eth_device *dev, bd_t * bis);
 static void natsemi_reset(struct eth_device *dev);
@@ -238,7 +240,7 @@
 static void natsemi_init_txd(struct eth_device *dev);
 static void natsemi_init_rxd(struct eth_device *dev);
 static void natsemi_set_rx_mode(struct eth_device *dev);
-static void natsemi_check_duplex(struct eth_device *dev);
+static int natsemi_check_duplex(struct eth_device *dev);
 static int natsemi_send(struct eth_device *dev, volatile void *packet,
 			int length);
 static int natsemi_poll(struct eth_device *dev);
@@ -249,8 +251,13 @@
 	{}
 };
 
+#if defined(CONFIG_E500)
+#define bus_to_phys(a) (a)
+#define phys_to_bus(a) (a)
+#else
 #define bus_to_phys(a)	pci_mem_to_phys((pci_dev_t)dev->priv, a)
 #define phys_to_bus(a)	pci_phys_to_mem((pci_dev_t)dev->priv, a)
+#endif
 
 static inline int
 INW(struct eth_device *dev, u_long addr)
@@ -296,8 +303,11 @@
 	int card_number = 0;
 	struct eth_device *dev;
 	u32 iobase, status, chip_config;
-	int i, idx = 0;
+	int idx = 0;
+#ifndef CONFIG_DEBV1
+	int i;
 	int prev_eedata;
+#endif
 	u32 tmp;
 
 	while (1) {
@@ -306,8 +316,8 @@
 			break;
 		}
 
-		pci_read_config_dword(devno, PCI_BASE_ADDRESS_0, &iobase);
-		iobase &= ~0x3;	/* bit 1: unused and bit 0: I/O Space Indicator */
+		pci_read_config_dword(devno, PCI_BASE_ADDRESS_1, &iobase);
+		iobase &= ~0xf;	/* bit 3: prefetchable, bit 2-1: location seletion, bit 0: I/O Space Indicator */
 
 		pci_write_config_dword(devno, PCI_COMMAND,
 				       PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
@@ -325,15 +335,14 @@
 		dev = (struct eth_device *) malloc(sizeof *dev);
 
 		sprintf(dev->name, "dp83815#%d", card_number);
-		dev->iobase = bus_to_phys(iobase);
-#ifdef NATSEMI_DEBUG
-		printf("natsemi: NatSemi ns8381[56] @ %#x\n", dev->iobase);
-#endif
 		dev->priv = (void *) devno;
 		dev->init = natsemi_init;
 		dev->halt = natsemi_disable;
 		dev->send = natsemi_send;
 		dev->recv = natsemi_poll;
+		dev->iobase = bus_to_phys(iobase);
+
+		printf("natsemi: NatSemi ns8381[56] @ %#x\n", dev->iobase);
 
 		eth_register(dev);
 
@@ -354,6 +363,7 @@
 			pci_write_config_dword(devno, PCIPM, newtmp);
 		}
 
+#ifndef CONFIG_DEBV1
 		printf("natsemi: EEPROM contents:\n");
 		for (i = 0; i <= EEPROM_SIZE; i++) {
 			short eedata = read_eeprom(dev, EECtrl, i);
@@ -369,6 +379,7 @@
 			dev->enetaddr[i*2+1] = eedata >> 7;
 			prev_eedata = eedata;
 		}
+#endif
 
 		/* Reset the chip to erase any previous misconfiguration. */
 		OUTL(dev, ChipReset, ChipCmd);
@@ -383,7 +394,40 @@
 			"disabled, force", chip_config & SpeedMask ? "0" : "",
 			chip_config & DuplexMask ? "full" : "half");
 #endif
+
+#ifndef CONFIG_DEBV1
 		chip_config |= AnegEnBothBoth;
+#else
+		{
+			DECLARE_GLOBAL_DATA_PTR;
+			bd_t *bd = gd->bd;
+
+			chip_config &= ~AnegEnBothBoth;
+			
+			/* Failover Eth, fecmode2 */
+			switch (bd->mii_operation[1]) {
+			case 0:		/* auto */
+			case 1:		/* 1000F */
+			case 2:		/* 1000H */
+			default:
+				chip_config |= AnegEnBothBoth;
+				break;
+			case 3:		/* 100F */
+				chip_config |= AnegDis100Full;
+				break;
+			case 4:		/* 100H */
+				chip_config |= AnegDis100Half;
+				break;
+			case 5:		/* 10F */
+				chip_config |= AnegDis10Full;
+				break;
+			case 6:		/* 10H */
+				chip_config |= AnegDis10Half;
+				break;
+			}
+		}
+#endif
+		
 #ifdef NATSEMI_DEBUG
 		printf("%s: changed to autoneg. %s 10%s %s duplex.\n",
 			dev->name, chip_config & AnegMask ? "enabled, advertise" :
@@ -490,6 +534,7 @@
 }
 #endif
 
+#ifndef CONFIG_DEBV1
 static int
 read_eeprom(struct eth_device *dev, long addr, int location)
 {
@@ -529,6 +574,7 @@
 #endif
 	return retval;
 }
+#endif
 
 /*  MII transceiver control section.
 	The 83815 series has an internal transceiver, and we present the
@@ -556,6 +602,7 @@
 static int
 natsemi_init(struct eth_device *dev, bd_t * bis)
 {
+	int link;
 
 	natsemi_reset(dev);
 
@@ -575,16 +622,18 @@
 	tx_config = TxAutoPad | TxCollRetry | TxMxdma_256 | (0x1002);
 	rx_config = RxMxdma_256 | 0x20;
 
-#ifdef NATSEMI_DEBUG
-	printf("%s: Setting TxConfig Register %#08X\n", dev->name, tx_config);
-	printf("%s: Setting RxConfig Register %#08X\n", dev->name, rx_config);
-#endif
 	OUTL(dev, tx_config, TxConfig);
 	OUTL(dev, rx_config, RxConfig);
 
-	natsemi_check_duplex(dev);
+	link = natsemi_check_duplex(dev);
+	if (!link) return 0;
+
 	natsemi_set_rx_mode(dev);
 
+#ifdef NATSEMI_DEBUG
+	printf("%s: Setting TxConfig Register %#08X\n", dev->name, tx_config);
+	printf("%s: Setting RxConfig Register %#08X\n", dev->name, rx_config);
+#endif
 	OUTL(dev, (RxOn | TxOn), ChipCmd);
 	return 1;
 }
@@ -653,15 +702,15 @@
 static void
 natsemi_init_txd(struct eth_device *dev)
 {
-	txd.link = (u32) 0;
-	txd.cmdsts = (u32) 0;
-	txd.bufptr = (u32) & txb[0];
+	txd.link = cpu_to_le32(phys_to_bus((u32) 0));
+	txd.cmdsts = cpu_to_le32((u32) 0);
+	txd.bufptr = cpu_to_le32(phys_to_bus((u32) & txb[0]));
 
 	/* load Transmit Descriptor Register */
-	OUTL(dev, (u32) & txd, TxRingPtr);
+	OUTL(dev, phys_to_bus((u32) & txd), TxRingPtr);
 #ifdef NATSEMI_DEBUG
 	printf("natsemi_init_txd: TX descriptor reg loaded with: %#08X\n",
-	       INL(dev, TxRingPtr));
+	       bus_to_phys(INL(dev, TxRingPtr)));
 #endif
 }
 
@@ -683,27 +732,28 @@
 
 	/* init RX descriptor */
 	for (i = 0; i < NUM_RX_DESC; i++) {
-		rxd[i].link =
-		    cpu_to_le32((i + 1 <
-				 NUM_RX_DESC) ? (u32) & rxd[i +
-							    1] : (u32) &
-				rxd[0]);
+		rxd[i].link = cpu_to_le32(phys_to_bus(
+					  (i + 1 < NUM_RX_DESC) ?
+					  (u32) & rxd[i + 1] :
+					  (u32) & rxd[0]));
 		rxd[i].cmdsts = cpu_to_le32((u32) RX_BUF_SIZE);
-		rxd[i].bufptr = cpu_to_le32((u32) & rxb[i * RX_BUF_SIZE]);
+		rxd[i].bufptr = cpu_to_le32(phys_to_bus(
+						    (u32) & rxb[i * RX_BUF_SIZE]));
 #ifdef NATSEMI_DEBUG
-		printf
-		    ("natsemi_init_rxd: rxd[%d]=%p link=%X cmdsts=%lX bufptr=%X\n",
-		     	i, &rxd[i], le32_to_cpu(rxd[i].link),
-		     		rxd[i].cmdsts, rxd[i].bufptr);
+		printf("natsemi_init_rxd: rxd[%d]=%p link=%X cmdsts=%lX bufptr=%X\n",
+		       i, &rxd[i],
+		       bus_to_phys(le32_to_cpu(rxd[i].link)),
+		       le32_to_cpu(rxd[i].cmdsts),
+		       bus_to_phys(le32_to_cpu(rxd[i].bufptr)));
 #endif
 	}
 
 	/* load Receive Descriptor Register */
-	OUTL(dev, (u32) & rxd[0], RxRingPtr);
+	OUTL(dev, phys_to_bus((u32) & rxd[0]), RxRingPtr);
 
 #ifdef NATSEMI_DEBUG
-	printf("natsemi_init_rxd: RX descriptor register loaded with: %X\n",
-	       INL(dev, RxRingPtr));
+	printf("natsemi_init_rxd: RX descriptor register loaded with: %#08X\n",
+	       bus_to_phys(INL(dev, RxRingPtr)));
 #endif
 }
 
@@ -726,24 +776,30 @@
 	OUTL(dev, rx_mode, RxFilterAddr);
 }
 
-static void
+static int
 natsemi_check_duplex(struct eth_device *dev)
 {
-	int duplex = INL(dev, ChipConfig) & FullDuplex ? 1 : 0;
-
-#ifdef NATSEMI_DEBUG
-	printf("%s: Setting %s-duplex based on negotiated link"
-	       " capability.\n", dev->name, duplex ? "full" : "half");
-#endif
-	if (duplex) {
-		rx_config |= RxAcceptTx;
-		tx_config |= (TxCarrierIgn | TxHeartIgn);
+	unsigned long cfg = INL(dev, ChipConfig);
+	int link = cfg & LinkSts ? 1 : 0;
+	int speed100 = cfg & HundSpeed ? 1 : 0;
+	int duplex = cfg & FullDuplex ? 1 : 0;
+
+	if (link) {
+		if (duplex) {
+			rx_config |= RxAcceptTx;
+			tx_config |= (TxCarrierIgn | TxHeartIgn);
+		} else {
+			rx_config &= ~RxAcceptTx;
+			tx_config &= ~(TxCarrierIgn | TxHeartIgn);
+		}
+		OUTL(dev, tx_config, TxConfig);
+		OUTL(dev, rx_config, RxConfig);
+		printf("Speed: %d, %s duplex\n"
+		       , (speed100 ? 100 : 10), duplex ? "full" : "half");
 	} else {
-		rx_config &= ~RxAcceptTx;
-		tx_config &= ~(TxCarrierIgn | TxHeartIgn);
+		printf("%s: No link.\n", dev->name);
 	}
-	OUTL(dev, tx_config, TxConfig);
-	OUTL(dev, rx_config, RxConfig);
+	return link;
 }
 
 /* Function: natsemi_send
@@ -766,27 +822,26 @@
 #endif
 
 	/* set the transmit buffer descriptor and enable Transmit State Machine */
-	txd.link = cpu_to_le32(0);
-	txd.bufptr = cpu_to_le32(phys_to_bus((u32) packet));
+	txd.link = cpu_to_le32(phys_to_bus((u32) 0));
 	txd.cmdsts = cpu_to_le32(DescOwn | length);
+	txd.bufptr = cpu_to_le32(phys_to_bus((u32) packet));
 
 	/* load Transmit Descriptor Register */
 	OUTL(dev, phys_to_bus((u32) & txd), TxRingPtr);
 #ifdef NATSEMI_DEBUG
 	if (natsemi_debug)
 	    printf("natsemi_send: TX descriptor register loaded with: %#08X\n",
-	     INL(dev, TxRingPtr));
+	     bus_to_phys(INL(dev, TxRingPtr)));
 #endif
 	/* restart the transmitter */
 	OUTL(dev, TxOn, ChipCmd);
 
 	for (i = 0;
-	     ((vu_long)tx_status = le32_to_cpu(txd.cmdsts)) & DescOwn;
+	     (tx_status = le32_to_cpu(txd.cmdsts)) & DescOwn;
 	     i++) {
 		if (i >= TOUT_LOOP) {
-			printf
-			    ("%s: tx error buffer not ready: txd.cmdsts == %#X\n",
-			     dev->name, tx_status);
+			printf("%s: tx error buffer not ready: txd.cmdsts == %#X\n",
+			       dev->name, tx_status);
 			goto Done;
 		}
 	}
@@ -844,7 +899,8 @@
 
 	/* return the descriptor and buffer to receive ring */
 	rxd[cur_rx].cmdsts = cpu_to_le32(RX_BUF_SIZE);
-	rxd[cur_rx].bufptr = cpu_to_le32((u32) & rxb[cur_rx * RX_BUF_SIZE]);
+	rxd[cur_rx].bufptr = cpu_to_le32(phys_to_bus(
+						 (u32) & rxb[cur_rx * RX_BUF_SIZE]));
 
 	if (++cur_rx == NUM_RX_DESC)
 		cur_rx = 0;
diff -Naur u-boot-1.1.2/drivers/ns16550.c uboot-1.1.2hsv/drivers/ns16550.c
--- u-boot-1.1.2/drivers/ns16550.c	2004-06-06 18:13:57.000000000 -0500
+++ uboot-1.1.2hsv/drivers/ns16550.c	2007-05-29 16:51:25.000000000 -0500
@@ -9,6 +9,7 @@
 #ifdef CFG_NS16550
 
 #include <ns16550.h>
+#include <watchdog.h>
 
 #define LCRVAL LCR_8N1					/* 8 data, 1 stop, no parity */
 #define MCRVAL (MCR_DTR | MCR_RTS)			/* RTS/DTR */
@@ -51,6 +52,9 @@
 char NS16550_getc (NS16550_t com_port)
 {
 	while ((com_port->lsr & LSR_DR) == 0) {
+#ifdef CONFIG_WATCHDOG
+		WATCHDOG_RESET();
+#endif
 #ifdef CONFIG_USB_TTY
 		extern void usbtty_poll(void);
 		usbtty_poll();
diff -Naur u-boot-1.1.2/drivers/ns9750_eth.c uboot-1.1.2hsv/drivers/ns9750_eth.c
--- u-boot-1.1.2/drivers/ns9750_eth.c	2004-02-26 17:46:22.000000000 -0600
+++ uboot-1.1.2hsv/drivers/ns9750_eth.c	2007-05-29 16:51:25.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_eth.c,v 1.2 2004/02/24 14:09:39 mpietrek Exp $
+ * $Id: ns9750_eth.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @Descr: Ethernet driver for the NS9750. Uses DMA Engine with polling
  *	   interrupt status. But interrupts are not enabled.
diff -Naur u-boot-1.1.2/drivers/ns9750_serial.c uboot-1.1.2hsv/drivers/ns9750_serial.c
--- u-boot-1.1.2/drivers/ns9750_serial.c	2004-02-26 17:46:22.000000000 -0600
+++ uboot-1.1.2hsv/drivers/ns9750_serial.c	2007-05-29 16:51:25.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_serial.c,v 1.1 2004/02/16 10:37:20 mpietrek Exp $
+ * $Id: ns9750_serial.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @Descr: Serial driver for the NS9750. Only one UART is supported yet.
  * @References: [1] NS9750 Hardware Reference/December 2003
diff -Naur u-boot-1.1.2/drivers/pci.c uboot-1.1.2hsv/drivers/pci.c
--- u-boot-1.1.2/drivers/pci.c	2004-12-16 11:48:41.000000000 -0600
+++ uboot-1.1.2hsv/drivers/pci.c	2007-05-29 16:51:25.000000000 -0500
@@ -46,12 +46,17 @@
 /*
  *
  */
+#define PCI_BUS(d)	(((d) >> 16) & 0xff)
+#define PCI_DEV(d)	(((d) >> 11) & 0x1f)
+#define PCI_FUNC(d)	(((d) >> 8) & 0x7)
 
 #define PCI_HOSE_OP(rw, size, type)					\
 int pci_hose_##rw##_config_##size(struct pci_controller *hose, 		\
 				  pci_dev_t dev, 			\
 				  int offset, type value)		\
 {									\
+  int bus_offset = hose->first_busno; \
+  dev = PCI_BDF( PCI_BUS(dev)-bus_offset, PCI_DEV(dev), PCI_FUNC(dev) ); /* DHS - remove bus offset */ \
 	return hose->rw##_##size(hose, dev, offset, value);		\
 }
 
@@ -230,7 +235,7 @@
 	struct pci_region *res;
 	unsigned long bus_addr;
 	int i;
-
+
 	if (!hose) {
 		printf ("pci_hose_phys_to_bus: %s\n", "invalid hose");
 		goto Done;
@@ -243,7 +248,7 @@
 			continue;
 
 		bus_addr = phys_addr - res->phys_start + res->bus_start;
-
+
 		if (bus_addr >= res->bus_start &&
 			bus_addr < res->bus_start + res->size) {
 			return bus_addr;
@@ -404,6 +409,200 @@
 {
 }
 
+/*================================================================*/
+
+#ifdef CONFIG_AVCT_SK98
+
+/*
+ * Macros to transform values
+ * into environment strings.
+ */
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+static void MarvelSetup( struct pci_controller *hose, pci_dev_t dev )
+{
+  static int mac = 0;
+  unsigned char macAddr[6];
+  char *tmp, *end;
+  unsigned i;
+  u32 baseAddr;
+
+#ifdef CONFIG_AMAZON_PCI_SCAN_SHOW
+  printf( "PCI: setup Marvel Mac/Phy\n" );
+#endif
+	tmp = getenv ( (unsigned char *) ((mac==0) ? "ethaddr" : "eth1addr") );
+	if ( ! tmp ) 
+  {
+    tmp = (mac==0) ? MK_STR(CONFIG_ETHADDR) : MK_STR(CONFIG_ETH1ADDR);
+  }
+	for (i=0; i<6; i++) 
+	{
+		macAddr[i] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
+		if (tmp)
+    {
+			tmp = (*end) ? end+1 : end;
+		}
+	}
+
+  pci_hose_read_config_dword( hose, dev, PCI_BASE_ADDRESS_0, & baseAddr );
+
+  out8( baseAddr + 0x004, 0x01 );   /* sw reset set */
+  out8( baseAddr + 0x004, 0x02 );   /* sw reset clr */
+
+  out8( baseAddr + 0x158, 0x02 );   /* set bit EN CONFIG WRITE */
+  out8( baseAddr + 0x3be, 0x17 );   /* set PCI config item min_gnt */
+  out8( baseAddr + 0x3bf, 0x1f );   /* set PCI config item max_lat */
+  out16r( baseAddr + 0x3ca, 0xfe02 ); /* adjust PCI flagged PM capabilities */
+  for ( i = 0; i < 6; ++i ) 
+  {
+    out8( baseAddr + 0x100 + i, macAddr[i] );
+  }
+  out8( baseAddr + 0x3c4, 0x00 );   /* disable requesting of 64bit wide transfers */
+  out8( baseAddr + 0x3c3, 0x05 );   /* enable PCI driver strength calibration */    
+  out8( baseAddr + 0x118, 0x4a );   /* flag connector type (RJ45 UTP) to driver */
+  out8( baseAddr + 0x119, 0x54 );   /* flag PMD to driver (4-pair UTP ) */
+  out8( baseAddr + 0x11a, 0x13 );   /* flag configuration */
+  out8( baseAddr + 0x11d, 0x04 );   /* flay PHY id */
+  out8( baseAddr + 0x388, 0x55 );   /* PCI Revision ID register (don't care much) */
+  out8( baseAddr + 0x3c9, 0x00 );   /* disable Yukon device's default setting to flag the availability of the PCI VDP feature */
+
+  out8( baseAddr + 0x158, 0x01 );   /* reset bit EN CONFIG WRITE to disable PCI config writes */
+
+#if 0
+  for ( i = 0; i < 6; ++i ) 
+  {
+    unsigned char b;
+    b = in8( baseAddr + 0x100 + i );
+    printf( "%02X ", b );
+  }
+  printf( "\n" );
+#endif
+
+  mac = 1;
+}
+#endif /* CONFIG_AVCT_SK98 */
+
+/*================================================================*/
+
+#ifdef CONFIG_AVCT_NEC_USB
+
+// #define NEC_USB_CONFIG_TESTING 
+
+/*
+ * NEC USB Host controller default configuration memory bytes
+ */
+static unsigned long usbHcDefaultCfg[ 6 ] =
+{
+  0x10331033,
+  0x00351033,
+  0x00E00035,
+  0x2A100101,
+  0x0000222A,
+  0xC41033A2
+};
+#ifdef NEC_USB_CONFIG_TESTING
+static unsigned long usbHcClearCfg[ 6 ] =
+{
+  0xFFFFFFFF,
+  0xFFFFFFFF,
+  0xFFFFFFFF,
+  0xFFFFFFFF,
+  0xFFFFFFFF,
+  0xFFFFFFFF
+};
+#endif
+
+static void delayTenth( void )
+{
+  int i;
+  for (i = 0; i < 100; i ++)
+  {
+    udelay(1000);
+  }
+}
+
+static void NecSetup( struct pci_controller *hose, pci_dev_t dev )
+{
+  u32 ehciBaseAddr;
+  unsigned long *usbCfg;
+
+  unsigned long I2C_CMD;
+  unsigned long I2C_WND0;
+  unsigned long I2C_WND1;
+  unsigned short sbsysid;
+  unsigned short sbsyvsid;
+
+#ifdef CONFIG_AMAZON_PCI_SCAN_SHOW
+  printf( "PCI: setup NEC/USB controller\n" );
+#endif
+  if ( PCI_FUNC(dev) != 2 )
+  {
+    return;
+  }
+  dev = PCI_BDF( PCI_BUS(dev), PCI_DEV(dev), 0 ); /* function 0 */
+  pci_hose_read_config_word( hose, dev, PCI_SUBSYSTEM_VENDOR_ID, & sbsyvsid );
+  pci_hose_read_config_word( hose, dev, PCI_SUBSYSTEM_ID, & sbsysid );
+#ifndef NEC_USB_CONFIG_TESTING
+  if ( (sbsysid  == 0x0035) && (sbsyvsid == 0x1033) ) 
+  {
+    return;
+  }
+#endif
+  printf( "\nInitializing USB Host Controller EEPROM\n" );
+  printf( "  SubsysId     = %04X before programming\n", sbsysid );
+  printf( "  SubsysVendId = %04X before programming\n", sbsyvsid );
+
+  dev = PCI_BDF( PCI_BUS(dev), PCI_DEV(dev), 2 ); /* function 2 */
+  pci_hose_write_config_word( hose, dev, PCI_COMMAND, PCI_COMMAND_MEMORY ); /* enable memory access to EHCI regs */
+  pci_hose_read_config_dword( hose, dev, PCI_BASE_ADDRESS_0, & ehciBaseAddr );
+
+  printf( "ehciBaseAddr = %08X\n", ehciBaseAddr );
+  
+  I2C_CMD   = (ehciBaseAddr + 0xF4);
+  I2C_WND0  = (ehciBaseAddr + 0xF8);
+  I2C_WND1  = (ehciBaseAddr + 0xFC);
+
+  usbCfg = usbHcDefaultCfg;
+#ifdef NEC_USB_CONFIG_TESTING
+  if ( sbsysid == 0x0035 ) 
+  {
+    usbCfg = usbHcClearCfg;
+  }
+#endif
+  /*
+   * write EEPROM with config information 
+   */
+  out32r( I2C_WND0, usbCfg[ 0 ] );
+  out32r( I2C_WND1, usbCfg[ 1 ] );
+  out32r( I2C_CMD, (0x00 << 1) | 0x01 );
+  delayTenth();
+
+  out32r( I2C_WND0, usbCfg[ 2 ] );
+  out32r( I2C_WND1, usbCfg[ 3 ] );
+  out32r( I2C_CMD, (0x01 << 1) | 0x01 );
+  delayTenth();
+
+  out32r( I2C_WND0, usbCfg[ 4 ] );
+  out32r( I2C_WND1, usbCfg[ 5 ] );
+  out32r( I2C_CMD, (0x02 << 1) | 0x01 );
+  delayTenth();
+
+  /*
+   * read EEPROM into USB controller 
+   */
+  out32r( I2C_CMD, (0x03 << 1) | 0x00 );
+  delayTenth();
+
+  dev = PCI_BDF( PCI_BUS(dev), PCI_DEV(dev), 0 ); /* function 0 */
+  pci_hose_read_config_word( hose, dev, PCI_SUBSYSTEM_VENDOR_ID, & sbsyvsid );
+  pci_hose_read_config_word( hose, dev, PCI_SUBSYSTEM_ID, & sbsysid );
+
+  printf( "  SubsysId     = %04X after programming\n", sbsysid );
+  printf( "  SubsysVendId = %04X after programming\n", sbsyvsid );
+}
+#endif /* CONFIG_AVCT_NEC_USB */
+
 /*
  *
  */
@@ -424,6 +623,9 @@
 
 	sub_bus = bus;
 
+#ifdef CONFIG_PCI_SCAN_SHOW
+	printf("PCI bus scanning ...\n");
+#endif
 	for (dev =  PCI_BDF(bus,0,0);
 	     dev <  PCI_BDF(bus,PCI_MAX_PCI_DEVICES-1,PCI_MAX_PCI_FUNCTIONS-1);
 	     dev += PCI_BDF(0,0,1))
@@ -442,6 +644,19 @@
 #endif
 		}
 
+#ifdef CONFIG_AVCT_NEC_USB
+    if ( dev == PCI_BDF(1,13,0) ) 
+    {
+#ifdef CONFIG_PCI_SCAN_SHOW
+#ifdef CONFIG_AMAZON_PCI_SCAN_SHOW
+      printf( "PCI: Enable access to EHCI on bus %d\n", PCI_BUS(dev) );
+#endif
+#endif
+      /* enable access to EHCI */
+      pci_hose_write_config_dword( hose, dev, 0x00E4, 0 ); /* EXT2 = 0 */
+    }
+#endif
+
 		if (PCI_FUNC(dev) && !found_multi)
 			continue;
 
@@ -486,6 +701,24 @@
 				   int_line);
 			}
 #endif
+
+#ifdef CONFIG_AMAZON
+      switch ( vendor ) 
+      {
+        case 0x1148:    /* Marvel GigE controller */
+#ifdef CONFIG_AVCT_SK98
+          MarvelSetup( hose, dev );
+#endif
+          break;
+        case 0x1033:    /* Nec EHCI */
+#ifdef CONFIG_AVCT_NEC_USB
+          NecSetup( hose, dev );
+#endif
+          break;
+        case 0x1057:    /* Moto security engine */
+          break;
+      }
+#endif
 		}
 	}
 
diff -Naur u-boot-1.1.2/drivers/s3c4510b_eth.h uboot-1.1.2hsv/drivers/s3c4510b_eth.h
--- u-boot-1.1.2/drivers/s3c4510b_eth.h	2004-07-01 11:30:48.000000000 -0500
+++ uboot-1.1.2hsv/drivers/s3c4510b_eth.h	2007-05-29 16:51:25.000000000 -0500
@@ -22,7 +22,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
  *
- * MODULE:        $Id:$
+ * MODULE:        $Id: s3c4510b_eth.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * Description:   Ethernet interface
  * Runtime Env:   ARM7TDMI
  * Change History:
diff -Naur u-boot-1.1.2/drivers/s3c4510b_uart.c uboot-1.1.2hsv/drivers/s3c4510b_uart.c
--- u-boot-1.1.2/drivers/s3c4510b_uart.c	2004-07-01 11:30:48.000000000 -0500
+++ uboot-1.1.2hsv/drivers/s3c4510b_uart.c	2007-05-29 16:51:25.000000000 -0500
@@ -35,7 +35,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * MODULE:        $Id:$
+ * MODULE:        $Id: s3c4510b_uart.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * Description:   UART/Serial interface for Samsung S3C4510B SoC
  * Runtime Env:   ARM7TDMI
  * Change History:
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/lm80.h uboot-1.1.2hsv/drivers/sk98lin/h/lm80.h
--- u-boot-1.1.2/drivers/sk98lin/h/lm80.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/lm80.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	lm80.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:	$Date: 2002/04/25 11:04:10 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Contains all defines for the LM80 Chip
  *		(National Semiconductor).
  *
@@ -26,6 +26,9 @@
  *
  * History:
  *	$Log: lm80.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.4  2002/04/25 11:04:10  rschmidt
  *	Editorial changes
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skaddr.h uboot-1.1.2hsv/drivers/sk98lin/h/skaddr.h
--- u-boot-1.1.2/drivers/sk98lin/h/skaddr.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skaddr.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skaddr.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.26 $
- * Date:	$Date: 2002/11/15 07:24:42 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Header file for Address Management (MC, UC, Prom).
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skaddr.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.26  2002/11/15 07:24:42  tschilli
  *	SK_ADDR_EQUAL macro fixed.
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skcsum.h uboot-1.1.2hsv/drivers/sk98lin/h/skcsum.h
--- u-boot-1.1.2/drivers/sk98lin/h/skcsum.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skcsum.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skcsum.h
  * Project:	GEnesis - SysKonnect SK-NET Gigabit Ethernet (SK-98xx)
- * Version:	$Revision: 1.9 $
- * Date:	$Date: 2001/02/06 11:21:39 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skcsum.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.9  2001/02/06 11:21:39  rassmann
  *	Editorial changes.
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skdebug.h uboot-1.1.2hsv/drivers/sk98lin/h/skdebug.h
--- u-boot-1.1.2/drivers/sk98lin/h/skdebug.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skdebug.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skdebug.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12 $
- * Date:	$Date: 2002/07/15 15:37:13 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	SK specific DEBUG support
  *
  ******************************************************************************/
@@ -25,6 +25,9 @@
  *
  * History:
  *	$Log: skdebug.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.12  2002/07/15 15:37:13  rschmidt
  *	Power Management support
  *	Editorial changes
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skdrv1st.h uboot-1.1.2hsv/drivers/sk98lin/h/skdrv1st.h
--- u-boot-1.1.2/drivers/sk98lin/h/skdrv1st.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skdrv1st.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skdrv1st.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.11 $
- * Date:	$Date: 2003/02/25 14:16:40 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	First header file for driver and all other modules
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skdrv1st.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.11  2003/02/25 14:16:40  mlindner
  *	Fix: Copyright statement
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skdrv2nd.h uboot-1.1.2hsv/drivers/sk98lin/h/skdrv2nd.h
--- u-boot-1.1.2/drivers/sk98lin/h/skdrv2nd.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skdrv2nd.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skdrv2nd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.15 $
- * Date:	$Date: 2003/02/25 14:16:40 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Second header file for driver and all other modules
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skdrv2nd.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.15  2003/02/25 14:16:40  mlindner
  *	Fix: Copyright statement
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skerror.h uboot-1.1.2hsv/drivers/sk98lin/h/skerror.h
--- u-boot-1.1.2/drivers/sk98lin/h/skerror.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skerror.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skerror.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.5 $
- * Date:	$Date: 2002/04/25 11:05:10 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
@@ -25,6 +25,9 @@
  *
  * History:
  *	$Log: skerror.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.5  2002/04/25 11:05:10  rschmidt
  *	Editorial changes
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skgedrv.h uboot-1.1.2hsv/drivers/sk98lin/h/skgedrv.h
--- u-boot-1.1.2/drivers/sk98lin/h/skgedrv.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skgedrv.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgedrv.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.6 $
- * Date:	$Date: 2002/07/15 15:38:01 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Interface with the driver
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgedrv.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.6  2002/07/15 15:38:01  rschmidt
  *	Power Management support
  *	Editorial changes
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skgehw.h uboot-1.1.2hsv/drivers/sk98lin/h/skgehw.h
--- u-boot-1.1.2/drivers/sk98lin/h/skgehw.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skgehw.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgehw.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.49 $
- * Date:	$Date: 2003/01/28 09:43:49 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines and Macros for the Gigabit Ethernet Adapter Product Family
  *
  ******************************************************************************/
@@ -25,6 +25,9 @@
  *
  * History:
  * $Log: skgehw.h,v $
+ * Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ * u-boot-1.1.2 src tree
+ *
  * Revision 1.49  2003/01/28 09:43:49  rschmidt
  * Added defines for PCI-Spec. 2.3 IRQ
  * Added defines for CLK_RUN (YUKON-Lite)
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skgehwt.h uboot-1.1.2hsv/drivers/sk98lin/h/skgehwt.h
--- u-boot-1.1.2/drivers/sk98lin/h/skgehwt.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skgehwt.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skhwt.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.5 $
- * Date:	$Date: 1999/11/22 13:54:24 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines for the hardware timer functions
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skgehwt.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.5  1999/11/22 13:54:24  cgoos
  *	Changed license header to GPL.
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skgei2c.h uboot-1.1.2hsv/drivers/sk98lin/h/skgei2c.h
--- u-boot-1.1.2/drivers/sk98lin/h/skgei2c.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skgei2c.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgei2c.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.23 $
- * Date:	$Date: 2002/12/19 14:34:27 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Special GEnesis defines for TWSI
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgei2c.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.23  2002/12/19 14:34:27  rschmidt
  *	Added cast in macros SK_I2C_SET_BIT() and SK_I2C_CLR_BIT()
  *	Editorial changes (TWSI)
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skgeinit.h uboot-1.1.2hsv/drivers/sk98lin/h/skgeinit.h
--- u-boot-1.1.2/drivers/sk98lin/h/skgeinit.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skgeinit.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgeinit.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.75 $
- * Date:	$Date: 2003/02/05 13:36:39 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Structures and prototypes for the GE Init Module
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgeinit.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.75  2003/02/05 13:36:39  rschmidt
  *	Added define SK_FACT_78	for YUKON's Host Clock of 78.12 MHz
  *	Editorial changes
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skgepnm2.h uboot-1.1.2hsv/drivers/sk98lin/h/skgepnm2.h
--- u-boot-1.1.2/drivers/sk98lin/h/skgepnm2.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skgepnm2.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnm2.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.34 $
- * Date:	$Date: 2002/12/16 09:05:18 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgepnm2.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.34  2002/12/16 09:05:18  tschilli
  *	Code for VCT handling added.
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skgepnmi.h uboot-1.1.2hsv/drivers/sk98lin/h/skgepnmi.h
--- u-boot-1.1.2/drivers/sk98lin/h/skgepnmi.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skgepnmi.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnmi.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.59 $
- * Date:	$Date: 2002/12/16 14:03:50 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgepnmi.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.59  2002/12/16 14:03:50  tschilli
  *	New defines for VCT added.
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skgesirq.h uboot-1.1.2hsv/drivers/sk98lin/h/skgesirq.h
--- u-boot-1.1.2/drivers/sk98lin/h/skgesirq.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skgesirq.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgesirq.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.26 $
- * Date:	$Date: 2002/10/14 09:52:36 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	SK specific Gigabit Ethernet special IRQ functions
  *
  ******************************************************************************/
@@ -25,6 +25,9 @@
  *
  * History:
  *	$Log: skgesirq.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.26  2002/10/14 09:52:36  rschmidt
  *	Added SKERR_SIRQ_E023 and SKERR_SIRQ_E023 for GPHY (Yukon)
  *	Editorial changes
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/ski2c.h uboot-1.1.2hsv/drivers/sk98lin/h/ski2c.h
--- u-boot-1.1.2/drivers/sk98lin/h/ski2c.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/ski2c.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	ski2c.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.34 $
- * Date:	$Date: 2003/01/28 09:11:21 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines to access Voltage and Temperature Sensor
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: ski2c.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.34  2003/01/28 09:11:21  rschmidt
  *	Editorial changes
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skqueue.h uboot-1.1.2hsv/drivers/sk98lin/h/skqueue.h
--- u-boot-1.1.2/drivers/sk98lin/h/skqueue.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skqueue.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skqueue.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.14 $
- * Date:	$Date: 2002/03/15 10:52:13 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines for the Event queue
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skqueue.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.14  2002/03/15 10:52:13  mkunz
  *	Added event classes for link aggregation
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skrlmt.h uboot-1.1.2hsv/drivers/sk98lin/h/skrlmt.h
--- u-boot-1.1.2/drivers/sk98lin/h/skrlmt.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skrlmt.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skrlmt.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.35 $
- * Date:	$Date: 2003/01/31 14:12:41 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Header file for Redundant Link ManagemenT.
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skrlmt.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.35  2003/01/31 14:12:41  mkunz
  *	single port adapter runs now with two identical MAC addresses
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/sktimer.h uboot-1.1.2hsv/drivers/sk98lin/h/sktimer.h
--- u-boot-1.1.2/drivers/sk98lin/h/sktimer.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/sktimer.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	sktimer.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.9 $
- * Date:	$Date: 1999/11/22 14:00:29 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines for the timer functions
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: sktimer.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.9  1999/11/22 14:00:29  cgoos
  *	Changed license header to GPL.
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/sktypes.h uboot-1.1.2hsv/drivers/sk98lin/h/sktypes.h
--- u-boot-1.1.2/drivers/sk98lin/h/sktypes.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/sktypes.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	sktypes.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.3 $
- * Date:	$Date: 2003/02/25 14:16:40 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Define data types for Linux
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: sktypes.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.3  2003/02/25 14:16:40  mlindner
  *	Fix: Copyright statement
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skversion.h uboot-1.1.2hsv/drivers/sk98lin/h/skversion.h
--- u-boot-1.1.2/drivers/sk98lin/h/skversion.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skversion.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	version.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:	$Date: 2003/02/25 14:16:40 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
@@ -25,6 +25,9 @@
  *
  * History:
  *	$Log: skversion.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.4  2003/02/25 14:16:40  mlindner
  *	Fix: Copyright statement
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/skvpd.h uboot-1.1.2hsv/drivers/sk98lin/h/skvpd.h
--- u-boot-1.1.2/drivers/sk98lin/h/skvpd.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/skvpd.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skvpd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.15 $
- * Date:	$Date: 2003/01/13 10:39:38 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines and Macros for VPD handling
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skvpd.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.15  2003/01/13 10:39:38  rschmidt
  *	Replaced define for PCI device Id for YUKON with GENESIS
  *	Editorial changes
diff -Naur u-boot-1.1.2/drivers/sk98lin/h/xmac_ii.h uboot-1.1.2hsv/drivers/sk98lin/h/xmac_ii.h
--- u-boot-1.1.2/drivers/sk98lin/h/xmac_ii.h	2003-10-15 18:53:55.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/h/xmac_ii.h	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	xmac_ii.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.46 $
- * Date:	$Date: 2003/01/28 09:47:45 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Defines and Macros for Gigabit Ethernet Controller
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: xmac_ii.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.46  2003/01/28 09:47:45  rschmidt
  *	Added defines for copper MDI/MDIX configuration
  *	Added defines for LED Control Register
diff -Naur u-boot-1.1.2/drivers/sk98lin/skaddr.c uboot-1.1.2hsv/drivers/sk98lin/skaddr.c
--- u-boot-1.1.2/drivers/sk98lin/skaddr.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skaddr.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skaddr.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.48 $
- * Date:	$Date: 2003/02/12 17:09:37 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Manage Addresses (Multicast and Unicast) and Promiscuous Mode.
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skaddr.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.48  2003/02/12 17:09:37  tschilli
  *	Fix in SkAddrOverride() to set both (physical and logical) MAC addresses
  *	in case that both addresses are identical.
@@ -224,7 +227,7 @@
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skaddr.c,v 1.48 2003/02/12 17:09:37 tschilli Exp $ (C) SysKonnect.";
+	"@(#) $Id: skaddr.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ (C) SysKonnect.";
 #endif	/* !defined(lint) */
 
 #define __SKADDR_C
diff -Naur u-boot-1.1.2/drivers/sk98lin/skcsum.c uboot-1.1.2hsv/drivers/sk98lin/skcsum.c
--- u-boot-1.1.2/drivers/sk98lin/skcsum.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skcsum.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skcsum.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.10 $
- * Date:	$Date: 2002/04/11 10:02:04 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skcsum.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.10  2002/04/11 10:02:04  rwahl
  *	Fix in SkCsGetSendInfo():
  *	- function did not return ProtocolFlags in every case.
@@ -78,7 +81,7 @@
 
 #ifndef lint
 static const char SysKonnectFileId[] = "@(#)"
-	"$Id: skcsum.c,v 1.10 2002/04/11 10:02:04 rwahl Exp $"
+	"$Id: skcsum.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $"
 	" (C) SysKonnect.";
 #endif	/* !lint */
 
diff -Naur u-boot-1.1.2/drivers/sk98lin/skge.c uboot-1.1.2hsv/drivers/sk98lin/skge.c
--- u-boot-1.1.2/drivers/sk98lin/skge.c	2004-04-25 09:37:30.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skge.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:    skge.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.46 $
- * Date:       	$Date: 2003/02/25 14:16:36 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:       	$Date: 2005/02/05 03:15:31 $
  * Purpose:	The main driver source module
  *
  ******************************************************************************/
@@ -56,6 +56,9 @@
  * History:
  *
  *	$Log: skge.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.46  2003/02/25 14:16:36  mlindner
  *	Fix: Copyright statement
  *
@@ -498,6 +501,51 @@
 	{}
 };
 
+#ifdef CONFIG_AVCT_SK98
+static void skgePciConfig( SK_AC *pAC )
+{
+#if 0
+  unsigned i;
+  char *baseAddr = pAC->IoBase;
+  unsigned char addr[6];
+#endif
+#if 0
+  SK_OUT8( baseAddr , 0x004, 0x01 );     /* sw reset set */
+  SK_OUT8( baseAddr , 0x004, 0x02 );     /* sw reset clr */
+
+  SK_OUT8( baseAddr , 0x158, 0x02 );   /* set bit EN CONFIG WRITE */
+
+  SK_OUT8( baseAddr , 0x3be, 0x17 );   /* set PCI config item min_gnt */
+  SK_OUT8( baseAddr , 0x3bf, 0x1f );   /* set PCI config item max_lat */
+  SK_OUT16( baseAddr , 0x3ca, 0xfe02 ); /* adjust PCI flagged PM capabilities */
+
+  for ( i = 0; i < 6; ++i ) 
+  {
+    SK_OUT8( baseAddr , 0x100 + i, addr[i] );
+  }
+
+  SK_OUT8( baseAddr , 0x3c4, 0x00 );   /* disable requesting of 64bit wide transfers */
+  SK_OUT8( baseAddr , 0x3c3, 0x05 );   /* enable PCI driver strength calibration */    
+  SK_OUT8( baseAddr , 0x118, 0x4a );   /* flag connector type (RJ45 UTP) to driver */
+  SK_OUT8( baseAddr , 0x119, 0x54 );   /* flag PMD to driver (4-pair UTP ) */
+  SK_OUT8( baseAddr , 0x11a, 0x13 );   /* flag configuration */
+  SK_OUT8( baseAddr , 0x11d, 0x04 );   /* flay PHY id */
+  SK_OUT8( baseAddr , 0x388, 0x55 );   /* PCI Revision ID register (don't care much) */
+  SK_OUT8( baseAddr , 0x3c9, 0x00 );   /* disable Yukon device's default setting to flag the availability of the PCI VDP feature */
+
+  SK_OUT8( baseAddr , 0x158, 0x01 );   /* reset bit EN CONFIG WRITE to disable PCI config writes */
+#endif
+#if 0
+  printf( "skgePciConfig: %08X: MAC ", baseAddr );
+  for ( i = 0; i < 6; ++i ) 
+  {
+    SK_IN8( baseAddr , 0x100 + i, & addr[i] );
+    printf( "%02X ", addr[i] );
+  }
+  printf( "\n" );
+#endif
+}
+#endif
 
 /*****************************************************************************
  *
@@ -556,7 +604,7 @@
 		while((devno = pci_find_devices (supported, boards_found)) >= 0)
 #endif
 		{
-
+
 		dev = NULL;
 		pNet = NULL;
 
@@ -627,9 +675,15 @@
 		pAC->dev[1] = dev;
 #else
 		pAC->PciDev = devno;
+#ifdef CONFIG_AVCT_SK98
+		pAC->dev[0] = dev;
+		pAC->dev[1] = dev;
+		ret_dev[boards_found] = dev;
+#else
 		ret_dev[0] = pAC->dev[0] = dev;
 		ret_dev[1] = pAC->dev[1] = dev;
 #endif
+#endif
 		sprintf(pAC->Name, "SysKonnect SK-98xx");
 		pAC->CheckQueue = SK_FALSE;
 
@@ -696,6 +750,10 @@
 		pAC->IoBase = (char*)pci_mem_to_phys(devno, base_address);
 #endif
 
+#ifdef CONFIG_AVCT_SK98
+    skgePciConfig( pAC );
+#endif
+
 		if (!pAC->IoBase){
 			printk(KERN_ERR "%s:  Unable to map I/O register, "
 			       "SK 98xx No. %i will be disabled.\n",
@@ -2153,7 +2211,11 @@
 		pMessage->len,
 		PCI_DMA_TODEVICE);
 #else
-	PhysAddr = (SK_U64) pci_phys_to_mem(pAC->PciDev, (u32) pMessage->data);
+#ifdef CONFIG_AVCT_SK98
+	PhysAddr = (SK_U64) pMessage->data ;
+#else
+ 	PhysAddr = (SK_U64) pci_phys_to_mem(pAC->PciDev, (u32) pMessage->data);
+#endif
 #endif
 	pTxd->VDataLow = (SK_U32)  (PhysAddr & 0xffffffff);
 	pTxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
@@ -2518,7 +2580,11 @@
 		pAC->RxBufSize - 2,
 		PCI_DMA_FROMDEVICE);
 #else
-	PhysAddr = (SK_U64) pci_phys_to_mem(pAC->PciDev, (u32)pMsgBlock->data);
+#ifdef CONFIG_AVCT_SK98
+	PhysAddr = (SK_U64) pMsgBlock->data ;
+#else
+ 	PhysAddr = (SK_U64) pci_phys_to_mem(pAC->PciDev, (u32)pMsgBlock->data);
+#endif
 #endif
 	pRxd->VDataLow = (SK_U32) (PhysAddr & 0xffffffff);
 	pRxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
diff -Naur u-boot-1.1.2/drivers/sk98lin/skgehwt.c uboot-1.1.2hsv/drivers/sk98lin/skgehwt.c
--- u-boot-1.1.2/drivers/sk98lin/skgehwt.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skgehwt.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgehwt.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.13 $
- * Date:	$Date: 1999/11/22 13:31:12 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Hardware Timer.
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skgehwt.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.13  1999/11/22 13:31:12  cgoos
  *	Changed license header to GPL.
  *
@@ -81,7 +84,7 @@
 	Event queue and dispatcher
 */
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/skgehwt.c,v 1.13 1999/11/22 13:31:12 cgoos Exp $" ;
+	"$Header: /usr/cvsroot//gartop/uboot/uboot-1.1.2/drivers/sk98lin/skgehwt.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
diff -Naur u-boot-1.1.2/drivers/sk98lin/skgeinit.c uboot-1.1.2hsv/drivers/sk98lin/skgeinit.c
--- u-boot-1.1.2/drivers/sk98lin/skgeinit.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skgeinit.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgeinit.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.85 $
- * Date:	$Date: 2003/02/05 15:30:33 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Contains functions to initialize the GE HW
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgeinit.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.85  2003/02/05 15:30:33  rschmidt
  *	Corrected setting of GIHstClkFact (Host Clock Factor) and
  *	GIPollTimerVal (Descr. Poll Timer Init Value) for YUKON.
@@ -405,7 +408,7 @@
 /* local variables ************************************************************/
 
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skgeinit.c,v 1.85 2003/02/05 15:30:33 rschmidt Exp $ (C) SK ";
+	"@(#)$Id: skgeinit.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ (C) SK ";
 
 struct s_QOffTab {
 	int	RxQOff;		/* Receive Queue Address Offset */
diff -Naur u-boot-1.1.2/drivers/sk98lin/skgemib.c uboot-1.1.2hsv/drivers/sk98lin/skgemib.c
--- u-boot-1.1.2/drivers/sk98lin/skgemib.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skgemib.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgemib.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.7 $
- * Date:	$Date: 2002/12/16 09:04:34 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Private Network Management Interface Management Database
  *
  ****************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgemib.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.7  2002/12/16 09:04:34  tschilli
  *	Code for VCT handling added.
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/skgepnmi.c uboot-1.1.2hsv/drivers/sk98lin/skgepnmi.c
--- u-boot-1.1.2/drivers/sk98lin/skgepnmi.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skgepnmi.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnmi.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.102 $
- * Date:	$Date: 2002/12/16 14:03:24 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Private Network Management Interface
  *
  ****************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgepnmi.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.102  2002/12/16 14:03:24  tschilli
  *	VCT code in Vct() changed.
  *
@@ -437,7 +440,7 @@
 #ifdef CONFIG_SK98
 
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgepnmi.c,v 1.102 2002/12/16 14:03:24 tschilli Exp $"
+	"@(#) $Id: skgepnmi.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $"
 	" (C) SysKonnect.";
 
 #include "h/skdrv1st.h"
diff -Naur u-boot-1.1.2/drivers/sk98lin/skgesirq.c uboot-1.1.2hsv/drivers/sk98lin/skgesirq.c
--- u-boot-1.1.2/drivers/sk98lin/skgesirq.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skgesirq.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skgesirq.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.83 $
- * Date:	$Date: 2003/02/05 15:10:59 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Special IRQ module
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skgesirq.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.83  2003/02/05 15:10:59  rschmidt
  *	Fixed setting of PLinkSpeedUsed in SkHWLinkUp() when
  *	auto-negotiation is disabled.
@@ -366,7 +369,7 @@
  */
 
 static const char SysKonnectFileId[] =
-	"$Id: skgesirq.c,v 1.83 2003/02/05 15:10:59 rschmidt Exp $" ;
+	"$Id: skgesirq.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skgepnmi.h"		/* PNMI Definitions */
diff -Naur u-boot-1.1.2/drivers/sk98lin/ski2c.c uboot-1.1.2hsv/drivers/sk98lin/ski2c.c
--- u-boot-1.1.2/drivers/sk98lin/ski2c.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/ski2c.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	ski2c.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.57 $
- * Date:	$Date: 2003/01/28 09:17:38 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Functions to access Voltage and Temperature Sensor
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: ski2c.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.57  2003/01/28 09:17:38  rschmidt
  *	Fixed handling for sensors on YUKON Fiber.
  *	Editorial changes.
@@ -236,7 +239,7 @@
  *	I2C Protocol
  */
 static const char SysKonnectFileId[] =
-	"$Id: ski2c.c,v 1.57 2003/01/28 09:17:38 rschmidt Exp $";
+	"$Id: ski2c.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $";
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/lm80.h"
diff -Naur u-boot-1.1.2/drivers/sk98lin/sklm80.c uboot-1.1.2hsv/drivers/sk98lin/sklm80.c
--- u-boot-1.1.2/drivers/sk98lin/sklm80.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/sklm80.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	sklm80.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.20 $
- * Date:	$Date: 2002/08/13 09:16:27 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Funktions to access Voltage and Temperature Sensor (LM80)
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: sklm80.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.20  2002/08/13 09:16:27  rschmidt
  *	Changed return value for SkLm80ReadSensor() back to 'int'
  *	Editorial changes
@@ -106,7 +109,7 @@
 	LM80 functions
 */
 static const char SysKonnectFileId[] =
-	"$Id: sklm80.c,v 1.20 2002/08/13 09:16:27 rschmidt Exp $" ;
+	"$Id: sklm80.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/lm80.h"
diff -Naur u-boot-1.1.2/drivers/sk98lin/skproc.c uboot-1.1.2hsv/drivers/sk98lin/skproc.c
--- u-boot-1.1.2/drivers/sk98lin/skproc.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skproc.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:    skproc.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:    $Date: 2003/02/25 14:16:37 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:    $Date: 2005/02/05 03:15:31 $
  * Purpose:	Funktions to display statictic data
  *
  ******************************************************************************/
@@ -28,6 +28,9 @@
  * History:
  *
  *	$Log: skproc.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.4  2003/02/25 14:16:37  mlindner
  *	Fix: Copyright statement
  *
diff -Naur u-boot-1.1.2/drivers/sk98lin/skqueue.c uboot-1.1.2hsv/drivers/sk98lin/skqueue.c
--- u-boot-1.1.2/drivers/sk98lin/skqueue.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skqueue.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skqueue.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.18 $
- * Date:	$Date: 2002/05/07 14:11:11 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Management of an event queue.
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skqueue.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.18  2002/05/07 14:11:11  rwahl
  *	Fixed Watcom Precompiler error.
  *
@@ -95,7 +98,7 @@
 	Event queue and dispatcher
 */
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/skqueue.c,v 1.18 2002/05/07 14:11:11 rwahl Exp $" ;
+	"$Header: /usr/cvsroot//gartop/uboot/uboot-1.1.2/drivers/sk98lin/skqueue.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skqueue.h"		/* Queue Definitions */
diff -Naur u-boot-1.1.2/drivers/sk98lin/skrlmt.c uboot-1.1.2hsv/drivers/sk98lin/skrlmt.c
--- u-boot-1.1.2/drivers/sk98lin/skrlmt.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skrlmt.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skrlmt.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.68 $
- * Date:	$Date: 2003/01/31 15:26:56 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Manage links on SK-NET Adapters, esp. redundant ones.
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skrlmt.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.68  2003/01/31 15:26:56  rschmidt
  *	Added init for local variables in RlmtInit().
  *
@@ -286,7 +289,7 @@
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skrlmt.c,v 1.68 2003/01/31 15:26:56 rschmidt Exp $ (C) SysKonnect.";
+	"@(#) $Id: skrlmt.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ (C) SysKonnect.";
 #endif	/* !defined(lint) */
 
 #define __SKRLMT_C
diff -Naur u-boot-1.1.2/drivers/sk98lin/sktimer.c uboot-1.1.2hsv/drivers/sk98lin/sktimer.c
--- u-boot-1.1.2/drivers/sk98lin/sktimer.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/sktimer.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	sktimer.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12 $
- * Date:	$Date: 1999/11/22 13:38:51 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	High level timer functions.
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: sktimer.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.12  1999/11/22 13:38:51  cgoos
  *	Changed license header to GPL.
  *
@@ -80,7 +83,7 @@
 	Event queue and dispatcher
 */
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/sktimer.c,v 1.12 1999/11/22 13:38:51 cgoos Exp $" ;
+	"$Header: /usr/cvsroot//gartop/uboot/uboot-1.1.2/drivers/sk98lin/sktimer.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
diff -Naur u-boot-1.1.2/drivers/sk98lin/skvpd.c uboot-1.1.2hsv/drivers/sk98lin/skvpd.c
--- u-boot-1.1.2/drivers/sk98lin/skvpd.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skvpd.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skvpd.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.37 $
- * Date:	$Date: 2003/01/13 10:42:45 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Shared software to read and write VPD data
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skvpd.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.37  2003/01/13 10:42:45  rschmidt
  *	Replaced check for PCI device Id from YUKON with GENESIS
  *	to set the VPD size in VpdInit()
@@ -168,13 +171,34 @@
 	Please refer skvpd.txt for infomation how to include this module
  */
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skvpd.c,v 1.37 2003/01/13 10:42:45 rschmidt Exp $ (C) SK";
+	"@(#)$Id: skvpd.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ (C) SK";
 
 #include "h/skdrv1st.h"
 #include "h/sktypes.h"
 #include "h/skdebug.h"
 #include "h/skdrv2nd.h"
 
+#ifdef CONFIG_AVCT_SK98		/* added to replace external storage for VPD */
+static unsigned char vpdBuffer[ 256 ] = {
+  0x82, 0x30, 0x00, 0x59, 0x75, 0x6B, 0x6F, 0x6E, 0x20, 0x47, 0x69, 0x67, 0x61, 0x62, 0x69, 0x74,
+  0x20, 0x45, 0x74, 0x68, 0x65, 0x72, 0x6E, 0x65, 0x74, 0x20, 0x31, 0x30, 0x2F, 0x31, 0x30, 0x30,
+  0x2F, 0x31, 0x30, 0x30, 0x30, 0x42, 0x61, 0x73, 0x65, 0x2D, 0x54, 0x20, 0x41, 0x64, 0x61, 0x70,
+  0x74, 0x65, 0x72, 0x90, 0x4A, 0x00, 0x50, 0x4E, 0x0D, 0x59, 0x75, 0x6B, 0x6F, 0x6E, 0x20, 0x38,
+  0x38, 0x45, 0x38, 0x30, 0x30, 0x31, 0x45, 0x43, 0x08, 0x52, 0x65, 0x76, 0x2E, 0x20, 0x31, 0x2E,
+  0x33, 0x4D, 0x4E, 0x07, 0x4D, 0x61, 0x72, 0x76, 0x65, 0x6C, 0x6C, 0x53, 0x4E, 0x0D, 0x41, 0x62,
+  0x43, 0x64, 0x45, 0x66, 0x47, 0x33, 0x33, 0x34, 0x34, 0x35, 0x34, 0x43, 0x50, 0x04, 0x01, 0x10,
+  0xCC, 0x03, 0x52, 0x56, 0x0B, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x91, 0x7C, 0x00, 0x52, 0x57, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
+};
+#endif
+
 /*
  * Static functions
  */
@@ -194,6 +218,7 @@
  * returns	0:	success, transfer completes
  *		error	exit(9) with a error message
  */
+#ifndef CONFIG_AVCT_SK98
 static int VpdWait(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	IoC,	/* IO Context */
@@ -233,6 +258,7 @@
 
 	return(0);
 }
+#endif
 
 #ifdef SKDIAG
 
@@ -246,6 +272,7 @@
  *
  * Returns the data read.
  */
+#ifndef CONFIG_AVCT_SK98
 SK_U32 VpdReadDWord(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	IoC,	/* IO Context */
@@ -272,6 +299,7 @@
 		("VPD read dword data = 0x%x\n",Rtv));
 	return(Rtv);
 }
+#endif
 
 #endif	/* SKDIAG */
 
@@ -347,6 +375,17 @@
 int		Addr,	/* VPD start address */
 int		Len)	/* number of bytes to read / to write */
 {
+#ifdef CONFIG_AVCT_SK98	/* added to replace external storage for VPD */
+	int		i;
+
+  for (i = 0; i < Len; i++ )
+  {
+    if ( (Addr + i) < sizeof(vpdBuffer) )
+    {
+      vpdBuffer[ Addr + i ] = buf[ i ];
+    }
+  }
+#else
 	int		i;
 	int		j;
 	SK_U16	AdrReg;
@@ -424,7 +463,7 @@
 			}
 		}
 	}
-
+#endif
 	return(Len);
 }
 
@@ -442,6 +481,17 @@
 int		Addr,	/* VPD start address */
 int		Len)	/* number of bytes to read / to write */
 {
+#ifdef CONFIG_AVCT_SK98	/* added to replace external storage for VPD */
+	int		i;
+
+  for (i = 0; i < Len; i++ )
+  {
+    if ( (Addr + i) < sizeof(vpdBuffer) )
+    {
+      buf[ i ] = vpdBuffer[ Addr + i ];
+    }
+  }
+#else
 	int		i;
 	SK_U16	AdrReg;
 	int		Rtv;
@@ -464,7 +514,7 @@
 		VPD_IN8(pAC, IoC, PCI_VPD_DAT_REG + (i%sizeof(SK_U32)),
 			(SK_U8 *)buf);
 	}
-
+#endif
 	return(Len);
 }
 
diff -Naur u-boot-1.1.2/drivers/sk98lin/skxmac2.c uboot-1.1.2hsv/drivers/sk98lin/skxmac2.c
--- u-boot-1.1.2/drivers/sk98lin/skxmac2.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/skxmac2.c	2007-05-29 16:51:24.000000000 -0500
@@ -2,8 +2,8 @@
  *
  * Name:	skxmac2.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.91 $
- * Date:	$Date: 2003/02/05 15:09:34 $
+ * Version:	$Revision: 1.1.1.1 $
+ * Date:	$Date: 2005/02/05 03:15:31 $
  * Purpose:	Contains functions to initialize the MACs and PHYs
  *
  ******************************************************************************/
@@ -26,6 +26,9 @@
  * History:
  *
  *	$Log: skxmac2.c,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.91  2003/02/05 15:09:34  rschmidt
  *	Removed setting of 'Collision Test'-bit in SkGmInitPhyMarv().
  *	Disabled auto-update for speed, duplex and flow-control when
@@ -427,7 +430,7 @@
 
 /* local variables ************************************************************/
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skxmac2.c,v 1.91 2003/02/05 15:09:34 rschmidt Exp $ (C) SK ";
+	"@(#)$Id: skxmac2.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ (C) SK ";
 
 BCOM_HACK BcomRegA1Hack[] = {
  { 0x18, 0x0c20 }, { 0x17, 0x0012 }, { 0x15, 0x1104 }, { 0x17, 0x0013 },
diff -Naur u-boot-1.1.2/drivers/sk98lin/uboot_drv.c uboot-1.1.2hsv/drivers/sk98lin/uboot_drv.c
--- u-boot-1.1.2/drivers/sk98lin/uboot_drv.c	2003-10-15 18:53:54.000000000 -0500
+++ uboot-1.1.2hsv/drivers/sk98lin/uboot_drv.c	2007-05-29 16:51:24.000000000 -0500
@@ -76,18 +76,32 @@
 	return numdev;
 }
 
+#define	endtick(seconds) (get_ticks() + (uint64_t)(seconds) * get_tbclk())
 
 static int skge_init(struct eth_device *dev, bd_t * bis)
 {
 	int ret;
 	SK_AC * pAC = ((DEV_NET*)dev->priv)->pAC;
 	int i;
-
+#ifdef CONFIG_AVCT_SK98
+	uint64_t etime = endtick(5);
+#endif
+
+#ifdef CONFIG_AVCT_SK98
+	ret = ! SkGeOpen(dev);
+#else
 	ret = SkGeOpen(dev);
+#endif
 
 	while (pAC->Rlmt.Port[0].PortState != SK_RLMT_PS_GOING_UP)
 	{
 		SkGeIsrOnePort (0, pAC->dev[0], 0);
+#ifdef CONFIG_AVCT_SK98
+    if ( get_ticks() >= etime )
+    {
+      return 0; /* Fail */
+    }
+#endif
 	}
 
 	for (i = 0; i < 100; i ++)
diff -Naur u-boot-1.1.2/examples/eepro100_eeprom.c uboot-1.1.2hsv/examples/eepro100_eeprom.c
--- u-boot-1.1.2/examples/eepro100_eeprom.c	2003-07-24 18:39:08.000000000 -0500
+++ uboot-1.1.2hsv/examples/eepro100_eeprom.c	2007-05-29 16:51:23.000000000 -0500
@@ -79,7 +79,10 @@
 static inline void *memcpy(void *dst, const void *src, unsigned int len)
 {
 	void * ret = dst;
-	while (len-- > 0) *((char *)dst)++ = *((char *)src)++;
+	char *d, *s;
+
+	d = dst; s = src;
+	while (len-- > 0) *d++ = *s++;
 	return ret;
 }
 
diff -Naur u-boot-1.1.2/examples/Makefile uboot-1.1.2hsv/examples/Makefile
--- u-boot-1.1.2/examples/Makefile	2004-10-10 16:27:33.000000000 -0500
+++ uboot-1.1.2hsv/examples/Makefile	2007-05-29 16:51:23.000000000 -0500
@@ -85,6 +85,11 @@
 SREC   += eepro100_eeprom.srec
 BIN    += eepro100_eeprom.bin eepro100_eeprom
 endif
+ifeq ($(BOARD),debmax)
+SREC   += eepro100_eeprom.srec
+BIN    += eepro100_eeprom.bin eepro100_eeprom
+endif
+
 
 ifeq ($(BIG_ENDIAN),y)
 EX_LDFLAGS += -EB
diff -Naur u-boot-1.1.2/fs/fat/fat.c uboot-1.1.2hsv/fs/fat/fat.c
--- u-boot-1.1.2/fs/fat/fat.c	2004-12-16 11:57:26.000000000 -0600
+++ uboot-1.1.2hsv/fs/fat/fat.c	2007-05-29 16:50:55.000000000 -0500
@@ -890,6 +890,12 @@
 		dentptr++;
 		continue;
 	    }
+
+		if (!dols && *fnamecopy == '*') {
+			printf("reading %s\n", l_name);
+			goto rootdir_done;  /* We got a match */
+		}
+
 	    if (strcmp (fnamecopy, s_name) && strcmp (fnamecopy, l_name)) {
 		FAT_DPRINT ("RootMismatch: |%s|%s|\n", s_name, l_name);
 		dentptr++;
@@ -1005,7 +1011,8 @@
 long
 file_fat_read(const char *filename, void *buffer, unsigned long maxsize)
 {
-	printf("reading %s\n",filename);
+	if (*filename != '*')
+		printf("reading %s\n",filename);
 	return do_fat_read(filename, buffer, maxsize, LS_NO);
 }
 
diff -Naur u-boot-1.1.2/fs/jffs2/compr_rtime.c uboot-1.1.2hsv/fs/jffs2/compr_rtime.c
--- u-boot-1.1.2/fs/jffs2/compr_rtime.c	2002-11-02 18:54:07.000000000 -0600
+++ uboot-1.1.2hsv/fs/jffs2/compr_rtime.c	2007-05-29 16:50:55.000000000 -0500
@@ -31,7 +31,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: compr_rtime.c,v 1.2 2002/01/24 22:58:42 rfeany Exp $
+ * $Id: compr_rtime.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  *
  * Very simple lz77-ish encoder.
diff -Naur u-boot-1.1.2/fs/jffs2/compr_rubin.c uboot-1.1.2hsv/fs/jffs2/compr_rubin.c
--- u-boot-1.1.2/fs/jffs2/compr_rubin.c	2002-11-02 18:54:17.000000000 -0600
+++ uboot-1.1.2hsv/fs/jffs2/compr_rubin.c	2007-05-29 16:50:55.000000000 -0500
@@ -34,7 +34,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: compr_rubin.c,v 1.2 2002/01/24 22:58:42 rfeany Exp $
+ * $Id: compr_rubin.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  */
 
@@ -86,7 +86,9 @@
 				rec_q |= (temp >> (bit++ ^ 7)) & 1;
 				if (bit > 31) {
 					bit = 0;
-					temp = *(++((u32 *) in));
+//Amazon fix					temp = *(++((u32 *) in));
+					temp = *((u32 *) in);
+          in += sizeof( u32 );
 				}
 			}
 			i0 =  (bits[i] * p) >> 8;
diff -Naur u-boot-1.1.2/fs/jffs2/compr_zlib.c uboot-1.1.2hsv/fs/jffs2/compr_zlib.c
--- u-boot-1.1.2/fs/jffs2/compr_zlib.c	2002-11-02 18:54:18.000000000 -0600
+++ uboot-1.1.2hsv/fs/jffs2/compr_zlib.c	2007-05-29 16:50:55.000000000 -0500
@@ -31,7 +31,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: compr_zlib.c,v 1.2 2002/01/24 22:58:42 rfeany Exp $
+ * $Id: compr_zlib.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  */
 
diff -Naur u-boot-1.1.2/fs/jffs2/jffs2_1pass.c uboot-1.1.2hsv/fs/jffs2/jffs2_1pass.c
--- u-boot-1.1.2/fs/jffs2/jffs2_1pass.c	2004-05-12 17:54:39.000000000 -0500
+++ uboot-1.1.2hsv/fs/jffs2/jffs2_1pass.c	2007-05-29 16:50:55.000000000 -0500
@@ -1,7 +1,7 @@
 /*
 -------------------------------------------------------------------------
  * Filename:      jffs2.c
- * Version:       $Id: jffs2_1pass.c,v 1.7 2002/01/25 01:56:47 nyet Exp $
+ * Version:       $Id: jffs2_1pass.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * Copyright:     Copyright (C) 2001, Russ Dill
  * Author:        Russ Dill <Russ.Dill@asu.edu>
  * Description:   Module to load kernel from jffs2
@@ -42,7 +42,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: jffs2_1pass.c,v 1.7 2002/01/25 01:56:47 nyet Exp $
+ * $Id: jffs2_1pass.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  */
 
diff -Naur u-boot-1.1.2/fs/jffs2/mini_inflate.c uboot-1.1.2hsv/fs/jffs2/mini_inflate.c
--- u-boot-1.1.2/fs/jffs2/mini_inflate.c	2002-03-08 17:11:41.000000000 -0600
+++ uboot-1.1.2hsv/fs/jffs2/mini_inflate.c	2007-05-29 16:50:55.000000000 -0500
@@ -1,6 +1,6 @@
 /*-------------------------------------------------------------------------
  * Filename:      mini_inflate.c
- * Version:       $Id: mini_inflate.c,v 1.3 2002/01/24 22:58:42 rfeany Exp $
+ * Version:       $Id: mini_inflate.c,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * Copyright:     Copyright (C) 2001, Russ Dill
  * Author:        Russ Dill <Russ.Dill@asu.edu>
  * Description:   Mini inflate implementation (RFC 1951)
diff -Naur u-boot-1.1.2/include/asm-arm/arch-pxa/mmc.h uboot-1.1.2hsv/include/asm-arm/arch-pxa/mmc.h
--- u-boot-1.1.2/include/asm-arm/arch-pxa/mmc.h	2003-06-27 16:32:42.000000000 -0500
+++ uboot-1.1.2hsv/include/asm-arm/arch-pxa/mmc.h	2007-05-29 16:50:56.000000000 -0500
@@ -4,7 +4,7 @@
  *  Author: Vladimir Shebordaev, Igor Oblakov
  *  Copyright:  MontaVista Software Inc.
  *
- *  $Id: mmc_pxa.h,v 0.3.1.6 2002/09/25 19:25:48 ted Exp ted $
+ *  $Id: mmc.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
diff -Naur u-boot-1.1.2/include/asm-mips/byteorder.h uboot-1.1.2hsv/include/asm-mips/byteorder.h
--- u-boot-1.1.2/include/asm-mips/byteorder.h	2003-02-27 18:49:48.000000000 -0600
+++ uboot-1.1.2hsv/include/asm-mips/byteorder.h	2007-05-29 16:50:55.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: byteorder.h,v 1.8 1998/11/02 09:29:32 ralf Exp $
+/* $Id: byteorder.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
diff -Naur u-boot-1.1.2/include/asm-mips/posix_types.h uboot-1.1.2hsv/include/asm-mips/posix_types.h
--- u-boot-1.1.2/include/asm-mips/posix_types.h	2003-06-27 16:32:43.000000000 -0500
+++ uboot-1.1.2hsv/include/asm-mips/posix_types.h	2007-05-29 16:50:56.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: posix_types.h,v 1.6 2000/02/04 23:32:54 ralf Exp $
+/* $Id: posix_types.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
diff -Naur u-boot-1.1.2/include/asm-mips/string.h uboot-1.1.2hsv/include/asm-mips/string.h
--- u-boot-1.1.2/include/asm-mips/string.h	2003-06-27 16:32:43.000000000 -0500
+++ uboot-1.1.2hsv/include/asm-mips/string.h	2007-05-29 16:50:55.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: string.h,v 1.13 2000/02/19 14:12:14 harald Exp $
+/* $Id: string.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
diff -Naur u-boot-1.1.2/include/asm-mips/types.h uboot-1.1.2hsv/include/asm-mips/types.h
--- u-boot-1.1.2/include/asm-mips/types.h	2003-06-27 16:32:43.000000000 -0500
+++ uboot-1.1.2hsv/include/asm-mips/types.h	2007-05-29 16:50:55.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: types.h,v 1.3 1999/08/18 23:37:50 ralf Exp $
+/* $Id: types.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
diff -Naur u-boot-1.1.2/include/asm-ppc/byteorder.h uboot-1.1.2hsv/include/asm-ppc/byteorder.h
--- u-boot-1.1.2/include/asm-ppc/byteorder.h	2000-11-23 07:12:41.000000000 -0600
+++ uboot-1.1.2hsv/include/asm-ppc/byteorder.h	2007-05-29 16:50:58.000000000 -0500
@@ -2,6 +2,8 @@
 #define _PPC_BYTEORDER_H
 
 #include <asm/types.h>
+
+#define __attribute_const__
 
 #ifdef __GNUC__
 
@@ -39,7 +41,7 @@
 #  define __arch_swab16(x) ld_le16(&x)
 #  define __arch_swab32(x) ld_le32(&x)
 #else
-static __inline__ __const__ __u16 ___arch__swab16(__u16 value)
+static __inline__ __attribute_const__ __u16 ___arch__swab16(__u16 value)
 {
 	__u16 result;
 
@@ -49,7 +51,7 @@
 	return result;
 }
 
-static __inline__ __const__ __u32 ___arch__swab32(__u32 value)
+static __inline__ __attribute_const__ __u32 ___arch__swab32(__u32 value)
 {
 	__u32 result;
 
diff -Naur u-boot-1.1.2/include/asm-ppc/cpm_85xx.h uboot-1.1.2hsv/include/asm-ppc/cpm_85xx.h
--- u-boot-1.1.2/include/asm-ppc/cpm_85xx.h	2003-10-15 18:53:56.000000000 -0500
+++ uboot-1.1.2hsv/include/asm-ppc/cpm_85xx.h	2007-05-29 16:50:58.000000000 -0500
@@ -822,4 +822,99 @@
 #define CMXSCR_TS4CS_CLK7  0x00000006   /* SCC4 Tx Clock Source is CLK7 */
 #define CMXSCR_TS4CS_CLK8  0x00000007   /* SCC4 Tx Clock Source is CLK8 */
 
+/* CPM Parallel IO Ports:
+ *   PA: 24 bits [8:31]
+ *   PB: 14 bits [18:31]
+ *   PC: 28 bits [0:31, NO: 2, 3, 30, 31]
+ *   PD: 16 bits [7, 14:25, 29:31]
+ *
+ * 16 bits in PC can be used for interrupt input pins:
+ *   PC[0:1, 4:15, 23, 29]
+ */
+#define CPM_PA_8           0x00800000
+#define CPM_PA_9           0x00400000
+#define CPM_PA_10          0x00200000
+#define CPM_PA_11          0x00100000
+#define CPM_PA_12          0x00080000
+#define CPM_PA_13          0x00040000
+#define CPM_PA_14          0x00020000
+#define CPM_PA_15          0x00010000
+#define CPM_PA_16          0x00008000
+#define CPM_PA_17          0x00004000
+#define CPM_PA_18          0x00002000
+#define CPM_PA_19          0x00001000
+#define CPM_PA_20          0x00000800
+#define CPM_PA_21          0x00000400
+#define CPM_PA_22          0x00000200
+#define CPM_PA_23          0x00000100
+#define CPM_PA_24          0x00000080
+#define CPM_PA_25          0x00000040
+#define CPM_PA_26          0x00000020
+#define CPM_PA_27          0x00000010
+#define CPM_PA_28          0x00000008
+#define CPM_PA_29          0x00000004
+#define CPM_PA_30          0x00000002
+#define CPM_PA_31          0x00000001
+
+#define CPM_PB_18          0x00002000
+#define CPM_PB_19          0x00001000
+#define CPM_PB_20          0x00000800
+#define CPM_PB_21          0x00000400
+#define CPM_PB_22          0x00000200
+#define CPM_PB_23          0x00000100
+#define CPM_PB_24          0x00000080
+#define CPM_PB_25          0x00000040
+#define CPM_PB_26          0x00000020
+#define CPM_PB_27          0x00000010
+#define CPM_PB_28          0x00000008
+#define CPM_PB_29          0x00000004
+#define CPM_PB_30          0x00000002
+#define CPM_PB_31          0x00000001
+
+#define CPM_PC_0           0x80000000
+#define CPM_PC_1           0x40000000
+#define CPM_PC_4           0x08000000
+#define CPM_PC_5           0x04000000
+#define CPM_PC_6           0x02000000
+#define CPM_PC_7           0x01000000
+#define CPM_PC_8           0x00800000
+#define CPM_PC_9           0x00400000
+#define CPM_PC_10          0x00200000
+#define CPM_PC_11          0x00100000
+#define CPM_PC_12          0x00080000
+#define CPM_PC_13          0x00040000
+#define CPM_PC_14          0x00020000
+#define CPM_PC_15          0x00010000
+#define CPM_PC_16          0x00008000
+#define CPM_PC_17          0x00004000
+#define CPM_PC_18          0x00002000
+#define CPM_PC_19          0x00001000
+#define CPM_PC_20          0x00000800
+#define CPM_PC_21          0x00000400
+#define CPM_PC_22          0x00000200
+#define CPM_PC_23          0x00000100
+#define CPM_PC_24          0x00000080
+#define CPM_PC_25          0x00000040
+#define CPM_PC_26          0x00000020
+#define CPM_PC_27          0x00000010
+#define CPM_PC_28          0x00000008
+#define CPM_PC_29          0x00000004
+
+#define CPM_PD_7           0x01000000
+#define CPM_PD_14          0x00020000
+#define CPM_PD_15          0x00010000
+#define CPM_PD_16          0x00008000
+#define CPM_PD_17          0x00004000
+#define CPM_PD_18          0x00002000
+#define CPM_PD_19          0x00001000
+#define CPM_PD_20          0x00000800
+#define CPM_PD_21          0x00000400
+#define CPM_PD_22          0x00000200
+#define CPM_PD_23          0x00000100
+#define CPM_PD_24          0x00000080
+#define CPM_PD_25          0x00000040
+#define CPM_PD_29          0x00000004
+#define CPM_PD_30          0x00000002
+#define CPM_PD_31          0x00000001
+
 #endif /* __CPM_85XX__ */
diff -Naur u-boot-1.1.2/include/asm-ppc/global_data.h uboot-1.1.2hsv/include/asm-ppc/global_data.h
--- u-boot-1.1.2/include/asm-ppc/global_data.h	2004-10-27 19:09:39.000000000 -0500
+++ uboot-1.1.2hsv/include/asm-ppc/global_data.h	2007-05-29 16:50:58.000000000 -0500
@@ -39,7 +39,11 @@
 	unsigned long	baudrate;
 	unsigned long	cpu_clk;	/* CPU clock in Hz!		*/
 	unsigned long	bus_clk;
-#if defined(CONFIG_8260) || defined(CONFIG_MPC8560)
+#if defined(CONFIG_KVMMAX) || defined(CONFIG_DEB) || defined(CONFIG_AMAZON)
+        unsigned long   pci1_clk;
+        unsigned long   pci2_clk;
+#endif
+#if defined(CONFIG_8260) || defined(CONFIG_MPC8560) || defined(CONFIG_MPC8555) || defined(CONFIG_MPC8541)
 	/* There are many clocks on the MPC8260 - see page 9-5 */
 	unsigned long	vco_out;
 	unsigned long	cpm_clk;
@@ -106,6 +110,13 @@
 #define	GD_FLG_DEVINIT	0x00002		/* Devices have been initialized	*/
 #define	GD_FLG_SILENT	0x00004		/* Silent mode				*/
 
+#if 1	/* fix for GCC 4.0 */
+
+#define DECLARE_GLOBAL_DATA_PTR     
+register gd_t *gd asm ("r29");
+
+#else 
+
 #if 1
 #define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r29")
 #else /* We could use plain global data, but the resulting code is bigger */
@@ -113,5 +124,6 @@
 #define DECLARE_GLOBAL_DATA_PTR     XTRN_DECLARE_GLOBAL_DATA_PTR \
 				    gd_t *gd
 #endif
+#endif	/* GCC 4.0 */
 
 #endif /* __ASM_GBL_DATA_H */
diff -Naur u-boot-1.1.2/include/asm-ppc/immap_85xx.h uboot-1.1.2hsv/include/asm-ppc/immap_85xx.h
--- u-boot-1.1.2/include/asm-ppc/immap_85xx.h	2004-10-10 16:21:57.000000000 -0500
+++ uboot-1.1.2hsv/include/asm-ppc/immap_85xx.h	2007-05-29 16:50:58.000000000 -0500
@@ -741,6 +741,8 @@
 	uint	frr;		/* 0x41000 - Feature Reporting Register */
 	char	res10[28];
 	uint	gcr;		/* 0x41020 - Global Configuration Register */
+#define MPC85xx_PICGCR_RST   0x80000000
+#define MPC85xx_PICGCR_M     0x20000000
 	char	res11[92];
 	uint	vir;		/* 0x41080 - Vendor Identification Register */
 	char	res12[12];
@@ -1022,10 +1024,12 @@
 	char	res150[130892];
 } ccsr_pic_t;
 
+/* cyclades: 8541 and 8555 both have CPM with some difference from 8560 */
 /* CPM Block(0x8_0000-0xc_0000) */
-#if defined(CONFIG_MPC8540) \
-	|| defined(CONFIG_MPC8541) \
-	|| defined(CONFIG_MPC8555)
+/* #if defined(CONFIG_MPC8540) \ */
+/* 	|| defined(CONFIG_MPC8541) \ */
+/* 	|| defined(CONFIG_MPC8555) */
+#if defined(CONFIG_MPC8540)
 typedef struct ccsr_cpm {
 	char res[262144];
 } ccsr_cpm_t;
diff -Naur u-boot-1.1.2/include/asm-ppc/u-boot.h uboot-1.1.2hsv/include/asm-ppc/u-boot.h
--- u-boot-1.1.2/include/asm-ppc/u-boot.h	2004-12-31 03:32:53.000000000 -0600
+++ uboot-1.1.2hsv/include/asm-ppc/u-boot.h	2007-05-29 16:50:58.000000000 -0500
@@ -59,7 +59,7 @@
 	unsigned short	bi_ethspeed;	/* Ethernet speed in Mbps */
 	unsigned long	bi_intfreq;	/* Internal Freq, in MHz */
 	unsigned long	bi_busfreq;	/* Bus Freq, in MHz */
-#if defined(CONFIG_8260) || defined(CONFIG_MPC8560)
+#if defined(CONFIG_8260) || defined(CONFIG_MPC8560) || defined(CONFIG_MPC8555) || defined(CONFIG_MPC8541)
 	unsigned long	bi_cpmfreq;	/* CPM_CLK Freq, in MHz */
 	unsigned long	bi_brgfreq;	/* BRG_CLK Freq, in MHz */
 	unsigned long	bi_sccfreq;	/* SCC_CLK Freq, in MHz */
@@ -82,6 +82,10 @@
 	unsigned int	bi_pci_busfreq;	/* PCI Bus speed, in Hz */
 	unsigned char	bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
 #endif
+#if defined(CONFIG_KVMMAX) || defined(CONFIG_DEB) || defined(CONFIG_AMAZON)
+        unsigned int    bi_pci1_busfreq; /* PCI1 freq */
+        unsigned int    bi_pci2_busfreq; /* PCI2 freq */
+#endif
 #if defined(CONFIG_HYMOD)
 	hymod_conf_t	bi_hymod_conf;	/* hymod configuration information */
 #endif
@@ -109,6 +113,19 @@
 	int 		bi_phynum[4];           /* Determines phy mapping */
 	int 		bi_phymode[4];          /* Determines phy mode */
 #endif
+#if defined(CONFIG_CYCLADES) || defined(CONFIG_AVOCENT)
+	unsigned char   wdt;
+	unsigned char   mii_operation[2];
+	unsigned char   board_type;
+	unsigned char	board_model;
+	unsigned char	pci;
+	unsigned char   fpga_version;
+	unsigned char   device_id[16];
+	unsigned char   board_ver_rev;
+#endif
+
+
+
 } bd_t;
 
 #endif /* __ASSEMBLY__ */
diff -Naur u-boot-1.1.2/include/bedbug/bedbug.h uboot-1.1.2hsv/include/bedbug/bedbug.h
--- u-boot-1.1.2/include/bedbug/bedbug.h	2002-03-08 15:31:10.000000000 -0600
+++ uboot-1.1.2hsv/include/bedbug/bedbug.h	2007-05-29 16:50:58.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id: bedbug.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 
 #ifndef _BEDBUG_H
 #define _BEDBUG_H
diff -Naur u-boot-1.1.2/include/bedbug/ppc.h uboot-1.1.2hsv/include/bedbug/ppc.h
--- u-boot-1.1.2/include/bedbug/ppc.h	2002-03-08 15:31:10.000000000 -0600
+++ uboot-1.1.2hsv/include/bedbug/ppc.h	2007-05-29 16:50:58.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id: ppc.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 
 #ifndef _PPC_H
 #define _PPC_H
diff -Naur u-boot-1.1.2/include/bedbug/regs.h uboot-1.1.2hsv/include/bedbug/regs.h
--- u-boot-1.1.2/include/bedbug/regs.h	2002-03-08 15:31:10.000000000 -0600
+++ uboot-1.1.2hsv/include/bedbug/regs.h	2007-05-29 16:50:58.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id: regs.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 
 #ifndef _REGS_H
 #define _REGS_H
diff -Naur u-boot-1.1.2/include/bedbug/tables.h uboot-1.1.2hsv/include/bedbug/tables.h
--- u-boot-1.1.2/include/bedbug/tables.h	2003-06-27 16:32:44.000000000 -0500
+++ uboot-1.1.2hsv/include/bedbug/tables.h	2007-05-29 16:50:58.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id: tables.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $ */
 
 #ifndef TABLES_H
 #define TABLES_H
diff -Naur u-boot-1.1.2/include/common.h uboot-1.1.2hsv/include/common.h
--- u-boot-1.1.2/include/common.h	2004-12-13 03:49:01.000000000 -0600
+++ uboot-1.1.2hsv/include/common.h	2007-05-29 16:51:02.000000000 -0500
@@ -176,6 +176,7 @@
 /* common/main.c */
 void	main_loop	(void);
 int	run_command	(const char *cmd, int flag);
+int	readline2	(const char *const prompt, const char *default_text);
 int	readline	(const char *const prompt);
 void	init_cmd_timeout(void);
 void	reset_cmd_timeout(void);
diff -Naur u-boot-1.1.2/include/configs/AMAZON.h uboot-1.1.2hsv/include/configs/AMAZON.h
--- u-boot-1.1.2/include/configs/AMAZON.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/configs/AMAZON.h	2007-05-29 16:51:01.000000000 -0500
@@ -0,0 +1,686 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * mpc8555cds board configuration file
+ *
+ * Please refer to doc/README.mpc85xxcds for more info.
+ *
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_RTC_M41T11 1
+#define CFG_I2C_RTC_ADDR 0x68
+#if 0
+#define CFG_M41T11_EXT_CENTURY_DATA
+#else
+#define CFG_M41T11_BASE_YEAR 2000
+#endif
+
+#define CONFIG_IDENT_STRING      " Amazon Version Not Set"
+
+/* cyclades: define CONFIG_BDI_SWITCH if using bdi2000 for debugging */
+#define CONFIG_BDI_SWITCH       1
+//FIXME #undef  CONFIG_BDI_SWITCH
+
+/* #define DEBUG */
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/60/55/41 */
+#define CONFIG_MPC8555		1	/* MPC8555 specific */
+
+#define CONFIG_AVOCENT		1       /* Avocent Corp. */
+#define CONFIG_AMAZON		1	/* Amazon family */
+
+#define CONFIG_PCI
+#define CONFIG_TSEC_ENET 		/* tsec ethernet support */
+#define CONFIG_SK98 			/* sk98lin ethernet support */
+#define CONFIG_AVCT_SK98 		/* Avocent mods to sk98lin ethernet support */
+#define CONFIG_AVCT_NEC_USB		/* Avocent mods to config NEC PCI device */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup*/
+
+/* cyclades: according to freescale FAE, we should turn off DDR DLL */
+#define CONFIG_DDR_DLL			/* possible DLL fix needed */
+#undef  CONFIG_DDR_DLL
+
+#define CONFIG_DDR_2T_TIMING		/* Sets the 2T timing bit */
+
+/*
+ * When initializing flash, if we cannot find the manufacturer ID,
+ * assume this is the AMD flash associated with the CDS board.
+ * This allows booting from a promjet.
+ */
+#define CONFIG_ASSUME_AMD_FLASH
+
+#define MPC85xx_DDR_SDRAM_CLK_CNTL	/* 85xx has clock control reg */
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_clock_freq(void);
+#endif
+#define CONFIG_SYS_CLK_FREQ	get_clock_freq() /* sysclk for MPC85xx */
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE		    	    /* toggle L2 cache 	*/
+#define CONFIG_BTB			    /* toggle branch predition */
+#define CONFIG_ADDR_STREAMING		    /* toggle addr streaming   */
+
+#define CONFIG_BOARD_EARLY_INIT_F	1	/* Call board_pre_init */
+#define CONFIG_BOARD_EARLY_INIT_R	1	/* Call board_pre_init in ram */
+#define CONFIG_MISC_INIT_R		1	/* call misc_init_r */
+#define CONFIG_LAST_STAGE_INIT 1
+
+#define	CFG_DRAM_TEST			/* memory test, takes time */
+#undef	CFG_DRAM_TEST			/* memory test, takes time */
+#define CFG_MEMTEST_START	0x00200000	/* memtest works on */
+#define CFG_MEMTEST_END		0x00400000
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CFG_CCSRBAR_DEFAULT 	0xff700000	/* CCSRBAR Default */
+#define CFG_CCSRBAR		0xe0000000	/* relocated CCSRBAR */
+#define CFG_IMMR		CFG_CCSRBAR	/* PQII uses CFG_IMMR */
+
+/*
+ * DDR Setup
+ */
+#define CFG_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory*/
+#define CFG_SDRAM_BASE		CFG_DDR_SDRAM_BASE
+
+/* cyclades: DDR SPD i2c addr: 0x50 */
+/* #define SPD_EEPROM_ADDRESS	0x51		/\* DDR DIMM *\/ */
+#define SPD_EEPROM_ADDRESS	0x50		/* DDR DIMM */
+
+/*
+ * Make sure required options are set
+ */
+#ifndef CONFIG_SPD_EEPROM
+/* cyclades: changed error output if no SPD_EEPROM */
+/* #error ("CONFIG_SPD_EEPROM is required by MPC85555CDS") */
+#error ("CONFIG_SPD_EEPROM is required by DEBV1")
+#endif
+
+/*
+ * SDRAM on the Local Bus
+ */
+
+/* avocent : only 8M FLASH on board from 0xff80_0000 to 0xffff_ffff */
+//#define CFG_FLASH_BASE		0xFF800000	/* start of FLASH 8M */
+#define CFG_FLASH_BASE		0xFF000000	/* start of FLASH 16M */
+
+
+/*
+  cyclades: BR0 for boot flash, see 13.3.1.1
+   BR0 register setup (1111_1111_1000_0000_0001_0000_0000_0001), Base Register
+   BR0[0-16]: Base address:	1111_1111_1000_0000_0 (0xFF80:0000)
+   BR0[17-18]: Reserved		00
+   BR0[19-20]: Port Size:   	1_0 (16-bit from configuration pullup-pulldown)
+   BR0[21-22]: DECC:		00 (no error checking)
+   BR0[23]:    WP		0 (Read/Write enabled)
+   BR0[24-26]: MSEL		_000 (GPCM select)
+   BR0[27]:    Reserved		0
+   BR0[28-29]: Atomic		_00 (no atomic operation)
+   BR0[30]:reserved		0
+   BR0[31]: Valid		1 (Valid chipselect)
+
+    */
+#define CFG_BR0_PRELIM		0xFF001001	/* port size 16bit */
+
+/*
+  cyclades: set OR0 according to flash's parameters, see 13.3.1.2.2, GPCM
+   OR0 register (1111_1111_1000_0000_0110_1101_0010_0110), Option Register
+   OR0[0-16]:  Addr. Mask	1111_1111_1000_0000_0 (8MB)
+   OR0[17-18]: Reserved		11 (set to 11, not 00. see 13.3.1.2.1)
+   OR0[19]:    BCTLD 		0  (Buffer Control enabled)
+   OR0[20]:    CSNT		_1 (chip sel negate earlier,see LCRR[CLKDIV])
+   OR0[21-22]: ACS		10 (LCS0 a qtr bus clk cycle, see LCRR[CLKDIV])
+   OR0[23]:    XACS		1 (addr chip-sel setup is extended)
+   OR0[24-27]: SCY		_0010 (2 bus clocks wait states)
+   OR0[28]:    SETA		_0 (access terminated internally)
+   OR0[29]:    TRLX		1 (relax timing)
+   OR0[30]:    ETHR		1 (8 idle clk for read, see TRLX)
+   OR0[31]:    EAD		0 (no extra clk added)
+
+   */
+#define	CFG_OR0_PRELIM		0xFF006d26	/* 16MB Flash */
+
+#define CFG_FLASH_BANKS_LIST    {CFG_FLASH_BASE}
+
+#define CFG_MAX_FLASH_BANKS     1
+
+#define CFG_FLASH_PROTECTION  /* device lockouts */
+
+
+/* Amazon uses 28F128P30B85 16MB = 128 sectoros x 128KB */
+
+#define CFG_MAX_FLASH_SECT	(127+4)   /* sectors per device */
+#undef	CFG_FLASH_CHECKSUM
+#define CFG_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CFG_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CFG_MONITOR_BASE    	TEXT_BASE	/* start of monitor */
+
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_EMPTY_INFO
+
+#undef CONFIG_CLOCKS_IN_MHZ
+
+
+/* LBC chip select registers BRx */ 
+#define CFG_LBC_BA(adr)         ((adr) & 0xFFFF8000)
+#define CFG_LBC_PS(x)           (((x) & 0x03) << 11)
+#define CFG_LBC_DECC(x)         (((x) & 0x03) <<  9)
+#define CFG_LBC_WP(x)           (((x) & 0x01) <<  8)
+#define CFG_LBC_MSEL(x)         (((x) & 0x07) <<  5)
+#define CFG_LBC_ATOM(x)         (((x) & 0x03) <<  2)
+#define CFG_LBC_V(x)            (((x) & 0x01) <<  0)
+
+
+/* LBC chip select registers ORx */ 
+#define CFG_LBC_AM(msk)         ((msk) & 0xFFFF8000)
+#define CFG_LBC_BCTLD(x)        (((x) & 0x01) << 12)
+#define CFG_LBC_CSNT(x)         (((x) & 0x01) << 11)
+#define CFG_LBC_ACS(x)          (((x) & 0x03) <<  9)
+#define CFG_LBC_XACS(x)         (((x) & 0x01) <<  8)
+#define CFG_LBC_SCY(x)          (((x) & 0x0F) <<  4)
+#define CFG_LBC_SETA(x)         (((x) & 0x01) <<  3)
+#define CFG_LBC_TRLX(x)         (((x) & 0x01) <<  2)
+#define CFG_LBC_EHTR(x)         (((x) & 0x01) <<  1)
+#define CFG_LBC_EAD(x)          (((x) & 0x01) <<  0)
+
+/* Config LBC Chip select 5 */
+
+#define CFG_BR5_PRELIM      CFG_LBC_BA(0xCA000000) | \
+                            CFG_LBC_PS(3)          | \
+                            CFG_LBC_DECC(0)        | \
+                            CFG_LBC_WP(0)          | \
+                            CFG_LBC_MSEL(0)        | \
+                            CFG_LBC_ATOM(0)        | \
+                            CFG_LBC_V(1)
+
+#define CFG_OR5_PRELIM      CFG_LBC_AM(0xFFFF8000) | \
+                            CFG_LBC_BCTLD(0)       | \
+                            CFG_LBC_CSNT(0)        | \
+                            CFG_LBC_ACS(2)         | \
+                            CFG_LBC_XACS(0)        | \
+                            CFG_LBC_SCY(1)         | \
+                            CFG_LBC_SETA(0)        | \
+                            CFG_LBC_TRLX(0)        | \
+                            CFG_LBC_EHTR(0)        | \
+                            CFG_LBC_EAD(0)  
+
+/* Config LBC Chip select 6 */
+
+#define CFG_BR6_PRELIM      CFG_LBC_BA(0xCC000000) | \
+                            CFG_LBC_PS(3)          | \
+                            CFG_LBC_DECC(0)        | \
+                            CFG_LBC_WP(0)          | \
+                            CFG_LBC_MSEL(0)        | \
+                            CFG_LBC_ATOM(0)        | \
+                            CFG_LBC_V(1)
+
+#define CFG_OR6_PRELIM      CFG_LBC_AM(0xFFC00000) | \
+                            CFG_LBC_BCTLD(0)       | \
+                            CFG_LBC_CSNT(0)        | \
+                            CFG_LBC_ACS(2)         | \
+                            CFG_LBC_XACS(0)        | \
+                            CFG_LBC_SCY(1)         | \
+                            CFG_LBC_SETA(0)        | \
+                            CFG_LBC_TRLX(0)        | \
+                            CFG_LBC_EHTR(0)        | \
+                            CFG_LBC_EAD(0)  
+
+/* Config LBC Chip select 7 */
+
+#define CFG_BR7_PRELIM      CFG_LBC_BA(0xCE000000) | \
+                            CFG_LBC_PS(3)          | \
+                            CFG_LBC_DECC(0)        | \
+                            CFG_LBC_WP(0)          | \
+                            CFG_LBC_MSEL(0)        | \
+                            CFG_LBC_ATOM(0)        | \
+                            CFG_LBC_V(1)
+
+#define CFG_OR7_PRELIM      CFG_LBC_AM(0xFE000000) | \
+                            CFG_LBC_BCTLD(0)       | \
+                            CFG_LBC_CSNT(0)        | \
+                            CFG_LBC_ACS(0)         | \
+                            CFG_LBC_XACS(0)        | \
+                            CFG_LBC_SCY(0)         | \
+                            CFG_LBC_SETA(1)        | \
+                            CFG_LBC_TRLX(0)        | \
+                            CFG_LBC_EHTR(0)        | \
+                            CFG_LBC_EAD(0)  
+/*
+ * Local Bus Definitions
+ */
+
+/* cyclades: we define localbus mem base addr */
+#define CFG_LBC_BASE            0xc0000000
+#define CFG_LBC_SIZE            0x10000000 /* 256MB */
+
+/*
+ * Base Register 2 and Option Register 2 configure SDRAM.
+ * The SDRAM base address, CFG_LBC_SDRAM_BASE, is 0xf0000000.
+ *
+ * For BR2, need:
+ *    Base address of 0xf0000000 = BR[0:16] = 1111 0000 0000 0000 0
+ *    port-size = 32-bits = BR2[19:20] = 11
+ *    no parity checking = BR2[21:22] = 00
+ *    SDRAM for MSEL = BR2[24:26] = 011
+ *    Valid = BR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 0000 0000 0000 0001 1000 0110 0001 = f0001861
+ *
+ * FIXME: CFG_LBC_SDRAM_BASE should be masked and OR'ed into
+ * FIXME: the top 17 bits of BR2.
+ */
+
+/* #define CFG_BR2_PRELIM          0xf0001861 */
+
+/*
+ * The SDRAM size in MB, CFG_LBC_SDRAM_SIZE, is 64.
+ *
+ * For OR2, need:
+ *    64MB mask for AM, OR2[0:7] = 1111 1100
+ *		   XAM, OR2[17:18] = 11
+ *    9 columns OR2[19-21] = 010
+ *    13 rows   OR2[23-25] = 100
+ *    EAD set for extra time OR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1100 0000 0000 0110 1001 0000 0001 = fc006901
+ */
+
+/* #define CFG_OR2_PRELIM		0xfc006901 */
+
+#define CFG_LBC_LCRR		0x80010008    /* LB clock ratio reg */
+
+#define CFG_LBC_LBCR		0x00000000    /* LB config reg */
+#define CFG_LBC_LSRT		0x20000000  /* LB sdram refresh timer */
+#define CFG_LBC_MRTPR		0x00000000  /* LB refresh timer prescal*/
+
+/*
+ * LSDMR masks
+ */
+#define CFG_LBC_LSDMR_RFEN	(1 << (31 -  1))
+#define CFG_LBC_LSDMR_BSMA1516	(3 << (31 - 10))
+#define CFG_LBC_LSDMR_BSMA1617	(4 << (31 - 10))
+#define CFG_LBC_LSDMR_RFCR16	(7 << (31 - 16))
+#define CFG_LBC_LSDMR_PRETOACT7	(7 << (31 - 19))
+#define CFG_LBC_LSDMR_ACTTORW7	(7 << (31 - 22))
+#define CFG_LBC_LSDMR_ACTTORW6	(6 << (31 - 22))
+#define CFG_LBC_LSDMR_BL8	(1 << (31 - 23))
+#define CFG_LBC_LSDMR_WRC4	(0 << (31 - 27))
+#define CFG_LBC_LSDMR_CL3	(3 << (31 - 31))
+
+#define CFG_LBC_LSDMR_OP_NORMAL	(0 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_ARFRSH	(1 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_SRFRSH	(2 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_MRW	(3 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_PRECH	(4 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_PCHALL	(5 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_ACTBNK	(6 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_RWINV	(7 << (31 - 4))
+
+/*
+ * Common settings for all Local Bus SDRAM commands.
+ * At run time, either BSMA1516 (for CPU 1.1)
+ *                  or BSMA1617 (for CPU 1.0) (old)
+ * is OR'ed in too.
+ */
+#define CFG_LBC_LSDMR_COMMON	( CFG_LBC_LSDMR_RFCR16		\
+				| CFG_LBC_LSDMR_PRETOACT7	\
+				| CFG_LBC_LSDMR_ACTTORW7	\
+				| CFG_LBC_LSDMR_BL8		\
+				| CFG_LBC_LSDMR_WRC4		\
+				| CFG_LBC_LSDMR_CL3		\
+				| CFG_LBC_LSDMR_RFEN		\
+				)
+
+/*
+ * The CADMUS registers are connected to CS3 on CDS.
+ * The new memory map places CADMUS at 0xf8000000.
+ *
+ * For BR3, need:
+ *    Base address of 0xf8000000 = BR[0:16] = 1111 1000 0000 0000 0
+ *    port-size = 8-bits  = BR[19:20] = 01
+ *    no parity checking  = BR[21:22] = 00
+ *    GPMC for MSEL       = BR[24:26] = 000
+ *    Valid               = BR[31]    = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1000 0000 0000 0000 1000 0000 0001 = f8000801
+ *
+ * For OR3, need:
+ *    1 MB mask for AM,   OR[0:16]  = 1111 1111 1111 0000 0
+ *    disable buffer ctrl OR[19]    = 0
+ *    CSNT                OR[20]    = 1
+ *    ACS                 OR[21:22] = 11
+ *    XACS                OR[23]    = 1
+ *    SCY 15 wait states  OR[24:27] = 1111	max is suboptimal but safe
+ *    SETA                OR[28]    = 0
+ *    TRLX                OR[29]    = 1
+ *    EHTR                OR[30]    = 1
+ *    EAD extra time      OR[31]    = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1111 1111 0000 0000 1111 1111 0111 = fff00ff7
+ */
+
+/* #define CADMUS_BASE_ADDR 0xf8000000 */
+/* #define CFG_BR3_PRELIM   0xf8000801 */
+/* #define CFG_OR3_PRELIM   0xfff00ff7 */
+
+#define CONFIG_L1_INIT_RAM
+#define CFG_INIT_RAM_LOCK 	1
+#define CFG_INIT_RAM_ADDR	0xe4010000	/* Initial RAM address */
+#define CFG_INIT_RAM_END    	0x4000	    /* End of used area in RAM */
+
+#define CFG_GBL_DATA_SIZE  	128	    /* num bytes initial data */
+#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+#define CFG_MONITOR_LEN	    	(512 * 1024)        /* Reserve 512 kB for Mon */
+#define CFG_MALLOC_LEN	    	(4 * (1024 * 1024)) /* Reserve 4 MB for malloc */
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX     1
+#undef	CONFIG_SERIAL_SOFTWARE_FIFO
+#define CFG_NS16550
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE    1
+#define CFG_NS16550_CLK		get_bus_freq(0)
+
+#define CFG_BAUDRATE_TABLE  \
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
+
+#define CFG_NS16550_COM1        (CFG_CCSRBAR+0x4500)
+#define CFG_NS16550_COM2        (CFG_CCSRBAR+0x4600)
+
+#define CFG_AUTO_COMPLETE   /* use TAB to complete */
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+#ifdef  CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif
+
+/* I2C */
+#define CONFIG_HARD_I2C			/* I2C with hardware support */
+#undef	CONFIG_SOFT_I2C			/* I2C bit-banged */
+#define CFG_I2C_SPEED		400000	/* I2C speed and slave address */
+
+/* #define CFG_I2C_EEPROM_ADDR	0x57 */
+#define CFG_I2C_EEPROM_ADDR	0xa3
+#define CFG_I2C_SLAVE		0x7F
+#define CFG_I2C_NOPROBES        {0x69}	/* Don't probe these addrs */
+
+/*
+ * General PCI
+ * Addresses are mapped 1-1.
+ */
+#define CFG_PCI1_MEM_BASE	0x80000000
+#define CFG_PCI1_MEM_PHYS	CFG_PCI1_MEM_BASE
+#define CFG_PCI1_MEM_SIZE	0x20000000	/* 512M */
+#define CFG_PCI1_IO_BASE	0xe2000000
+#define CFG_PCI1_IO_PHYS	CFG_PCI1_IO_BASE
+#define CFG_PCI1_IO_SIZE	0x1000000	/* 16M */
+
+#define CFG_PCI2_MEM_BASE	0xa0000000
+#define CFG_PCI2_MEM_PHYS	CFG_PCI2_MEM_BASE
+#define CFG_PCI2_MEM_SIZE	0x20000000	/* 512M */
+#define CFG_PCI2_IO_BASE	0xe3000000
+#define CFG_PCI2_IO_PHYS	CFG_PCI2_IO_BASE
+#define CFG_PCI2_IO_SIZE	0x1000000	/* 16M */
+
+
+#if defined(CONFIG_PCI)
+
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP	               	/* do pci plug-and-play */
+
+/* #define CONFIG_EEPRO100 */
+#undef CONFIG_TULIP
+#undef CONFIG_NATSEMI
+
+#if !defined(CONFIG_PCI_PNP)
+    #define PCI_ENET0_IOADDR      0xe0000000
+    #define PCI_ENET0_MEMADDR     0xe0000000
+    #define PCI_IDSEL_NUMBER      0x0c 	/*slot0->3(IDSEL)=12->15*/
+#endif
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CFG_PCI_SUBSYS_VENDORID 0x1057  /* Motorola */
+
+#endif	/* CONFIG_PCI */
+
+
+#if defined(CONFIG_TSEC_ENET)
+
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI 	1
+#endif
+
+#define CONFIG_MII		1	            /* MII PHY management */
+#define CONFIG_MPC85XX_TSEC1  1
+#define CONFIG_MPC85XX_TSEC2	1
+#undef  CONFIG_MPC85XX_FEC
+                                    /* MUST config TSEC1 even if unused in order for MV88E6095 PHY communication to work */
+#define TSEC1_PHY_ADDR		0x0008    /* MV88E3015 Phy address is 8 */ 
+#define TSEC2_PHY_ADDR		0xc800    /* Fake PHY, link up, full duplex, 1000mbps see cpu/mpc85xx/tsec.h */
+#define FEC_PHY_ADDR		  0
+
+#ifdef CONFIG_MPC85XX_TSEC2
+#define CONFIG_MV88E6095        1 
+  #define DEBUG_QD  /* DHS FIXME later */
+#endif
+
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+#define FEC_PHYIDX		0
+//#define CONFIG_ETHPRIME		"MOTO ENET0"
+#define CONFIG_ETHPRIME		"SK98#0"  /* Marvel PCI MacPhy */
+
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Environment
+ */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	0x20000	/* 128K(one sector) for env */
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE - CFG_ENV_SECT_SIZE)
+#define CFG_ENV_SIZE		0x2000
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+#if defined(CONFIG_PCI)
+#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL \
+				| CFG_CMD_PCI \
+				| CFG_CMD_PING \
+				| CFG_CMD_I2C \
+				| CFG_CMD_IDE \
+				| CFG_CMD_FAT \
+        | CFG_CMD_DATE \
+        | CFG_CMD_LEDS \
+        | CFG_CMD_JFFS2 \
+				| CFG_CMD_MII)
+#else
+#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL \
+				| CFG_CMD_PING \
+				| CFG_CMD_I2C \
+				| CFG_CMD_IDE \
+				| CFG_CMD_FAT \
+        | CFG_CMD_DATE \
+        | CFG_CMD_LEDS \
+        | CFG_CMD_JFFS2 \
+				| CFG_CMD_MII)
+#endif
+#include <cmd_confdefs.h>
+
+/* JFFS2 location when using NOR flash */
+#define CFG_JFFS2_BASE	(CFG_FLASH_BASE + 0x0000)
+#define CFG_JFFS2_SIZE	(0xF60000)      /* 16M - 655360 (16M - (u-boot + env)) */
+
+#define CFG_JFFS2_FIRST_BANK    0           /* use for JFFS2 */
+#define CFG_JFFS2_NUM_BANKS     1           /* ! second bank contains u-boot    */
+
+#define CONFIG_DOS_PARTITION
+
+#define CONFIG_WATCHDOG		1	/* watchdog enabled */
+#undef CONFIG_WATCHDOG			/* DHS FIXME */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP			/* undef to save memory	*/
+#define CFG_LOAD_ADDR	0x2000000	/* default load address */
+#define CFG_PROMPT	"=> "		/* Monitor Command Prompt */
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CFG_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS	16		/* max number of command args */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size */
+#define CFG_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ	(8 << 20) 	/* Initial Memory map for Linux*/
+
+/* Cache Configuration */
+#define CFG_DCACHE_SIZE	32768
+#define CFG_CACHELINE_SIZE	32
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CACHELINE_SHIFT	5	/*log base 2 of the above value*/
+#endif
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02		/* Software reboot */
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+/* The mac addresses for all ethernet interface */
+#if defined(CONFIG_TSEC_ENET)
+
+#define CONFIG_ETHADDR   00:E0:86:02:00:00
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR  00:E0:86:02:00:01
+#define CONFIG_HAS_ETH2
+#define CONFIG_ETH2ADDR  00:E0:86:02:00:02
+#define CONFIG_HAS_ETH3
+#define CONFIG_ETH3ADDR  00:E0:86:02:00:03
+#endif
+
+#define CONFIG_IPADDR    10.10.10.10
+
+#define CONFIG_BOOTFILE  uImage.amazon.initrd.factory
+
+#define CONFIG_SERVERIP  10.10.10.1
+//#define CONFIG_GATEWAYIP 172.31.1.254
+#define CONFIG_NETMASK   255.255.0.0
+
+#define CONFIG_LOADADDR  1000000   /*default location for tftp and bootm*/
+
+#define CONFIG_BOOTDELAY 3       /* -1 disables auto-boot */
+
+#define CONFIG_BOOTARGS_NFS     "root=/dev/nfs/ rw ip=on"
+#define CONFIG_BOOTARGS_FLASH   "root=/dev/mtdblock0 rw rootfstype=jffs2"
+#define CONFIG_BOOTARGS         "root=/dev/ram0 rw ramdisk_size=100000"
+
+#define CONFIG_LOADADDR_DEF     "0x01000000"
+
+#define CONFIG_BAUDRATE	9600
+
+/* cyclades: change ramdiskfile */
+/* #define	CONFIG_EXTRA_ENV_SETTINGS				        \ */
+/*    "netdev=eth0\0"                                                      \ */
+/*    "consoledev=ttyS0\0"                                                 \ */
+/*    "ramdiskaddr=400000\0"                                               \ */
+/*    "ramdiskfile=rd.yang\0" */
+
+/* cyclades: No need for nfsboot */
+/* cyclades: change nfs boot cmd */
+/* #define CONFIG_NFSBOOTCOMMAND	                                        \ */
+/*    "setenv bootargs root=/dev/nfs rw "                                  \ */
+/*       "nfsroot=$serverip:$rootpath "                                    \ */
+/*       "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \ */
+/*       "console=$consoledev,$baudrate $othbootargs;"                     \ */
+/*    "tftp $loadaddr $bootfile;"                                          \ */
+/*    "bootm $loadaddr" */
+
+/* cyclades: No need for ramboot */
+/* cyclades: change ram boot cmd */
+/* #define CONFIG_RAMBOOTCOMMAND \ */
+/*    "setenv bootargs root=/dev/ram rw "                                  \ */
+/*       "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \ */
+/*       "console=$consoledev,$baudrate $othbootargs;"                     \ */
+/*    "tftp $ramdiskaddr $ramdiskfile;"                                    \ */
+/*    "tftp $loadaddr $bootfile;"                                          \ */
+/*    "bootm $loadaddr $ramdiskaddr" */
+
+#define CONFIG_BOOTCOMMAND  "tftpboot; bootm"
+
+/* cyclades: IDE/ATA stuffs copied from kvmnetv2 */
+/* put them into include/cyc_ide_cfg.h to help DEB and KVMMAX */
+// #include <cyc_ide_cfg.h>
+
+#if 1 
+#define CFG_ATA_BASE_ADDR     0xe3000000
+
+#define CFG_IDE_MAXBUS		2	/* max. 1 IDE busses	*/
+#define CFG_IDE_MAXDEVICE	CFG_IDE_MAXBUS /* max. 1 drive per IDE bus */
+
+#define CFG_ATA_DATA_OFFSET	0
+#define	CFG_ATA_REG_OFFSET	1
+#define	CFG_ATA_ALT_OFFSET	0x11
+#define CFG_ATA_IDE0_OFFSET	0x0000
+#endif
+
+#endif	/* __CONFIG_H */
diff -Naur u-boot-1.1.2/include/configs/DB64360.h uboot-1.1.2hsv/include/configs/DB64360.h
--- u-boot-1.1.2/include/configs/DB64360.h	2004-12-31 03:32:53.000000000 -0600
+++ uboot-1.1.2hsv/include/configs/DB64360.h	2007-05-29 16:51:01.000000000 -0500
@@ -29,7 +29,7 @@
  * (c) 2002 Datentechnik AG - Project: Dino
  *
  *
- * $Id: DB64360.h,v 1.3 2003/04/26 04:58:13 brad Exp $
+ * $Id: DB64360.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  *
   ************************************************************************/
 
@@ -38,6 +38,9 @@
  * History:
  *
  *	$Log: DB64360.h,v $
+ *	Revision 1.1.1.1  2005/02/05 03:15:31  yang
+ *	u-boot-1.1.2 src tree
+ *	
  *	Revision 1.3  2003/04/26 04:58:13  brad
  *	Cosmetic changes and compiler warning cleanups
  *
diff -Naur u-boot-1.1.2/include/configs/DEBV1.h uboot-1.1.2hsv/include/configs/DEBV1.h
--- u-boot-1.1.2/include/configs/DEBV1.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/configs/DEBV1.h	2007-05-29 16:51:01.000000000 -0500
@@ -0,0 +1,630 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * mpc8555cds board configuration file
+ *
+ * Please refer to doc/README.mpc85xxcds for more info.
+ *
+ */
+
+/*
+ * debv1 board configuration file
+ *
+ * modified by Yang Yang, Cyclades Corp.
+ * 2/7/05
+ *
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* cyclades: define CONFIG_BDI_SWITCH if using bdi2000 for debugging */
+#define CONFIG_BDI_SWITCH       1
+#undef  CONFIG_BDI_SWITCH
+
+/* #define DEBUG */
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/60/55/41 */
+#define CONFIG_MPC8555		1	/* MPC8555 specific */
+/* cyclades: board name is DEBV1 */
+#define CONFIG_CYCLADES         1       /* Cyclades Corp. */
+#define CONFIG_DEB              1       /* DEB family */
+#define CONFIG_DEBV1            1       /* DEBV1 board specific */
+/* cyclades: DEBV1_REV1 is for the 2nd HW spin */
+/* cyclades: HW revision is autodetected by code now. */
+/* #define CONFIG_DEBV1_REV1       1       /\* DEBV1 board Rev specific *\/ */
+
+/* cyclades: this 24P setting only affect 1st spin board, autodetecting it on 2nd spin */
+#define DEB_24_PORT
+
+#define CONFIG_PCI
+#define CONFIG_TSEC_ENET 		/* tsec ethernet support */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup*/
+/* cyclades: debv1 board use nonECC  */
+/* #define CONFIG_DDR_ECC			/\* only for ECC DDR module *\/ */
+
+/* cyclades: according to freescale FAE, we should turn off DDR DLL */
+#define CONFIG_DDR_DLL			/* possible DLL fix needed */
+#undef  CONFIG_DDR_DLL
+
+#define CONFIG_DDR_2T_TIMING		/* Sets the 2T timing bit */
+
+/*
+ * When initializing flash, if we cannot find the manufacturer ID,
+ * assume this is the AMD flash associated with the CDS board.
+ * This allows booting from a promjet.
+ */
+#define CONFIG_ASSUME_AMD_FLASH
+
+#define MPC85xx_DDR_SDRAM_CLK_CNTL	/* 85xx has clock control reg */
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_clock_freq(void);
+#endif
+#define CONFIG_SYS_CLK_FREQ	get_clock_freq() /* sysclk for MPC85xx */
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE		    	    /* toggle L2 cache 	*/
+#define CONFIG_BTB			    /* toggle branch predition */
+#define CONFIG_ADDR_STREAMING		    /* toggle addr streaming   */
+
+#define CONFIG_BOARD_EARLY_INIT_F	1	/* Call board_pre_init */
+#define CONFIG_BOARD_EARLY_INIT_R	1	/* Call board_pre_init in ram */
+#define CONFIG_MISC_INIT_R		1	/* call misc_init_r */
+
+#define	CFG_DRAM_TEST			/* memory test, takes time */
+#undef	CFG_DRAM_TEST			/* memory test, takes time */
+#define CFG_MEMTEST_START	0x00200000	/* memtest works on */
+#define CFG_MEMTEST_END		0x00400000
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CFG_CCSRBAR_DEFAULT 	0xff700000	/* CCSRBAR Default */
+#define CFG_CCSRBAR		0xe0000000	/* relocated CCSRBAR */
+#define CFG_IMMR		CFG_CCSRBAR	/* PQII uses CFG_IMMR */
+
+/*
+ * DDR Setup
+ */
+#define CFG_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory*/
+#define CFG_SDRAM_BASE		CFG_DDR_SDRAM_BASE
+
+/* cyclades: DDR SPD i2c addr: 0x50 */
+/* #define SPD_EEPROM_ADDRESS	0x51		/\* DDR DIMM *\/ */
+#define SPD_EEPROM_ADDRESS	0x50		/* DDR DIMM */
+
+/*
+ * Make sure required options are set
+ */
+#ifndef CONFIG_SPD_EEPROM
+/* cyclades: changed error output if no SPD_EEPROM */
+/* #error ("CONFIG_SPD_EEPROM is required by MPC85555CDS") */
+#error ("CONFIG_SPD_EEPROM is required by DEBV1")
+#endif
+
+/*
+ * SDRAM on the Local Bus
+ */
+/* cyclades: no SDRAM on Local Bus in debv1 board */
+/* #define CFG_LBC_SDRAM_BASE	0xf0000000	/\* Localbus SDRAM *\/ */
+/* #define CFG_LBC_SDRAM_SIZE	64		/\* LBC SDRAM is 64MB *\/ */
+
+/* cyclades: only 8M FLASH on board from 0xff80_0000 to 0xffff_ffff */
+/* #define CFG_FLASH_BASE		0xff000000	/\* start of FLASH 8M *\/ */
+#define CFG_FLASH_BASE          0xff800000
+
+/*
+  cyclades: BR0 for boot flash, see 13.3.1.1
+   BR0 register setup (1111_1111_1000_0000_0001_0000_0000_0001), Base Register
+   BR0[0-16]: Base address:	1111_1111_1000_0000_0 (0xFF80:0000)
+   BR0[17-18]: Reserved		00
+   BR0[19-20]: Port Size:   	1_0 (16-bit from configuration pullup-pulldown)
+   BR0[21-22]: DECC:		00 (no error checking)
+   BR0[23]:    WP		0 (Read/Write enabled)
+   BR0[24-26]: MSEL		_000 (GPCM select)
+   BR0[27]:    Reserved		0
+   BR0[28-29]: Atomic		_00 (no atomic operation)
+   BR0[30]:reserved		0
+   BR0[31]: Valid		1 (Valid chipselect)
+
+    */
+#define CFG_BR0_PRELIM		0xff801001	/* port size 16bit */
+
+/* cyclades: only one boot flash, so BR1/OR1 not used */
+/* #define CFG_BR1_PRELIM		0xff001001	/\* port size 16bit *\/ */
+
+/*
+  cyclades: set OR0 according to flash's parameters, see 13.3.1.2.2, GPCM
+   OR0 register (1111_1111_1000_0000_0110_1101_0010_0110), Option Register
+   OR0[0-16]:  Addr. Mask	1111_1111_1000_0000_0 (8MB)
+   OR0[17-18]: Reserved		11 (set to 11, not 00. see 13.3.1.2.1)
+   OR0[19]:    BCTLD 		0  (Buffer Control enabled)
+   OR0[20]:    CSNT		_1 (chip sel negate earlier,see LCRR[CLKDIV])
+   OR0[21-22]: ACS		10 (LCS0 a qtr bus clk cycle, see LCRR[CLKDIV])
+   OR0[23]:    XACS		1 (addr chip-sel setup is extended)
+   OR0[24-27]: SCY		_0010 (2 bus clocks wait states)
+   OR0[28]:    SETA		_0 (access terminated internally)
+   OR0[29]:    TRLX		1 (relax timing)
+   OR0[30]:    ETHR		1 (8 idle clk for read, see TRLX)
+   OR0[31]:    EAD		0 (no extra clk added)
+
+   */
+
+/* #define	CFG_OR0_PRELIM		0xff806e61	/\* 8MB Flash *\/ */
+#define	CFG_OR0_PRELIM		0xff806d26	/* 8MB Flash */
+
+/* cyclades: only one boot flash, so BR1/OR1 not used */
+/* #define	CFG_OR1_PRELIM		0xff806e61	/\* 8MB Flash *\/ */
+
+/* cyclades: only one bank */
+/* #define CFG_FLASH_BANKS_LIST	{0xff800000, CFG_FLASH_BASE} */
+#define CFG_FLASH_BANKS_LIST    {CFG_FLASH_BASE}
+
+/* #define CFG_MAX_FLASH_BANKS	2		/\* number of banks *\/ */
+#define CFG_MAX_FLASH_BANKS     1
+
+/* cyclades: consult to flash's Data Sheet */
+/* cyclades: use 28F640J3A : 8MB = 64 sectors x 128KB */
+/* #define CFG_MAX_FLASH_SECT	128		/\* sectors per device *\/ */
+#define CFG_MAX_FLASH_SECT	64		/* sectors per device */
+#undef	CFG_FLASH_CHECKSUM
+#define CFG_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CFG_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+/* cyclades: TEXT_BASE defined in board/debmax/config.mk, 0xfff80000 */
+#define CFG_MONITOR_BASE    	TEXT_BASE	/* start of monitor */
+
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_EMPTY_INFO
+
+#undef CONFIG_CLOCKS_IN_MHZ
+
+/*
+ * Local Bus Definitions
+ */
+
+/* cyclades: we define localbus mem base addr */
+#define CFG_LBC_BASE            0xc0000000
+#define CFG_LBC_SIZE            0x10000000 /* 256MB */
+
+/* cyclades: no SDRAM on debv1 board */
+/*
+ * Base Register 2 and Option Register 2 configure SDRAM.
+ * The SDRAM base address, CFG_LBC_SDRAM_BASE, is 0xf0000000.
+ *
+ * For BR2, need:
+ *    Base address of 0xf0000000 = BR[0:16] = 1111 0000 0000 0000 0
+ *    port-size = 32-bits = BR2[19:20] = 11
+ *    no parity checking = BR2[21:22] = 00
+ *    SDRAM for MSEL = BR2[24:26] = 011
+ *    Valid = BR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 0000 0000 0000 0001 1000 0110 0001 = f0001861
+ *
+ * FIXME: CFG_LBC_SDRAM_BASE should be masked and OR'ed into
+ * FIXME: the top 17 bits of BR2.
+ */
+
+/* #define CFG_BR2_PRELIM          0xf0001861 */
+
+/*
+ * The SDRAM size in MB, CFG_LBC_SDRAM_SIZE, is 64.
+ *
+ * For OR2, need:
+ *    64MB mask for AM, OR2[0:7] = 1111 1100
+ *		   XAM, OR2[17:18] = 11
+ *    9 columns OR2[19-21] = 010
+ *    13 rows   OR2[23-25] = 100
+ *    EAD set for extra time OR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1100 0000 0000 0110 1001 0000 0001 = fc006901
+ */
+
+/* #define CFG_OR2_PRELIM		0xfc006901 */
+
+/* cyclades: LBC some registers values are supplied here */
+
+/* cyclades: CFG_LBC_LCRR: CCB to LBC ratio is 266/33 = 8, 13.3.1.16 */
+/* #define CFG_LBC_LCRR		0x00030004    /\* LB clock ratio reg *\/ */
+#define CFG_LBC_LCRR		0x00030008    /* LB clock ratio reg */
+
+/* cyclades: CFG_LBC_LBCR etc. are used in sdram_init, so we don't use them. */
+#define CFG_LBC_LBCR		0x00000000    /* LB config reg */
+#define CFG_LBC_LSRT		0x20000000  /* LB sdram refresh timer */
+#define CFG_LBC_MRTPR		0x00000000  /* LB refresh timer prescal*/
+
+/*
+ * LSDMR masks
+ */
+#define CFG_LBC_LSDMR_RFEN	(1 << (31 -  1))
+#define CFG_LBC_LSDMR_BSMA1516	(3 << (31 - 10))
+#define CFG_LBC_LSDMR_BSMA1617	(4 << (31 - 10))
+#define CFG_LBC_LSDMR_RFCR16	(7 << (31 - 16))
+#define CFG_LBC_LSDMR_PRETOACT7	(7 << (31 - 19))
+#define CFG_LBC_LSDMR_ACTTORW7	(7 << (31 - 22))
+#define CFG_LBC_LSDMR_ACTTORW6	(6 << (31 - 22))
+#define CFG_LBC_LSDMR_BL8	(1 << (31 - 23))
+#define CFG_LBC_LSDMR_WRC4	(0 << (31 - 27))
+#define CFG_LBC_LSDMR_CL3	(3 << (31 - 31))
+
+#define CFG_LBC_LSDMR_OP_NORMAL	(0 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_ARFRSH	(1 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_SRFRSH	(2 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_MRW	(3 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_PRECH	(4 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_PCHALL	(5 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_ACTBNK	(6 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_RWINV	(7 << (31 - 4))
+
+/*
+ * Common settings for all Local Bus SDRAM commands.
+ * At run time, either BSMA1516 (for CPU 1.1)
+ *                  or BSMA1617 (for CPU 1.0) (old)
+ * is OR'ed in too.
+ */
+#define CFG_LBC_LSDMR_COMMON	( CFG_LBC_LSDMR_RFCR16		\
+				| CFG_LBC_LSDMR_PRETOACT7	\
+				| CFG_LBC_LSDMR_ACTTORW7	\
+				| CFG_LBC_LSDMR_BL8		\
+				| CFG_LBC_LSDMR_WRC4		\
+				| CFG_LBC_LSDMR_CL3		\
+				| CFG_LBC_LSDMR_RFEN		\
+				)
+
+/* cyclades: no CADMUS registers in debv1 board */
+/*
+ * The CADMUS registers are connected to CS3 on CDS.
+ * The new memory map places CADMUS at 0xf8000000.
+ *
+ * For BR3, need:
+ *    Base address of 0xf8000000 = BR[0:16] = 1111 1000 0000 0000 0
+ *    port-size = 8-bits  = BR[19:20] = 01
+ *    no parity checking  = BR[21:22] = 00
+ *    GPMC for MSEL       = BR[24:26] = 000
+ *    Valid               = BR[31]    = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1000 0000 0000 0000 1000 0000 0001 = f8000801
+ *
+ * For OR3, need:
+ *    1 MB mask for AM,   OR[0:16]  = 1111 1111 1111 0000 0
+ *    disable buffer ctrl OR[19]    = 0
+ *    CSNT                OR[20]    = 1
+ *    ACS                 OR[21:22] = 11
+ *    XACS                OR[23]    = 1
+ *    SCY 15 wait states  OR[24:27] = 1111	max is suboptimal but safe
+ *    SETA                OR[28]    = 0
+ *    TRLX                OR[29]    = 1
+ *    EHTR                OR[30]    = 1
+ *    EAD extra time      OR[31]    = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1111 1111 0000 0000 1111 1111 0111 = fff00ff7
+ */
+
+/* #define CADMUS_BASE_ADDR 0xf8000000 */
+/* #define CFG_BR3_PRELIM   0xf8000801 */
+/* #define CFG_OR3_PRELIM   0xfff00ff7 */
+
+#define CONFIG_L1_INIT_RAM
+#define CFG_INIT_RAM_LOCK 	1
+#define CFG_INIT_RAM_ADDR	0xe4010000	/* Initial RAM address */
+#define CFG_INIT_RAM_END    	0x4000	    /* End of used area in RAM */
+
+#define CFG_GBL_DATA_SIZE  	128	    /* num bytes initial data */
+#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+#define CFG_MONITOR_LEN	    	(512 * 1024) /* Reserve 512 kB for Mon */
+#define CFG_MALLOC_LEN	    	(128 * 1024)	/* Reserved for malloc */
+
+/* Serial Port */
+/* cyclades: use UART 1 as console, UART 2 as AUX */
+/* #define CONFIG_CONS_INDEX     2 */
+#define CONFIG_CONS_INDEX     1
+#undef	CONFIG_SERIAL_SOFTWARE_FIFO
+#define CFG_NS16550
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE    1
+#define CFG_NS16550_CLK		get_bus_freq(0)
+
+#define CFG_BAUDRATE_TABLE  \
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
+
+#define CFG_NS16550_COM1        (CFG_CCSRBAR+0x4500)
+#define CFG_NS16550_COM2        (CFG_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+#ifdef  CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif
+
+/* I2C */
+#define CONFIG_HARD_I2C			/* I2C with hardware support */
+#undef	CONFIG_SOFT_I2C			/* I2C bit-banged */
+/* cyclades: this i2c speed is not used in cpu/mpc85xx/i2c.c:i2c_init() */
+#define CFG_I2C_SPEED		400000	/* I2C speed and slave address */
+
+/* cyclades: what's these I2C addr?  */
+/* cyclades: DEB doesn't use EEPROM for CPU config */
+/* #define CFG_I2C_EEPROM_ADDR	0x57 */
+#define CFG_I2C_EEPROM_ADDR	0xa3
+#define CFG_I2C_SLAVE		0x7F
+#define CFG_I2C_NOPROBES        {0x69}	/* Don't probe these addrs */
+
+/*
+ * General PCI
+ * Addresses are mapped 1-1.
+ */
+#define CFG_PCI1_MEM_BASE	0x80000000
+#define CFG_PCI1_MEM_PHYS	CFG_PCI1_MEM_BASE
+#define CFG_PCI1_MEM_SIZE	0x20000000	/* 512M */
+#define CFG_PCI1_IO_BASE	0xe2000000
+#define CFG_PCI1_IO_PHYS	CFG_PCI1_IO_BASE
+#define CFG_PCI1_IO_SIZE	0x1000000	/* 16M */
+
+#define CFG_PCI2_MEM_BASE	0xa0000000
+#define CFG_PCI2_MEM_PHYS	CFG_PCI2_MEM_BASE
+#define CFG_PCI2_MEM_SIZE	0x20000000	/* 512M */
+#define CFG_PCI2_IO_BASE	0xe3000000
+#define CFG_PCI2_IO_PHYS	CFG_PCI2_IO_BASE
+#define CFG_PCI2_IO_SIZE	0x1000000	/* 16M */
+
+
+#if defined(CONFIG_PCI)
+
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP	               	/* do pci plug-and-play */
+
+/* cyclades: for DEB, we need to turn on CONFIG_EEPRO100 */
+/* cyclades: since DEB 2nd spin, we use NATSEMI's DP83816 to replace 82559ER */
+/* #define CONFIG_EEPRO100 */
+#undef CONFIG_TULIP
+#define CONFIG_NATSEMI
+
+#if !defined(CONFIG_PCI_PNP)
+    #define PCI_ENET0_IOADDR      0xe0000000
+    #define PCI_ENET0_MEMADDR     0xe0000000
+    #define PCI_IDSEL_NUMBER      0x0c 	/*slot0->3(IDSEL)=12->15*/
+#endif
+
+/* cyclades: we want to see existing PCI devices at startup */
+/* #undef CONFIG_PCI_SCAN_SHOW		/\* show pci devices on startup *\/ */
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CFG_PCI_SUBSYS_VENDORID 0x1057  /* Motorola */
+
+#endif	/* CONFIG_PCI */
+
+
+#if defined(CONFIG_TSEC_ENET)
+
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI 	1
+#endif
+
+#define CONFIG_MII		1	/* MII PHY management */
+#define CONFIG_MPC85XX_TSEC1	1
+#define CONFIG_MPC85XX_TSEC2	1
+#undef CONFIG_MPC85XX_FEC
+#define TSEC1_PHY_ADDR		0
+
+/* look at cpu/mpc85xx/tsec.h for those CONSTANTS */
+/* link up, full duplex, 1000mbps */
+#define TSEC2_PHY_ADDR		0xc800
+
+#ifdef CONFIG_MPC85XX_TSEC2
+#define CONFIG_MV88E6095        1
+#endif
+
+#define FEC_PHY_ADDR		3
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+#define FEC_PHYIDX		0
+#define CONFIG_ETHPRIME		"MOTO ENET0"
+
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Environment
+ */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	0x20000	/* 128K(one sector) for env */
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE - CFG_ENV_SECT_SIZE)
+#define CFG_ENV_SIZE		0x2000
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+#if defined(CONFIG_PCI)
+#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL \
+				| CFG_CMD_PCI \
+				| CFG_CMD_PING \
+				| CFG_CMD_I2C \
+				| CFG_CMD_IDE \
+				| CFG_CMD_FAT \
+				| CFG_CMD_MII)
+#else
+#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL \
+				| CFG_CMD_PING \
+				| CFG_CMD_I2C \
+				| CFG_CMD_IDE \
+				| CFG_CMD_FAT \
+				| CFG_CMD_MII)
+#endif
+#include <cmd_confdefs.h>
+
+#define CONFIG_WATCHDOG		1	/* watchdog enabled */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP			/* undef to save memory	*/
+#define CFG_LOAD_ADDR	0x2000000	/* default load address */
+#define CFG_PROMPT	"=> "		/* Monitor Command Prompt */
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CFG_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS	16		/* max number of command args */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size */
+#define CFG_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ	(8 << 20) 	/* Initial Memory map for Linux*/
+
+/* Cache Configuration */
+#define CFG_DCACHE_SIZE	32768
+#define CFG_CACHELINE_SIZE	32
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CACHELINE_SHIFT	5	/*log base 2 of the above value*/
+#endif
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02		/* Software reboot */
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+/*
+   cyclades: need to change these MAC addr settings.
+             OUI for cyclades is 00-60-2E
+	     for myself (Yang), I use the last 3 bytes of my IP addresses
+	     to get unique MACs:
+	     192.168.48.165/166/167 (C0.A8.30.A5/A6/A7)
+	     so MAC are 00-60-2E-A8-30-A5/A6/A7
+	     (To differ from KVMMAX board, we changed them by adding 0x10)
+	     so MAC are 00-60-2E-A8-30-B5/B6/B7
+
+   cyclades: For production, need to change these MAC addr for every DEB board.
+*/
+/* The mac addresses for all ethernet interface */
+#if defined(CONFIG_TSEC_ENET)
+/* #define CONFIG_ETHADDR   00:E0:0C:00:00:FD */
+#define CONFIG_ETHADDR   00:60:2E:A8:30:B5
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR  00:60:2E:A8:30:B6
+#define CONFIG_HAS_ETH2
+#define CONFIG_ETH2ADDR  00:60:2E:A8:30:B7
+#endif
+
+/* cyclades: need to change local IP addr setting */
+/* #define CONFIG_IPADDR    192.168.1.253 */
+#define CONFIG_IPADDR    192.168.48.166
+
+/* cyclades: change bootfile settings */
+/* #define CONFIG_HOSTNAME  unknown */
+/* #define CONFIG_ROOTPATH  /nfsroot /\* cyclades: right? *\/ */
+
+/* TFTP boot file is allImage for DEB*/
+#define CONFIG_BOOTFILE  allImage
+
+/* cyclades: change server IP settings */
+/* #define CONFIG_SERVERIP  192.168.1.1 */
+/* #define CONFIG_GATEWAYIP 192.168.1.1 */
+/* #define CONFIG_NETMASK   255.255.255.0 */
+#define CONFIG_SERVERIP  192.168.49.128
+#define CONFIG_GATEWAYIP 192.168.48.1
+#define CONFIG_NETMASK   255.255.252.0
+
+/* cyclades: loadaddr should be 1000000, since unzipped kernel may overlap it */
+/* #define CONFIG_LOADADDR  200000   /\*default location for tftp and bootm*\/ */
+#define CONFIG_LOADADDR  1000000   /*default location for tftp and bootm*/
+
+#define CONFIG_BOOTDELAY 3       /* -1 disables auto-boot */
+#undef  CONFIG_BOOTARGS           /* the boot command will set bootargs*/
+/* cyclades: set BOOTARGS */
+/* #define CONFIG_BOOTARGS "root=/dev/hda2" */
+#define CONFIG_LOADADDR_DEF     "0x01000000"
+
+#define CONFIG_BAUDRATE	9600
+
+/* cyclades: change ramdiskfile */
+/* #define	CONFIG_EXTRA_ENV_SETTINGS				        \ */
+/*    "netdev=eth0\0"                                                      \ */
+/*    "consoledev=ttyS0\0"                                                 \ */
+/*    "ramdiskaddr=400000\0"                                               \ */
+/*    "ramdiskfile=rd.yang\0" */
+
+/* cyclades: No need for nfsboot */
+/* cyclades: change nfs boot cmd */
+/* #define CONFIG_NFSBOOTCOMMAND	                                        \ */
+/*    "setenv bootargs root=/dev/nfs rw "                                  \ */
+/*       "nfsroot=$serverip:$rootpath "                                    \ */
+/*       "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \ */
+/*       "console=$consoledev,$baudrate $othbootargs;"                     \ */
+/*    "tftp $loadaddr $bootfile;"                                          \ */
+/*    "bootm $loadaddr" */
+
+/* cyclades: No need for ramboot */
+/* cyclades: change ram boot cmd */
+/* #define CONFIG_RAMBOOTCOMMAND \ */
+/*    "setenv bootargs root=/dev/ram rw "                                  \ */
+/*       "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \ */
+/*       "console=$consoledev,$baudrate $othbootargs;"                     \ */
+/*    "tftp $ramdiskaddr $ramdiskfile;"                                    \ */
+/*    "tftp $loadaddr $bootfile;"                                          \ */
+/*    "bootm $loadaddr $ramdiskaddr" */
+
+/* cyclades: add our CF IDE boot cmd, TODO */
+
+
+/* cyclades: bootcommand should be set to "hw_boot" */
+/* cyclades: change bootcommand according to boot method */
+/* #define CONFIG_BOOTCOMMAND  CONFIG_NFSBOOTCOMMAND */
+#define CONFIG_BOOTCOMMAND  "hw_boot"
+
+
+/* cyclades: IDE/ATA stuffs copied from kvmnetv2 */
+/* put them into include/cyc_ide_cfg.h to help DEB and KVMMAX */
+#include <cyc_ide_cfg.h>
+
+#endif	/* __CONFIG_H */
diff -Naur u-boot-1.1.2/include/configs/KVMMAXV1.h uboot-1.1.2hsv/include/configs/KVMMAXV1.h
--- u-boot-1.1.2/include/configs/KVMMAXV1.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/configs/KVMMAXV1.h	2007-05-29 16:51:01.000000000 -0500
@@ -0,0 +1,602 @@
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * mpc8555cds board configuration file
+ *
+ * Please refer to doc/README.mpc85xxcds for more info.
+ *
+ */
+
+/**
+ * kvmmaxv1 board configuration file
+ *
+ * modified by Yang Yang, Cyclades Corp.
+ * changed parts are prepended with "cyclades"
+ * 2/8/05
+ *
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* cyclades: define CONFIG_BDI_SWITCH if using bdi2000 for debugging */
+#define CONFIG_BDI_SWITCH       1
+//DHS #undef  CONFIG_BDI_SWITCH
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/60/55/41 */
+#define CONFIG_MPC8555		1	/* MPC8555 specific */
+/* cyclades: board name is KVMMAXV1 */
+/* #define CONFIG_MPC8555CDS	1	/\* MPC8555CDS board specific *\/ */
+#define CONFIG_CYCLADES         1       /* Cyclades Corp. */
+#define CONFIG_KVM              1       /* KVM family */
+#define CONFIG_KVMMAX           1       /* KVMMAX series */
+#define CONFIG_KVMMAXV1         1       /* KVMMAXV1 board specific */
+
+#define CONFIG_PCI
+#define CONFIG_TSEC_ENET 		/* tsec ethernet support */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup*/
+/* cyclades: kvmmaxv1 board use nonECC  */
+/* #define CONFIG_DDR_ECC			/\* only for ECC DDR module *\/ */
+
+/* cyclades: according to freescale FAE, we should turn off DDR DLL */
+#define CONFIG_DDR_DLL			/* possible DLL fix needed */
+#undef  CONFIG_DDR_DLL
+
+#define CONFIG_DDR_2T_TIMING		/* Sets the 2T timing bit */
+
+/*
+ * When initializing flash, if we cannot find the manufacturer ID,
+ * assume this is the AMD flash associated with the CDS board.
+ * This allows booting from a promjet.
+ */
+#define CONFIG_ASSUME_AMD_FLASH
+
+#define MPC85xx_DDR_SDRAM_CLK_CNTL	/* 85xx has clock control reg */
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_clock_freq(void);
+#endif
+#define CONFIG_SYS_CLK_FREQ	get_clock_freq() /* sysclk for MPC85xx */
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE		    	    /* toggle L2 cache 	*/
+#define CONFIG_BTB			    /* toggle branch predition */
+#define CONFIG_ADDR_STREAMING		    /* toggle addr streaming   */
+
+#define CONFIG_BOARD_EARLY_INIT_F	1	/* Call board_pre_init */
+#define CONFIG_BOARD_EARLY_INIT_R	1	/* Call board_pre_init in ram */
+
+#undef	CFG_DRAM_TEST			/* memory test, takes time */
+#define CFG_MEMTEST_START	0x00200000	/* memtest works on */
+#define CFG_MEMTEST_END		0x00400000
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CFG_CCSRBAR_DEFAULT 	0xff700000	/* CCSRBAR Default */
+#define CFG_CCSRBAR		0xe0000000	/* relocated CCSRBAR */
+#define CFG_IMMR		CFG_CCSRBAR	/* PQII uses CFG_IMMR */
+
+/*
+ * DDR Setup
+ */
+#define CFG_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory*/
+#define CFG_SDRAM_BASE		CFG_DDR_SDRAM_BASE
+
+/* cyclades: DDR SPD i2c addr: 0x50 */
+/* #define SPD_EEPROM_ADDRESS	0x51		/\* DDR DIMM *\/ */
+#define SPD_EEPROM_ADDRESS	0x50		/* DDR DIMM */
+
+/*
+ * Make sure required options are set
+ */
+#ifndef CONFIG_SPD_EEPROM
+/* cyclades: changed error output if no SPD_EEPROM */
+/* #error ("CONFIG_SPD_EEPROM is required by MPC85555CDS") */
+#error ("CONFIG_SPD_EEPROM is required by KVMMAXV1")
+#endif
+
+/*
+ * SDRAM on the Local Bus
+ */
+/* cyclades: no SDRAM on Local Bus in kvmmaxv1 board */
+/* #define CFG_LBC_SDRAM_BASE	0xf0000000	/\* Localbus SDRAM *\/ */
+/* #define CFG_LBC_SDRAM_SIZE	64		/\* LBC SDRAM is 64MB *\/ */
+
+/* cyclades: only 8M FLASH on board from 0xff80_0000 to 0xffff_ffff */
+/* #define CFG_FLASH_BASE		0xff000000	/\* start of FLASH 8M *\/ */
+#define CFG_FLASH_BASE          0xff800000
+
+/*
+  cyclades: BR0 for boot flash, see 13.3.1.1
+   BR0 register setup (1111_1111_1000_0000_0001_0000_0000_0001), Base Register
+   BR0[0-16]: Base address:	1111_1111_1000_0 (0xFF80:0000)
+   BR0[17-18]: Reserved		00
+   BR0[19-20]: Port Size:   	1_0 (16-bit from configuration pullup-pulldown)
+   BR0[21-22]: DECC:		00 (no error checking)
+   BR0[23]:    WP		0 (Read/Write enabled)
+   BR0[24-26]: MSEL		_000 (GPCM select)
+   BR0[27]:    Reserved		0
+   BR0[28-29]: Atomic		_00 (no atomic operation)
+   BR0[30]:reserved		0
+   BR0[31]: Valid		1 (Valid chipselect)
+
+    */
+#define CFG_BR0_PRELIM		0xff801001	/* port size 16bit */
+
+/* cyclades: only one boot flash, so BR1/OR1 not used */
+/* #define CFG_BR1_PRELIM		0xff001001	/\* port size 16bit *\/ */
+
+/*
+  cyclades: set OR0 according to flash's parameters, see 13.3.1.2.2, GPCM
+   OR0 register (1111_1111_1000_0000_0110_1101_0010_0110), Option Register
+   OR0[0-16]:  Addr. Mask	1111_1111_1000_0000_0 (8MB)
+   OR0[17-18]: Reserved		11 (set to 11, not 00. see 13.3.1.2.1)
+   OR0[19]:    BCTLD 		0  (Buffer Control enabled)
+   OR0[20]:    CSNT		_1 (chip sel negate earlier,see LCRR[CLKDIV])
+   OR0[21-22]: ACS		10 (LCS0 a qtr bus clk cycle, see LCRR[CLKDIV])
+   OR0[23]:    XACS		1 (addr chip-sel setup is extended)
+   OR0[24-27]: SCY		_0010 (2 bus clocks wait states)
+   OR0[28]:    SETA		_0 (access terminated internally)
+   OR0[29]:    TRLX		1 (relax timing)
+   OR0[30]:    ETHR		1 (8 idle clk for read, see TRLX)
+   OR0[31]:    EAD		0 (no extra clk added)
+
+   */
+
+/* #define	CFG_OR0_PRELIM		0xff806e61	/\* 8MB Flash *\/ */
+#define	CFG_OR0_PRELIM		0xff806d26	/* 8MB Flash */
+
+/* cyclades: only one boot flash, so BR1/OR1 not used */
+/* #define	CFG_OR1_PRELIM		0xff806e61	/\* 8MB Flash *\/ */
+
+/* cyclades: only one bank */
+/* #define CFG_FLASH_BANKS_LIST	{0xff800000, CFG_FLASH_BASE} */
+#define CFG_FLASH_BANKS_LIST    {CFG_FLASH_BASE}
+
+/* #define CFG_MAX_FLASH_BANKS	2		/\* number of banks *\/ */
+#define CFG_MAX_FLASH_BANKS     1
+
+/* cyclades: consult to flash's Data Sheet */
+/* cyclades: use 28F640J3A : 8MB = 64 sectors x 128KB */
+/* #define CFG_MAX_FLASH_SECT	128		/\* sectors per device *\/ */
+#define CFG_MAX_FLASH_SECT	64		/* sectors per device */
+#undef	CFG_FLASH_CHECKSUM
+#define CFG_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CFG_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+/* cyclades: TEXT_BASE defined in board/debmax/config.mk, 0xfff80000 */
+#define CFG_MONITOR_BASE    	TEXT_BASE	/* start of monitor */
+
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_EMPTY_INFO
+
+#undef CONFIG_CLOCKS_IN_MHZ
+
+/*
+ * Local Bus Definitions
+ */
+
+/* cyclades: we define localbus mem base addr */
+#define CFG_LBC_BASE            0xc0000000
+#define CFG_LBC_SIZE            0x10000000 /* 256MB */
+
+/* cyclades: no SDRAM on kvmmaxv1 board */
+/*
+ * Base Register 2 and Option Register 2 configure SDRAM.
+ * The SDRAM base address, CFG_LBC_SDRAM_BASE, is 0xf0000000.
+ *
+ * For BR2, need:
+ *    Base address of 0xf0000000 = BR[0:16] = 1111 0000 0000 0000 0
+ *    port-size = 32-bits = BR2[19:20] = 11
+ *    no parity checking = BR2[21:22] = 00
+ *    SDRAM for MSEL = BR2[24:26] = 011
+ *    Valid = BR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 0000 0000 0000 0001 1000 0110 0001 = f0001861
+ *
+ * FIXME: CFG_LBC_SDRAM_BASE should be masked and OR'ed into
+ * FIXME: the top 17 bits of BR2.
+ */
+
+/* #define CFG_BR2_PRELIM          0xf0001861 */
+
+/*
+ * The SDRAM size in MB, CFG_LBC_SDRAM_SIZE, is 64.
+ *
+ * For OR2, need:
+ *    64MB mask for AM, OR2[0:7] = 1111 1100
+ *		   XAM, OR2[17:18] = 11
+ *    9 columns OR2[19-21] = 010
+ *    13 rows   OR2[23-25] = 100
+ *    EAD set for extra time OR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1100 0000 0000 0110 1001 0000 0001 = fc006901
+ */
+
+/* #define CFG_OR2_PRELIM		0xfc006901 */
+
+/* cyclades: LBC some registers values are supplied here */
+
+/* cyclades: CFG_LBC_LCRR: CCB to LBC ratio is 266/33 = 8, 13.3.1.16 */
+/* #define CFG_LBC_LCRR		0x00030004    /\* LB clock ratio reg *\/ */
+#define CFG_LBC_LCRR		0x00030008    /* LB clock ratio reg */
+
+/* cyclades: CFG_LBC_LBCR etc. are used in sdram_init, so we don't use them. */
+#define CFG_LBC_LBCR		0x00000000    /* LB config reg */
+#define CFG_LBC_LSRT		0x20000000  /* LB sdram refresh timer */
+#define CFG_LBC_MRTPR		0x00000000  /* LB refresh timer prescal*/
+
+/*
+ * LSDMR masks
+ */
+#define CFG_LBC_LSDMR_RFEN	(1 << (31 -  1))
+#define CFG_LBC_LSDMR_BSMA1516	(3 << (31 - 10))
+#define CFG_LBC_LSDMR_BSMA1617	(4 << (31 - 10))
+#define CFG_LBC_LSDMR_RFCR16	(7 << (31 - 16))
+#define CFG_LBC_LSDMR_PRETOACT7	(7 << (31 - 19))
+#define CFG_LBC_LSDMR_ACTTORW7	(7 << (31 - 22))
+#define CFG_LBC_LSDMR_ACTTORW6	(6 << (31 - 22))
+#define CFG_LBC_LSDMR_BL8	(1 << (31 - 23))
+#define CFG_LBC_LSDMR_WRC4	(0 << (31 - 27))
+#define CFG_LBC_LSDMR_CL3	(3 << (31 - 31))
+
+#define CFG_LBC_LSDMR_OP_NORMAL	(0 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_ARFRSH	(1 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_SRFRSH	(2 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_MRW	(3 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_PRECH	(4 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_PCHALL	(5 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_ACTBNK	(6 << (31 - 4))
+#define CFG_LBC_LSDMR_OP_RWINV	(7 << (31 - 4))
+
+/*
+ * Common settings for all Local Bus SDRAM commands.
+ * At run time, either BSMA1516 (for CPU 1.1)
+ *                  or BSMA1617 (for CPU 1.0) (old)
+ * is OR'ed in too.
+ */
+#define CFG_LBC_LSDMR_COMMON	( CFG_LBC_LSDMR_RFCR16		\
+				| CFG_LBC_LSDMR_PRETOACT7	\
+				| CFG_LBC_LSDMR_ACTTORW7	\
+				| CFG_LBC_LSDMR_BL8		\
+				| CFG_LBC_LSDMR_WRC4		\
+				| CFG_LBC_LSDMR_CL3		\
+				| CFG_LBC_LSDMR_RFEN		\
+				)
+
+/* cyclades: no CADMUS registers in kvmmaxv1 board */
+/*
+ * The CADMUS registers are connected to CS3 on CDS.
+ * The new memory map places CADMUS at 0xf8000000.
+ *
+ * For BR3, need:
+ *    Base address of 0xf8000000 = BR[0:16] = 1111 1000 0000 0000 0
+ *    port-size = 8-bits  = BR[19:20] = 01
+ *    no parity checking  = BR[21:22] = 00
+ *    GPMC for MSEL       = BR[24:26] = 000
+ *    Valid               = BR[31]    = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1000 0000 0000 0000 1000 0000 0001 = f8000801
+ *
+ * For OR3, need:
+ *    1 MB mask for AM,   OR[0:16]  = 1111 1111 1111 0000 0
+ *    disable buffer ctrl OR[19]    = 0
+ *    CSNT                OR[20]    = 1
+ *    ACS                 OR[21:22] = 11
+ *    XACS                OR[23]    = 1
+ *    SCY 15 wait states  OR[24:27] = 1111	max is suboptimal but safe
+ *    SETA                OR[28]    = 0
+ *    TRLX                OR[29]    = 1
+ *    EHTR                OR[30]    = 1
+ *    EAD extra time      OR[31]    = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1111 1111 0000 0000 1111 1111 0111 = fff00ff7
+ */
+
+/* #define CADMUS_BASE_ADDR 0xf8000000 */
+/* #define CFG_BR3_PRELIM   0xf8000801 */
+/* #define CFG_OR3_PRELIM   0xfff00ff7 */
+
+#define CONFIG_L1_INIT_RAM
+#define CFG_INIT_RAM_LOCK 	1
+#define CFG_INIT_RAM_ADDR	0xe4010000	/* Initial RAM address */
+#define CFG_INIT_RAM_END    	0x4000	    /* End of used area in RAM */
+
+#define CFG_GBL_DATA_SIZE  	128	    /* num bytes initial data */
+#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
+#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
+
+#define CFG_MONITOR_LEN	    	0x80000 	/* Reserve 512 kB for Mon */
+#define CFG_MALLOC_LEN	    	(128 * 1024)	/* Reserved for malloc */
+
+/* Serial Port */
+/* cyclades: use UART 1 as console, UART 2 as AUX */
+/* #define CONFIG_CONS_INDEX     2 */
+#define CONFIG_CONS_INDEX     1
+#undef	CONFIG_SERIAL_SOFTWARE_FIFO
+#define CFG_NS16550
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE    1
+#define CFG_NS16550_CLK		get_bus_freq(0)
+
+#define CFG_BAUDRATE_TABLE  \
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
+
+#define CFG_NS16550_COM1        (CFG_CCSRBAR+0x4500)
+#define CFG_NS16550_COM2        (CFG_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+#ifdef  CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif
+
+/* I2C */
+#define CONFIG_HARD_I2C			/* I2C with hardware support */
+#undef	CONFIG_SOFT_I2C			/* I2C bit-banged */
+#define CFG_I2C_SPEED		400000	/* I2C speed and slave address */
+
+/* cyclades: what's these I2C addr?  */
+/* #define CFG_I2C_EEPROM_ADDR	0x57 */
+#define CFG_I2C_EEPROM_ADDR	0xa3
+#define CFG_I2C_SLAVE		0x7F
+#define CFG_I2C_NOPROBES        {0x69}	/* Don't probe these addrs */
+
+/*
+ * General PCI
+ * Addresses are mapped 1-1.
+ */
+#define CFG_PCI1_MEM_BASE	0x80000000
+#define CFG_PCI1_MEM_PHYS	CFG_PCI1_MEM_BASE
+#define CFG_PCI1_MEM_SIZE	0x20000000	/* 512M */
+#define CFG_PCI1_IO_BASE	0xe2000000
+#define CFG_PCI1_IO_PHYS	CFG_PCI1_IO_BASE
+#define CFG_PCI1_IO_SIZE	0x1000000	/* 16M */
+
+#define CFG_PCI2_MEM_BASE	0xa0000000
+#define CFG_PCI2_MEM_PHYS	CFG_PCI2_MEM_BASE
+#define CFG_PCI2_MEM_SIZE	0x20000000	/* 512M */
+#define CFG_PCI2_IO_BASE	0xe3000000
+#define CFG_PCI2_IO_PHYS	CFG_PCI2_IO_BASE
+#define CFG_PCI2_IO_SIZE	0x1000000	/* 16M */
+
+
+#if defined(CONFIG_PCI)
+
+#define CONFIG_NET_MULTI
+#define CONFIG_PCI_PNP	               	/* do pci plug-and-play */
+
+/* cyclades: for DEB, we need to turn on CONFIG_EEPRO100 */
+#undef CONFIG_EEPRO100
+#undef CONFIG_TULIP
+
+#if !defined(CONFIG_PCI_PNP)
+    #define PCI_ENET0_IOADDR      0xe0000000
+    #define PCI_ENET0_MEMADDR     0xe0000000
+    #define PCI_IDSEL_NUMBER      0x0c 	/*slot0->3(IDSEL)=12->15*/
+#endif
+
+/* cyclades: we want to see existing PCI devices at startup */
+/* #undef CONFIG_PCI_SCAN_SHOW		/\* show pci devices on startup *\/ */
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CFG_PCI_SUBSYS_VENDORID 0x1057  /* Motorola */
+
+#endif	/* CONFIG_PCI */
+
+
+#if defined(CONFIG_TSEC_ENET)
+
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI 	1
+#endif
+
+#define CONFIG_MII		1	/* MII PHY management */
+#define CONFIG_MPC85XX_TSEC1	1
+#define CONFIG_MPC85XX_TSEC2	1
+#undef CONFIG_MPC85XX_FEC
+#define TSEC1_PHY_ADDR		0
+#define TSEC2_PHY_ADDR		7
+#define FEC_PHY_ADDR		3
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+#define FEC_PHYIDX		0
+#define CONFIG_ETHPRIME		"MOTO ENET0"
+
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Environment
+ */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	0x20000 /* one sector for env */
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE - CFG_ENV_SECT_SIZE)
+#define CFG_ENV_SIZE		0x2000
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+#if defined(CONFIG_PCI)
+#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL \
+				| CFG_CMD_PCI \
+				| CFG_CMD_PING \
+				| CFG_CMD_I2C \
+				| CFG_CMD_IDE \
+				| CFG_CMD_FAT \
+				| CFG_CMD_MII)
+#else
+#define  CONFIG_COMMANDS	(CONFIG_CMD_DFL \
+				| CFG_CMD_PING \
+				| CFG_CMD_I2C \
+				| CFG_CMD_IDE \
+				| CFG_CMD_FAT \
+				| CFG_CMD_MII)
+#endif
+#include <cmd_confdefs.h>
+
+#undef CONFIG_WATCHDOG			/* watchdog disabled */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_LONGHELP			/* undef to save memory	*/
+#define CFG_LOAD_ADDR	0x2000000	/* default load address */
+#define CFG_PROMPT	"=> "		/* Monitor Command Prompt */
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CFG_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS	16		/* max number of command args */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size */
+#define CFG_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_BOOTMAPSZ	(8 << 20) 	/* Initial Memory map for Linux*/
+
+/* Cache Configuration */
+#define CFG_DCACHE_SIZE	32768
+#define CFG_CACHELINE_SIZE	32
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CFG_CACHELINE_SHIFT	5	/*log base 2 of the above value*/
+#endif
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02		/* Software reboot */
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+/*
+   cyclades: need to change these MAC addr settings.
+             OUI for cyclades is 00-60-2E
+	     for myself (Yang), I use the last 3 bytes of my IP addresses
+	     to get unique MACs:
+	     192.168.48.165/166/167 (C0.A8.30.A5/A6/A7)
+	     so MAC are 00-60-2E-A8-30-A5/A6/A7
+*/
+/* The mac addresses for all ethernet interface */
+#if defined(CONFIG_TSEC_ENET)
+/* #define CONFIG_ETHADDR   00:E0:0C:00:00:FD */
+#define CONFIG_ETHADDR   00:60:2E:A8:30:A5
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR  00:60:2E:A8:30:A6
+#define CONFIG_HAS_ETH2
+#define CONFIG_ETH2ADDR  00:60:2E:A8:30:A7
+#endif
+
+/* cyclades: need to change local IP addr setting */
+/* #define CONFIG_IPADDR    192.168.1.253 */
+#define CONFIG_IPADDR    192.168.48.167
+
+/* cyclades: change bootfile settings */
+/* #define CONFIG_HOSTNAME  unknown */
+/* #define CONFIG_ROOTPATH  /nfsroot */
+/* #define CONFIG_BOOTFILE  your.uImage */
+#define CONFIG_HOSTNAME  unknown
+#define CONFIG_ROOTPATH  /nfsroot /* cyclades: right? */
+#define CONFIG_BOOTFILE  allImage.yang
+
+/* cyclades: change server IP settings */
+/* #define CONFIG_SERVERIP  192.168.1.1 */
+/* #define CONFIG_GATEWAYIP 192.168.1.1 */
+/* #define CONFIG_NETMASK   255.255.255.0 */
+#define CONFIG_SERVERIP  192.168.49.128
+#define CONFIG_GATEWAYIP 192.168.48.1
+#define CONFIG_NETMASK   255.255.252.0
+
+//DHS #define CONFIG_LOADADDR  200000   /*default location for tftp and bootm*/
+#define CONFIG_LOADADDR  1000000   /*default location for tftp and bootm*/
+
+#define CONFIG_BOOTDELAY 10       /* -1 disables auto-boot */
+#undef  CONFIG_BOOTARGS           /* the boot command will set bootargs*/
+/* cyclades: set BOOTARGS */
+/* #define CONFIG_BOOTARGS "root=/dev/hda2" */
+#define CONFIG_LOADADDR_DEF "0x01000000"	/* DHS added */
+
+#define CONFIG_BAUDRATE	115200
+
+/* cyclades: change ramdiskfile */
+#define	CONFIG_EXTRA_ENV_SETTINGS				        \
+   "netdev=eth0\0"                                                      \
+   "consoledev=ttyS1\0"                                                 \
+   "ramdiskaddr=400000\0"                                               \
+   "ramdiskfile=your.ramdisk.u-boot\0"
+
+/* cyclades: change nfs boot cmd */
+#define CONFIG_NFSBOOTCOMMAND	                                        \
+   "setenv bootargs root=/dev/nfs rw "                                  \
+      "nfsroot=$serverip:$rootpath "                                    \
+      "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+      "console=$consoledev,$baudrate $othbootargs;"                     \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr"
+
+/* cyclades: change ram boot cmd */
+#define CONFIG_RAMBOOTCOMMAND \
+   "setenv bootargs root=/dev/ram rw "                                  \
+      "console=$consoledev,$baudrate $othbootargs;"                     \
+   "tftp $ramdiskaddr $ramdiskfile;"                                    \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr $ramdiskaddr"
+
+/* cyclades: add our CF IDE boot cmd, TODO */
+
+
+/* cyclades: change bootcommand according to boot method */
+#define CONFIG_BOOTCOMMAND  CONFIG_NFSBOOTCOMMAND
+
+
+/* cyclades: IDE/ATA stuffs copied from kvmnetv2 */
+/* put them into include/cyc_ide_cfg.h to help DEB and KVMMAX */
+#include <cyc_ide_cfg.h>
+
+#endif	/* __CONFIG_H */
diff -Naur u-boot-1.1.2/include/configs/sbc8560.h uboot-1.1.2hsv/include/configs/sbc8560.h
--- u-boot-1.1.2/include/configs/sbc8560.h	2004-12-31 03:32:54.000000000 -0600
+++ uboot-1.1.2hsv/include/configs/sbc8560.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,400 +0,0 @@
-/*
- * (C) Copyright 2002,2003 Motorola,Inc.
- * Xianghua Xiao <X.Xiao@motorola.com>
- *
- * (C) Copyright 2004 Wind River Systems Inc <www.windriver.com>.
- * Added support for Wind River SBC8560 board
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-/* mpc8560ads board configuration file */
-/* please refer to doc/README.mpc85xx for more info */
-/* make sure you change the MAC address and other network params first,
- * search for CONFIG_ETHADDR,CONFIG_SERVERIP,etc in this file
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-/* High Level Configuration Options */
-#define CONFIG_BOOKE		1	/* BOOKE			*/
-#define CONFIG_E500		1	/* BOOKE e500 family		*/
-#define CONFIG_MPC85xx		1	/* MPC8540/MPC8560		*/
-#define CONFIG_MPC85xx_REV1	1	/* MPC85xx Rev 1.0 chip		*/
-
-
-#define CONFIG_MPC8560		1	/* MPC8560 specific		*/
-#define CONFIG_SBC8560		1	/* configuration for SBC8560 board */
-
-/* XXX flagging this as something I might want to delete */
-#define CONFIG_MPC8560ADS	1	/* MPC8560ADS board specific	*/
-
-#define CONFIG_TSEC_ENET		/* tsec ethernet support	*/
-#undef	CONFIG_PCI			/* pci ethernet support		*/
-#undef  CONFIG_ETHER_ON_FCC		/* cpm FCC ethernet support	*/
-
-
-#define CONFIG_ENV_OVERWRITE
-
-/* Using Localbus SDRAM to emulate flash before we can program the flash,
- * normally you need a flash-boot image(u-boot.bin), if so undef this.
- */
-#undef CONFIG_RAM_AS_FLASH
-
-#if defined(CONFIG_PCI_66)		/* some PCI card is 33Mhz only	*/
-  #define CONFIG_SYS_CLK_FREQ	66000000/* sysclk for MPC85xx		*/
-#else
-  #define CONFIG_SYS_CLK_FREQ	33000000/* most pci cards are 33Mhz	*/
-#endif
-
-/* below can be toggled for performance analysis. otherwise use default */
-#define CONFIG_L2_CACHE			    /* toggle L2 cache		*/
-#undef	CONFIG_BTB			    /* toggle branch predition	*/
-#undef	CONFIG_ADDR_STREAMING		    /* toggle addr streaming	*/
-
-#define CONFIG_BOARD_EARLY_INIT_F 1	    /* Call board_early_init_f	*/
-
-#undef	CFG_DRAM_TEST			    /* memory test, takes time	*/
-#define CFG_MEMTEST_START	0x00200000  /* memtest region */
-#define CFG_MEMTEST_END		0x00400000
-
-#if (defined(CONFIG_PCI) && defined(CONFIG_TSEC_ENET) || \
-     defined(CONFIG_PCI) && defined(CONFIG_ETHER_ON_FCC) || \
-     defined(CONFIG_TSEC_ENET) && defined(CONFIG_ETHER_ON_FCC))
-#error "You can only use ONE of PCI Ethernet Card or TSEC Ethernet or CPM FCC."
-#endif
-
-/*
- * Base addresses -- Note these are effective addresses where the
- * actual resources get mapped (not physical addresses)
- */
-#define CFG_CCSRBAR_DEFAULT	0xff700000	/* CCSRBAR Default	*/
-
-#if XXX
-  #define CFG_CCSRBAR		0xfdf00000	/* relocated CCSRBAR	*/
-#else
-  #define CFG_CCSRBAR		0xff700000	/* default CCSRBAR	*/
-#endif
-#define CFG_IMMR		CFG_CCSRBAR	/* PQII uses CFG_IMMR	*/
-
-#define CFG_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory	 */
-#define CFG_SDRAM_BASE		CFG_DDR_SDRAM_BASE
-#define CFG_SDRAM_SIZE		512		/* DDR is 512MB */
-#define SPD_EEPROM_ADDRESS	0x55		/*  DDR DIMM */
-
-#undef  CONFIG_DDR_ECC				/* only for ECC DDR module	*/
-#undef  CONFIG_SPD_EEPROM			/* Use SPD EEPROM for DDR setup */
-
-#if defined(CONFIG_MPC85xx_REV1)
-  #define CONFIG_DDR_DLL			/* possible DLL fix needed	*/
-#endif
-
-#undef CONFIG_CLOCKS_IN_MHZ
-
-#if defined(CONFIG_RAM_AS_FLASH)
-  #define CFG_LBC_SDRAM_BASE	0xfc000000	/* Localbus SDRAM */
-  #define CFG_FLASH_BASE	0xf8000000      /* start of FLASH 8M  */
-  #define CFG_BR0_PRELIM	0xf8000801      /* port size 8bit */
-  #define CFG_OR0_PRELIM	0xf8000ff7	/* 8MB Flash		*/
-#else /* Boot from real Flash */
-  #define CFG_LBC_SDRAM_BASE	0xf8000000	/* Localbus SDRAM */
-  #define CFG_FLASH_BASE	0xff800000      /* start of FLASH 8M    */
-  #define CFG_BR0_PRELIM	0xff800801      /* port size 8bit      */
-  #define CFG_OR0_PRELIM	0xff800ff7	/* 8MB Flash		*/
-#endif
-#define CFG_LBC_SDRAM_SIZE	64		/* LBC SDRAM is 64MB	*/
-
-/* local bus definitions */
-#define CFG_BR1_PRELIM		0xe4001801	/* 64M, 32-bit flash */
-#define CFG_OR1_PRELIM		0xfc000ff7
-
-#define CFG_BR2_PRELIM		0x00000000	/* CS2 not used */
-#define CFG_OR2_PRELIM		0x00000000
-
-#define CFG_BR3_PRELIM		0xf0001861	/* 64MB localbus SDRAM	*/
-#define CFG_OR3_PRELIM		0xfc000cc1
-
-#if defined(CONFIG_RAM_AS_FLASH)
-  #define CFG_BR4_PRELIM	0xf4001861	/* 64M localbus SDRAM */
-#else
-  #define CFG_BR4_PRELIM	0xf8001861	/* 64M localbus SDRAM */
-#endif
-#define CFG_OR4_PRELIM		0xfc000cc1
-
-#define CFG_BR5_PRELIM		0xfc000801	/* 16M CS5 misc devices */
-#if 1
-  #define CFG_OR5_PRELIM	0xff000ff7
-#else
-  #define CFG_OR5_PRELIM	0xff0000f0
-#endif
-
-#define CFG_BR6_PRELIM		0xe0001801	/* 64M, 32-bit flash */
-#define CFG_OR6_PRELIM		0xfc000ff7
-#define CFG_LBC_LCRR		0x00030002	/* local bus freq	*/
-#define CFG_LBC_LBCR		0x00000000
-#define CFG_LBC_LSRT		0x20000000
-#define CFG_LBC_MRTPR		0x20000000
-#define CFG_LBC_LSDMR_1		0x2861b723
-#define CFG_LBC_LSDMR_2		0x0861b723
-#define CFG_LBC_LSDMR_3		0x0861b723
-#define CFG_LBC_LSDMR_4		0x1861b723
-#define CFG_LBC_LSDMR_5		0x4061b723
-
-/* just hijack the MOT BCSR def for SBC8560 misc devices */
-#define CFG_BCSR		((CFG_BR5_PRELIM & 0xff000000)|0x00400000)
-/* the size of CS5 needs to be >= 16M for TLB and LAW setups */
-
-#define CONFIG_L1_INIT_RAM
-#define CFG_INIT_RAM_LOCK	1
-#define CFG_INIT_RAM_ADDR	0x70000000	/* Initial RAM address	*/
-#define CFG_INIT_RAM_END	0x4000		/* End of used area in RAM */
-
-#define CFG_GBL_DATA_SIZE	128		/* num bytes initial data */
-#define CFG_GBL_DATA_OFFSET	(CFG_INIT_RAM_END - CFG_GBL_DATA_SIZE)
-#define CFG_INIT_SP_OFFSET	CFG_GBL_DATA_OFFSET
-
-#define CFG_MONITOR_LEN		(256 * 1024)	/* Reserve 256 kB for Mon */
-#define CFG_MALLOC_LEN		(128 * 1024)	/* Reserved for malloc */
-
-/* Serial Port */
-#undef  CONFIG_CONS_ON_SCC			/* define if console on SCC */
-#undef	CONFIG_CONS_NONE			/* define if console on something else */
-
-#define CONFIG_CONS_INDEX	1
-#undef	CONFIG_SERIAL_SOFTWARE_FIFO
-#define CFG_NS16550
-#define CFG_NS16550_SERIAL
-#define CFG_NS16550_REG_SIZE	1
-#define CFG_NS16550_CLK		1843200 /* get_bus_freq(0) */
-#define CONFIG_BAUDRATE		9600
-
-#define CFG_BAUDRATE_TABLE  \
-	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
-
-#define CFG_NS16550_COM1	((CFG_BR5_PRELIM & 0xff000000)+0x00700000)
-#define CFG_NS16550_COM2	((CFG_BR5_PRELIM & 0xff000000)+0x00800000)
-
-/* Use the HUSH parser */
-#define CFG_HUSH_PARSER
-#ifdef	CFG_HUSH_PARSER
-#define CFG_PROMPT_HUSH_PS2 "> "
-#endif
-
-/* I2C */
-#define	 CONFIG_HARD_I2C		/* I2C with hardware support*/
-#undef	CONFIG_SOFT_I2C			/* I2C bit-banged */
-#define CFG_I2C_SPEED		400000	/* I2C speed and slave address	*/
-#define CFG_I2C_SLAVE		0x7F
-#define CFG_I2C_NOPROBES	{0x69}	/* Don't probe these addrs */
-
-#define CFG_PCI_MEM_BASE	0xC0000000
-#define CFG_PCI_MEM_PHYS	0xC0000000
-#define CFG_PCI_MEM_SIZE	0x10000000
-
-#if defined(CONFIG_TSEC_ENET)		/* TSEC Ethernet port */
-
-  #define CONFIG_NET_MULTI	1
-  #define CONFIG_PHY_BCM5421S	1	/* GigaBit Ether PHY	     */
-  #define CONFIG_MII		1	/* MII PHY management		*/
-  #define CONFIG_PHY_ADDR	25	/* PHY address			*/
-
-#elif defined(CONFIG_ETHER_ON_FCC)	/* CPM FCC Ethernet */
-
-  #undef  CONFIG_ETHER_NONE		/* define if ether on something else */
-  #define CONFIG_ETHER_ON_FCC2		/* cpm FCC ethernet support	*/
-  #define CONFIG_ETHER_INDEX	2	/* which channel for ether  */
-
-  #if (CONFIG_ETHER_INDEX == 2)
-    /*
-     * - Rx-CLK is CLK13
-     * - Tx-CLK is CLK14
-     * - Select bus for bd/buffers
-     * - Full duplex
-     */
-    #define CFG_CMXFCR_MASK	(CMXFCR_FC2 | CMXFCR_RF2CS_MSK | CMXFCR_TF2CS_MSK)
-    #define CFG_CMXFCR_VALUE	(CMXFCR_RF2CS_CLK13 | CMXFCR_TF2CS_CLK14)
-    #define CFG_CPMFCR_RAMTYPE	0
-    #define CFG_FCC_PSMR	(FCC_PSMR_FDE)
-
-  #elif (CONFIG_ETHER_INDEX == 3)
-    /* need more definitions here for FE3 */
-  #endif				/* CONFIG_ETHER_INDEX */
-
-  #define CONFIG_MII			/* MII PHY management */
-  #define CONFIG_BITBANGMII		/* bit-bang MII PHY management	*/
-  /*
-   * GPIO pins used for bit-banged MII communications
-   */
-  #define MDIO_PORT	2		/* Port C */
-  #define MDIO_ACTIVE	(iop->pdir |=  0x00400000)
-  #define MDIO_TRISTATE	(iop->pdir &= ~0x00400000)
-  #define MDIO_READ	((iop->pdat &  0x00400000) != 0)
-
-  #define MDIO(bit)	if(bit) iop->pdat |=  0x00400000; \
-			else	iop->pdat &= ~0x00400000
-
-  #define MDC(bit)	if(bit) iop->pdat |=  0x00200000; \
-			else	iop->pdat &= ~0x00200000
-
-  #define MIIDELAY	udelay(1)
-
-#endif
-
-/*-----------------------------------------------------------------------
- * FLASH and environment organization
- */
-
-#define CFG_FLASH_CFI		1	/* Flash is CFI conformant		*/
-#define CFG_FLASH_CFI_DRIVER	1	/* Use the common driver		*/
-#if 0
-#define CFG_FLASH_USE_BUFFER_WRITE 1    /* use buffered writes (20x faster)     */
-#define CFG_FLASH_PROTECTION		/* use hardware protection		*/
-#endif
-#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
-#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
-
-#undef	CFG_FLASH_CHECKSUM
-#define CFG_FLASH_ERASE_TOUT	200000		/* Timeout for Flash Erase (in ms)	*/
-#define CFG_FLASH_WRITE_TOUT	50000		/* Timeout for Flash Write (in ms)	*/
-
-#define CFG_MONITOR_BASE	TEXT_BASE	/* start of monitor	*/
-
-#if 0
-/* XXX This doesn't work and I don't want to fix it */
-#if (CFG_MONITOR_BASE < CFG_FLASH_BASE)
-  #define CFG_RAMBOOT
-#else
-  #undef  CFG_RAMBOOT
-#endif
-#endif
-
-/* Environment */
-#if !defined(CFG_RAMBOOT)
-  #if defined(CONFIG_RAM_AS_FLASH)
-    #define CFG_ENV_IS_NOWHERE
-    #define CFG_ENV_ADDR	(CFG_FLASH_BASE + 0x100000)
-    #define CFG_ENV_SIZE	0x2000
-  #else
-    #define CFG_ENV_IS_IN_FLASH	1
-    #define CFG_ENV_SECT_SIZE	0x20000 /* 128K(one sector) for env */
-    #define CFG_ENV_ADDR	(CFG_MONITOR_BASE - CFG_ENV_SECT_SIZE)
-    #define CFG_ENV_SIZE	0x2000 /* CFG_ENV_SECT_SIZE */
-  #endif
-#else
-  #define CFG_NO_FLASH		1	/* Flash is not usable now	*/
-  #define CFG_ENV_IS_NOWHERE	1	/* Store ENV in memory only	*/
-  #define CFG_ENV_ADDR		(CFG_MONITOR_BASE - 0x1000)
-  #define CFG_ENV_SIZE		0x2000
-#endif
-
-#define CONFIG_BOOTARGS "root=/dev/nfs rw nfsroot=192.168.0.251:/tftpboot ip=192.168.0.105:192.168.0.251::255.255.255.0:sbc8560:eth0:off console=ttyS0,9600"
-/*#define CONFIG_BOOTARGS      "root=/dev/ram rw console=ttyS0,115200"*/
-#define CONFIG_BOOTCOMMAND	"bootm 0xff800000 0xffa00000"
-#define CONFIG_BOOTDELAY	5	/* -1 disable autoboot */
-
-#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
-#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
-
-#if defined(CFG_RAMBOOT) || defined(CONFIG_RAM_AS_FLASH)
-  #if defined(CONFIG_PCI)
-    #define  CONFIG_COMMANDS	((CONFIG_CMD_DFL | CFG_CMD_PCI | \
-				CFG_CMD_PING | CFG_CMD_I2C) & \
-				 ~(CFG_CMD_ENV | \
-				  CFG_CMD_LOADS ))
-  #elif (defined(CONFIG_TSEC_ENET) || defined(CONFIG_ETHER_ON_FCC))
-    #define  CONFIG_COMMANDS	((CONFIG_CMD_DFL | CFG_CMD_MII | \
-				CFG_CMD_PING | CFG_CMD_I2C) & \
-				~(CFG_CMD_ENV))
-  #endif
-#else
-  #if defined(CONFIG_PCI)
-    #define  CONFIG_COMMANDS	(CONFIG_CMD_DFL | CFG_CMD_PCI | \
-				CFG_CMD_PING | CFG_CMD_I2C)
-  #elif (defined(CONFIG_TSEC_ENET) || defined(CONFIG_ETHER_ON_FCC))
-    #define  CONFIG_COMMANDS	(CONFIG_CMD_DFL | CFG_CMD_MII | \
-				CFG_CMD_PING | CFG_CMD_I2C)
-  #endif
-#endif
-
-#include <cmd_confdefs.h>
-
-#undef CONFIG_WATCHDOG			/* watchdog disabled		*/
-
-/*
- * Miscellaneous configurable options
- */
-#define CFG_LONGHELP			/* undef to save memory		*/
-#define CFG_PROMPT	"SBC8560=> " /* Monitor Command Prompt	*/
-#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
-  #define CFG_CBSIZE	1024		/* Console I/O Buffer Size	*/
-#else
-  #define CFG_CBSIZE	256		/* Console I/O Buffer Size	*/
-#endif
-#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
-#define CFG_MAXARGS	16		/* max number of command args	*/
-#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size	*/
-#define CFG_LOAD_ADDR	0x1000000	/* default load address */
-#define CFG_HZ		1000		/* decrementer freq: 1 ms ticks */
-
-/*
- * For booting Linux, the board info and command line data
- * have to be in the first 8 MB of memory, since this is
- * the maximum mapped by the Linux kernel during initialization.
- */
-#define CFG_BOOTMAPSZ		(8 << 20) /* Initial Memory map for Linux */
-
-/* Cache Configuration */
-#define CFG_DCACHE_SIZE		32768
-#define CFG_CACHELINE_SIZE	32
-#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
-  #define CFG_CACHELINE_SHIFT	5	/* log base 2 of the above value */
-#endif
-
-/*
- * Internal Definitions
- *
- * Boot Flags
- */
-#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
-#define BOOTFLAG_WARM	0x02		/* Software reboot		*/
-
-#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
-  #define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
-  #define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
-#endif
-
-/*Note: change below for your network setting!!! */
-#if defined(CONFIG_TSEC_ENET) || defined(CONFIG_ETHER_ON_FCC)
-#  define CONFIG_ETHADDR	00:01:af:07:9b:8a
-#  define CONFIG_HAS_ETH1
-#  define CONFIG_ETH1ADDR	00:01:af:07:9b:8b
-#  define CONFIG_HAS_ETH2
-#  define CONFIG_ETH2ADDR	00:01:af:07:9b:8c
-#endif
-
-#define CONFIG_SERVERIP		192.168.0.131
-#define CONFIG_IPADDR		192.168.0.105
-#define CONFIG_GATEWAYIP	0.0.0.0
-#define CONFIG_NETMASK		255.255.255.0
-#define CONFIG_HOSTNAME		SBC8560
-#define CONFIG_ROOTPATH		/home/ppc
-#define CONFIG_BOOTFILE		pImage
-
-#endif	/* __CONFIG_H */
diff -Naur u-boot-1.1.2/include/cyc_env.h uboot-1.1.2hsv/include/cyc_env.h
--- u-boot-1.1.2/include/cyc_env.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/cyc_env.h	2007-05-29 16:51:02.000000000 -0500
@@ -0,0 +1,21 @@
+/*****************************************************************
+* File: cyc_env.h
+*
+* Copyright (C) 2003 Cyclades Corporation
+*
+* www.cyclades.com
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* as published by the Free Software Foundation; either version
+* 2 of the License, or (at your option) any later version.
+*
+* Description: API for u-boot enviroment variables
+*
+****************************************************************/
+
+char *cyc_set_env_ptr(char *ptr);
+int cyc_check_crc(void);
+void cyc_set_default_env(char *def_vars[]);
+int cyc_setenv (char *name, char *val);
+char *cyc_getenv (unsigned char *name);
diff -Naur u-boot-1.1.2/include/cyc_ide_cfg.h uboot-1.1.2hsv/include/cyc_ide_cfg.h
--- u-boot-1.1.2/include/cyc_ide_cfg.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/cyc_ide_cfg.h	2007-05-29 16:51:02.000000000 -0500
@@ -0,0 +1,35 @@
+/*-----------------------------------------------------------------------
+ * IDE/ATA stuff, for both KVMMAX and DEB
+ *-----------------------------------------------------------------------
+ */
+
+#ifndef _CYC_IDE_CFG_H
+#define _CYC_IDE_CFG_H
+
+#define CONFIG_MAC_PARTITION    1
+#define CONFIG_DOS_PARTITION    1
+#define CONFIG_ISO_PARTITION	1
+
+#define CONFIG_IDE_BYTESWAP	1
+#undef	CONFIG_ATAPI
+#undef  CONFIG_IDE_8xx_PCCARD		/* Use IDE with PC Card Adapter */
+#undef	CONFIG_IDE_8xx_DIRECT		/* Direct IDE	 not supported	*/
+#undef	CONFIG_IDE_LED			/* LED	 for ide not supported	*/
+#undef	CONFIG_IDE_RESET		/* reset for ide not supported	*/
+
+#define CFG_IDE_MAXBUS		1	/* max. 1 IDE busses	*/
+#define CFG_IDE_MAXDEVICE	CFG_IDE_MAXBUS /* max. 1 drive per IDE bus */
+
+#define CFG_ATA_BASE_ADDR	0xc0000000
+#define CFG_BR1_PRELIM   	0xc0001001
+#define CFG_OR1_PRELIM   	0xe0000f77
+
+#define CFG_ATA_STRIDE		2
+#define CFG_ATA_DATA_OFFSET	0
+#define	CFG_ATA_REG_OFFSET	1
+#define	CFG_ATA_ALT_OFFSET	0x11
+#define CFG_ATA_IDE0_OFFSET	0x0000
+
+#undef CONFIG_DISK_SPINUP_TIME	/* using Compact Flash */
+
+#endif /* _CYC_IDE_CFG_H */
diff -Naur u-boot-1.1.2/include/e500.h uboot-1.1.2hsv/include/e500.h
--- u-boot-1.1.2/include/e500.h	2004-08-01 18:03:10.000000000 -0500
+++ uboot-1.1.2hsv/include/e500.h	2007-05-29 16:51:02.000000000 -0500
@@ -48,10 +48,15 @@
  * esel(Entry Select): 0,1,2,...,15 for TLB1
  * nv(Next victim):0,1
  */
+/* cyclades: more safe define */
+/* #define TLB1_MAS0(tlbsel,esel,nv) \ */
+/* 			((((tlbsel) << 28) & MAS0_TLBSEL)       |\ */
+/* 			(((esel) << 16) & MAS0_ESEL )           |\ */
+/* 			(nv) ) */
 #define TLB1_MAS0(tlbsel,esel,nv) \
 			((((tlbsel) << 28) & MAS0_TLBSEL)       |\
 			(((esel) << 16) & MAS0_ESEL )           |\
-			(nv) )
+			((nv) & MAS0_NV) )
 
 
 /* MAS1
@@ -76,6 +81,17 @@
  * w,i,m,g,e(write-through,cache-inhibited,memory coherency,guarded,
  *      endianness):0,1
  */
+/* cyclades: more safe define */
+/* #define TLB1_MAS2(epn,sharen,x0,x1,w,i,m,g,e) \ */
+/* 			((((epn) << 12) & MAS2_EPN)             |\ */
+/* 			(((sharen) << 9) & MAS2_SHAREN)         |\ */
+/* 			(((x0) << 6) & MAS2_X0)                 |\ */
+/* 			(((x1) << 5) & MAS2_X1)                 |\ */
+/* 			(((w) << 4) & MAS2_W)                   |\ */
+/* 			(((i) << 3) & MAS2_I)                   |\ */
+/* 			(((m) << 2) & MAS2_M)                   |\ */
+/* 			(((g) << 1) & MAS2_G)                   |\ */
+/* 			(e) ) */
 #define TLB1_MAS2(epn,sharen,x0,x1,w,i,m,g,e) \
 			((((epn) << 12) & MAS2_EPN)             |\
 			(((sharen) << 9) & MAS2_SHAREN)         |\
@@ -85,7 +101,7 @@
 			(((i) << 3) & MAS2_I)                   |\
 			(((m) << 2) & MAS2_M)                   |\
 			(((g) << 1) & MAS2_G)                   |\
-			(e) )
+			((e) & MAS2_E) )
 
 
 /* MAS3
@@ -94,6 +110,19 @@
  * ux,sx,uw,sw,ur,sr(permission bits, user and supervisor read,
  *      write,execute permission).
  */
+/* cyclades: more safe define */
+/* #define TLB1_MAS3(rpn,u0,u1,u2,u3,ux,sx,uw,sw,ur,sr) \ */
+/* 			((((rpn) << 12) & MAS3_RPN)             |\ */
+/* 			(((u0) << 9) & MAS3_U0)                 |\ */
+/* 			(((u1) << 8) & MAS3_U1)                 |\ */
+/* 			(((u2) << 7) & MAS3_U2)                 |\ */
+/* 			(((u3) << 6) & MAS3_U3)                 |\ */
+/* 			(((ux) << 5) & MAS3_UX)                 |\ */
+/* 			(((sx) << 4) & MAS3_SX)                 |\ */
+/* 			(((uw) << 3) & MAS3_UW)                 |\ */
+/* 			(((sw) << 2) & MAS3_SW)                 |\ */
+/* 			(((ur) << 1) & MAS3_UR)                 |\ */
+/* 			(sr) ) */
 #define TLB1_MAS3(rpn,u0,u1,u2,u3,ux,sx,uw,sw,ur,sr) \
 			((((rpn) << 12) & MAS3_RPN)             |\
 			(((u0) << 9) & MAS3_U0)                 |\
@@ -105,7 +134,7 @@
 			(((uw) << 3) & MAS3_UW)                 |\
 			(((sw) << 2) & MAS3_SW)                 |\
 			(((ur) << 1) & MAS3_UR)                 |\
-			(sr) )
+			((sr) & MAS3_SR) )
 
 
 #define RESET_VECTOR	0xfffffffc
diff -Naur u-boot-1.1.2/include/jffs2/compr_rubin.h uboot-1.1.2hsv/include/jffs2/compr_rubin.h
--- u-boot-1.1.2/include/jffs2/compr_rubin.h	2002-03-08 15:31:11.000000000 -0600
+++ uboot-1.1.2hsv/include/jffs2/compr_rubin.h	2007-05-29 16:51:02.000000000 -0500
@@ -1,7 +1,7 @@
 /* Rubin encoder/decoder header       */
 /* work started at   : aug   3, 1994  */
 /* last modification : aug  15, 1994  */
-/* $Id: compr_rubin.h,v 1.1 2002/01/16 23:34:32 nyet Exp $ */
+/* $Id: compr_rubin.h,v 1.1.1.1 2005/02/05 03:15:32 yang Exp $ */
 
 #define RUBIN_REG_SIZE   16
 #define UPPER_BIT_RUBIN    (((long) 1)<<(RUBIN_REG_SIZE-1))
diff -Naur u-boot-1.1.2/include/jffs2/jffs2.h uboot-1.1.2hsv/include/jffs2/jffs2.h
--- u-boot-1.1.2/include/jffs2/jffs2.h	2004-01-04 10:28:36.000000000 -0600
+++ uboot-1.1.2hsv/include/jffs2/jffs2.h	2007-05-29 16:51:02.000000000 -0500
@@ -31,7 +31,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: jffs2.h,v 1.2 2002/01/17 00:53:20 nyet Exp $
+ * $Id: jffs2.h,v 1.1.1.1 2005/02/05 03:15:32 yang Exp $
  *
  */
 
diff -Naur u-boot-1.1.2/include/jffs2/load_kernel.h uboot-1.1.2hsv/include/jffs2/load_kernel.h
--- u-boot-1.1.2/include/jffs2/load_kernel.h	2002-11-02 18:56:52.000000000 -0600
+++ uboot-1.1.2hsv/include/jffs2/load_kernel.h	2007-05-29 16:51:02.000000000 -0500
@@ -2,7 +2,7 @@
 #define load_kernel_h
 /*-------------------------------------------------------------------------
  * Filename:      load_kernel.h
- * Version:       $Id: load_kernel.h,v 1.3 2002/01/25 01:34:11 nyet Exp $
+ * Version:       $Id: load_kernel.h,v 1.1.1.1 2005/02/05 03:15:32 yang Exp $
  * Copyright:     Copyright (C) 2001, Russ Dill
  * Author:        Russ Dill <Russ.Dill@asu.edu>
  * Description:   header for load kernel modules
diff -Naur u-boot-1.1.2/include/jffs2/mini_inflate.h uboot-1.1.2hsv/include/jffs2/mini_inflate.h
--- u-boot-1.1.2/include/jffs2/mini_inflate.h	2002-03-08 15:31:11.000000000 -0600
+++ uboot-1.1.2hsv/include/jffs2/mini_inflate.h	2007-05-29 16:51:02.000000000 -0500
@@ -1,6 +1,6 @@
 /*-------------------------------------------------------------------------
  * Filename:      mini_inflate.h
- * Version:       $Id: mini_inflate.h,v 1.2 2002/01/17 00:53:20 nyet Exp $
+ * Version:       $Id: mini_inflate.h,v 1.1.1.1 2005/02/05 03:15:32 yang Exp $
  * Copyright:     Copyright (C) 2001, Russ Dill
  * Author:        Russ Dill <Russ.Dill@asu.edu>
  * Description:   Mini deflate implementation
diff -Naur u-boot-1.1.2/include/linux/byteorder/swab.h uboot-1.1.2hsv/include/linux/byteorder/swab.h
--- u-boot-1.1.2/include/linux/byteorder/swab.h	2004-02-06 19:27:18.000000000 -0600
+++ uboot-1.1.2hsv/include/linux/byteorder/swab.h	2007-05-29 16:50:58.000000000 -0500
@@ -1,6 +1,8 @@
 #ifndef _LINUX_BYTEORDER_SWAB_H
 #define _LINUX_BYTEORDER_SWAB_H
 
+#define __attribute_const__
+
 /*
  * linux/byteorder/swab.h
  * Byte-swapping, independently from CPU endianness
@@ -96,7 +98,7 @@
 #endif /* OPTIMIZE */
 
 
-static __inline__ __const__ __u16 __fswab16(__u16 x)
+static __inline__ __attribute_const__ __u16 __fswab16(__u16 x)
 {
 	return __arch__swab16(x);
 }
@@ -109,7 +111,7 @@
 	__arch__swab16s(addr);
 }
 
-static __inline__ __const__ __u32 __fswab32(__u32 x)
+static __inline__ __attribute_const__ __u32 __fswab32(__u32 x)
 {
 	return __arch__swab32(x);
 }
@@ -123,7 +125,7 @@
 }
 
 #ifdef __BYTEORDER_HAS_U64__
-static __inline__ __const__ __u64 __fswab64(__u64 x)
+static __inline__ __attribute_const__ __u64 __fswab64(__u64 x)
 {
 #  ifdef __SWAB_64_THRU_32__
 	__u32 h = x >> 32;
diff -Naur u-boot-1.1.2/include/linux/mtd/doc2000.h uboot-1.1.2hsv/include/linux/mtd/doc2000.h
--- u-boot-1.1.2/include/linux/mtd/doc2000.h	2003-03-26 05:45:56.000000000 -0600
+++ uboot-1.1.2hsv/include/linux/mtd/doc2000.h	2007-05-29 16:50:58.000000000 -0500
@@ -2,7 +2,7 @@
 /* Linux driver for Disk-On-Chip 2000       */
 /* (c) 1999 Machine Vision Holdings, Inc.   */
 /* Author: David Woodhouse <dwmw2@mvhi.com> */
-/* $Id: doc2000.h,v 1.15 2001/09/19 00:22:15 dwmw2 Exp $ */
+/* $Id: doc2000.h,v 1.1.1.1 2005/02/05 03:15:32 yang Exp $ */
 
 #ifndef __MTD_DOC2000_H__
 #define __MTD_DOC2000_H__
diff -Naur u-boot-1.1.2/include/linux/mtd/nand.h uboot-1.1.2hsv/include/linux/mtd/nand.h
--- u-boot-1.1.2/include/linux/mtd/nand.h	2003-09-11 14:50:28.000000000 -0500
+++ uboot-1.1.2hsv/include/linux/mtd/nand.h	2007-05-29 16:50:58.000000000 -0500
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@cotw.com>
  *		       Thomas Gleixner <gleixner@autronix.de>
  *
- * $Id: nand.h,v 1.7 2003/07/24 23:30:46 a0384864 Exp $
+ * $Id: nand.h,v 1.1.1.1 2005/02/05 03:15:32 yang Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Naur u-boot-1.1.2/include/linux/mtd/nand_ids.h uboot-1.1.2hsv/include/linux/mtd/nand_ids.h
--- u-boot-1.1.2/include/linux/mtd/nand_ids.h	2003-05-31 13:35:29.000000000 -0500
+++ uboot-1.1.2hsv/include/linux/mtd/nand_ids.h	2007-05-29 16:50:58.000000000 -0500
@@ -4,7 +4,7 @@
  *  Copyright (c) 2000 David Woodhouse <dwmw2@mvhi.com>
  *                     Steven J. Hill <sjhill@cotw.com>
  *
- * $Id: nand_ids.h,v 1.1 2000/10/13 16:16:26 mdeans Exp $
+ * $Id: nand_ids.h,v 1.1.1.1 2005/02/05 03:15:32 yang Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff -Naur u-boot-1.1.2/include/linux/mtd/nftl.h uboot-1.1.2hsv/include/linux/mtd/nftl.h
--- u-boot-1.1.2/include/linux/mtd/nftl.h	2003-06-27 16:32:46.000000000 -0500
+++ uboot-1.1.2hsv/include/linux/mtd/nftl.h	2007-05-29 16:50:58.000000000 -0500
@@ -2,7 +2,7 @@
 /* Defines for NAND Flash Translation Layer  */
 /* (c) 1999 Machine Vision Holdings, Inc.    */
 /* Author: David Woodhouse <dwmw2@mvhi.com>  */
-/* $Id: nftl.h,v 1.10 2000/12/29 00:25:38 dwmw2 Exp $ */
+/* $Id: nftl.h,v 1.1.1.1 2005/02/05 03:15:32 yang Exp $ */
 
 #ifndef __MTD_NFTL_H__
 #define __MTD_NFTL_H__
diff -Naur u-boot-1.1.2/include/linux_logo.h uboot-1.1.2hsv/include/linux_logo.h
--- u-boot-1.1.2/include/linux_logo.h	2002-09-17 16:45:40.000000000 -0500
+++ uboot-1.1.2hsv/include/linux_logo.h	2007-05-29 16:51:02.000000000 -0500
@@ -1,4 +1,4 @@
-/* $Id: linux_logo.h,v 1.5 1998/07/30 16:30:58 jj Exp $
+/* $Id: linux_logo.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * include/linux/linux_logo.h: This is a linux logo
  *                             to be displayed on boot.
  *
diff -Naur u-boot-1.1.2/include/lxt971a.h uboot-1.1.2hsv/include/lxt971a.h
--- u-boot-1.1.2/include/lxt971a.h	2004-08-02 18:39:05.000000000 -0500
+++ uboot-1.1.2hsv/include/lxt971a.h	2007-05-29 16:51:02.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_eth.h,v 1.2 2004/02/24 13:25:39 mpietrek Exp $
+ * $Id: lxt971a.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @References: [1] NS9750 Hardware Reference, December 2003
  *              [2] Intel LXT971 Datasheet #249414 Rev. 02
diff -Naur u-boot-1.1.2/include/marvell/Copyright.h uboot-1.1.2hsv/include/marvell/Copyright.h
--- u-boot-1.1.2/include/marvell/Copyright.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/Copyright.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,17 @@
+/*******************************************************************************
+*                Copyright 2000 ~ 2005, Marvell International Ltd.
+* This code contains confidential information of Marvell semiconductor, inc.
+* no rights are granted herein under any patent, mask work right or copyright
+* of Marvell or any third party.
+* Marvell reserves the right at its sole discretion to request that this code
+* be immediately returned to Marvell. This code is provided "as is".
+* Marvell makes no warranties, express, implied or otherwise, regarding its
+* accuracy, completeness or performance.
+*******************************************************************************/
+#ifndef _msCopyright_h
+#define _msCopyright_h
+
+#define MSAPI_COPYRIGHT "Copyright 2000~2005, Marvell International Ltd."
+#define MSAPI_VERSION "2.3b"
+
+#endif /* _msCopyright_h */
diff -Naur u-boot-1.1.2/include/marvell/gtDrvConfig.h uboot-1.1.2hsv/include/marvell/gtDrvConfig.h
--- u-boot-1.1.2/include/marvell/gtDrvConfig.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/gtDrvConfig.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,80 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtDrvConfig.h
+*
+* DESCRIPTION:
+*       Includes driver level configuration and initialization function.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#ifndef __gtDrvConfigh
+#define __gtDrvConfigh
+
+#include <marvell/msApi.h>
+#include <marvell/gtDrvSwRegs.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+* driverConfig
+*
+* DESCRIPTION:
+*       This function initializes the driver level of the quarterDeck software.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success, or
+*       GT_OUT_OF_CPU_MEM   - if failed to allocate CPU memory,
+*       GT_FAIL             - otherwise.
+*
+* COMMENTS:
+*       1.  This function should perform the following:
+*           -   Initialize the global switch configuration structure.
+*           -   Initialize Mii Interface
+*           -   Set the CPU port into trailer mode (Ingress and Egress).
+*
+*******************************************************************************/
+GT_STATUS driverConfig(IN GT_QD_DEV *dev);
+
+/*******************************************************************************
+* driverEnable
+*
+* DESCRIPTION:
+*       This function enables the switch for full operation, after the driver
+*       Config function was called.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL othrwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS driverEnable(IN GT_QD_DEV *dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtDrvConfigh */
diff -Naur u-boot-1.1.2/include/marvell/gtDrvEvents.h uboot-1.1.2hsv/include/marvell/gtDrvEvents.h
--- u-boot-1.1.2/include/marvell/gtDrvEvents.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/gtDrvEvents.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,87 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtDrvEvents.h
+*
+* DESCRIPTION:
+*       This file includes function declarations for QuarterDeck interrupts
+*       configuration and handling.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#ifndef __gtDrvEventsh
+#define __gtDrvEventsh
+
+#include <marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+* drvEventInit
+*
+* DESCRIPTION:
+*       This function initializes the driver's interrupt handling mechanism.
+*
+* INPUTS:
+*       intVecNum   - The interrupt vector the switch is connected to.
+*       isrFunc     - A pointer to the Interrupt Service Routine to be
+*                     connected to the given interrupt vector.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success,
+*       GT_FAIL - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS drvEventsInit
+(
+    IN  GT_QD_DEV     *dev,
+    IN GT_U32         intVecNum,
+    IN GT_VOIDFUNCPTR isrFunc
+);
+
+
+
+/*******************************************************************************
+* eventQdSr
+*
+* DESCRIPTION:
+*       QuarterDeck interrupt service routine.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL eventQdSr
+(
+	IN  GT_QD_DEV  *dev,
+	OUT GT_U16*    intCause
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtDrvEventsh */
diff -Naur u-boot-1.1.2/include/marvell/gtDrvSwRegs.h uboot-1.1.2hsv/include/marvell/gtDrvSwRegs.h
--- u-boot-1.1.2/include/marvell/gtDrvSwRegs.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/gtDrvSwRegs.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,178 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+ * * gtDrvSwRegs.h
+ * *
+ * * DESCRIPTION:
+ * *       definitions of the register map of QuarterDeck Device
+ * *
+ * * DEPENDENCIES:
+ * *
+ * * FILE REVISION NUMBER:
+ * *
+ * *******************************************************************************/
+#ifndef __gtDrvSwRegsh
+#define __gtDrvSwRegsh
+
+/* QuarterDeck Per Port Registers */
+#define QD_REG_PORT_STATUS		0x0
+#define QD_REG_PCS_CONTROL		0x1		/* for Sapphire family */
+#define QD_REG_SWITCH_ID		0x3
+#define QD_REG_PORT_CONTROL		0x4
+#define QD_REG_PORT_CONTROL1		0x5
+#define QD_REG_PORT_VLAN_MAP		0x6
+#define QD_REG_PVID			0x7
+#define QD_REG_PORT_CONTROL2		0x8	/* for Sapphire family */
+#define QD_REG_INGRESS_RATE_CTRL	0x9	/* for Sapphire family */
+#define QD_REG_EGRESS_RATE_CTRL		0xA	/* for Sapphire family */
+#define QD_REG_RATE_CTRL		0xA
+#define QD_REG_PAV			0xB
+#define QD_REG_RX_COUNTER		0x10
+#define QD_REG_TX_COUNTER		0x11
+
+#define QD_REG_INDISCARD_LO_COUNTER		0x10
+#define QD_REG_INDISCARD_HI_COUNTER		0x11
+#define QD_REG_INFILTERED_COUNTER		0x12
+#define QD_REG_OUTFILTERED_COUNTER		0x13
+
+#define QD_REG_Q_COUNTER		0x1B
+#define QD_REG_RATE_CONTROL		0x0A
+#define QD_REG_PORT_ASSOCIATION		0x0B
+#define QD_REG_IEEE_PRI_REMAP_3_0	0x18	/* for Sapphire family */
+#define QD_REG_IEEE_PRI_REMAP_7_4	0x19	/* for Sapphire family */
+
+
+/* QuarterDeck Global Registers */
+#define QD_REG_GLOBAL_STATUS		0x0
+#define QD_REG_MACADDR_01		0x1
+#define QD_REG_MACADDR_23		0x2
+#define QD_REG_MACADDR_45		0x3
+#define QD_REG_GLOBAL_CONTROL		0x4
+#define QD_REG_GLOBAL_CONTROL2		0x1C	/* for Sapphire family */
+#define QD_REG_CORETAG_TYPE		0x19		/* for Ruby family */
+#define QD_REG_MONITOR_CONTROL	0x1A		/* for Ruby family */
+
+/* QuarterDeck Global 2 Registers */
+#define QD_REG_MGMT_ENABLE		0x3
+#define QD_REG_FLOWCTRL_DELAY	0x4
+#define QD_REG_MANAGEMENT		0x5
+#define QD_REG_ROUTING_TBL		0x6
+#define QD_REG_TRUNK_MASK_TBL	0x7
+#define QD_REG_TRUNK_ROUTING	0x8
+
+/* the following VTU entries are added for Fullsail and Clippership */
+#define QD_REG_VTU_OPERATION		0x5
+#define QD_REG_VTU_VID_REG		0x6
+#define QD_REG_VTU_DATA1_REG		0x7
+#define QD_REG_VTU_DATA2_REG		0x8
+#define QD_REG_VTU_DATA3_REG		0x9
+#define QD_REG_STATS_OPERATION		0x1D
+#define QD_REG_STATS_COUNTER3_2		0x1E
+#define QD_REG_STATS_COUNTER1_0		0x1F
+ 
+
+#define QD_REG_ATU_CONTROL		0xA
+#define QD_REG_ATU_OPERATION		0xB
+#define QD_REG_ATU_DATA_REG		0xC
+#define QD_REG_ATU_MAC_BASE		0xD
+#define QD_REG_IP_PRI_BASE		0x10
+#define QD_REG_IEEE_PRI			0x18
+
+/* Definitions for MIB Counter */
+#define GT_STATS_NO_OP			0x0
+#define GT_STATS_FLUSH_ALL		0x1
+#define GT_STATS_FLUSH_PORT		0x2
+#define GT_STATS_READ_COUNTER		0x4
+#define GT_STATS_CAPTURE_PORT		0x5
+
+#define QD_PHY_CONTROL_REG			0
+#define QD_PHY_AUTONEGO_AD_REG			4
+#define QD_PHY_NEXTPAGE_TX_REG			7
+#define QD_PHY_SPEC_CONTROL_REG			16
+#define QD_PHY_INT_ENABLE_REG			18
+#define QD_PHY_INT_STATUS_REG			19
+#define QD_PHY_INT_PORT_SUMMARY_REG		20
+
+/* Bit Definition for QD_PHY_CONTROL_REG */
+#define QD_PHY_RESET			0x8000
+#define QD_PHY_LOOPBACK			0x4000
+#define QD_PHY_SPEED			0x2000
+#define QD_PHY_AUTONEGO			0x1000
+#define QD_PHY_POWER			0x800
+#define QD_PHY_ISOLATE			0x400
+#define QD_PHY_RESTART_AUTONEGO		0x200
+#define QD_PHY_DUPLEX			0x100
+
+#define QD_PHY_POWER_BIT			11
+#define QD_PHY_RESTART_AUTONEGO_BIT		9
+
+/* Bit Definition for QD_PHY_AUTONEGO_AD_REG */
+#define QD_PHY_NEXTPAGE			0x8000
+#define QD_PHY_REMOTEFAULT		0x4000
+#define QD_PHY_PAUSE			0x400
+#define QD_PHY_100_FULL			0x100
+#define QD_PHY_100_HALF			0x80
+#define QD_PHY_10_FULL			0x40
+#define QD_PHY_10_HALF			0x20
+
+#define QD_PHY_MODE_AUTO_AUTO	(QD_PHY_100_FULL | QD_PHY_100_HALF | QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_100_AUTO	(QD_PHY_100_FULL | QD_PHY_100_HALF)
+#define QD_PHY_MODE_10_AUTO		(QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_AUTO_FULL	(QD_PHY_100_FULL | QD_PHY_10_FULL)
+#define QD_PHY_MODE_AUTO_HALF	(QD_PHY_100_HALF | QD_PHY_10_HALF)
+
+#define QD_PHY_MODE_100_FULL	QD_PHY_100_FULL
+#define QD_PHY_MODE_100_HALF	QD_PHY_100_HALF
+#define QD_PHY_MODE_10_FULL		QD_PHY_10_FULL	
+#define QD_PHY_MODE_10_HALF		QD_PHY_10_HALF	
+
+/* Gigabit Phy related definition */
+#define QD_GIGPHY_1000X_FULL_CAP	0x8
+#define QD_GIGPHY_1000X_HALF_CAP	0x4
+#define QD_GIGPHY_1000T_FULL_CAP	0x2
+#define QD_GIGPHY_1000T_HALF_CAP	0x1
+
+#define QD_GIGPHY_1000X_CAP		(QD_GIGPHY_1000X_FULL_CAP|QD_GIGPHY_1000X_HALF_CAP)
+#define QD_GIGPHY_1000T_CAP		(QD_GIGPHY_1000T_FULL_CAP|QD_GIGPHY_1000T_HALF_CAP)
+
+#define QD_GIGPHY_1000X_FULL		0x20
+#define QD_GIGPHY_1000X_HALF		0x40
+
+#define QD_GIGPHY_1000T_FULL		0x200
+#define QD_GIGPHY_1000T_HALF		0x100
+
+/* Bit definition for QD_PHY_INT_ENABLE_REG */
+#define QD_PHY_INT_SPEED_CHANGED		0x4000
+#define QD_PHY_INT_DUPLEX_CHANGED		0x2000
+#define QD_PHY_INT_PAGE_RECEIVED		0x1000
+#define QD_PHY_INT_AUTO_NEG_COMPLETED		0x800
+#define QD_PHY_INT_LINK_STATUS_CHANGED		0x400
+#define QD_PHY_INT_SYMBOL_ERROR			0x200
+#define QD_PHY_INT_FALSE_CARRIER		0x100
+#define QD_PHY_INT_FIFO_FLOW			0x80
+#define QD_PHY_INT_CROSSOVER_CHANGED		0x40
+#define QD_PHY_INT_POLARITY_CHANGED		0x2
+#define QD_PHY_INT_JABBER			0x1
+
+/* Definition for Multi Address Mode */
+#define QD_REG_SMI_COMMAND		0x0
+#define QD_REG_SMI_DATA			0x1
+
+/* Bit definition for QD_REG_SMI_COMMAND */
+#define QD_SMI_BUSY				0x8000
+#define QD_SMI_MODE				0x1000
+#define QD_SMI_MODE_BIT			12
+#define QD_SMI_OP_BIT			10
+#define QD_SMI_OP_SIZE			2
+#define QD_SMI_DEV_ADDR_BIT		5
+#define QD_SMI_DEV_ADDR_SIZE	5
+#define QD_SMI_REG_ADDR_BIT		0
+#define QD_SMI_REG_ADDR_SIZE	5
+
+#define QD_SMI_CLAUSE45			0
+#define QD_SMI_CLAUSE22			1
+
+#define QD_SMI_WRITE			0x01
+#define QD_SMI_READ				0x02
+
+#endif /* __gtDrvSwRegsh */
diff -Naur u-boot-1.1.2/include/marvell/gtHwCntl.h uboot-1.1.2hsv/include/marvell/gtHwCntl.h
--- u-boot-1.1.2/include/marvell/gtHwCntl.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/gtHwCntl.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,701 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtHwCntl.h
+*
+* DESCRIPTION:
+*       Functions declarations for Hw accessing quarterDeck phy, internal and
+*       global registers.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#ifndef __gtHwCntlh
+#define __gtHwCntlh
+
+#include <marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This macro is used to calculate the register's SMI   */
+/* device address, according to the baseAddr            */
+/* field in the Switch configuration struct.            */
+#define CALC_SMI_DEV_ADDR(_dev, _portNum, _accessType)        \
+            portToSmiMapping(_dev, _portNum, _accessType)
+
+/* This macro calculates the mask for partial read /    */
+/* write of register's data.                            */
+#define CALC_MASK(fieldOffset,fieldLen,mask)        \
+            if((fieldLen + fieldOffset) >= 16)      \
+                mask = (0 - (1 << fieldOffset));    \
+            else                                    \
+                mask = (((1 << (fieldLen + fieldOffset))) - (1 << fieldOffset))
+
+/* Start address of phy related register.               */
+#define PHY_REGS_START_ADDR     0x0
+#define PHY_REGS_START_ADDR_8PORT	0x0
+
+/* Start address of ports related register.             */
+#define PORT_REGS_START_ADDR    	0x8
+#define PORT_REGS_START_ADDR_8PORT	0x10
+
+/* Start address of global register.                    */
+#define GLOBAL_REGS_START_ADDR  0xF
+#define GLOBAL_REGS_START_ADDR_8PORT  0x1B
+
+#define PHY_ACCESS			1
+#define PORT_ACCESS			2
+#define GLOBAL_REG_ACCESS	3
+#define GLOBAL2_REG_ACCESS	4
+
+/****************************************************************************/
+/* Phy registers related functions.                                         */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadPhyReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port phy register.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWritePhyReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port phy register.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetPhyRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port phy register.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPhyRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetPhyRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port phy register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPhyRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+
+/****************************************************************************/
+/* Per port registers related functions.                                    */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadPortReg
+*
+* DESCRIPTION:
+*       This function reads a switch's port register.
+*
+* INPUTS:
+*       portNum - Port number to read the register for.
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadPortReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWritePortReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's port register.
+*
+* INPUTS:
+*       portNum - Port number to write the register for.
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWritePortReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetPortRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to read the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetPortRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetPortRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's port register.
+*
+* INPUTS:
+*       portNum     - Port number to write the register for.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetPortRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     portNum,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+
+/****************************************************************************/
+/* Global registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadGlobalReg
+*
+* DESCRIPTION:
+*       This function reads a switch's global register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobalReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWriteGlobalReg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobalReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetGlobalRegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobalRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetGlobalRegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobalRegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+
+/****************************************************************************/
+/* Global 2 registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadGlobal2Reg
+*
+* DESCRIPTION:
+*       This function reads a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobal2Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWriteGlobal2Reg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobal2Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetGlobal2RegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobal2RegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetGlobal2RegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global 2 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal2RegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwReadMiiReg
+*
+* DESCRIPTION:
+*       This function reads a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadMiiReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWriteMiiReg
+*
+* DESCRIPTION:
+*       This function writes a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteMiiReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+/*******************************************************************************
+* hwReadPPU
+*
+* DESCRIPTION:
+*			This function reads PPU bit in Global Register
+*
+* INPUTS:
+*			None.
+*
+* OUTPUTS:
+*			data    - The read register's data.
+*
+* RETURNS:
+*			GT_OK on success, or
+*			GT_FAIL otherwise.
+*
+* COMMENTS:
+*			This function can be used to access PHY register connected to Gigabit
+*			Switch.
+*
+*******************************************************************************/
+GT_STATUS hwReadPPU
+(
+	IN  GT_QD_DEV *dev,
+	OUT GT_U16    *data
+);
+
+/*******************************************************************************
+* hwWritePPU
+*
+* DESCRIPTION:
+*			This function writes PPU bit in Global Register
+*
+* INPUTS:
+*			data - The value to write into PPU bit
+*
+* OUTPUTS:
+*			None.
+*
+* RETURNS:
+*			GT_OK on success, or
+*			GT_FAIL otherwise.
+*
+* COMMENTS:
+*			This function can be used to access PHY register connected to Gigabit
+*			Switch.
+*
+*******************************************************************************/
+GT_STATUS hwWritePPU
+(
+	IN  GT_QD_DEV *dev,
+	IN  GT_U16    data
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __gtHwCntlh */
diff -Naur u-boot-1.1.2/include/marvell/gtMiiSmiIf.h uboot-1.1.2hsv/include/marvell/gtMiiSmiIf.h
--- u-boot-1.1.2/include/marvell/gtMiiSmiIf.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/gtMiiSmiIf.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,156 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtMiiSmiIf.h
+*
+* DESCRIPTION:
+*       Includes functions prototypes for initializing and accessing the
+*       MII / SMI interface.
+*       This is the only file to be included from upper layers.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*
+*******************************************************************************/
+
+#ifndef __gtMiiSmiIfh
+#define __gtMiiSmiIfh
+
+
+#include <marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+* miiSmiIfInit
+*
+* DESCRIPTION:
+*       This function initializes the MII / SMI interface.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       highSmiDevAddr - Indicates whether to use the high device register
+*                     addresses when accessing switch's registers (of all kinds)
+*                     i.e, the devices registers range is 0x10 to 0x1F, or to
+*                     use the low device register addresses (range 0x0 to 0xF).
+*                       GT_TRUE     - use high addresses (0x10 to 0x1F).
+*                       GT_FALSE    - use low addresses (0x0 to 0xF).
+*
+* RETURNS:
+*       DEVICE_ID       - on success
+*       0     - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U16 miiSmiIfInit
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   * highSmiDevAddr
+);
+
+/*******************************************************************************
+* miiSmiManualIfInit
+*
+* DESCRIPTION:
+*       This function returns Device ID from the given base address
+*
+* INPUTS:
+*       baseAddr - either 0x0 or 0x10. Indicates whether to use the low device 
+*					register address or high device register address.
+*					The device register range is from 0x0 to 0xF or from 0x10 
+*					to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port 
+*					switchs.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       DEVICE_ID       - on success
+*       0    - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_U16 miiSmiManualIfInit
+(
+	IN  GT_QD_DEV   *dev,
+	IN  GT_U32		baseAddr
+);
+
+/*******************************************************************************
+* miiSmiIfReadRegister
+*
+* DESCRIPTION:
+*       This function reads a register throw the SMI / MII interface, to be used
+*       by upper layers.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*
+* OUTPUTS:
+*       data        - The register's data.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS miiSmiIfReadRegister
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* miiSmiIfWriteRegister
+*
+* DESCRIPTION:
+*       This function writes to a register throw the SMI / MII interface, to be
+*       used by upper layers.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       data        - The data to be written to the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS miiSmiIfWriteRegister
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtMiiSmiIfh */
diff -Naur u-boot-1.1.2/include/marvell/gtSem.h uboot-1.1.2hsv/include/marvell/gtSem.h
--- u-boot-1.1.2/include/marvell/gtSem.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/gtSem.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,153 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* gtOs.h
+*
+* DESCRIPTION:
+*       Operating System wrapper
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.2 $
+*******************************************************************************/
+
+#ifndef __gtSemh
+#define __gtSemh
+
+#include <marvell/msApi.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***** Defines  ********************************************************/
+
+#define OS_WAIT_FOREVER             0
+
+#define OS_MAX_TASKS                30
+#define OS_MAX_TASK_NAME_LENGTH     10
+
+#define OS_MAX_QUEUES               30
+#define OS_MAX_QUEUE_NAME_LENGTH    10
+
+#define OS_MAX_EVENTS               10
+
+#define OS_MAX_SEMAPHORES           50
+
+#define OS_EOF                      (-1)
+
+
+/*******************************************************************************
+* gtSemCreate
+*
+* DESCRIPTION:
+*       Create semaphore.
+*
+* INPUTS:
+*		state - beginning state of the semaphore, either SEM_EMPTY or SEM_FULL
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_SEM if success. Otherwise, NULL
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_SEM gtSemCreate
+(
+	IN GT_QD_DEV    *dev,
+	IN GT_SEM_BEGIN_STATE state
+);
+
+/*******************************************************************************
+* gtSemDelete
+*
+* DESCRIPTION:
+*       Delete semaphore.
+*
+* INPUTS:
+*       smid - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemDelete
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM       smid
+);
+
+/*******************************************************************************
+* gtSemTake
+*
+* DESCRIPTION:
+*       Wait for semaphore.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*       timeOut - time out in miliseconds or 0 to wait forever
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       OS_TIMEOUT - on time out
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemTake
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM       smid,
+    IN GT_U32       timeOut
+);
+
+/*******************************************************************************
+* gtSemGive
+*
+* DESCRIPTION:
+*       release the semaphore which was taken previously.
+*
+* INPUTS:
+*       smid    - semaphore Id
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemGive
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_SEM       smid
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* __gtSemh */
+/* Do Not Add Anything Below This Line */
diff -Naur u-boot-1.1.2/include/marvell/gtVct.h uboot-1.1.2hsv/include/marvell/gtVct.h
--- u-boot-1.1.2/include/marvell/gtVct.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/gtVct.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,64 @@
+/*******************************************************************************
+*              Copyright 2002, GALILEO TECHNOLOGY, LTD.
+*
+* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL. NO RIGHTS ARE GRANTED
+* HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT OF MARVELL OR ANY THIRD
+* PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE DISCRETION TO REQUEST THAT THIS
+* CODE BE IMMEDIATELY RETURNED TO MARVELL. THIS CODE IS PROVIDED "AS IS".
+* MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED OR OTHERWISE, REGARDING ITS
+* ACCURACY, COMPLETENESS OR PERFORMANCE. MARVELL COMPRISES MARVELL TECHNOLOGY
+* GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, MARVELL INTERNATIONAL LTD. (MIL),
+* MARVELL TECHNOLOGY, INC. (MTI), MARVELL SEMICONDUCTOR, INC. (MSI), MARVELL
+* ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K. (MJKK), GALILEO TECHNOLOGY LTD. (GTL)
+* AND GALILEO TECHNOLOGY, INC. (GTI).
+********************************************************************************
+* gtVct.h
+*
+* DESCRIPTION:
+*       API definitions for Marvell Virtual Cable Tester functionality.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*******************************************************************************/
+
+#ifndef __gtVcth
+#define __gtVcth
+
+#include "msApi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MARVELL_OUI_MSb		0x0141
+#define MARVELL_OUI_LSb		0x0C00
+#define OUI_LSb_MASK		0xFC00
+#define PHY_MODEL_MASK		0x03F0
+#define PHY_REV_MASK		0x000F
+
+#define DEV_E3082		0x8 << 4
+#define DEV_E104X		0x2 << 4
+#define DEV_E1111		0xC << 4
+#define DEV_E1112		0x9 << 4
+#define DEV_E114X		0xD << 4
+#define DEV_E1149		0xA << 4
+#define DEV_E1180		0xE << 4
+#define DEV_EC010		0x3 << 4
+
+/* definition for formula to calculate actual distance */
+#ifdef FP_SUPPORT
+#define FORMULA_PHY100M(_data)	((_data)*0.7861 - 18.862)
+#define FORMULA_PHY1000M(_data)	((_data)*0.8018 - 28.751)
+#else
+#define FORMULA_PHY100M(_data)	(((long)(_data)*7861 - 188620)/10000 + (((((long)(_data)*7861 - 188620)%10000) >= 5000)?1:0))
+#define FORMULA_PHY1000M(_data)	(((long)(_data)*8018 - 287510)/10000 + (((((long)(_data)*8018 - 287510)%10000) >= 5000)?1:0))
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gtVcth */
diff -Naur u-boot-1.1.2/include/marvell/msApiDefs.h uboot-1.1.2hsv/include/marvell/msApiDefs.h
--- u-boot-1.1.2/include/marvell/msApiDefs.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/msApiDefs.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,1365 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* msApiDefs.h
+*
+* DESCRIPTION:
+*       API definitions for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiDefs_h
+#define __msApiDefs_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <marvell/msApiTypes.h>
+/* Debug function   */
+
+#ifdef DEBUG_QD
+#define DBG_INFO(x) gtDbgPrint x
+#else
+#define DBG_INFO(x);
+#endif /* DEBUG_QD */
+
+typedef GT_U32 GT_SEM;
+
+#define ETHERNET_HEADER_SIZE	GT_ETHERNET_HEADER_SIZE
+#define IS_MULTICAST_MAC		GT_IS_MULTICAST_MAC
+#define IS_BROADCAST_MAC		GT_IS_BROADCAST_MAC
+
+/*
+ *   Logical Port value based on a Port
+ *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |0|  reserved                                   |    port       |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ *
+ *   The following macros should be used to extract specific info
+ *   from a Logical Port index
+ */
+typedef GT_U32 GT_LPORT;
+
+
+/* Define the different device type that may exist in system        */
+typedef enum
+{
+    GT_88E6021  = 0x021,
+    GT_88E6051  = 0x051,
+    GT_88E6052  = 0x052,
+    GT_88E6060  = 0x060,
+    GT_88E6063	= 0x153,
+    GT_FH_VPN	= 0xF53,
+    GT_FF_EG	= 0xF91,
+    GT_FF_HG	= 0xF93,
+	GT_88E6083	= 0x083,
+	GT_88E6181	= 0x1A0,
+	GT_88E6153	= 0x1A1,
+	GT_88E6183	= 0x1A3,
+	GT_88E6093	= 0x093,
+	GT_88E6092	= 0x097,
+	GT_88E6095	= 0x095,
+	GT_88E6152	= 0x1A4,
+	GT_88E6155	= 0x1A5,
+	GT_88E6182	= 0x1A6,
+	GT_88E6185	= 0x1A7
+}GT_DEVICE;
+
+typedef enum
+{
+    INTR_MODE_DISABLE =0,
+    INTR_MODE_ENABLE
+}INTERRUPT_MODE;
+
+typedef enum
+{
+	PORT_SPEED_10_MBPS,
+	PORT_SPEED_100_MBPS,
+	PORT_SPEED_1000_MBPS
+} GT_PORT_SPEED_MODE;
+
+typedef enum
+{
+	PORT_FORCE_SPEED_10_MBPS,
+	PORT_FORCE_SPEED_100_MBPS,
+	PORT_FORCE_SPEED_1000_MBPS,
+	PORT_DO_NOT_FORCE_SPEED
+} GT_PORT_FORCED_SPEED_MODE;
+
+typedef enum
+{
+	PORT_DO_NOT_FORCE_DUPLEX,
+	PORT_FORCE_FULL_DUPLEX,
+	PORT_FORCE_HALF_DUPLEX
+} GT_PORT_FORCED_DUPLEX_MODE;
+
+typedef enum
+{
+	PORT_DO_NOT_FORCE_LINK,
+	PORT_FORCE_LINK_UP,
+	PORT_FORCE_LINK_DOWN
+} GT_PORT_FORCED_LINK_MODE;
+
+typedef enum
+{
+	PORT_DO_NOT_FORCE_FC,
+	PORT_FORCE_FC_ENABLED,
+	PORT_FORCE_FC_DISABLED
+} GT_PORT_FORCED_FC_MODE;
+
+typedef enum
+{
+	PPU_STATE_DISABLED_AT_RESET,
+	PPU_STATE_ACTIVE,
+	PPU_STATE_DISABLED_AFTER_RESET,
+	PPU_STATE_POLLING
+} GT_PPU_STATE;
+
+typedef enum
+{
+	PORTCFG_GMII_125MHZ,		/* Px_GTXCLK = 125MHz, 1000BASE - Port 9 Only */
+	PORTCFG_FD_MII_0MHZ,		/* Px_GTXCLK = 0 MHz, Power Save - Port 9 Only */
+	PORTCFG_FDHD_MII_25MHZ,		/* Px_GTXCLK = 25MHz, 100BASE - Port 9 Only */ 
+	PORTCFG_FDHD_MII_2_5MHZ,	/* Px_GTXCLK = 2.5MHz, 10BASE - Port 9 Only */
+	PORTCFG_FD_SERDES,			/* Default value */
+	PORTCFG_FD_1000BASE_X,		/* Port 7,8,9 only */
+	PORTCFG_MGMII,				/* duplex, speed determined by the PPU */
+	PORTCFG_DISABLED			/* Port 9 Only */
+} GT_PORT_CONFIG_MODE;
+
+/* Maximal number of ports a switch may have.   */
+#define MAX_SWITCH_PORTS    11
+#define VERSION_MAX_LEN 30
+
+/*
+ * Typedef: struct GT_VERSION
+ *
+ * Description: This struct holds the package version.
+ *
+ * Fields:
+ *      version - string array holding the version.
+ *
+ */
+typedef struct
+{
+    GT_U8   version[VERSION_MAX_LEN];
+}GT_VERSION;
+
+
+
+/*
+ * Typedef: enum GT_ATU_OPERARION
+ *
+ * Description: Defines the different ATU and VTU operations
+ *
+ * Fields:
+ *      FLUSH_ALL           - Flush all entries.
+ *      FLUSH_UNLOCKED      - Flush all unlocked entries in ATU.
+ *      LOAD_PURGE_ENTRY    - Load / Purge entry.
+ *      GET_NEXT_ENTRY      - Get next ATU or VTU  entry.
+ *      FLUSH_ALL_IN_DB     - Flush all entries in a particular DBNum.
+ *      FLUSH_UNLOCKED_IN_DB - Flush all unlocked entries in a particular DBNum.
+ *      SERVICE_VIOLATONS   - sevice violations of VTU
+ *
+ */
+typedef enum
+{
+    FLUSH_ALL = 1,	/* for both atu and vtu */
+    FLUSH_UNLOCKED,	/* for atu only */
+    LOAD_PURGE_ENTRY,	/* for both atu and vtu */
+    GET_NEXT_ENTRY,	/* for both atu and vtu */
+	FLUSH_ALL_IN_DB,	/* for atu only */
+    FLUSH_UNLOCKED_IN_DB,	/* for atu only */
+    SERVICE_VIOLATIONS 	/* for vtu only */
+} GT_ATU_OPERATION, GT_VTU_OPERATION;
+
+
+/*
+ * typedef: enum GT_FLUSH_CMD
+ *
+ * Description: Enumeration of the address translation unit flush operation.
+ *
+ * Enumerations:
+ *   GT_FLUSH_ALL       - flush all entries.
+ *   GT_FLUSH_ALL_UNBLK - flush all unblocked.
+ */
+typedef enum
+{
+    GT_FLUSH_ALL       = 1,
+    GT_FLUSH_ALL_UNBLK
+}GT_FLUSH_CMD;
+
+/*
+ * typedef: enum GT_MOVE_CMD
+ *
+ * Description: Enumeration of the address translation unit flush operation.
+ *
+ * Enumerations:
+ *   GT_MOVE_ALL       - move all entries.
+ *   GT_MOVE_ALL_UNBLK - move all unblocked.
+ */
+typedef enum
+{
+    GT_MOVE_ALL       = 1,
+    GT_MOVE_ALL_UNBLK
+}GT_MOVE_CMD;
+
+
+/*
+ * typedef: enum GT_ATU_UC_STATE
+ *
+ * Description:
+ *      Enumeration of the address translation unit entry state of unicast
+ *      entris.
+ *
+ * Enumerations:
+ *      GT_UC_INVALID   - invalid entry.
+ *      GT_UC_DYNAMIC   - unicast dynamic entry.
+ *		GT_UC_NO_PRI_TO_CPU_STATIC - static unicast entry with To_CPU Marvell tag without forcing priority.
+ *		GT_UC_TO_CPU_STATIC - static unicast entry with To_CPU Marvell tag.
+ *      GT_UC_NO_PRI_STATIC - static unicast entry without forcing priority.
+ *      GT_UC_STATIC    - static unicast entry.
+ *
+ * Note: GT_UC_NO_PRI_STATIC is supported only by 88E6183 family and 88E6093 family.
+ */
+typedef enum
+{
+    GT_UC_INVALID      = 0,
+    GT_UC_DYNAMIC      = 0x1,
+    GT_UC_NO_PRI_TO_CPU_STATIC       = 0xC,
+    GT_UC_TO_CPU_STATIC       = 0xD,
+    GT_UC_NO_PRI_STATIC       = 0xE,
+    GT_UC_STATIC       = 0xF
+} GT_ATU_UC_STATE;
+
+
+/*
+ * typedef: enum GT_ATU_MC_STATE
+ *
+ * Description:
+ *      Enumeration of the address translation unit entry state of multicast
+ *      entris.
+ *
+ * Enumerations:
+ *      GT_MC_INVALID         - invalid entry.
+ *      GT_MC_MGM_STATIC      - static multicast management entries.
+ *      GT_MC_STATIC          - static multicast regular entris.
+ *      GT_MC_PRIO_MGM_STATIC - static multicast management entries with
+ *                              priority.
+ *      GT_MC_PRIO_STATIC     - static multicast regular entris with priority.
+ */
+typedef enum
+{
+    GT_MC_INVALID         = 0,
+    GT_MC_STATIC_UNLIMITED_RATE	= 0x5,
+    GT_MC_MGM_STATIC      = 0x6,
+    GT_MC_STATIC          = 0x7,
+    GT_MC_PRIO_STATIC_UNLIMITED_RATE	= 0xD,
+    GT_MC_PRIO_MGM_STATIC = 0xE,
+    GT_MC_PRIO_STATIC     = 0xF
+} GT_ATU_MC_STATE;
+
+
+
+/*
+ *  typedef: struct GT_ATU_ENTRY
+ *
+ *  Description: address tarnslaton unit Entry
+ *
+ *  Fields:
+ *      macAddr    - mac address
+ *      trunkMember- GT_TRUE if entry belongs to a Trunk. This field will be
+ *					ignored if device does not support Trunk.
+ *      portVec    - port Vector. 
+ *					If trunkMember field is GT_TRUE, this value represents trunk ID.
+ *      prio       - entry priority.
+ *      entryState - the entry state.
+ *		DBNum	   - ATU MAC Address Database number. If multiple address 
+ *					databases are not being used, DBNum should be zero.
+ *					If multiple address databases are being used, this value
+ *					should be set to the desired address database number.
+ *
+ *  Comment:
+ *      The entryState union Type is determine according to the Mac Type.
+ */
+typedef struct
+{
+	GT_ETHERADDR 	macAddr;
+	GT_BOOL			trunkMember;
+	GT_U32			portVec;
+	GT_U8			prio;
+	GT_U8			DBNum;
+	union
+	{
+		GT_ATU_UC_STATE ucEntryState;
+		GT_ATU_MC_STATE mcEntryState;
+	} entryState;
+} GT_ATU_ENTRY;
+
+
+/*
+ *  typedef: struct GT_VTU_DATA
+ *
+ *  Description: VLAN  tarnslaton unit Data Register
+ *
+ *  Fields:
+ *      memberTagP - Membership and Egress Tagging
+ *                   memberTagP[0] is for Port 0, MemberTagP[1] is for port 1, and so on 
+ *
+ *  Comment:
+ * 	MAX_SWITCH_PORTS is 10 for Octane.
+ * 	In the case of FullSail, there are 3 ports. So, the rest 7 is ignored in memeberTagP
+ */
+typedef struct
+{
+    GT_U8     memberTagP[MAX_SWITCH_PORTS];
+    GT_U8     portStateP[MAX_SWITCH_PORTS];
+} GT_VTU_DATA;
+
+/*
+ *  definition for MEMBER_TAG
+ */
+#define MEMBER_EGRESS_UNMODIFIED	0
+#define NOT_A_MEMBER				1
+#define MEMBER_EGRESS_UNTAGGED		2
+#define MEMBER_EGRESS_TAGGED		3
+ 
+/*
+ *  typedef: struct GT_VTU_ENTRY
+ *
+ *  Description: VLAN  tarnslaton unit Entry
+ *
+ *  Fields:
+ *      DBNum      - database number 
+ *      vid        - VLAN ID 
+ *      vtuData    - VTU data
+ *		vidPriOverride - override the priority on any frame associated with this VID
+ *		vidPriority - VID Priority bits (0 ~ 7)
+ */
+typedef struct
+{
+    GT_U8         DBNum;
+    GT_U16         vid;
+    GT_VTU_DATA   vtuData;
+	GT_BOOL		  vidPriOverride;
+	GT_U8		  vidPriority;
+} GT_VTU_ENTRY;
+
+/*
+ *  typedef: struct GT_VTU_INT_STATUS
+ *
+ *  Description: VLAN tarnslaton unit interrupt status
+ *
+ *  Fields:
+ *      intCause  - VTU Interrupt Cause
+ *					GT_VTU_FULL_VIOLATION,GT_MEMEBER_VIOLATION,or
+ *					GT_MISS_VIOLATION
+ *      SPID      - source port number
+ * 					if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ *      vid       - VLAN ID 
+ * 					if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ */
+typedef struct
+{
+    GT_U16   vtuIntCause;
+    GT_U8    spid;
+    GT_U16   vid;
+} GT_VTU_INT_STATUS;
+
+/*
+ *  typedef: struct GT_ATU_INT_STATUS
+ *
+ *  Description: VLAN tarnslaton unit interrupt status
+ *
+ *  Fields:
+ *      intCause  - ATU Interrupt Cause
+ *					GT_FULL_VIOLATION,GT_MEMEBER_VIOLATION,or
+ *					GT_MISS_VIOLATION
+ *      SPID      - source port number
+ * 					if intCause is GT_FULL_VIOLATION, it means nothing
+ *      DBNum     - DB Num
+ * 					if intCause is GT_FULL_VIOLATION, it means nothing
+ *		macAddr	  - MAC Address
+ */
+typedef struct
+{
+    GT_U16   atuIntCause;
+    GT_U8    spid;
+    GT_U8    dbNum;
+    GT_ETHERADDR  macAddr;
+} GT_ATU_INT_STATUS;
+
+/*
+* Definition for VTU interrupt
+*/
+#define GT_MEMBER_VIOLATION		0x4
+#define GT_MISS_VIOLATION		0x2
+#define GT_VTU_FULL_VIOLATION	0x1
+/*
+* Definitions for ATU interrupt in Gigabit switch are the same as 
+* the ones for VTU interrupt. Here we just redefine the FULL_VIOLATION for
+* both VTU and ATU.
+*/
+#define GT_FULL_VIOLATION		0x1
+
+
+/*
+ * Typedef:
+ *
+ * Description: Defines the different sizes of the Mac address table.
+ *
+ * Fields:
+ *      ATU_SIZE_256    -   256 entries Mac address table.
+ *      ATU_SIZE_512    -   512 entries Mac address table.
+ *      ATU_SIZE_1024   -   1024 entries Mac address table.
+ *      ATU_SIZE_2048   -   2048 entries Mac address table.
+ *      ATU_SIZE_4096   -   4096 entries Mac address table.
+ *
+ */
+typedef enum
+{
+    ATU_SIZE_256,
+    ATU_SIZE_512,
+    ATU_SIZE_1024,
+    ATU_SIZE_2048,
+    ATU_SIZE_4096
+}ATU_SIZE;
+
+
+/*
+ * typedef: enum GT_PORT_STP_STATE
+ *
+ * Description: Enumeration of the port spanning tree state.
+ *
+ * Enumerations:
+ *   GT_PORT_DISABLE    - port is disabled.
+ *   GT_PORT_BLOCKING   - port is in blocking/listening state.
+ *   GT_PORT_LEARNING   - port is in learning state.
+ *   GT_PORT_FORWARDING - port is in forwarding state.
+ */
+typedef enum
+{
+    GT_PORT_DISABLE = 0,
+    GT_PORT_BLOCKING,
+    GT_PORT_LEARNING,
+    GT_PORT_FORWARDING
+} GT_PORT_STP_STATE;
+
+
+/*
+ * typedef: enum GT_EGRESS_MODE
+ *
+ * Description: Enumeration of the port egress mode.
+ *
+ * Enumerations:
+ *   GT_UNMODIFY_EGRESS - frames are transmited unmodified.
+ *   GT_TAGGED_EGRESS   - all frames are transmited tagged.
+ *   GT_UNTAGGED_EGRESS - all frames are transmited untagged.
+ *   GT_ADD_TAG         - always add a tag. (or double tag)
+ */
+typedef enum
+{
+    GT_UNMODIFY_EGRESS = 0,
+    GT_UNTAGGED_EGRESS,
+    GT_TAGGED_EGRESS,
+    GT_ADD_TAG
+} GT_EGRESS_MODE;
+
+/*  typedef: enum GT_DOT1Q_MODE */
+
+typedef enum
+{
+	GT_DISABLE = 0,
+    GT_FALLBACK,
+	GT_CHECK,
+	GT_SECURE
+} GT_DOT1Q_MODE;
+
+
+/* typedef: enum GT_SW_MODE */
+
+typedef enum
+{
+	GT_CPU_ATTATCHED = 0, /* ports come up disabled */
+	GT_BACKOFF,           /* EEPROM attac mode with old half duplex backoff mode */
+	GT_STAND_ALONE,       /* ports come up enabled, ignore EEPROM */
+        GT_EEPROM_ATTATCHED   /* EEPROM defined prot states */
+} GT_SW_MODE;
+
+/* typedef: enum GT_RATE_LIMIT_MODE
+ * The ingress limit mode in the rate control register (0xA)
+ */
+
+typedef enum
+{
+	GT_LIMT_ALL = 0, 		/* limit and count all frames */
+	GT_LIMIT_FLOOD,      	/* limit and count Broadcast, Multicast and flooded unicast frames */
+	GT_LIMIT_BRDCST_MLTCST,	/* limit and count Broadcast and Multicast frames */
+	GT_LIMIT_BRDCST   		/* limit and count Broadcast frames */
+} GT_RATE_LIMIT_MODE;
+
+/* typedef: enum GT_PRI0_RATE
+ * The ingress data rate limit for priority 0 frames 
+ */
+
+typedef enum
+{
+	GT_NO_LIMIT = 0, 	/* Not limited   */
+	GT_128K,      		/* 128K bits/sec */
+	GT_256K,      		/* 256K bits/sec */
+	GT_512K,      		/* 512 bits/sec */
+	GT_1M,      		/* 1M  bits/sec */
+	GT_2M,      		/* 2M  bits/sec */
+	GT_4M,      		/* 4M  bits/sec */
+	GT_8M,      		/* 8M  bits/sec */
+	GT_16M,      		/* 16M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+	GT_32M,      		/* 32M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+	GT_64M,      		/* 64M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+	GT_128M,      		/* 128M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+	GT_256M      		/* 256M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+} GT_PRI0_RATE,GT_EGRESS_RATE;
+/*
+ * Formula for Gigabit Switch family's Rate Limit
+ */
+#define GT_GET_RATE_LIMIT(_kbps)	((_kbps)?(8000000 / (28 * (_kbps))):0)
+#define GT_GET_RATE_LIMIT2(_kbps)	((_kbps)?(8000000 / (32 * (_kbps))):0)
+
+#define MAX_RATE_LIMIT		256000	/* unit of Kbps */
+#define MIN_RATE_LIMIT		65		/* unit of Kbps */
+
+/*
+ * typedef: enum GT_EVENT_TYPE
+ *
+ * Description: Enumeration of the available hardware driven events.
+ *
+ * Enumerations:
+ *   GT_STATS_DONE - Statistics Operation Done interrrupt Enable 
+ *   GT_VTU_PROB - VLAN Problem/Violation Interrupt Enable
+ *   GT_VTU_DONE - VALN Table Operation Done Interrupt Enable
+ *   GT_ATU_PROB - ATU Problem/Violation Interrupt Enable, for Gigabit Switch
+ *   GT_ATU_FULL - ATU full interrupt enable, for Fast Ethernet Switch
+ *   GT_ATU_DONE - ATU Done interrupt enable.
+ *   GT_PHY_INT  - PHY interrupt enable, for Fast Ethernet Switch
+ *   GT_EE_INT   - EEPROM Done interrupt enable.
+ */
+#define GT_STATS_DONE           0x40
+#define GT_VTU_PROB             0x20
+#define GT_VTU_DONE             0x10
+#define GT_ATU_PROB 		0x8
+#define GT_ATU_FULL 		0x8
+#define GT_ATU_DONE		0x4
+#define GT_PHY_INTERRUPT	0x2	/* For Fast Ethernet Switch (not supported by Gigabit Switch) */
+#define GT_EE_INTERRUPT		0x1
+
+#define GT_INT_MASK		(GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_FULL | GT_ATU_DONE | GT_PHY_INTERRUPT | GT_EE_INTERRUPT)
+#define GT_NO_INTERNAL_PHY_INT_MASK		(GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_PROB | GT_ATU_DONE | GT_EE_INTERRUPT)
+
+/*
+* typedef: enum GT_PHY_INT
+*
+* Description: Enumeration of PHY interrupt
+*/
+
+#define GT_SPEED_CHANGED 		0x4000
+#define GT_DUPLEX_CHANGED		0x2000
+#define GT_PAGE_RECEIVED		0x1000
+#define GT_AUTO_NEG_COMPLETED	0x800
+#define GT_LINK_STATUS_CHANGED	0x400
+#define GT_SYMBOL_ERROR			0x200
+#define GT_FALSE_CARRIER		0x100
+#define GT_FIFO_FLOW			0x80
+#define GT_CROSSOVER_CHANGED	0x40
+#define GT_POLARITY_CHANGED		0x2
+#define GT_JABBER				0x1
+
+#define GT_AUTO_NEG_ERROR		0x8000
+#define GT_DOWNSHIFT_DETECT		0x20
+#define GT_ENERGY_DETECT		0x10
+
+/*
+* typedef: enum GT_PHY_AUTO_MODE
+*
+* Description: Enumeration of Autonegotiation mode.
+*	Auto for both speed and duplex.
+*	Auto for speed only and Full duplex.
+*	Auto for speed only and Half duplex. (1000Mbps is not supported)
+*	Auto for duplex only and speed 1000Mbps.
+*	Auto for duplex only and speed 100Mbps.
+*	Auto for duplex only and speed 10Mbps.
+*	1000Mbps Full duplex.
+*	100Mbps Full duplex.
+*	100Mbps Half duplex.
+*	10Mbps Full duplex.
+*	10Mbps Half duplex.
+*/
+
+typedef enum
+{
+	SPEED_AUTO_DUPLEX_AUTO,
+	SPEED_1000_DUPLEX_AUTO,
+	SPEED_100_DUPLEX_AUTO,
+	SPEED_10_DUPLEX_AUTO,
+	SPEED_AUTO_DUPLEX_FULL,
+	SPEED_AUTO_DUPLEX_HALF,
+	SPEED_1000_DUPLEX_FULL,
+	SPEED_1000_DUPLEX_HALF,
+	SPEED_100_DUPLEX_FULL,
+	SPEED_100_DUPLEX_HALF,
+	SPEED_10_DUPLEX_FULL,
+	SPEED_10_DUPLEX_HALF
+}GT_PHY_AUTO_MODE;
+
+
+
+/*
+ * typedef: enum GT_INGRESS_MODE
+ *
+ * Description: Enumeration of the port ingress mode.
+ *
+ * Enumerations:
+ *   GT_UNMODIFY_INGRESS - frames are receive unmodified.
+ *   GT_TRAILER_INGRESS  - all frames are received with trailer.
+ *   GT_UNTAGGED_INGRESS  - remove tag on receive (for double tagging).
+ *   GT_CPUPORT_INGRESS - no trailer. used to identify the CPU port for IGMP/MLD Snooping
+ */
+typedef enum
+{
+    GT_UNMODIFY_INGRESS = 0,  /* 0x00 */
+    GT_TRAILER_INGRESS,       /* 0x01 */
+    GT_UNTAGGED_INGRESS,      /* 0x10 */
+    GT_CPUPORT_INGRESS        /* 0x11 */
+} GT_INGRESS_MODE;
+
+
+/*
+ *  typedef: enum GT_INGRESS_MODE
+ *
+ *  Description: Enumeration of the port ingress mode.
+ *
+ *  Enumerations:
+ *      GT_MC_3_PERCENT_RL   - multicast rate is limited to 3 percent.
+ *      GT_MC_6_PERCENT_RL   - multicast rate is limited to 6 percent.
+ *      GT_MC_12_PERCENT_RL  - multicast rate is limited to 12 percent.
+ *      GT_MC_100_PERCENT_RL - unlimited multicast rate.
+ */
+typedef enum
+{
+    GT_MC_3_PERCENT_RL = 0,
+    GT_MC_6_PERCENT_RL,
+    GT_MC_12_PERCENT_RL,
+    GT_MC_100_PERCENT_RL,
+} GT_MC_RATE;
+
+
+
+/*
+ *  typedef: struct GT_PORT_STAT
+ *
+ *  Description: port statistic struct.
+ *
+ *  Fields:
+ *      rxCtr    - port receive counter.
+ *      txCtr    - port transmit counter.
+ *
+ *  Comment:
+ */
+typedef struct
+{
+    GT_U16  rxCtr;
+    GT_U16  txCtr;
+} GT_PORT_STAT;
+
+/*
+ *  typedef: struct GT_PORT_STAT2
+ *
+ *  Description: port statistic struct.
+ *
+ *  Fields:
+ *      inDiscardLo - InDiscards Low Frame Counter
+ *      inDiscardHi - InDiscards High Frame Counter
+ *      inFiltered  - InFiltered Frame Counter
+ *      outFiltered - OutFiltered Frame Counter
+ *
+ *  Comment:
+ */
+typedef struct
+{
+    GT_U16  inDiscardLo;
+    GT_U16  inDiscardHi;
+    GT_U16  inFiltered;
+    GT_U16  outFiltered;
+} GT_PORT_STAT2;
+
+
+/*
+ **  typedef: struct GT_PORT_Q_COUNTERS
+ **
+ **  Description: port queue statistic struct.
+ **
+ **  Fields:
+ **      OutQ_Size - port egress queue size coi
+ **      Rsv_Size  - ingress reserved e counter
+ **
+ **/
+typedef struct
+{
+    GT_U16  OutQ_Size;
+    GT_U16  Rsv_Size;
+} GT_PORT_Q_STAT;
+
+/*
+ * typedef: enum GT_CTR_MODE
+ *
+ * Description: Enumeration of the port counters mode.
+ *
+ * Enumerations:
+ *   GT_CTR_ALL    - In this mode the counters counts Rx receive and transmit
+ *                   frames.
+ *   GT_CTR_ERRORS - In this mode the counters counts Rx Errors and collisions.
+ */
+typedef enum
+{
+    GT_CTR_ALL = 0,
+    GT_CTR_ERRORS,
+} GT_CTR_MODE;
+
+typedef struct _GT_QD_DEV GT_QD_DEV;
+
+/*
+ * semaphore related definitions.
+ * User Applications may register Semaphore functions using following definitions
+ */
+typedef enum
+{
+	GT_SEM_EMPTY,
+	GT_SEM_FULL
+} GT_SEM_BEGIN_STATE;
+
+typedef GT_SEM (*FGT_SEM_CREATE)(
+						GT_SEM_BEGIN_STATE state);
+typedef GT_STATUS (*FGT_SEM_DELETE)(
+						GT_SEM semId);
+typedef GT_STATUS (*FGT_SEM_TAKE)(
+						GT_SEM semId, GT_U32 timOut);
+typedef GT_STATUS (*FGT_SEM_GIVE)(
+						GT_SEM semId);
+
+typedef struct
+{
+	FGT_SEM_CREATE	semCreate; 	/* create semapore */
+	FGT_SEM_DELETE	semDelete; 	/* delete the semapore */
+	FGT_SEM_TAKE	semTake;	/* try to get a semapore */
+	FGT_SEM_GIVE	semGive;	/* return semaphore */
+}GT_SEM_ROUTINES;
+
+/*
+ * definitions for registering MII access functions.
+ *
+*/
+typedef GT_BOOL (*FGT_READ_MII)(
+						GT_QD_DEV*   dev,
+						unsigned int phyAddr, 
+						unsigned int miiReg, 
+						unsigned int* value);
+typedef GT_BOOL (*FGT_WRITE_MII)(
+						GT_QD_DEV*   dev,
+						unsigned int phyAddr, 
+						unsigned int miiReg, 
+						unsigned int value);
+typedef GT_BOOL (*FGT_INT_HANDLER)(
+						GT_QD_DEV*   dev,
+						GT_U16*);
+
+typedef struct _BSP_FUNCTIONS
+{
+	FGT_READ_MII 	readMii;	/* read MII Registers */
+	FGT_WRITE_MII 	writeMii;	/* write MII Registers */
+	FGT_SEM_CREATE	semCreate; 	/* create semapore */
+	FGT_SEM_DELETE	semDelete; 	/* delete the semapore */
+	FGT_SEM_TAKE	semTake;	/* try to get a semapore */
+	FGT_SEM_GIVE	semGive;	/* return semaphore */
+}BSP_FUNCTIONS;
+
+
+/*
+ *	Type definition for MIB counter operation
+*/
+typedef enum 
+{
+	STATS_FLUSH_ALL,		/* Flush all counters for all ports */
+	STATS_FLUSH_PORT,		/* Flush all counters for a port */
+	STATS_READ_COUNTER,	/* Read a specific counter from a port */
+	STATS_READ_ALL		/* Read all counters from a port */
+
+} GT_STATS_OPERATION;
+
+typedef struct _GT_STATS_COUNTER_SET
+{
+	GT_U32	InUnicasts;
+	GT_U32	InBroadcasts;
+	GT_U32	InPause;
+	GT_U32	InMulticasts;
+	GT_U32	InFCSErr;
+	GT_U32	AlignErr;
+	GT_U32	InGoodOctets;
+	GT_U32	InBadOctets;
+	GT_U32	Undersize;
+	GT_U32	Fragments;
+	GT_U32	In64Octets;		/* 64 Octets */
+	GT_U32	In127Octets;	/* 65 to 127 Octets */
+	GT_U32	In255Octets;	/* 128 to 255 Octets */
+	GT_U32	In511Octets;	/* 256 to 511 Octets */
+	GT_U32	In1023Octets;	/* 512 to 1023 Octets */
+	GT_U32	InMaxOctets;	/* 1024 to Max Octets */
+	GT_U32	Jabber;
+	GT_U32	Oversize;
+	GT_U32	InDiscards;
+	GT_U32	Filtered;
+	GT_U32	OutUnicasts;
+	GT_U32	OutBroadcasts;
+	GT_U32	OutPause;
+	GT_U32	OutMulticasts;
+	GT_U32	OutFCSErr;
+	GT_U32	OutGoodOctets;
+	GT_U32	Out64Octets;	/* 64 Octets */
+	GT_U32	Out127Octets;	/* 65 to 127 Octets */
+	GT_U32	Out255Octets;	/* 128 to 255 Octets */
+	GT_U32	Out511Octets;	/* 256 to 511 Octets */
+	GT_U32	Out1023Octets;	/* 512 to 1023 Octets */
+	GT_U32	OutMaxOctets;	/* 1024 to Max Octets */
+	GT_U32	Collisions;
+	GT_U32	Late;
+	GT_U32	Excessive;
+	GT_U32	Multiple;
+	GT_U32	Single;
+	GT_U32	Deferred;
+	GT_U32	OutDiscards;
+
+} GT_STATS_COUNTER_SET;
+
+
+typedef enum
+{
+	STATS_InUnicasts = 0,
+	STATS_InBroadcasts,
+	STATS_InPause,
+	STATS_InMulticasts,
+	STATS_InFCSErr,
+	STATS_AlignErr,
+	STATS_InGoodOctets,
+	STATS_InBadOctets,
+	STATS_Undersize,
+	STATS_Fragments,
+	STATS_In64Octets,
+	STATS_In127Octets,
+	STATS_In255Octets,
+	STATS_In511Octets,
+	STATS_In1023Octets,
+	STATS_InMaxOctets,
+	STATS_Jabber,
+	STATS_Oversize,
+	STATS_InDiscards,
+	STATS_Filtered,
+	STATS_OutUnicasts,
+	STATS_OutBroadcasts,
+	STATS_OutPause,
+	STATS_OutMulticasts,
+	STATS_OutFCSErr,
+	STATS_OutGoodOctets,
+	STATS_Out64Octets,
+	STATS_Out127Octets,
+	STATS_Out255Octets,
+	STATS_Out511Octets,
+	STATS_Out1023Octets,
+	STATS_OutMaxOctets,
+	STATS_Collisions,
+	STATS_Late,
+	STATS_Excessive,
+	STATS_Multiple,
+	STATS_Single,
+	STATS_Deferred,
+	STATS_OutDiscards
+
+} GT_STATS_COUNTERS;
+/*
+ * typedef: enum GT_HISTOGRAM_MODE
+ *
+ * Description: Enumeration of the histogram counters mode.
+ *
+ * Enumerations:
+ *   GT_COUNT_RX_ONLY - In this mode, Rx Histogram Counters are counted.
+ *   GT_COUNT_TX_ONLY - In this mode, Tx Histogram Counters are counted.
+ *   GT_COUNT_RX_TX   - In this mode, Rx and Tx Histogram Counters are counted.
+ */
+typedef enum
+{
+    GT_COUNT_RX_ONLY = 0,
+    GT_COUNT_TX_ONLY,
+	GT_COUNT_RX_TX
+} GT_HISTOGRAM_MODE;
+
+/*
+	Counter set 2 is used by 88E6183
+*/
+typedef struct _GT_STATS_COUNTER_SET2
+{
+	GT_U32	InGoodOctetsHi;
+	GT_U32	InGoodOctetsLo;
+	GT_U32	InBadOctets;
+	GT_U32	OutDiscards;
+	GT_U32	InGoodFrames;
+	GT_U32	InBadFrames;
+	GT_U32	InBroadcasts;
+	GT_U32	InMulticasts;
+	/* 
+		Histogram Counters : Rx Only, Tx Only, or both Rx and Tx 
+		(refer to Histogram Mode) 
+	*/
+	GT_U32	Octets64;		/* 64 Octets */
+	GT_U32	Octets127;		/* 65 to 127 Octets */
+	GT_U32	Octets255;		/* 128 to 255 Octets */
+	GT_U32	Octets511;		/* 256 to 511 Octets */
+	GT_U32	Octets1023;		/* 512 to 1023 Octets */
+	GT_U32	OctetsMax;		/* 1024 to Max Octets */
+	GT_U32	OutOctetsHi;
+	GT_U32	OutOctetsLo;
+	GT_U32	OutFrames;
+	GT_U32	Excessive;
+	GT_U32	OutMulticasts;
+	GT_U32	OutBroadcasts;
+	GT_U32	InBadMACCtrl;
+
+	GT_U32	OutPause;
+	GT_U32	InPause;
+	GT_U32	InDiscards;
+	GT_U32	Undersize;
+	GT_U32	Fragments;
+	GT_U32	Oversize;
+	GT_U32	Jabber;
+	GT_U32	MACRcvErr;
+	GT_U32	InFCSErr;
+	GT_U32	Collisions;
+	GT_U32	Late;
+
+} GT_STATS_COUNTER_SET2;
+
+
+typedef enum
+{
+	STATS2_InGoodOctetsHi = 0,
+	STATS2_InGoodOctetsLo,
+	STATS2_InBadOctets,
+	
+	STATS2_OutDiscards,
+	STATS2_InGoodFrames,
+	STATS2_InBadFrames,
+	STATS2_InBroadcasts,
+	STATS2_InMulticasts,
+	STATS2_64Octets,
+	STATS2_127Octets,
+	STATS2_255Octets,
+	STATS2_511Octets,
+	STATS2_1023Octets,
+	STATS2_MaxOctets,
+	STATS2_OutOctetsHi,
+	STATS2_OutOctetsLo,
+	STATS2_OutFrames,
+	STATS2_Excessive,
+	STATS2_OutMulticasts,
+	STATS2_OutBroadcasts,
+	STATS2_InBadMACCtrl,
+	STATS2_OutPause,
+	STATS2_InPause,
+	STATS2_InDiscards,
+	STATS2_Undersize,
+	STATS2_Fragments,
+	STATS2_Oversize,
+	STATS2_Jabber,
+	STATS2_MACRcvErr,
+	STATS2_InFCSErr,
+	STATS2_Collisions,
+	STATS2_Late
+
+} GT_STATS_COUNTERS2;
+
+/*
+	Counter set 3 is used by 88E6093
+*/
+typedef struct _GT_STATS_COUNTER_SET3
+{
+	GT_U32	InGoodOctetsLo;	/* offset 0 */
+	GT_U32	InGoodOctetsHi;	/* offset 1 */
+	GT_U32	InBadOctets;		/* offset 2 */
+	GT_U32	OutFCSErr;			/* offset 3 */
+	GT_U32	InUnicasts;			/* offset 4 */
+	GT_U32	Deferred;			/* offset 5 */
+	GT_U32	InBroadcasts;		/* offset 6 */
+	GT_U32	InMulticasts;		/* offset 7 */
+	/* 
+		Histogram Counters : Rx Only, Tx Only, or both Rx and Tx 
+		(refer to Histogram Mode) 
+	*/
+	GT_U32	Octets64;		/* 64 Octets, offset 8 */
+	GT_U32	Octets127;		/* 65 to 127 Octets, offset 9 */
+	GT_U32	Octets255;		/* 128 to 255 Octets, offset 10 */
+	GT_U32	Octets511;		/* 256 to 511 Octets, offset 11 */
+	GT_U32	Octets1023;		/* 512 to 1023 Octets, offset 12 */
+	GT_U32	OctetsMax;		/* 1024 to Max Octets, offset 13 */
+	GT_U32	OutOctetsLo;	/* offset 14 */
+	GT_U32	OutOctetsHi;	/* offset 15 */
+	GT_U32	OutUnicasts;	/* offset 16 */
+	GT_U32	Excessive;		/* offset 17 */
+	GT_U32	OutMulticasts;	/* offset 18 */
+	GT_U32	OutBroadcasts;	/* offset 19 */
+	GT_U32	Single;			/* offset 20 */
+
+	GT_U32	OutPause;		/* offset 21 */
+	GT_U32	InPause;			/* offset 22 */
+	GT_U32	Multiple;		/* offset 23 */
+	GT_U32	Undersize;		/* offset 24 */
+	GT_U32	Fragments;		/* offset 25 */
+	GT_U32	Oversize;		/* offset 26 */
+	GT_U32	Jabber;			/* offset 27 */
+	GT_U32	InMACRcvErr;	/* offset 28 */
+	GT_U32	InFCSErr;		/* offset 29 */
+	GT_U32	Collisions;		/* offset 30 */
+	GT_U32	Late;				/* offset 31 */
+
+} GT_STATS_COUNTER_SET3;
+
+
+typedef enum
+{
+	STATS3_InGoodOctetsLo = 0,
+	STATS3_InGoodOctetsHi,
+	STATS3_InBadOctets,
+	
+	STATS3_OutFCSErr,
+	STATS3_InUnicasts,
+	STATS3_Deferred,			/* offset 5 */
+	STATS3_InBroadcasts,
+	STATS3_InMulticasts,
+	STATS3_64Octets,
+	STATS3_127Octets,
+	STATS3_255Octets,			/* offset 10 */
+	STATS3_511Octets,
+	STATS3_1023Octets,
+	STATS3_MaxOctets,
+	STATS3_OutOctetsLo,
+	STATS3_OutOctetsHi,
+	STATS3_OutUnicasts,		/* offset 16 */
+	STATS3_Excessive,
+	STATS3_OutMulticasts,
+	STATS3_OutBroadcasts,
+	STATS3_Single,
+	STATS3_OutPause,
+	STATS3_InPause,
+	STATS3_Multiple,
+	STATS3_Undersize,			/* offset 24 */
+	STATS3_Fragments,
+	STATS3_Oversize,
+	STATS3_Jabber,
+	STATS3_InMACRcvErr,
+	STATS3_InFCSErr,
+	STATS3_Collisions,
+	STATS3_Late					/* offset 31 */
+
+} GT_STATS_COUNTERS3;
+
+
+
+/*
+ * typedef: struct GT_1000T_MASTER_SLAVE
+ *
+ * Description: 1000Base-T Master/Slave Configuration
+ *
+ * Fields:
+ *      autoConfig   - GT_TRUE for auto-config, GT_FALSE for manual setup.
+ *      masterPrefer - GT_TRUE if Master configuration is preferred.
+ *
+ */
+typedef struct _GT_1000T_MASTER_SLAVE
+{
+	GT_BOOL	autoConfig;
+	GT_BOOL masterPrefer;
+} GT_1000T_MASTER_SLAVE;
+
+
+#define GT_MDI_PAIR_NUM     	4	/* (1,2),(3,6),(4,5),(7,8) */
+#define GT_CHANNEL_PAIR_NUM     2	/* (channel A,B),(channel C,D) */
+
+/*
+ * typedef: enum GT_TEST_STATUS
+ *
+ * Description: Enumeration of VCT test status
+ *
+ * Enumerations:
+ *      GT_TEST_FAIL    - virtual cable test failed.
+ *      GT_NORMAL_CABLE - normal cable.
+ *      GT_IMPEDANCE_MISMATCH - impedance mismatch.
+ *      GT_OPEN_CABLE   - open in cable.
+ *      GT_SHORT_CABLE  - short in cable.
+ *
+ */
+typedef enum
+{
+    GT_TEST_FAIL,
+    GT_NORMAL_CABLE,
+	GT_IMPEDANCE_MISMATCH,
+    GT_OPEN_CABLE,
+    GT_SHORT_CABLE,
+} GT_TEST_STATUS;
+
+
+/*
+ * typedef: enum GT_NORMAL_CABLE_LEN
+ *
+ * Description: Enumeration for normal cable length
+ *
+ * Enumerations:
+ *      GT_LESS_THAN_50M - cable length less than 50 meter.
+ *      GT_50M_80M       - cable length between 50 - 80 meter.
+ *      GT_80M_110M      - cable length between 80 - 110 meter.
+ *      GT_110M_140M     - cable length between 110 - 140 meter.
+ *      GT_MORE_THAN_140 - cable length more than 140 meter.
+ *      GT_UNKNOWN_LEN   - unknown length.
+ *
+ */
+typedef enum
+{
+    GT_LESS_THAN_50M,
+    GT_50M_80M,
+    GT_80M_110M,
+    GT_110M_140M,
+    GT_MORE_THAN_140,
+    GT_UNKNOWN_LEN,
+
+} GT_NORMAL_CABLE_LEN;
+
+
+/*
+ * typedef: enum GT_CABLE_LEN
+ *
+ * Description: Enumeration cable length
+ *
+ * Enumerations:
+ *      normCableLen - cable lenght for normal cable.
+ *      errCableLen  - for cable failure the estimate fault distance in meters.
+ *
+ */
+typedef union
+{
+    GT_NORMAL_CABLE_LEN normCableLen;
+    GT_U8               errCableLen;
+
+} GT_CABLE_LEN;
+
+/*
+ * typedef: struct GT_CABLE_STATUS
+ *
+ * Description: virtual cable diagnostic status per MDI pair.
+ *
+ * Fields:
+ *      cableStatus - VCT cable status.
+ *      cableLen    - VCT cable length.
+ *	phyType	    - type of phy (100M phy or Gigabit phy)
+ */
+typedef struct
+{
+    GT_TEST_STATUS  cableStatus[GT_MDI_PAIR_NUM];
+    GT_CABLE_LEN    cableLen[GT_MDI_PAIR_NUM];
+    GT_U16	    phyType;
+
+} GT_CABLE_STATUS;
+
+
+/*
+ * typedef: enum GT_CABLE_TYPE
+ *
+ * Description: Enumeration of Cable Type
+ *
+ * Enumerations:
+ *		GT_STRAIGHT_CABLE	_ straight cable
+ *      GT_CROSSOVER_CABLE 	- crossover cable
+ */
+typedef enum
+{
+    GT_STRAIGHT_CABLE,
+	GT_CROSSOVER_CABLE
+
+} GT_CABLE_TYPE;
+
+/*
+ * typedef: enum GT_POLARITY_STATUS
+ *
+ * Description: Enumeration of polarity status
+ *
+ * Enumerations:
+ *		GT_POSITIVE	- positive polarity
+ *      GT_NEGATIVE	- negative polarity
+ */
+typedef enum
+{
+    GT_POSITIVE,
+	GT_NEGATIVE
+
+} GT_POLARITY_STATUS;
+
+
+/*
+ * typedef: struct GT_1000BT_EXTENDED_STATUS
+ *
+ * Description: Currently the 1000Base-T PCS can determine the cable polarity
+ * 		on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among 
+ *		the pares. These status enhance the capability of the virtual cable tester
+ *
+ * Fields:
+ *      isValid		- GT_TRUE if this structure have valid information, 
+ * 					  GT_FALSE otherwise.
+ *					  It is valid only if 1000BASE-T Link is up.
+ *      pairSwap    - GT_CROSSOVER_CABLE, if the cable is crossover,
+ *					  GT_STRAIGHT_CABLE, otherwise
+ *		pairPolarity- GT_POSITIVE, if polarity is positive,
+ *					  GT_NEGATIVE, otherwise
+ *		pairSkew	- pair skew in units of ns
+ */
+typedef struct
+{
+	GT_BOOL				isValid;
+    GT_CABLE_TYPE		pairSwap[GT_CHANNEL_PAIR_NUM];
+    GT_POLARITY_STATUS	pairPolarity[GT_MDI_PAIR_NUM];
+    GT_U32			    pairSkew[GT_MDI_PAIR_NUM];
+
+} GT_1000BT_EXTENDED_STATUS;
+
+
+/*
+ * if isGigPhy in GT_CABLE_STATUS is not GT_TRUE, cableStatus and cableLen 
+ * will have only 2 pairs available.
+ * One is RX Pair and the other is TX Pair.
+ */
+#define MDI_RX_PAIR		0	/* cableStatus[0] or cableLen[0] */
+#define MDI_TX_PAIR		1	/* cableStatus[1] or cableLen[1] */
+
+/* definition for Phy Type */
+#define PHY_100M		0 /* 10/100M phy, E3082 or E3083 */
+#define PHY_1000M		1 /* Gigabit phy, the rest phys */
+#define PHY_10000M		2 /* 10 Gigabit phy, unused */
+#define PHY_1000M_B		3 /* Gigabit phy which needs work-around */
+#define PHY_1000M_MP	4 /* Gigabit phy with multiple page mode */
+
+
+/* definition for Trunking */
+#define IS_TRUNK_ID_VALID(_dev, _id)	(((_id) < 16) ? 1 : 0)
+
+
+/* definition for device scan mode */
+#define SMI_AUTO_SCAN_MODE		0	/* Scan 0 or 0x10 base address to find the QD */
+#define SMI_MANUAL_MODE			1	/* Use QD located at manually defined base addr */
+#define SMI_MULTI_ADDR_MODE		2	/* Use QD at base addr and use indirect access */
+typedef struct
+{
+	GT_U32	scanMode;	/* check definition for device scan mode */
+	GT_U32	baseAddr;	/* meaningful if scanMode is not SMI_AUTO_SCAN_MODE */
+} GT_SCAN_MODE;
+
+
+/*
+ * Typedef: struct GT_SYS_CONFIG
+ *
+ * Description: System configuration Parameters struct.
+ *
+ * Fields:
+ *	devNum		- Switch Device Number 
+ *      cpuPortNum      - The physical port used to connect the device to CPU.
+ *                        This is the port to which packets destined to CPU are
+ *                        forwarded.
+ *      initPorts       - Whether to initialize the ports state.
+ *                          GT_FALSE    - leave in default state.
+ *                          GT_TRUE     - Initialize to Forwarding state.
+ *	BSPFunctions	- Group of BSP specific functions.
+ *				SMI Read/Write and Semaphore Related functions.
+ */
+typedef struct
+{
+    GT_U8         devNum;
+    GT_U8         cpuPortNum;
+    GT_BOOL       initPorts;
+    BSP_FUNCTIONS BSPFunctions;
+	GT_SCAN_MODE  mode;
+}GT_SYS_CONFIG;
+
+
+
+/*
+ * Typedef: struct GT_QD_DEV
+ *
+ * Description: Includes Tapi layer switch configuration data.
+ *
+ * Fields:
+ *   deviceId        - The device type identifier.
+ *   revision        - The device revision number.
+ *   baseRegAddr     - Switch Base Register address.
+ *   numOfPorts      - Number of active ports.
+ *   cpuPortNum      - The physical port connected to the CPU.
+ *   maxPhyNum       - max configurable Phy address.
+ *	  stpMode         - current switch STP mode (0 none, 1 en, 2 dis)
+ *	  accessMode	   - shows how to find and access the device.
+ *   phyAddr         - SMI address used to access Switch registers(only for SMI_MULTI_ADDR_MODE).
+ *   devGroup	      - the device group
+ *   devName	      - name of the device
+ *	  atuRegsSem	- Semaphore for ATU access
+ *	  vtuRegsSem	- Semaphore for VTU access
+ *	  statsRegsSem	- Semaphore for RMON counter access
+ *	  fgtReadMii	   - platform specific SMI register Read function
+ *	  fgtWriteMii	   - platform specific SMI register Write function
+ *	  semCreate	   - function to create semapore
+ *	  semDelete	   - function to delete the semapore
+ *	  semTake		- function to get a semapore
+ *	  semGive		- function to return semaphore
+ *	  appData	      - application data that user may use
+ */
+struct _GT_QD_DEV
+{
+    GT_DEVICE   deviceId;
+    GT_U8       revision;
+    GT_U8		devNum;
+    GT_U8		devEnabled;
+    GT_U8       baseRegAddr;
+    GT_U8       numOfPorts;
+    GT_U8       cpuPortNum;
+    GT_U8       maxPhyNum;
+    GT_U8		stpMode;
+	GT_U8		accessMode;
+	GT_U8		phyAddr;
+	GT_U16		devGroup;
+    GT_U32		devName;
+    GT_SEM		multiAddrSem;
+    GT_SEM		atuRegsSem;
+    GT_SEM		vtuRegsSem;
+    GT_SEM		statsRegsSem;
+
+    FGT_READ_MII 	fgtReadMii;
+    FGT_WRITE_MII 	fgtWriteMii;
+
+    FGT_SEM_CREATE	semCreate; 	/* create semapore */
+    FGT_SEM_DELETE	semDelete; 	/* delete the semapore */
+    FGT_SEM_TAKE	semTake;	/* try to get a semapore */
+    FGT_SEM_GIVE	semGive;	/* return semaphore */
+    void*		appData;
+
+};
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApi_h */
diff -Naur u-boot-1.1.2/include/marvell/msApi.h uboot-1.1.2hsv/include/marvell/msApi.h
--- u-boot-1.1.2/include/marvell/msApi.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/msApi.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,22 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* msApi.h
+*
+* DESCRIPTION:
+*       API definitions for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApi_h
+#define __msApi_h
+
+#include <marvell/msApiDefs.h>
+#include <marvell/msApiInternal.h>
+#include <marvell/msApiPrototype.h>
+
+#endif /* __msApi_h */
diff -Naur u-boot-1.1.2/include/marvell/msApiInternal.h uboot-1.1.2hsv/include/marvell/msApiInternal.h
--- u-boot-1.1.2/include/marvell/msApiInternal.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/msApiInternal.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,670 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* msApiPrototype.h
+*
+* DESCRIPTION:
+*       API Prototypes for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiInternal_h
+#define __msApiInternal_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define GT_LPORT_2_PORT(_lport)      (GT_U8)((_lport) & 0xff)
+#define GT_PORT_2_LPORT(_port)       (GT_32)((_port) & 0xff)
+
+/* The following macro converts a binary    */
+/* value (of 1 bit) to a boolean one.       */
+/* 0 --> GT_FALSE                           */
+/* 1 --> GT_TRUE                            */
+#define BIT_2_BOOL(binVal,boolVal)                                  \
+            (boolVal) = (((binVal) == 0) ? GT_FALSE : GT_TRUE)
+
+/* The following macro converts a boolean   */
+/* value to a binary one (of 1 bit).        */
+/* GT_FALSE --> 0                           */
+/* GT_TRUE --> 1                            */
+#define BOOL_2_BIT(boolVal,binVal)                                  \
+            (binVal) = (((boolVal) == GT_TRUE) ? 1 : 0)
+
+/* device name - devName */
+#define DEV_88E6051                      0x0001    /* quarterdeck 6051      */
+#define DEV_88E6052                      0x0002    /* quarterdeck 6052      */
+#define DEV_88E6021                      0x0004    /* fullsail              */
+#define DEV_88E6060                      0x0008    /* Gondola               */
+#define DEV_88E6063                      0x0010    /* clippership 6063      */
+#define DEV_FF_EG                        0x0020    /* FireFox-EG            */
+#define DEV_FF_HG                        0x0040    /* FireFox-HG            */
+#define DEV_FH_VPN                       0x0080    /* FireHawk-VPN          */
+#define DEV_88E6083                      0x0100    /* Octane 6083           */
+#define DEV_88E6181                      0x0200    /* Sapphire 88E6181      */
+#define DEV_88E6183                      0x0400    /* Sapphire 88E6153,88E6183 */
+#define DEV_88E6093	 	                    0x0800   /* 88E6093                  */
+#define DEV_88E6092	 	                    0x1000   /* 88E6092                  */
+#define DEV_88E6095	 	                    0x2000   /* 88E6095                  */
+#define DEV_88E6182                      0x4000   /* Jade 88E6152, 88E6182 */
+#define DEV_88E6185                      0x8000   /* Jade 88E6155, 88E6185 */
+
+#define DEV_88E6095_FAMILY	( DEV_88E6092 | DEV_88E6095 )
+#define DEV_88E6185_FAMILY	( DEV_88E6182 | DEV_88E6185 )
+
+/* DEV_8PORT_SWITCH is used to access the given device's Register Map */
+#define DEV_8PORT_SWITCH	( DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 	\
+							  DEV_88E6093 | 								\
+							  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_PORT_SECURITY	( DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 	\
+							  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_BROADCAST_INVALID	( DEV_88E6051 | DEV_88E6052 | DEV_FF_EG | DEV_FF_HG)
+
+#define DEV_ATU_256_2048 		( DEV_88E6021 | DEV_88E6060 )
+#define DEV_ATU_562_2048 		\
+						( DEV_88E6052 | DEV_88E6063 | DEV_FF_HG | 	\
+						  DEV_FH_VPN | DEV_88E6083 )
+
+#define DEV_DBNUM_FULL 	\
+						( DEV_88E6021 | DEV_88E6060 | DEV_88E6063 | 	\
+						  DEV_FH_VPN |  DEV_88E6083 |					\
+						  DEV_88E6183 | DEV_88E6093 )
+
+#define DEV_DBNUM_256 	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_STATIC_ADDR	\
+						( DEV_88E6021 | DEV_FF_EG | DEV_FF_HG |			\
+						  DEV_88E6052 | DEV_88E6063 | DEV_FH_VPN |		\
+						  DEV_88E6083 |	DEV_88E6183 | DEV_88E6093 | 	\
+						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY)
+
+#define DEV_TRAILER		\
+						( DEV_88E6021 | DEV_FF_HG | DEV_88E6052 |  		\
+						  DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+
+#define DEV_TRAILER_P5		( DEV_FF_EG )
+#define DEV_TRAILER_P4P5	( DEV_88E6060 )
+
+#define DEV_HEADER		\
+						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |	\
+						  DEV_88E6083 |	DEV_88E6183 | DEV_88E6093 | \
+						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_HEADER_P5		( DEV_FF_EG )
+#define DEV_HEADER_P4P5		( DEV_88E6060 )
+
+/* DEV_QoS : Devices with multiple Queues for QoS Priority Support */
+#define DEV_QoS			\
+						( DEV_88E6021 | DEV_FF_HG |	DEV_88E6051 | 		\
+						  DEV_88E6052 | DEV_88E6063 | DEV_FH_VPN |		\
+						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 	\
+						  DEV_88E6093 | DEV_88E6095_FAMILY |			\
+						  DEV_88E6185_FAMILY )
+
+#define DEV_TAGGING			DEV_QoS
+
+#define DEV_EGRESS_DOUBLE_TAGGING	\
+						( DEV_QoS & ~(DEV_88E6051 | DEV_88E6092 | DEV_88E6182) )
+
+#define DEV_INGRESS_DOUBLE_TAGGING	\
+						( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
+						  DEV_88E6095 | DEV_88E6185 )
+
+#define DEV_PRIORITY_REMAPPING		\
+						( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
+						  DEV_88E6095 | DEV_88E6185 )
+
+
+#define DEV_802_1Q		( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | 			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
+						  DEV_88E6095 | DEV_88E6092 | DEV_88E6185_FAMILY )
+
+#define DEV_802_1S		( DEV_88E6095 | DEV_88E6185 )
+
+#define DEV_802_1W		( DEV_88E6183 | DEV_88E6093 )
+
+#define DEV_RMON		( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | 			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
+						  DEV_88E6092 | DEV_88E6095 | DEV_88E6185_FAMILY ) 
+
+#define DEV_RMON_TYPE_1	( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 ) 
+#define DEV_RMON_TYPE_2 ( DEV_88E6183 )
+#define DEV_RMON_TYPE_3 ( DEV_88E6093 | DEV_88E6095 | DEV_88E6092 | 	\
+						  DEV_88E6185_FAMILY )
+
+#define DEV_IGMP_SNOOPING	\
+						( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
+						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_PORT_MONITORING	\
+						( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
+						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_ENABLE_MONITORING	\
+						( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 )
+
+#define DEV_MC_RATE_PERCENT	\
+						( DEV_88E6021 | DEV_88E6051 | DEV_88E6052 )
+
+#define DEV_MC_RATE_KBPS	\
+						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 )
+
+#define DEV_INGRESS_RATE_KBPS	\
+						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 		\
+						  DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY)
+
+#define DEV_EGRESS_RATE_KBPS	\
+						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 		\
+						  DEV_88E6093 | DEV_88E6095 | DEV_88E6185 )
+
+#define DEV_MII_DUPLEX_CONFIG	\
+						( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |			\
+						  DEV_88E6083 )
+
+#define DEV_QD_PLUS 	\
+					( DEV_88E6021 | DEV_FF_EG | DEV_FF_HG |					\
+					  DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |				\
+					  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 			\
+					  DEV_88E6093 | 										\
+					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_FASTETH_SWITCH	\
+					( DEV_88E6051 | DEV_88E6052 | DEV_88E6021 | 		\
+					  DEV_FF_EG | DEV_FF_HG | DEV_88E6060 | 			\
+					  DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+
+#define DEV_EXTERNAL_PHY	\
+					( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |			\
+					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_EXTERNAL_PHY_ONLY	( DEV_88E6181 | DEV_88E6183 | DEV_88E6185_FAMILY )
+
+#define DEV_FC_WITH_VALUE	( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_CORE_TAG		( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_PCS_LINK		( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_MGMII_STATUS	( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_88E6183_FAMILY		( DEV_88E6183 | DEV_88E6185_FAMILY )
+#define DEV_88E6093_FAMILY		( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_UNMANAGED_SWITCH	( DEV_88E6181 )
+
+#define DEV_GIGABIT_SWITCH		\
+					( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
+					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_GIGABIT_MANAGED_SWITCH	\
+					( DEV_88E6183 | DEV_88E6093 | \
+					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_CROSS_CHIP_VLAN		\
+					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_TRUNK	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_FRAME_SIZE_1632		\
+					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_FLOW_CTRL_DELAY		\
+					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_ENHANCED_CPU_PORT	\
+					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+/* supports Reserved Multicast, etc */
+#define DEV_ENHANCED_MULTICAST	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_ARP_SUPPORT		( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_MARVELL_TAG_FLOW_CTRL	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_USE_DOUBLE_TAG_DATA		( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_MARVELL_TAG_LOOP_BLOCK	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+
+#define DEV_PRIORITY_OVERRIDE	\
+					( DEV_88E6183 | DEV_88E6093 | DEV_88E6095 | 	\
+					  DEV_88E6185 )
+
+#define DEV_STACKING	\
+					( DEV_88E6095 | DEV_88E6185 )
+
+#define DEV_8_TRUNKING	( DEV_88E6092 | DEV_88E6182 )
+
+
+#define IS_IN_DEV_GROUP(dev,_group) (dev->devName & (_group))
+
+/* need to check port number(_hwPort) later */
+#define IS_VALID_API_CALL(dev,_hwPort, _devName)	    	\
+	(!(dev->devName & (_devName)) ? GT_NOT_SUPPORTED : GT_OK)
+
+#define DOES_DEVPORT_SUPPORT_PCS(dev, _hwPort)			\
+	(!(dev->devName & DEV_GIGABIT_SWITCH) || \
+	(!(dev->devName & DEV_EXTERNAL_PHY_ONLY) && (((_hwPort) < 8) || ((_hwPort) > 10)))	\
+	? 0 : 1)
+
+#define IS_CONFIGURABLE_PHY(dev,_hwPort)	(dev->maxPhyNum > (_hwPort))
+
+typedef struct _EXTRA_OP_DATA
+{
+	GT_U32 moveFrom;
+	GT_U32 moveTo;
+	GT_U32 intCause;
+	GT_U32 reserved;
+} GT_EXTRA_OP_DATA;
+
+/*******************************************************************************
+* gvtuGetViolation
+*
+* DESCRIPTION:
+*       Get VTU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*		This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation
+(
+    IN GT_QD_DEV*       dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+);
+
+/*******************************************************************************
+* gvtuGetViolation2
+*
+* DESCRIPTION:
+*       Get VTU Violation data (for Gigabit Device)
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*		This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetViolation2
+(
+    IN GT_QD_DEV*       dev,
+    OUT GT_VTU_INT_STATUS *vtuIntStatus
+);
+
+/*******************************************************************************
+* gatuGetViolation
+*
+* DESCRIPTION:
+*       Get ATU Violation data
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuIntStatus - interrupt cause, source portID, and vid.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORT  - if current device does not support this feature.
+*
+* COMMENTS:
+*		This is an internal function. No user should call this function.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gatuGetViolation
+(
+    IN  GT_QD_DEV         *dev,
+    OUT GT_ATU_INT_STATUS *atuIntStatus
+);
+
+/*******************************************************************************
+* gsysSetRetransmitMode
+*
+* DESCRIPTION:
+*       This routine set the Retransmit Mode.
+*
+* INPUTS:
+*       en - GT_TRUE Retransimt Mode is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRetransmitMode
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL en
+);
+
+/*******************************************************************************
+* gsysGetRetransmitMode
+*
+* DESCRIPTION:
+*       This routine get the Retransmit Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Retransmit Mode is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRetransmitMode
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *en
+);
+
+/*******************************************************************************
+* gsysSetLimitBackoff
+*
+* DESCRIPTION:
+*       This routine set the Limit Backoff bit.
+*
+* INPUTS:
+*       en - GT_TRUE:  uses QoS half duplex backoff operation  
+*            GT_FALSE: uses normal half duplex backoff operation
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetLimitBackoff
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL en
+);
+
+/*******************************************************************************
+* gsysGetLimitBackoff
+*
+* DESCRIPTION:
+*       This routine set the Limit Backoff bit.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE:  uses QoS half duplex backoff operation  
+*            GT_FALSE: uses normal half duplex backoff operation
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetLimitBackoff
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *en
+);
+
+/*******************************************************************************
+* gsysSetRsvRegPri
+*
+* DESCRIPTION:
+*       This routine set the Reserved Queue's Requesting Priority 
+*
+* INPUTS:
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvReqPri
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL en
+);
+
+/*******************************************************************************
+* gsysGetRsvReqPri
+*
+* DESCRIPTION:
+*       This routine get the Reserved Queue's Requesting Priority 
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority 
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvReqPri
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *en
+);
+
+/*******************************************************************************
+* gsysGetPtrCollision
+*
+* DESCRIPTION:
+*       This routine get the QC Pointer Collision.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+* 		This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPtrCollision
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *mode
+);
+
+/*******************************************************************************
+* gsysGetDpvCorrupt
+*
+* DESCRIPTION:
+*       This routine get the DpvCorrupt bit. This bit is set to a one when the 
+*       QC detects a destination vector error
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: destination vector corrupt, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+* 	This feature is on clippership, but not on fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDpvCorrupt
+(
+    IN GT_BOOL *mode
+);
+
+/*******************************************************************************
+* gsysGetMissingPointers
+*
+* DESCRIPTION:
+*       This routine get the Missing Pointer bit. This bit is set to a one when  
+*       the Register File detects less than 64 pointers in the Link List. 
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: Missing Pointers error, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+* 	This feature is on clippership, but not on fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMissingPointers
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_BOOL *mode
+);
+
+/*******************************************************************************
+* gtDbgPrint
+*
+* DESCRIPTION:
+*       .
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void gtDbgPrint(char* format, ...);
+
+
+/*******************************************************************************
+* gtSemRegister
+*
+* DESCRIPTION:
+*       Assign QuarterDeck Semaphore functions to the given semaphore set.
+*		QuarterDeck maintains its own memory for the structure.
+*
+* INPUTS:
+*		semFunctions - point to the GT_SEM_ROUTINES
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtSemRegister
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_SEM_ROUTINES* semRoutines
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApiInternal_h */
diff -Naur u-boot-1.1.2/include/marvell/msApiPrototype.h uboot-1.1.2hsv/include/marvell/msApiPrototype.h
--- u-boot-1.1.2/include/marvell/msApiPrototype.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/msApiPrototype.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,9199 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* msApiPrototype.h
+*
+* DESCRIPTION:
+*       API Prototypes for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiPrototype_h
+#define __msApiPrototype_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbSetAtuSize
+*
+* DESCRIPTION:
+*       Sets the Mac address table size.
+*
+* INPUTS:
+*       size    - Mac address table size.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetAtuSize
+(
+    IN GT_QD_DEV *dev,
+    IN ATU_SIZE size
+);
+
+
+/*******************************************************************************
+* gfdbGetAgingTimeRange
+*
+* DESCRIPTION:
+*       Gets the maximal and minimum age times that the hardware can support.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       maxTimeout - max aging time in secounds.
+*       minTimeout - min aging time in secounds.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAgingTimeRange
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_U32 *maxTimeout,
+    OUT GT_U32 *minTimeout
+);
+
+
+/*******************************************************************************
+* gfdbSetAgingTimeout
+*
+* DESCRIPTION:
+*       Sets the timeout period in seconds for aging out dynamically learned
+*       forwarding information. The standard recommends 300 sec.
+*
+* INPUTS:
+*       timeout - aging time in seconds.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetAgingTimeout
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U32 timeout
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuDynamicCount
+*
+* DESCRIPTION:
+*       Gets the current number of dynamic unicast entries in this
+*       Filtering Database.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numDynEntries - number of dynamic entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuDynamicCount
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_U32 *numDynEntries
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic MAC address entry from the ATU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from Mac[00:00:00:00:00:00]
+*
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuEntryFirst
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_ATU_ENTRY    *atuEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbGetAtuEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic MAC address from the specified Mac Addr.
+*
+* INPUTS:
+*       atuEntry - the Mac Address to start the search.
+*
+* OUTPUTS:
+*       atuEntry - match Address translate unit entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
+*       user.
+*
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbGetAtuEntryNext
+(
+    IN GT_QD_DEV *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbFindAtuMacEntry
+*
+* DESCRIPTION:
+*       Find FDB entry for specific MAC address from the ATU.
+*
+* INPUTS:
+*       atuEntry - the Mac address to search.
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       atuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbFindAtuMacEntry
+(
+    IN GT_QD_DEV *dev,
+    INOUT GT_ATU_ENTRY  *atuEntry,
+    OUT GT_BOOL         *found
+);
+
+
+
+/*******************************************************************************
+* gfdbFlush
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the MAC Address
+*       Table.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbFlush
+(
+    IN GT_QD_DEV *dev,
+    IN GT_FLUSH_CMD flushCmd
+);
+
+/*******************************************************************************
+* gfdbFlushInDB
+*
+* DESCRIPTION:
+*       This routine flush all or unblocked addresses from the particular
+*       ATU Database (DBNum). If multiple address databases are being used, this
+*		API can be used to flush entries in a particular DBNum database.
+*
+* INPUTS:
+*       flushCmd - the flush operation type.
+*		DBNum	 - ATU MAC Address Database Number. 
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbFlushInDB
+(
+    IN GT_QD_DEV *dev,
+    IN GT_FLUSH_CMD flushCmd,
+	IN GT_U8 DBNum
+);
+
+/*******************************************************************************
+* gfdbAddMacEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in MAC address table.
+*
+* INPUTS:
+*       macEntry    - mac address entry to insert to the ATU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_NO_RESOURCE    - failed to allocate a t2c struct
+*       GT_OUT_OF_CPU_MEM - oaMalloc failed
+*
+* COMMENTS:
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbAddMacEntry
+(
+    IN GT_QD_DEV *dev,
+    IN GT_ATU_ENTRY *macEntry
+);
+
+
+
+/*******************************************************************************
+* gfdbDelMacEntry
+*
+* DESCRIPTION:
+*       Deletes MAC address entry.
+*
+* INPUTS:
+*       macAddress - mac address.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*       For SVL mode vlan Id is ignored.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbDelMacEntry
+(
+    IN GT_QD_DEV *dev,
+    IN GT_ETHERADDR  *macAddress
+);
+
+/*******************************************************************************
+* gfdbDelAtuEntry
+*
+* DESCRIPTION:
+*       Deletes ATU entry.
+*
+* INPUTS:
+*       atuEntry - the ATU entry to be deleted.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_RESOURCE  - failed to allocate a t2c struct
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*		DBNum in atuEntry - 
+*			ATU MAC Address Database number. If multiple address 
+*			databases are not being used, DBNum should be zero.
+*			If multiple address databases are being used, this value
+*			should be set to the desired address database number.
+*
+*******************************************************************************/
+GT_STATUS gfdbDelAtuEntry
+(
+    IN GT_QD_DEV *dev,
+    IN GT_ATU_ENTRY  *atuEntry
+);
+
+/*******************************************************************************
+* gfdbLearnEnable
+*
+* DESCRIPTION:
+*       Enable/disable automatic learning of new source MAC addresses on port
+*       ingress.
+*
+* INPUTS:
+*       en - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbLearnEnable
+(
+    IN GT_QD_DEV *dev,
+    IN GT_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gstpSetMode
+*
+* DESCRIPTION:
+*       This routine Enable the Spanning tree.
+*
+* INPUTS:
+*       en - GT_TRUE for enable, GT_FALSE for disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       when enabled, this function sets all port to blocking state, and inserts
+*       the BPDU MAC into the ATU to be captured to CPU, on disable all port are
+*       being modified to be in forwarding state.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpSetMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gstpSetPortState
+*
+* DESCRIPTION:
+*       This routine set the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       state - the port state to set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpSetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT           port,
+    IN GT_PORT_STP_STATE  state
+);
+
+
+
+/*******************************************************************************
+* gstpGetPortState
+*
+* DESCRIPTION:
+*       This routine returns the port state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       state - the current port state.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstpGetPortState
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT           port,
+    OUT GT_PORT_STP_STATE  *state
+);
+
+/*******************************************************************************
+* gprtSetEgressMode
+*
+* DESCRIPTION:
+*       This routine set the egress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the egress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT        port,
+    IN GT_EGRESS_MODE  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetEgressMode
+*
+* DESCRIPTION:
+*       This routine get the egress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the egress mode.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_EGRESS_MODE  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine sets the vlan tunnel mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the vlan tunnel mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetVlanTunnel
+*
+* DESCRIPTION:
+*       This routine get the vlan tunnel mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the vlan tunnel mode..
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetVlanTunnel
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+/*******************************************************************************
+* gprtSetIGMPSnoop
+*
+* DESCRIPTION:
+* 		This routine set the IGMP Snoop. When set to one and this port receives
+*		IGMP frame, the frame is switched to the CPU port, overriding all other 
+*		switching decisions, with exception for CPU's Trailer.
+*		CPU port is determined by the Ingress Mode bits. A port is considered 
+*		the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or 
+*		GT_CPUPORT_INGRESS.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIGMPSnoop
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* gprtGetIGMPSnoop
+*
+* DESCRIPTION:
+*		This routine get the IGMP Snoop mode.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: IGMP Snoop enabled
+*  			GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIGMPSnoop
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/* the following two APIs are added to support clippership */
+
+/*******************************************************************************
+* gprtSetHeaderMode
+*
+* DESCRIPTION:
+*		This routine set ingress and egress header mode of a switch port. 
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for header mode  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetHeaderMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* gprtGetHeaderMode
+*
+* DESCRIPTION:
+*		This routine gets ingress and egress header mode of a switch port. 
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: header mode enabled
+*  			GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHeaderMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+/*******************************************************************************
+* gprtSetProtectedMode
+*
+* DESCRIPTION:
+*		This routine set protected mode of a switch port. 
+*		When this mode is set to GT_TRUE, frames are allowed to egress port
+*		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*		by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*		allow the frame to Egress.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetProtectedMode
+(
+    IN  GT_QD_DEV   *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
+);
+
+/*******************************************************************************
+* gprtGetProtectedMode
+*
+* DESCRIPTION:
+*		This routine gets protected mode of a switch port. 
+*		When this mode is set to GT_TRUE, frames are allowed to egress port
+*		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*		by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*		allow the frame to Egress.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: header mode enabled
+*  			GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetProtectedMode
+(
+    IN  GT_QD_DEV		*dev,
+    IN  GT_LPORT		port,
+    OUT GT_BOOL		*mode
+);
+
+/*******************************************************************************
+* gprtSetForwardUnknown
+*
+* DESCRIPTION:
+*		This routine set Forward Unknown mode of a switch port. 
+*		When this mode is set to GT_TRUE, normal switch operation occurs.
+*		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*		will not egress out this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetForwardUnknown
+(
+    IN GT_QD_DEV	*dev,
+    IN GT_LPORT	port,
+    IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetForwardUnknown
+*
+* DESCRIPTION:
+*		This routine gets Forward Unknown mode of a switch port. 
+*		When this mode is set to GT_TRUE, normal switch operation occurs.
+*		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*		will not egress out this port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: header mode enabled
+*				GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetForwardUnknown
+(
+    IN  GT_QD_DEV		*dev,
+    IN  GT_LPORT		port,
+    OUT GT_BOOL		*mode
+);
+
+/*******************************************************************************
+* gprtGetSwitchReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSwitchReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32	     regAddr,
+    OUT GT_U16	     *data
+);
+
+/*******************************************************************************
+* gprtSetSwitchReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Port Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetSwitchReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32	     regAddr,
+    IN  GT_U16	     data
+);
+
+
+/*******************************************************************************
+* gprtGetGlobalReg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobalReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32	     regAddr,
+    OUT GT_U16	     *data
+);
+
+/*******************************************************************************
+* gprtSetGlobalReg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobalReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32	     regAddr,
+    IN  GT_U16	     data
+);
+
+
+
+/*******************************************************************************
+* gvlnSetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*       memPorts    - array of logical ports.
+*       memPortsLen - number of members in memPorts array
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_LPORT memPorts[],
+    IN GT_U8    memPortsLen
+);
+
+
+
+/*******************************************************************************
+* gvlnGetPortVlanPorts
+*
+* DESCRIPTION:
+*       This routine gets the port VLAN group port membership list.
+*
+* INPUTS:
+*       port        - logical port number to set.
+*
+* OUTPUTS:
+*       memPorts    - array of logical ports.
+*       memPortsLen - number of members in memPorts array
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanPorts
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_LPORT memPorts[],
+    OUT GT_U8    *memPortsLen
+);
+
+
+
+
+/*******************************************************************************
+* gvlnSetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine Set the user priority (VPT) LSB bit, to be added to the
+*       user priority on the egress.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortUserPriLsb
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  userPriLsb
+);
+
+
+
+/*******************************************************************************
+* gvlnGetPortUserPriLsb
+*
+* DESCRIPTION:
+*       This routine gets the user priority (VPT) LSB bit.
+*
+* INPUTS:
+*       port       - logical port number to set.
+*
+* OUTPUTS:
+*       userPriLsb - GT_TRUE for 1, GT_FALSE for 0.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortUserPriLsb
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *userPriLsb
+);
+
+
+/*******************************************************************************
+* gvlnSetPortVid
+*
+* DESCRIPTION:
+*       This routine Set the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*       vid  - the port vlan id.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVid
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_U16   vid
+);
+
+
+/*******************************************************************************
+* gvlnGetPortVid
+*
+* DESCRIPTION:
+*       This routine Get the port default vlan id.
+*
+* INPUTS:
+*       port - logical port number to set.
+*
+* OUTPUTS:
+*       vid  - the port vlan id.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVid
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U16   *vid
+);
+
+/*******************************************************************************
+* gvlnSetPortVlanDBNum
+*
+* DESCRIPTION:
+*       This routine sets the port VLAN database number (DBNum).
+*
+* INPUTS:
+*       port	- logical port number to set.
+*       DBNum 	- database number for this port 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_U8    DBNum
+);
+
+
+/*******************************************************************************
+* gvlnGetPortVlanDBNum
+*
+* DESCRIPTION:IN GT_INGRESS_MODE mode
+*       This routine gets the port VLAN database number (DBNum).
+*
+* INPUTS:
+*       port 	- logical port number to get.
+*
+* OUTPUTS:
+*       DBNum 	- database number for this port 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanDBNum
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_U8    *DBNum
+);
+
+/********************************************************************
+* gvlnSetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine sets the port 802.1q mode (11:10) 
+*
+* INPUTS:
+*       port	- logical port number to set.
+*       mode 	- 802.1q mode for this port 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:IN GT_INGRESS_MODE mode
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanDot1qMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT 	port,
+    IN GT_DOT1Q_MODE	mode
+);
+
+/*******************************************************************************
+* gvlnGetPortVlanDot1qMode
+*
+* DESCRIPTION:
+*       This routine gets the port 802.1q mode (bit 11:10).
+*
+* INPUTS:
+*       port 	- logical port number to get.
+*
+* OUTPUTS:
+*       mode 	- 802.1q mode for this port 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanDot1qMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_DOT1Q_MODE    *mode
+);
+
+
+/********************************************************************
+* gvlnSetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine sets the port 802.1q mode (11:10) 
+*
+* INPUTS:
+*       port	- logical port number to set.
+*       mode    - GT_TRUE, force to use default VID
+*                 GT_FAULSE, otherwise 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnSetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT 	port,
+    IN GT_BOOL  	mode
+);
+
+/*******************************************************************************
+* gvlnGetPortVlanForceDefaultVID
+*
+* DESCRIPTION:
+*       This routine gets the port mode for ForceDefaultVID (bit 12).
+*
+* INPUTS:
+*       port 	- logical port number to get.
+*
+* OUTPUTS:
+*       mode 	- ForceDefaultVID mode for this port 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvlnGetPortVlanForceDefaultVID
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT 	 port,
+    OUT GT_BOOL    	*mode
+);
+
+/*******************************************************************************
+* eventSetActive
+*
+* DESCRIPTION:
+*       This routine enables/disables the receive of an hardware driven event.
+*
+* INPUTS:
+*       eventType - the event type. any combination of the folowing: 
+*       	GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+*       	GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS eventSetActive
+(
+    IN GT_QD_DEV 	*dev,
+    IN GT_U32 		eventType
+);
+
+/*******************************************************************************
+* eventGetIntStatus
+*
+* DESCRIPTION:
+*       This routine reads an hardware driven event status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       intCause -  It provides the source of interrupt of the following:
+*       GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+*       GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT.
+*		For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_FULL and 
+*		GT_PHY_INTERRUPT is not supported.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS eventGetIntStatus
+(
+    IN  GT_QD_DEV 	*dev,
+    OUT GT_U16		*intCause
+);
+
+/*******************************************************************************
+* gvtuGetIntStatus
+*
+* DESCRIPTION:
+* 		Check to see if a specific type of VTU interrupt occured
+*
+* INPUTS:
+*       intType - the type of interrupt which causes an interrupt.
+*			any combination of 
+*			GT_MEMEBER_VIOLATION,
+*			GT_MISS_VIOLATION,
+*			GT_FULL_VIOLATION
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK   - on success
+* 		GT_FAIL - on error
+*
+* COMMENTS:
+* 		FULL_VIOLATION is only for Fast Ethernet Switch (not for Gigabit Switch).
+*
+*******************************************************************************/
+
+GT_STATUS gvtuGetIntStatus
+(
+    IN  GT_QD_DEV 			*dev,
+    OUT GT_VTU_INT_STATUS 	*vtuIntStatus
+);
+
+/*******************************************************************************
+* gvtuGetEntryCount
+*
+* DESCRIPTION:
+*       Gets the current number of entries in the VTU table
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       numEntries - number of VTU entries.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - vlan does not exist.
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryCount
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U32 		*numEntries
+);
+
+/*******************************************************************************
+* gvtuGetEntryFirst
+*
+* DESCRIPTION:
+*       Gets first lexicographic entry from the VTU.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU entry.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*
+* COMMENTS:
+*       Search starts from vid of all one's
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryFirst
+(
+	IN  GT_QD_DEV 		*dev,
+	OUT GT_VTU_ENTRY	*vtuEntry
+);
+
+/*******************************************************************************
+* gvtuGetEntryNext
+*
+* DESCRIPTION:
+*       Gets next lexicographic VTU entry from the specified VID.
+*
+* INPUTS:
+*       vtuEntry - the VID to start the search.
+*
+* OUTPUTS:
+*       vtuEntry - match VTU  entry.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*       Search starts from the VID specified by the user.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuGetEntryNext
+(
+	IN  GT_QD_DEV 		*dev,
+	INOUT GT_VTU_ENTRY  *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuFindVidEntry
+*
+* DESCRIPTION:
+*       Find VTU entry for a specific VID, it will return the entry, if found, 
+*       along with its associated data 
+*
+* INPUTS:
+*       vtuEntry - contains the VID to search for.
+*
+* OUTPUTS:
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       vtuEntry - the entry parameters.
+*
+* RETURNS:
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuFindVidEntry
+(
+	IN GT_QD_DEV 		*dev,
+	INOUT GT_VTU_ENTRY  *vtuEntry,
+	OUT GT_BOOL         *found
+);
+
+/*******************************************************************************
+* gvtuFlush
+*
+* DESCRIPTION:
+*       This routine removes all entries from VTU Table.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuFlush
+(
+    IN GT_QD_DEV *dev
+);
+
+/*******************************************************************************
+* gvtuAddEntry
+*
+* DESCRIPTION:
+*       Creates the new entry in VTU table based on user input.
+*
+* INPUTS:
+*       vtuEntry    - vtu entry to insert to the VTU.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*       GT_FULL			  - vtu table is full
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuAddEntry
+(
+    IN GT_QD_DEV 	*dev,
+    IN GT_VTU_ENTRY *vtuEntry
+);
+
+/*******************************************************************************
+* gvtuDelEntry
+*
+* DESCRIPTION:
+*       Deletes VTU entry specified by user.
+*
+* INPUTS:
+*       vtuEntry - the VTU entry to be deleted 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NO_SUCH      - if specified address entry does not exist
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gvtuDelEntry
+(
+    IN GT_QD_DEV 	*dev,
+    IN GT_VTU_ENTRY *vtuEntry
+);
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtPhyReset
+*
+* DESCRIPTION:
+*		This routine preforms PHY reset.
+*		After reset, phy will be in Autonegotiation mode.
+*
+* INPUTS:
+* 		port - The logical port number
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+* COMMENTS:
+* 		data sheet register 0.15 - Reset
+* 		data sheet register 0.13 - Speed
+* 		data sheet register 0.12 - Autonegotiation
+* 		data sheet register 0.8  - Duplex Mode
+*
+*******************************************************************************/
+
+GT_STATUS gprtPhyReset
+(
+    IN GT_QD_DEV 	*dev,
+    IN GT_LPORT 	port
+);
+
+
+/*******************************************************************************
+* gprtSetPortLoopback
+*
+* DESCRIPTION:
+* 		Enable/Disable Internal Port Loopback. Enabling Loopback will disable the 
+* 		Autonegotiation and set the phy mode to 10 Half duplex.
+* 		To test Loopback on a different mode, such as 100 Full duplex, 
+* 		user may need to call gprtSetPortSpeed and gprtSetPortDuplexMode.
+* 		Disabling Loopback does not enable the Autonegotiation, so user may need to call
+* 		gprtPortAutoNegEnable in order to enable Autonegotiation.
+*
+* INPUTS:
+* 		port - logical port number
+* 		enable - If GT_TRUE, enable loopback mode
+* 					If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortLoopback
+(
+	IN GT_QD_DEV 	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL 		enable
+);
+
+
+/*******************************************************************************
+* gprtSetPortSpeed
+*
+* DESCRIPTION:
+* 		Sets speed for a specific logical port. This function will keep the duplex 
+*		mode and loopback mode to the previous value, but disable others, such as 
+*		Autonegotiation.
+*
+* INPUTS:
+* 		port  - logical port number
+* 		speed - port speed. 	GT_TRUE=100Mb/s, GT_FALSE=10Mb/s
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.13 - Speed Selection (LSB)
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortSpeed
+(
+	IN GT_QD_DEV 	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	speed
+);
+
+
+/*******************************************************************************
+* gprtPortAutoNegEnable
+*
+* DESCRIPTION:
+* 		Enable/disable an Auto-Negotiation for duplex mode on specific
+* 		logical port. When Autonegotiation is disabled, phy will be in 10Mbps Half 
+*		Duplex mode. Enabling Autonegotiation will set 100BASE-TX Full Duplex, 
+*		100BASE-TX Full Duplex, 100BASE-TX Full Duplex, and 100BASE-TX Full Duplex
+*		in AutoNegotiation Advertisement register.
+*
+* INPUTS:
+* 		port - logical port number
+* 		state - GT_TRUE for enable Auto-Negotiation for duplex mode,
+* 					GT_FALSE otherwise
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.12 - Auto-Negotiation Enable
+* 		data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortAutoNegEnable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL 		state
+);
+
+
+/*******************************************************************************
+* gprtPortPowerDown
+*
+* DESCRIPTION:
+* 		Enable/disable (power down) on specific logical port. When this function 
+*		is called with normal operation request, phy will set to Autonegotiation 
+*		mode.
+*
+* INPUTS:
+* 		port	- logical port number
+* 		state	-  GT_TRUE: power down
+* 					GT_FALSE: normal operation
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortPowerDown
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		state
+);
+
+
+/*******************************************************************************
+* gprtPortRestartAutoNeg
+*
+* DESCRIPTION:
+* 		Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
+*		it. Loopback and Power Down will be disabled by this routine.
+*
+* INPUTS:
+* 		port - logical port number
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.9 - Restart Auto-Negotiation
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortRestartAutoNeg
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+);
+
+
+/*******************************************************************************
+* gprtSetPortDuplexMode
+*
+* DESCRIPTION:
+* 		Sets duplex mode for a specific logical port. This function will keep 
+*		the speed and loopback mode to the previous value, but disable others,
+*		such as Autonegotiation.
+*
+* INPUTS:
+* 		port 	- logical port number
+* 		dMode	- dulpex mode
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+* 		data sheet register 0.8 - Duplex Mode
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortDuplexMode
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		dMode
+);
+
+
+/*******************************************************************************
+* gprtSetPortAutoMode
+*
+* DESCRIPTION:
+* 		This routine sets up the port with given Auto Mode.
+*		Supported mode is as follows:
+*		- Auto for both speed and duplex.
+*		- Auto for speed only and Full duplex.
+*		- Auto for speed only and Half duplex.
+*		- Auto for duplex only and speed 1000Mbps.
+*		- Auto for duplex only and speed 100Mbps.
+*		- Auto for duplex only and speed 10Mbps.
+*		- Speed 1000Mbps and Full duplex.
+*		- Speed 1000Mbps and Half duplex.
+*		- Speed 100Mbps and Full duplex.
+*		- Speed 100Mbps and Half duplex.
+*		- Speed 10Mbps and Full duplex.
+*		- Speed 10Mbps and Half duplex.
+*		
+*
+* INPUTS:
+* 		port - The logical port number
+* 		mode - Auto Mode to be written
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+* COMMENTS:
+* 		data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+* 		data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+* 		data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+
+GT_STATUS gprtSetPortAutoMode
+(
+	IN GT_QD_DEV 	*dev,
+	IN GT_LPORT 	port,
+	IN GT_PHY_AUTO_MODE mode
+);
+
+/*******************************************************************************
+* gprtSetPause
+*
+* DESCRIPTION:
+*		This routine will set the pause bit in Autonegotiation Advertisement
+*		Register. And restart the autonegotiation.
+*
+* INPUTS:
+* 		port 	- The logical port number
+* 		state - either GT_TRUE(for enable) or GT_FALSE(for disable)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+* COMMENTS:
+* 		data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+
+GT_STATUS gprtSetPause
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL 		state
+);
+
+/*******************************************************************************
+* gprtGetPhyReg
+*
+* DESCRIPTION:
+*       This routine reads Phy Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32	     regAddr,
+    OUT GT_U16	     *data
+);
+
+/*******************************************************************************
+* gprtSetPhyReg
+*
+* DESCRIPTION:
+*       This routine writes Phy Registers.
+*
+* INPUTS:
+*       port    - logical port number
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32	     regAddr,
+    IN  GT_U16	     data
+);
+
+
+/*******************************************************************************
+* gprtPhyIntEnable
+*
+* DESCRIPTION:
+* Enable/Disable one PHY Interrupt
+* This register determines whether the INT# pin is asserted when an interrupt 
+* event occurs. When an interrupt occurs, the corresponding bit is set and
+* remains set until register 19 is read via the SMI. When interrupt enable
+* bits are not set in register 18, interrupt status bits in register 19 are 
+* still set when the corresponding interrupt events occur. However, the INT# 
+* is not asserted.
+*
+* INPUTS:
+* port    - logical port number
+* intType - the type of interrupt to enable/disable. any combination of 
+*			GT_SPEED_CHANGED,
+*			GT_DUPLEX_CHANGED,
+*			GT_PAGE_RECEIVED,
+*			GT_AUTO_NEG_COMPLETED,
+*			GT_LINK_STATUS_CHANGED,
+*			GT_SYMBOL_ERROR,
+*			GT_FALSE_CARRIER,
+*			GT_FIFO_FLOW,
+*			GT_CROSSOVER_CHANGED,
+*			GT_POLARITY_CHANGED, and
+*			GT_JABBER
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 18
+*
+*******************************************************************************/
+
+GT_STATUS gprtPhyIntEnable
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT   port,
+IN GT_U16	intType
+);
+
+
+/*******************************************************************************
+* gprtGetPhyIntStatus
+*
+* DESCRIPTION:
+* Check to see if a specific type of  interrupt occured
+*
+* INPUTS:
+* port - logical port number
+* intType - the type of interrupt which causes an interrupt.
+*			any combination of 
+*			GT_SPEED_CHANGED,
+*			GT_DUPLEX_CHANGED,
+*			GT_PAGE_RECEIVED,
+*			GT_AUTO_NEG_COMPLETED,
+*			GT_LINK_STATUS_CHANGED,
+*			GT_SYMBOL_ERROR,
+*			GT_FALSE_CARRIER,
+*			GT_FIFO_FLOW,
+*			GT_CROSSOVER_CHANGED,
+*			GT_POLARITY_CHANGED, and
+*			GT_JABBER
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 19
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntStatus
+(
+IN GT_QD_DEV *dev,
+IN  GT_LPORT port,
+OUT  GT_U16* intType
+);
+
+/*******************************************************************************
+* gprtGetPhyIntPortSummary
+*
+* DESCRIPTION:
+* Lists the ports that have active interrupts. It provides a quick way to 
+* isolate the interrupt so that the MAC or switch does not have to poll the
+* interrupt status register (19) for all ports. Reading this register does not
+* de-assert the INT# pin
+*
+* INPUTS:
+* none
+*
+* OUTPUTS:
+* GT_U8 *intPortMask - bit Mask with the bits set for the corresponding 
+* phys with active interrupt. E.g., the bit number 0 and 2 are set when 
+* port number 0 and 2 have active interrupt
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 20
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntPortSummary
+(
+IN GT_QD_DEV *dev,
+OUT GT_U16 *intPortMask
+);
+
+
+
+/*******************************************************************************
+* gprtSetForceFc
+*
+* DESCRIPTION:
+*       This routine set the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetForceFc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  force
+);
+
+
+
+/*******************************************************************************
+* gprtGetForceFc
+*
+* DESCRIPTION:
+*       This routine get the force flow control state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetForceFc
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *force
+);
+
+
+
+/*******************************************************************************
+* gprtSetTrailerMode
+*
+* DESCRIPTION:
+*       This routine set the egress trailer mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetTrailerMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetTrailerMode
+*
+* DESCRIPTION:
+*       This routine get the egress trailer mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for add trailer or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTrailerMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetIngressMode
+*
+* DESCRIPTION:
+*       This routine set the ingress mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIngressMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT        port,
+    IN GT_INGRESS_MODE mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetIngressMode
+*
+* DESCRIPTION:
+*       This routine get the ingress mode.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - the ingress mode.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIngressMode
+(
+    IN GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_INGRESS_MODE *mode
+);
+
+
+
+/*******************************************************************************
+* gprtSetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine set the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMcRateLimit
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT     port,
+    IN GT_MC_RATE   rate
+);
+
+
+
+/*******************************************************************************
+* gprtGetMcRateLimit
+*
+* DESCRIPTION:
+*       This routine Get the port multicast rate limit.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       rate - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMcRateLimit
+(
+    IN GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_MC_RATE  *rate
+);
+
+
+
+/*******************************************************************************
+* gprtSetCtrMode
+*
+* DESCRIPTION:
+*       This routine sets the port counters mode of operation.
+*
+* INPUTS:
+*       mode  - the counter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetCtrMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_CTR_MODE  mode
+);
+
+
+
+/*******************************************************************************
+* gprtClearAllCtr
+*
+* DESCRIPTION:
+*       This routine clears all port counters.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtClearAllCtr
+(
+    IN GT_QD_DEV *dev
+);
+
+
+/*******************************************************************************
+* gprtGetPortCtr
+*
+* DESCRIPTION:
+*       This routine gets the port counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortCtr
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT    *ctr
+);
+
+
+
+
+/*******************************************************************************
+* gprtGetPartnerLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link partner pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPartnerLinkPause
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetSelfLinkPause
+*
+* DESCRIPTION:
+*       This routine retrives the link pause state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for enable  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSelfLinkPause
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetResolve
+*
+* DESCRIPTION:
+*       This routine retrives the resolve state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Done  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetResolve
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetLinkState
+*
+* DESCRIPTION:
+*       This routine retrives the link state.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       state - GT_TRUE for Up  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLinkState
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *state
+);
+
+
+
+/*******************************************************************************
+* gprtGetPortMode
+*
+* DESCRIPTION:
+*       This routine retrives the port mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetPhyMode
+*
+* DESCRIPTION:
+*       This routine retrives the PHY mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for MII PHY  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyMode
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetDuplex
+*
+* DESCRIPTION:
+*       This routine retrives the port duplex mode.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for Full  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDuplex
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gprtGetSpeed
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       speed - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for 100Mb/s  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSpeed
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *speed
+);
+
+/*******************************************************************************
+* gprtSetDuplex
+*
+* DESCRIPTION:
+*       This routine sets the duplex mode of MII/SNI/RMII ports.
+*
+* INPUTS:
+*       port - 	the logical port number.
+*				(for FullSail, it will be port 2, and for ClipperShip, 
+*				it could be either port 5 or port 6.)
+*       mode -  GT_TRUE for Full Duplex,
+*				GT_FALSE for Half Duplex.
+*
+* OUTPUTS: None
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDuplex
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    IN  GT_BOOL  mode
+);
+
+
+/*******************************************************************************
+* gqosSetPortDefaultTc
+*
+* DESCRIPTION:
+*       Sets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*       trafClass - default traffic class of a port.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosSetPortDefaultTc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_U8    trafClass
+);
+
+
+/*******************************************************************************
+* gcosGetPortDefaultTc
+*
+* DESCRIPTION:
+*       Gets the default traffic class for a specific port.
+*
+* INPUTS:
+*       port      - logical port number
+*
+* OUTPUTS:
+*       trafClass - default traffic class of a port.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gcosGetPortDefaultTc
+(
+    IN  GT_QD_DEV *dev,
+    IN GT_LPORT   port,
+    OUT GT_U8     *trafClass
+);
+
+
+/*******************************************************************************
+* gqosSetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine sets priority mapping rule.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetPrioMapRule
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+
+
+/*******************************************************************************
+* gqosGetPrioMapRule
+*
+* DESCRIPTION:
+*       This routine get the priority mapping rule.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetPrioMapRule
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+
+
+/*******************************************************************************
+* gqosIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the IP priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosIpPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gqosGetIpPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the IP priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetIpPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *en
+);
+
+
+
+/*******************************************************************************
+* gqosUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine enables the user priority mapping.
+*
+* INPUTS:
+*       port - the logical port number.
+*       en   - GT_TRUE to Enable, GT_FALSE for otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosUserPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  en
+);
+
+
+
+/*******************************************************************************
+* gqosGetUserPrioMapEn
+*
+* DESCRIPTION:
+*       This routine return the user priority mapping state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       en    - GT_TRUE for user prio rule, GT_FALSE for otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetUserPrioMapEn
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *en
+);
+
+
+
+/*******************************************************************************
+* gcosGetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Gets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+GT_STATUS gcosGetUserPrio2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    userPrior,
+    OUT GT_U8   *trClass
+);
+
+
+/*******************************************************************************
+* gcosSetUserPrio2Tc
+*
+* DESCRIPTION:
+*       Sets the traffic class number for a specific 802.1p user priority.
+*
+* INPUTS:
+*       userPrior - user priority of a port.
+*       trClass   - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+GT_STATUS gcosSetUserPrio2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8    userPrior,
+    IN GT_U8    trClass
+);
+
+
+/*******************************************************************************
+* gcosGetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine retrieves the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to query.
+*
+* OUTPUTS:
+*       trClass - The Traffic Class the received frame is assigned.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+GT_STATUS gcosGetDscp2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8   dscp,
+    OUT GT_U8   *trClass
+);
+
+
+/*******************************************************************************
+* gcosSetDscp2Tc
+*
+* DESCRIPTION:
+*       This routine sets the traffic class assigned for a specific
+*       IPv4 Dscp.
+*
+* INPUTS:
+*       dscp    - the IPv4 frame dscp to map.
+*       trClass - the Traffic Class the received frame is assigned.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*       Table - UserPrio2Tc
+*
+*******************************************************************************/
+GT_STATUS gcosSetDscp2Tc
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8    dscp,
+    IN GT_U8    trClass
+);
+
+
+/*******************************************************************************
+* qdLoadDriver
+*
+* DESCRIPTION:
+*       QuarterDeck Driver Initialization Routine. 
+*       This is the first routine that needs be called by system software. 
+*       It takes sysCfg from system software, and retures a pointer (*dev) 
+*       to a data structure which includes infomation related to this QuarterDeck
+*       device. This pointer (*dev) is then used for all the API functions. 
+*
+* INPUTS:
+*       sysCfg      - Holds system configuration parameters.
+*
+* OUTPUTS:
+*       dev         - Holds general system information.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_ALREADY_EXIST    - if device already started
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+* 	qdUnloadDriver is provided when the driver is not to be used anymore.
+*
+*******************************************************************************/
+GT_STATUS qdLoadDriver
+(
+    IN  GT_SYS_CONFIG   *sysCfg,
+    OUT GT_QD_DEV	*dev
+);
+
+
+/*******************************************************************************
+* qdUnloadDriver
+*
+* DESCRIPTION:
+*       This function unloads the QuaterDeck Driver.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       1.  This function should be called only after successful execution of
+*           qdLoadDriver().
+*
+*******************************************************************************/
+GT_STATUS qdUnloadDriver
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* sysEnable
+*
+* DESCRIPTION:
+*       This function enables the system for full operation.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS sysEnable
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSwReset
+*
+* DESCRIPTION:
+*       This routine preforms switch software reset.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSwReset
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine set the Discard Excessive state.
+*
+* INPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDiscardExcessive
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetDiscardExcessive
+*
+* DESCRIPTION:
+*       This routine get the Discard Excessive state.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDiscardExcessive
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL *en
+);
+
+
+
+/*******************************************************************************
+* gsysSetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine set the Scheduling Mode.
+*
+* INPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetSchedulingMode
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL mode
+);
+
+
+
+/*******************************************************************************
+* gsysGetSchedulingMode
+*
+* DESCRIPTION:
+*       This routine get the Scheduling Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE wrr, GT_FALSE strict.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSchedulingMode
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_BOOL *mode
+);
+
+
+
+/*******************************************************************************
+* gsysSetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Set the max frame size allowed.
+*
+* INPUTS:
+*       mode - GT_TRUE max size 1522, GT_FALSE max size 1535.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetMaxFrameSize
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL mode
+);
+
+
+
+/*******************************************************************************
+* gsysGetMaxFrameSize
+*
+* DESCRIPTION:
+*       This routine Get the max frame size allowed.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE max size 1522, GT_FALSE max size 1535.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMaxFrameSize
+(
+    IN GT_QD_DEV *dev,
+    OUT GT_BOOL *mode
+);
+
+
+
+/*******************************************************************************
+* gsysReLoad
+*
+* DESCRIPTION:
+*       This routine cause to the switch to reload the EEPROM.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysReLoad
+(
+    IN GT_QD_DEV* dev
+);
+
+
+/*******************************************************************************
+* gsysSetWatchDog
+*
+* DESCRIPTION:
+*       This routine Set the the watch dog mode.
+*
+* INPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetWatchDog
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetWatchDog
+*
+* DESCRIPTION:
+*       This routine Get the the watch dog mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       en - GT_TRUE enables, GT_FALSE disable.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetWatchDog
+(
+    IN GT_QD_DEV* dev,
+    OUT GT_BOOL *en
+);
+
+
+/*******************************************************************************
+* gsysSetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets the full duplex pause src Mac Address.
+*
+* INPUTS:
+*       mac - The Mac address to be set.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN GT_ETHERADDR *mac
+);
+
+
+/*******************************************************************************
+* gsysGetDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets the full duplex pause src Mac Address.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    OUT GT_ETHERADDR *mac
+);
+
+
+
+/*******************************************************************************
+* gsysSetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine sets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPerPortDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL en
+);
+
+
+
+/*******************************************************************************
+* gsysGetPerPortDuplexPauseMac
+*
+* DESCRIPTION:
+*       This routine Gets whether the full duplex pause src Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPerPortDuplexPauseMac
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL *en
+);
+
+
+/*******************************************************************************
+* gsysReadMiiRegister
+*
+* DESCRIPTION:
+*       This routine reads QuarterDeck Registers. Since this routine is only for
+*		Diagnostic Purpose, no error checking will be performed.
+*		User has to know exactly which phy address(0 ~ 0x1F) will be read.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysReadMiiReg
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_U32	phyAddr,
+    IN  GT_U32	regAddr,
+    OUT GT_U32	*data
+);
+
+/*******************************************************************************
+* gsysWriteMiiRegister
+*
+* DESCRIPTION:
+*       This routine writes QuarterDeck Registers. Since this routine is only for
+*		Diagnostic Purpose, no error checking will be performed.
+*		User has to know exactly which phy address(0 ~ 0x1F) will be read.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*       data    - data to be written.
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysWriteMiiReg
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_U32	phyAddr,
+    IN  GT_U32	regAddr,
+    IN  GT_U16	data
+);
+
+/*******************************************************************************
+* gsysGetSW_Mode
+*
+* DESCRIPTION:
+*       This routine get the Switch mode. These two bits returen 
+*       the current value of the SW_MODE[1:0] pins.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+* 		This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSW_Mode
+(
+    IN GT_QD_DEV* dev,
+    IN GT_SW_MODE *mode
+);
+
+/*******************************************************************************
+* gsysGetInitReady
+*
+* DESCRIPTION:
+*       This routine get the InitReady bit. This bit is set to a one when the ATU,
+*       the Queue Controller and the Statistics Controller are done with their 
+*       initialization and are ready to accept frames.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+* 		This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetInitReady
+(
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL *mode
+);
+
+
+/*******************************************************************************
+* gstatsFlushAll
+*
+* DESCRIPTION:
+*       Flush All RMON counters for all ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushAll
+(
+    IN GT_QD_DEV* dev
+);
+
+/*******************************************************************************
+* gstatsFlushPort
+*
+* DESCRIPTION:
+*       Flush All RMON counters for a given port.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushPort
+(
+    IN GT_QD_DEV* dev,
+    IN GT_LPORT	port
+);
+
+/*******************************************************************************
+* gstatsGetPortCounter
+*
+* DESCRIPTION:
+*		This routine gets a specific counter of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*		counter - the counter which will be read
+*
+* OUTPUTS:
+*		statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS	counter,
+	OUT GT_U32			*statsData
+);
+
+/*******************************************************************************
+* gstatsGetPortAllCounters
+*
+* DESCRIPTION:
+*       This routine gets all RMON counters of the given port
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters
+(
+	IN  GT_QD_DEV* dev,
+	IN  GT_LPORT		port,
+	OUT GT_STATS_COUNTER_SET	*statsCounterSet
+);
+
+
+/*******************************************************************************
+* grcSetLimitMode
+*
+* DESCRIPTION:
+*       This routine sets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port	- logical port number.
+*       mode 	- rate control ingress limit mode. 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*******************************************************************************/
+GT_STATUS grcSetLimitMode
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT 	     port,
+    IN GT_RATE_LIMIT_MODE    mode
+);
+
+/*******************************************************************************
+* grcGetLimitMode
+*
+* DESCRIPTION:
+*       This routine gets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*       port	- logical port number.
+*
+* OUTPUTS:
+*       mode 	- rate control ingress limit mode. 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetLimitMode
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_LPORT port,
+    OUT GT_RATE_LIMIT_MODE    *mode
+);
+
+/*******************************************************************************
+* grcSetPri3Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+GT_STATUS grcSetPri3Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri3Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri3Rate
+(
+    IN GT_QD_DEV* dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri2Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+GT_STATUS grcSetPri2Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri2Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri2Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri1Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+GT_STATUS grcSetPri1Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri1Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri1Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri0Rate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port	- logical port number.
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*       	  will be discarded after the ingress rate selected is reached 
+*       	  or exceeded. 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcSetPri0Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT        port,
+    IN GT_PRI0_RATE    rate
+);
+
+/*******************************************************************************
+* grcGetPri0Rate
+*
+* DESCRIPTION:
+*       This routine gets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port	- logical port number to set.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*       	  will be discarded after the ingress rate selected is reached 
+*       	  or exceeded. 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri0Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_PRI0_RATE    *rate
+);
+
+/*******************************************************************************
+* grcSetBytesCount
+*
+* DESCRIPTION:
+*       This routine sets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port	  - logical port number to set.
+*    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*    		    GT_FALSE: otherwise
+*    	countIFG  - GT_TRUE: To count IFG bytes
+*    		    GT_FALSE: otherwise
+*    	countPre  - GT_TRUE: To count Preamble bytes
+*    		    GT_FALSE: otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcSetBytesCount
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT        	port,
+    IN GT_BOOL 		limitMGMT,
+    IN GT_BOOL 		countIFG,
+    IN GT_BOOL 		countPre
+);
+
+/*******************************************************************************
+* grcGetBytesCount
+*
+* DESCRIPTION:
+*       This routine gets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port	- logical port number 
+*
+* OUTPUTS:
+*    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*    		    GT_FALSE: otherwise
+*    	countIFG  - GT_TRUE: To count IFG bytes
+*    		    GT_FALSE: otherwise
+*    	countPre  - GT_TRUE: To count Preamble bytes
+*    		    GT_FALSE: otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetBytesCount
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT        	port,
+    IN GT_BOOL 		*limitMGMT,
+    IN GT_BOOL 		*countIFG,
+    IN GT_BOOL 		*countPre
+);
+
+/*******************************************************************************
+* grcSetEgressRate
+*
+* DESCRIPTION:
+*       This routine sets the port's egress data limit.
+*
+* INPUTS:
+*       port	- logical port number.
+*       rate    - egress data rate limit.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcSetEgressRate
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT        port,
+    IN GT_EGRESS_RATE  rate
+);
+
+/*******************************************************************************
+* grcGetEgressRate
+*
+* DESCRIPTION:
+*       This routine gets the port's egress data limit.
+*
+* INPUTS:
+*       port	- logical port number.
+*
+* OUTPUTS:
+*       rate    - egress data rate limit.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetEgressRate
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT GT_EGRESS_RATE  *rate
+);
+
+
+/*******************************************************************************
+* gpavSetPAV
+*
+* DESCRIPTION:
+*       This routine sets the Port Association Vector 
+*
+* INPUTS:
+*       port	- logical port number.
+*       pav 	- Port Association Vector 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavSetPAV
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT	port,
+    IN GT_U16	pav
+);
+
+/*******************************************************************************
+* gpavGetPAV
+*
+* DESCRIPTION:
+*       This routine gets the Port Association Vector 
+*
+* INPUTS:
+*       port	- logical port number.
+*
+* OUTPUTS:
+*       pav 	- Port Association Vector 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavGetPAV
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT GT_U16    *pav
+);
+
+/*******************************************************************************
+* gpavSetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine sets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled 
+*              GT_TRUE:  Ingress Monitor disabled 
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*******************************************************************************/
+GT_STATUS gpavSetIngressMonitor
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* gpavGetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine gets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled 
+*              GT_TRUE:  Ingress Monitor disabled 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavGetIngressMonitor
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* gvctGetCableStatus
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the requested port,
+*       and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+*******************************************************************************/
+GT_STATUS gvctGetCableDiag
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+);
+
+
+/*******************************************************************************
+* gvctGet1000BTExtendedStatus
+*
+* DESCRIPTION:
+*       This routine retrieves extended cable status, such as Pair Poloarity,
+*		Pair Swap, and Pair Skew. Note that this routine will be success only
+*		if 1000Base-T Link is up.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+*******************************************************************************/
+GT_STATUS gvctGet1000BTExtendedStatus
+(
+    IN  GT_QD_DEV 		*dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+);
+
+
+/*******************************************************************************
+* gtMemSet
+*
+* DESCRIPTION:
+*       Set a block of memory
+*
+* INPUTS:
+*       start  - start address of memory block for setting
+*       simbol - character to store, converted to an unsigned char
+*       size   - size of block to be set
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to set memory block
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemSet
+(
+    IN void * start,
+    IN int    symbol,
+    IN GT_U32 size
+);
+
+/*******************************************************************************
+* gtMemCpy
+*
+* DESCRIPTION:
+*       Copies 'size' characters from the object pointed to by 'source' into
+*       the object pointed to by 'destination'. If copying takes place between
+*       objects that overlap, the behavior is undefined.
+*
+* INPUTS:
+*       destination - destination of copy
+*       source      - source of copy
+*       size        - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to destination
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemCpy
+(
+    IN void *       destination,
+    IN const void * source,
+    IN GT_U32       size
+);
+
+
+/*******************************************************************************
+* gtMemCmp
+*
+* DESCRIPTION:
+*       Compares given memories.
+*
+* INPUTS:
+*       src1 - source 1
+*       src2 - source 2
+*       size - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0, if equal.
+*		negative number, if src1 < src2.
+*		positive number, if src1 > src2.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int gtMemCmp
+(
+    IN char src1[],
+    IN char src2[],
+    IN GT_U32 size
+);
+
+/*******************************************************************************
+* gtStrlen
+*
+* DESCRIPTION:
+*       Determine the length of a string
+* INPUTS:
+*       source  - string
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       size    - number of characters in string, not including EOS.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_U32 gtStrlen
+(
+    IN const void * source
+);
+
+/*******************************************************************************
+* gtVersion
+*
+* DESCRIPTION:
+*       This function returns the version of the QuarterDeck SW suite.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       version     - QuarterDeck software version.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_BAD_PARAM on bad parameters,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gtVersion
+(
+    OUT GT_VERSION   *version
+);
+
+
+/* Prototypes added for Gigabit Ethernet Switch Support */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbMove
+*
+* DESCRIPTION:
+*		This routine moves all or unblocked addresses from a port to another.
+*
+* INPUTS:
+*		moveCmd  - the move operation type.
+*		moveFrom - port where moving from
+*		moveTo   - port where moving to
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMove
+(
+	IN GT_QD_DEV 	*dev,
+	IN GT_MOVE_CMD	moveCmd,
+	IN GT_U32		moveFrom,
+	IN GT_U32		moveTo
+);
+
+/*******************************************************************************
+* gfdbMoveInDB
+*
+* DESCRIPTION:
+* 		This routine move all or unblocked addresses which are in the particular
+* 		ATU Database (DBNum) from a port to another.
+*
+* INPUTS:
+* 		moveCmd  - the move operation type.
+*		DBNum	 	- ATU MAC Address Database Number.
+*		moveFrom - port where moving from
+*		moveTo   - port where moving to
+*
+* OUTPUTS:
+*     None
+*
+* RETURNS:
+* 		GT_OK           - on success
+* 		GT_FAIL         - on error
+* 		GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMoveInDB
+(
+	IN GT_QD_DEV   *dev,
+	IN GT_MOVE_CMD moveCmd,
+	IN GT_U8 		DBNum,
+	IN GT_U32		moveFrom,
+	IN GT_U32		moveTo
+);
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/*******************************************************************************
+* gatuGetIntStatus
+*
+* DESCRIPTION:
+*		Check to see if a specific type of ATU interrupt occured
+*
+* INPUTS:
+*     intType - the type of interrupt which causes an interrupt.
+*					GT_MEMEBER_VIOLATION, GT_MISS_VIOLATION, or GT_FULL_VIOLATION 
+*
+* OUTPUTS:
+* 		None.
+*
+* RETURNS:
+* 		GT_OK 	- on success
+* 		GT_FAIL 	- on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gatuGetIntStatus
+(
+	IN  GT_QD_DEV				*dev,
+	OUT GT_ATU_INT_STATUS	*atuIntStatus
+);
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtSet1000TMasterMode
+*
+* DESCRIPTION:
+*		This routine set the port multicast rate limit.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_1000T_MASTER_SLAVE structure
+*				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*				masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_1000T_MASTER_SLAVE	*mode
+);
+
+/*******************************************************************************
+* gprtGet1000TMasterMode
+*
+* DESCRIPTION:
+*		This routine set the port multicast rate limit.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_1000T_MASTER_SLAVE structure
+*				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*				masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_1000T_MASTER_SLAVE	*mode
+);
+
+/*******************************************************************************
+* gprtGetPhyReg
+*
+* DESCRIPTION:
+*		This routine reads Phy Registers.
+*
+* INPUTS:
+*		port    - logical port number
+*		regAddr - The register's address.
+*
+* OUTPUTS:
+*		data    - The read register's data.
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_FAIL         - on error
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyReg
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_U32	 	regAddr,
+	OUT GT_U16	 	*data
+);
+
+/*******************************************************************************
+* gprtSetPhyReg
+*
+* DESCRIPTION:
+*		This routine writes Phy Registers.
+*		
+* INPUTS:
+*		port    - logical port number
+*		regAddr - The register's address.
+*
+* OUTPUTS:
+*		data    - The read register's data.
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_FAIL         - on error
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPhyReg
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_U32	 	regAddr,
+	IN  GT_U16	 	data
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetDropOnLock
+*
+* DESCRIPTION:
+*		This routine set the Drop on Lock. When set to one, Ingress frames will
+*		be discarded if their SA field is not in the ATU's address database.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDropOnLock
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetDropOnLock
+*
+* DESCRIPTION:
+*		This routine gets DropOnLock mode.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: DropOnLock enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDropOnLock
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+);
+
+/*******************************************************************************
+* gprtSetDoubleTag
+*
+* DESCRIPTION:
+*		This routine set the Ingress Double Tag Mode. When set to one, 
+*		ingressing frames are examined to see if they contain an 802.3ac tag.
+*		If they do, the tag is removed and then the frame is processed from
+*		there (i.e., removed tag is ignored). Essentially, untagged frames
+*		remain untagged, single tagged frames become untagged and double tagged
+*		frames become single tagged.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDoubleTag
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetDoubleTag
+*
+* DESCRIPTION:
+*		This routine gets DoubleTag mode.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: DoubleTag enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDoubleTag
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+);
+
+/*******************************************************************************
+* gprtSetInterswitchPort
+*
+* DESCRIPTION:
+*		This routine set Interswitch Port. When set to one, 
+*		it indicates this port is a interswitch port used to communicated with
+*		CPU or to cascade with another switch device.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetInterswitchPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetInterswithPort
+*
+* DESCRIPTION:
+*		This routine gets InterswitchPort.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: This port is interswitch port,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetInterswitchPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+);
+
+/*******************************************************************************
+* gprtSetLearnDisable
+*
+* DESCRIPTION:
+*		This routine enables/disables automatic learning of new source MAC
+*		addresses on the given port ingress
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for disable or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLearnDisable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+);
+
+
+/*******************************************************************************
+* gprtGetLearnDisable
+*
+* DESCRIPTION:
+*		This routine gets LearnDisable setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: Learning disabled on the given port ingress frames,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLearnDisable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+);
+
+/*******************************************************************************
+* gprtSetIgnoreFCS
+*
+* DESCRIPTION:
+*		This routine sets FCS Ignore mode. When this bit is set to a one,
+*		the last four bytes of frames received on this port are overwritten with
+*		a good CRC and the frames will be accepted by the switch.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreFCS
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL 		mode
+);
+
+/*******************************************************************************
+* gprtGetIgnoreFCS
+*
+* DESCRIPTION:
+*		This routine gets Ignore FCS setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreFCS
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+);
+
+/*******************************************************************************
+* gprtSetVTUPriOverride
+*
+* DESCRIPTION:
+*		This routine sets VTU Priority Override. When this bit is set to a one,
+*		VTU priority overrides can occur on this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for VTU Priority Override or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetVTUPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetVTUPriOverride
+*
+* DESCRIPTION:
+*		This routine gets VTU Priority Override setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: VTU Priority Override enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetVTUPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL		*mode
+);
+
+/*******************************************************************************
+* gprtSetSAPriOverride
+*
+* DESCRIPTION:
+*		This routine sets SA Priority Override. When this bit is set to a one,
+*		SA priority overrides can occur on this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for SA Priority Override or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetSAPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetSAPriOverride
+*
+* DESCRIPTION:
+*		This routine gets SA Priority Override setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: SA Priority Override enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSAPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*mode
+);
+
+/*******************************************************************************
+* gprtSetDAPriOverride
+*
+* DESCRIPTION:
+*		This routine sets DA Priority Override. When this bit is set to a one,
+*		DA priority overrides can occur on this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for DA Priority Override or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDAPriOverride
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+);
+
+/*******************************************************************************
+* gprtGetDAPriOverride
+*
+* DESCRIPTION:
+*		This routine gets DA Priority Override setup
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE: DA Priority Override enabled,
+*				 GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDAPriOverride
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+);
+
+/*******************************************************************************
+* gprtSetCPUPort
+*
+* DESCRIPTION:
+*		This routine sets CPU Port number. When Snooping is enabled on this port
+*		or when this port is configured as an Interswitch Port and it receives a 
+*		To_CPU frame, the switch needs to know what port on this device the frame 
+*		should egress.
+*
+* INPUTS:
+*		port - the logical port number.
+*		cpuPort - CPU Port number or interswitch port where CPU Port is connected
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetCPUPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_LPORT 	cpuPort
+);
+
+/*******************************************************************************
+* gprtGetCPUPort
+*
+* DESCRIPTION:
+*		This routine gets CPU Logical Port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		cpuPort - CPU Port's logical number
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetCPUPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_LPORT 	*cpuLPort
+);
+
+/*******************************************************************************
+* gprtSetLockedPort
+*
+* DESCRIPTION:
+*		This routine sets LockedPort. When it's set to one, CPU directed 
+*		learning for 802.1x MAC authentication is enabled on this port. In this
+*		mode, an ATU Miss Violation interrupt will occur when a new SA address
+*		is received in a frame on this port. Automatically SA learning and 
+*		refreshing is disabled in this mode.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLockedPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetLockedPort
+*
+* DESCRIPTION:
+*		This routine gets Locked Port mode for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLockedPort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL  	*mode
+);
+
+/*******************************************************************************
+* gprtSetIgnoreWrongData
+*
+* DESCRIPTION:
+*		This routine sets Ignore Wrong Data. If the frame's SA address is found 
+*		in the database and if the entry is 'static' or if the port is 'locked'
+*		the source port's bit is checked to insure the SA has been assigned to 
+*		this port. If the SA is NOT assigned to this port, it is considered an 
+*		ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+*		Member Violation interrupt will be generated. If it's set to GT_TRUE,
+*		the ATU Member Violation error will be masked and ignored.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreWrongData
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port,
+	IN GT_BOOL		mode
+);
+
+
+/*******************************************************************************
+* gprtGetIgnoreWrongData
+*
+* DESCRIPTION:
+*		This routine gets Ignore Wrong Data mode for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreWrongData
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+);
+
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+* gstatsGetPortCounter2
+*
+* DESCRIPTION:
+*		This routine gets a specific counter of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*		counter - the counter which will be read
+*
+* OUTPUTS:
+*		statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter2
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS2	counter,
+	OUT GT_U32			*statsData
+);
+
+
+/*******************************************************************************
+* gstatsGetPortAllCounters2
+*
+* DESCRIPTION:
+*		This routine gets all counters of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters2
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	OUT GT_STATS_COUNTER_SET2	*statsCounterSet
+);
+
+/*******************************************************************************
+* gstatsGetHistogramMode
+*
+* DESCRIPTION:
+*		This routine gets the Histogram Counters Mode.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+*					and GT_COUNT_RX_TX)
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_BAD_PARAM    - on bad parameter
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetHistogramMode
+(
+	IN  GT_QD_DEV				*dev,
+	OUT GT_HISTOGRAM_MODE	*mode
+);
+
+/*******************************************************************************
+* gstatsSetHistogramMode
+*
+* DESCRIPTION:
+*		This routine sets the Histogram Counters Mode.
+*
+* INPUTS:
+*		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+*					and GT_COUNT_RX_TX)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_BAD_PARAM    - on bad parameter
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsSetHistogramMode
+(
+	IN GT_QD_DEV 				*dev,
+	IN GT_HISTOGRAM_MODE		mode
+);
+
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetPauseEn
+*
+* DESCRIPTION:
+*		This routine retrives the link pause state.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		If set MAC Pause (for Full Duplex flow control) is implemented in the
+*		link partner and in MyPause
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPauseEn
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*state
+);
+
+/*******************************************************************************
+* gprtGetHdFlow
+*
+* DESCRIPTION:
+*		This routine retrives the half duplex flow control value.
+*		If set, Half Duplex back pressure will be used on this port if this port
+*		is in a half duplex mode.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE for enable or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHdFlow
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*state
+);
+
+/*******************************************************************************
+* gprtGetPHYDetect
+*
+* DESCRIPTION:
+*		This routine retrives the information regarding PHY detection.
+*		If set, An 802.3 PHY is attached to this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if connected or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPHYDetect
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL 	*state
+);
+
+/*******************************************************************************
+* gprtSetPHYDetect
+*
+* DESCRIPTION:
+*		This routine sets PHYDetect bit which make PPU change its polling.
+*		PPU's pool routine uses these bits to determine which port's to poll
+*		PHYs on for Link, Duplex, Speed, and Flow Control.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		This function should not be called if gsysGetPPUState returns 
+*		PPU_STATE_ACTIVE.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPHYDetect
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_BOOL  	state
+);
+
+/*******************************************************************************
+* gprtGetSpeedMode
+*
+* DESCRIPTION:
+*       This routine retrives the port speed.
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_PORT_SPEED_MODE type.
+*					(PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, or PORT_SPEED_10_MBPS)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetSpeedMode
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_PORT_SPEED_MODE   *speed
+);
+
+/*******************************************************************************
+* gprtGetHighErrorRate
+*
+* DESCRIPTION:
+*		This routine retrives the PCS High Error Rate.
+*		This routine returns GT_TRUE if the rate of invalid code groups seen by
+*		PCS has exceeded 10 to the power of -11.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetHighErrorRate
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gprtGetTxPaused
+*
+* DESCRIPTION:
+*		This routine retrives Transmit Pause state.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
+*				  GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetTxPaused
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+
+/*******************************************************************************
+* gprtGetFlowCtrl
+*
+* DESCRIPTION:
+*		This routine retrives Flow control state.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if Rx MAC determines that no more data should be 
+*					entering this port.
+*				  GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetFlowCtrl
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gprtGetC_Duplex
+*
+* DESCRIPTION:
+*		This routine retrives Port 9's duplex configuration mode determined
+*		at reset.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if configured as Full duplex operation
+*				  GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetC_Duplex
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gprtGetC_Mode
+*
+* DESCRIPTION:
+*		This routine retrives port's interface type configuration mode 
+*		determined at reset.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - one of value in GT_PORT_CONFIG_MODE enum type
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		Return value is valid only if the given port is 9.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetC_Mode
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_PORT_CONFIG_MODE   *state
+);
+
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetPPUEn
+*
+* DESCRIPTION:
+*		This routine enables/disables Phy Polling Unit.
+*
+* INPUTS:
+*		en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetPPUEn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL 		en
+);
+
+/*******************************************************************************
+* gsysGetPPUEn
+*
+* DESCRIPTION:
+*		This routine get the PPU state.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_BAD_PARAM    - on bad parameter
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPPUEn
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+);
+
+/*******************************************************************************
+* gsysSetCascadePort
+*
+* DESCRIPTION:
+*		This routine sets Cascade Port number.
+*		In multichip systems frames coming from a CPU need to know when they
+*		have reached their destination chip.
+*
+* INPUTS:
+*		port - Cascade Port
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetCascadePort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port
+);
+
+/*******************************************************************************
+* gsysGetCascadePort
+*
+* DESCRIPTION:
+*		This routine gets Cascade Port number.
+*		In multichip systems frames coming from a CPU need to know when they
+*		have reached their destination chip.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		port - Cascade Port
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetCascadePort
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT 	*port
+);
+
+/*******************************************************************************
+* gsysSetDeviceNumber
+*
+* DESCRIPTION:
+*		This routine sets Device Number.
+*		In multichip systems frames coming from a CPU need to know when they
+*		have reached their destination chip. From CPU frames whose Dev_Num
+*		fieldmatches these bits have reachedtheir destination chip and are sent
+*		out this chip using the port number indicated in the frame's Trg_Port 
+*		field.
+*
+* INPUTS:
+*		devNum - Device Number (0 ~ 31)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDeviceNumber
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		devNum
+);
+
+/*******************************************************************************
+* gsysGetDeviceNumber
+*
+* DESCRIPTION:
+*		This routine gets Device Number.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		devNum - Device Number (0 ~ 31)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDeviceNumber
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U32  	*devNum
+);
+
+
+/* gtPCSCtrl.c */
+
+
+/*******************************************************************************
+* gpcsGetCommaDet
+*
+* DESCRIPTION:
+*		This routine retrieves Comma Detection status in PCS
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetCommaDet
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsGetSyncOK
+*
+* DESCRIPTION:
+*		This routine retrieves SynOK bit. It is set to a one when the PCS has
+*		detected a few comma patterns and is synchronized with its peer PCS 
+*		layer.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if synchronized or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetSyncOK
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsGetSyncFail
+*
+* DESCRIPTION:
+*		This routine retrieves SynFail bit.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetSyncFail
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsGetAnBypassed
+*
+* DESCRIPTION:
+*		This routine retrieves Inband Auto-Negotiation bypass status.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetAnBypassed
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsGetAnBypassMode
+*
+* DESCRIPTION:
+*		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetAnBypassMode
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+);
+
+/*******************************************************************************
+* gpcsSetAnBypassMode
+*
+* DESCRIPTION:
+*		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetAnBypassMode
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+);
+
+/*******************************************************************************
+* gpcsGetPCSAnEn
+*
+* DESCRIPTION:
+*		This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSAnEn
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+);
+
+/*******************************************************************************
+* gpcsSetPCSAnEn
+*
+* DESCRIPTION:
+*		This routine sets Enable mode of PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetPCSAnEn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL  	mode
+);
+
+/*******************************************************************************
+* gpcsSetRestartPCSAn
+*
+* DESCRIPTION:
+*		This routine restarts PCS Inband Auto-Negotiation.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetRestartPCSAn
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port
+);
+
+/*******************************************************************************
+* gpcsGetPCSAnDone
+*
+* DESCRIPTION:
+*		This routine retrieves completion information of PCS Auto-Negotiation.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE if PCS AN is done or never done
+*			    GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSAnDone
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*mode
+);
+
+/*******************************************************************************
+* gpcsSetLinkValue
+*
+* DESCRIPTION:
+*		This routine sets Link's force value
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force link up, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetLinkValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+);
+
+/*******************************************************************************
+* gpcsGetLinkValue
+*
+* DESCRIPTION:
+*		This routine retrieves Link Value which will be used for Forcing Link 
+*		up or down.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if Link Force value is one (link up)
+*			     GT_FALSE otherwise (link down)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetLinkValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsSetForcedLink
+*
+* DESCRIPTION:
+*		This routine forces Link. If LinkValue is set to one, calling this 
+*		routine with GT_TRUE will force Link to be up.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force link (up or down), GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedLink
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+);
+
+/*******************************************************************************
+* gpcsGetForcedLink
+*
+* DESCRIPTION:
+*		This routine retrieves Forced Link bit
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if ForcedLink bit is one,
+*			     GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedLink
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsSetDpxValue
+*
+* DESCRIPTION:
+*		This routine sets Duplex's Forced value. This function needs to be
+*		called prior to gpcsSetForcedDpx.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force full duplex, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetDpxValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+);
+
+/*******************************************************************************
+* gpcsGetDpxValue
+*
+* DESCRIPTION:
+*		This routine retrieves Duplex's Forced value
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if Duplex's Forced value is set to Full duplex,
+*			     GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetDpxValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsSetForcedDpx
+*
+* DESCRIPTION:
+*		This routine forces duplex mode. If DpxValue is set to one, calling this 
+*		routine with GT_TRUE will force duplex mode to be full duplex.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force duplex mode, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedDpx
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+);
+
+/*******************************************************************************
+* gpcsGetForcedDpx
+*
+* DESCRIPTION:
+*		This routine retrieves Forced Duplex.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if ForcedDpx bit is one,
+*			     GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedDpx
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsSetForceSpeed
+*
+* DESCRIPTION:
+*		This routine forces speed. 
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or No Speed Force)
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForceSpeed
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_PORT_FORCED_SPEED_MODE  mode
+);
+
+/*******************************************************************************
+* gpcsGetForceSpeed
+*
+* DESCRIPTION:
+*		This routine retrieves Force Speed value
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForceSpeed
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_PORT_FORCED_SPEED_MODE   *mode
+);
+
+
+
+/* gtQosMap.c */
+
+/*******************************************************************************
+* gqosGetTagRemap
+*
+* DESCRIPTION:
+*		Gets the remapped priority value for a specific 802.1p priority on a
+*		given port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*		pri   - 802.1p priority
+*
+* OUTPUTS:
+*		remappedPri - remapped Priority
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosGetTagRemap
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_U8    	pri,
+	OUT GT_U8   	*remappedPri
+);
+
+/*******************************************************************************
+* gqosSetTagRemap
+*
+* DESCRIPTION:
+*		Sets the remapped priority value for a specific 802.1p priority on a
+*		given port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*		pri   - 802.1p priority
+*		remappedPri - remapped Priority
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gqosSetTagRemap
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_U8    	pri,
+	IN GT_U8    	remappedPri
+);
+
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+/*******************************************************************************
+* gsysGetPPUState
+*
+* DESCRIPTION:
+*		This routine get the PPU State. These two bits return 
+*		the current value of the PPU.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		mode - GT_PPU_STATE
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_BAD_PARAM    - on bad parameter
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPPUState
+(
+	IN  GT_QD_DEV   	*dev,
+	OUT GT_PPU_STATE	*mode
+);
+
+
+/* Prototypes added for 88E6093 */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbGetLearn2All
+*
+* DESCRIPTION:
+*		When more than one Marvell device is used to form a single 'switch', it
+*		may be desirable for all devices in the 'switch' to learn any address this 
+*		device learns. When this bit is set to a one all other devices in the 
+*		'switch' learn the same addresses this device learns. When this bit is 
+*		cleared to a zero, only the devices that actually receive frames will learn
+*		from those frames. This mode typically supports more active MAC addresses 
+*		at one time as each device in the switch does not need to learn addresses 
+*		it may nerver use.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK           - on success
+*		GT_FAIL         - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbGetLearn2All
+(
+	IN  GT_QD_DEV    *dev,
+	OUT GT_BOOL 	*mode
+);
+
+/*******************************************************************************
+* gfdbSetLearn2All
+*
+* DESCRIPTION:
+*		Enable or disable Learn2All mode.
+*
+* INPUTS:
+*		mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbSetLearn2All
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gfdbRemovePort
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port.
+*
+* INPUTS:
+*       moveCmd - the move operation type.
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbRemovePort
+(
+	IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD 	moveCmd,
+    IN GT_LPORT		port
+);
+
+/*******************************************************************************
+* gfdbRemovePortInDB
+*
+* DESCRIPTION:
+*       This routine deassociages all or unblocked addresses from a port in the
+*       particular ATU Database (DBNum).
+*
+* INPUTS:
+*       moveCmd  - the move operation type.
+*       port - the logical port number.
+*		DBNum	 - ATU MAC Address Database Number.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbRemovePortInDB
+(
+	IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD 	moveCmd,
+    IN GT_LPORT		port,
+	IN GT_U8 		DBNum
+);
+
+
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/* gtPCSCtrl.c */
+
+/*******************************************************************************
+* gpcsGetPCSLink
+*
+* DESCRIPTION:
+*		This routine retrieves Link up status in PCS
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetPCSLink
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsSetFCValue
+*
+* DESCRIPTION:
+*		This routine sets Flow Control's force value
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetFCValue
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+);
+
+/*******************************************************************************
+* gpcsGetFCValue
+*
+* DESCRIPTION:
+*		This routine retrieves Flow Control Value which will be used for Forcing 
+*		Flow Control enabled or disabled.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if FC Force value is one (flow control enabled)
+*			     GT_FALSE otherwise (flow control disabled)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetFCValue
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gpcsSetForcedFC
+*
+* DESCRIPTION:
+*		This routine forces Flow Control. If FCValue is set to one, calling this 
+*		routine with GT_TRUE will force Flow Control to be enabled.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsSetForcedFC
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN	GT_BOOL		state
+);
+
+/*******************************************************************************
+* gpcsGetForcedFC
+*
+* DESCRIPTION:
+*		This routine retrieves Forced Flow Control bit
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE if ForcedFC bit is one,
+*			     GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*		
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gpcsGetForcedFC
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtGetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*		port 	- port to be read
+*		regAddr	- register offset to be read
+*		page	- page number to be read
+*
+* OUTPUTS:
+*		data	- value of the read register
+*
+* RETURNS:
+*       GT_OK   			- if read successed
+*       GT_FAIL   			- if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtGetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+	IN	GT_U32  regAddr,
+	IN	GT_U32  page,
+    OUT GT_U16* data
+);
+
+/*******************************************************************************
+* gprtSetPagedPhyReg
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*		port 	- port to be read
+*		regAddr	- register offset to be read
+*		page	- page number to be read
+*		data	- value of the read register
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*       GT_OK   			- if read successed
+*       GT_FAIL   			- if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtSetPagedPhyReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+	IN	GT_U32 regAddr,
+	IN	GT_U32 page,
+    IN  GT_U16 data
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetUseCoreTag
+*
+* DESCRIPTION:
+*       This routine set the UseCoreTag bit in Port Control Register.
+*			When this bit is cleared to a zero, ingressing frames are considered
+*			Tagged if the 16-bits following the frame's Source Address is 0x8100.
+*			When this bit is set to a one, ingressing frames are considered Tagged
+*			if the 16-bits following the frame's Source Address is equal to the 
+*			CoreTag register value.
+*
+* INPUTS:
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetUseCoreTag
+(
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    force
+);
+
+/*******************************************************************************
+* gprtGetUseCoreTag
+*
+* DESCRIPTION:
+*       This routine get the Use Core Tag state.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetUseCoreTag
+(
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *force
+);
+
+/*******************************************************************************
+* gprtSetDiscardTagged
+*
+* DESCRIPTION:
+*		When this bit is set to a one, all non-MGMT frames that are processed as 
+*		Tagged will be discarded as they enter this switch port. Priority only 
+*		tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardTagged
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetDiscardTagged
+*
+* DESCRIPTION:
+*		This routine gets DiscardTagged bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardTagged
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+);
+
+/*******************************************************************************
+* gprtSetDiscardUntagged
+*
+* DESCRIPTION:
+*		When this bit is set to a one, all non-MGMT frames that are processed as 
+*		Untagged will be discarded as they enter this switch port. Priority only 
+*		tagged frames (with a VID of 0x000) are considered tagged.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDiscardUntagged
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetDiscardUntagged
+*
+* DESCRIPTION:
+*		This routine gets DiscardUntagged bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDiscardUntagged
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+);
+
+/*******************************************************************************
+* gprtSetMapDA
+*
+* DESCRIPTION:
+*		When this bit is set to a one, normal switch operation will occur where a 
+*		frame's DA address is used to direct the frame out the correct port.
+*		When this be is cleared to a zero, the frame will be sent out the port(s) 
+*		defined by ForwardUnknown bits or the DefaultForward bits even if the DA 
+*		is ound in the address database.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMapDA
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetMapDA
+*
+* DESCRIPTION:
+*		This routine gets MapDA bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMapDA
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+);
+
+/*******************************************************************************
+* gprtSetDefaultForward
+*
+* DESCRIPTION:
+*		When this bit is set to a one, normal switch operation will occurs and 
+*		multicast frames with unknown DA addresses are allowed to egress out this 
+*		port (assuming the VLAN settings allow the frame to egress this port too).
+*		When this be is cleared to a zero, multicast frames with unknown DA 
+*		addresses will not egress out this port.
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDefaultForward
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetDefaultForward
+*
+* DESCRIPTION:
+*		This routine gets DefaultForward bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDefaultForward
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+);
+
+/*******************************************************************************
+* gprtSetEgressMonitorSource
+*
+* DESCRIPTION:
+*		When this be is cleared to a zero, normal network switching occurs.
+*		When this bit is set to a one, any frame that egresses out this port will
+*		also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetEgressMonitorSource
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetEgressMonitorSource
+*
+* DESCRIPTION:
+*		This routine gets EgressMonitorSource bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetEgressMonitorSource
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+);
+
+/*******************************************************************************
+* gprtSetIngressMonitorSource
+*
+* DESCRIPTION:
+*		When this be is cleared to a zero, normal network switching occurs.
+*		When this bit is set to a one, any frame that egresses out this port will
+*		also be sent to the EgressMonitorDest Port
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIngressMonitorSource
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetIngressMonitorSource
+*
+* DESCRIPTION:
+*		This routine gets IngressMonitorSource bit for the given port
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIngressMonitorSource
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+);
+
+
+/* gtPortPAV.c */
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
+/*******************************************************************************
+* gstatsGetPortCounter3
+*
+* DESCRIPTION:
+*		This routine gets a specific counter of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*		counter - the counter which will be read
+*
+* OUTPUTS:
+*		statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter3
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	IN  GT_STATS_COUNTERS3	counter,
+	OUT GT_U32			*statsData
+);
+
+/*******************************************************************************
+* gstatsGetPortAllCounters3
+*
+* DESCRIPTION:
+*		This routine gets all counters of the given port
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*
+* RETURNS:
+*		GT_OK      - on success
+*		GT_FAIL    - on error
+*
+* COMMENTS:
+*		This function supports Gigabit Switch only
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortAllCounters3
+(
+	IN  GT_QD_DEV		*dev,
+	IN  GT_LPORT		port,
+	OUT GT_STATS_COUNTER_SET3	*statsCounterSet
+);
+
+
+/* gtPortStat.c */
+
+/*******************************************************************************
+* gprtGetPortCtr2
+*
+* DESCRIPTION:
+*       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
+*
+* INPUTS:
+*       port  - the logical port number.
+*
+* OUTPUTS:
+*       ctr - the counters value.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPortCtr2
+(
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT2   *ctr
+);
+
+/* gtPortStatus.c */
+
+/*******************************************************************************
+* gprtGetMGMII
+*
+* DESCRIPTION:
+*		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+*		detected connected to this port, the SERDES interface between this port
+*		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*		detected connected to this port, the SERDES interface between this port 
+*		and the PHY will be MGMII. When no PHY is detected on this port and the 
+*		SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		state - GT_TRUE or GT_FALSE
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMGMII
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	OUT GT_BOOL  	*state
+);
+
+/*******************************************************************************
+* gprtSetMGMII
+*
+* DESCRIPTION:
+*		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+*		detected connected to this port, the SERDES interface between this port
+*		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*		detected connected to this port, the SERDES interface between this port 
+*		and the PHY will be MGMII. When no PHY is detected on this port and the 
+*		SERDES interface is being used, it will be configured in 1000Base-X mode.
+*
+* INPUTS:
+*		port - the logical port number.
+*		state - GT_TRUE or GT_FALSE
+*
+* OUTPUTS:
+*		None
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetMGMII
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT 	port,
+	IN  GT_BOOL  	state
+);
+
+
+/* gtQosMap.c */
+
+/* gtSysCtrl.c */
+
+/*******************************************************************************
+* gsysSetCoreTagType
+*
+* DESCRIPTION:
+*		This routine sets Ether Core Tag Type.
+*		This Ether Type is added to frames that egress the switch as Double Tagged 
+*		frames. It is also the Ether Type expected during Ingress to determine if 
+*		a frame is Tagged or not on ports configured as UseCoreTag mode.
+*
+* INPUTS:
+*		etherType - Core Tag Type (2 bytes)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetCoreTagType
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16  		etherType
+);
+
+/*******************************************************************************
+* gsysGetCoreTagType
+*
+* DESCRIPTION:
+*		This routine gets CoreTagType
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		etherType - Core Tag Type (2 bytes)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetCoreTagType
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*etherType
+);
+
+/*******************************************************************************
+* gsysSetIngressMonitorDest
+*
+* DESCRIPTION:
+*		This routine sets Ingress Monitor Destination Port. Frames that are 
+*		targeted toward an Ingress Monitor Destination go out the port number 
+*		indicated in these bits. This includes frames received on a Marvell Tag port
+*		with the Ingress Monitor type, and frames received on a Network port that 
+*		is enabled to be the Ingress Monitor Source Port.
+*		If the Ingress Monitor Destination Port resides in this device these bits 
+*		should point to the Network port where these frames are to egress. If the 
+*		Ingress Monitor Destination Port resides in another device these bits 
+*		should point to the Marvell Tag port in this device that is used to get 
+*		to the device that contains the Ingress Monitor Destination Port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetIngressMonitorDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+);
+
+/*******************************************************************************
+* gsysGetIngressMonitorDest
+*
+* DESCRIPTION:
+*		This routine gets Ingress Monitor Destination Port.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		port  - the logical port number.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetIngressMonitorDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+);
+
+/*******************************************************************************
+* gsysSetEgressMonitorDest
+*
+* DESCRIPTION:
+*		This routine sets Egress Monitor Destination Port. Frames that are 
+*		targeted toward an Egress Monitor Destination go out the port number 
+*		indicated in these bits. This includes frames received on a Marvell Tag port
+*		with the Egress Monitor type, and frames transmitted on a Network port that 
+*		is enabled to be the Egress Monitor Source Port.
+*		If the Egress Monitor Destination Port resides in this device these bits 
+*		should point to the Network port where these frames are to egress. If the 
+*		Egress Monitor Destination Port resides in another device these bits 
+*		should point to the Marvell Tag port in this device that is used to get 
+*		to the device that contains the Egress Monitor Destination Port.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetEgressMonitorDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+);
+
+/*******************************************************************************
+* gsysGetEgressMonitorDest
+*
+* DESCRIPTION:
+*		This routine gets Egress Monitor Destination Port.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		port  - the logical port number.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetEgressMonitorDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+);
+
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+
+/* functions added on rev 2.2 */
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetMessagePort
+*
+* DESCRIPTION:
+*		When the Learn2All bit is set to one, learning message frames are 
+*		generated. These frames will be sent out all ports whose Message Port is 
+*		set to one.
+* 		If this feature is used, it is recommended that all Marvell Tag ports, 
+*		except for the CPU's port, have their MessagePort bit set to one. 
+*		Ports that are not Marvell Tag ports should not have their Message Port
+*		bit set to one.
+*		
+*
+* INPUTS:
+*		port - the logical port number.
+*		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+*******************************************************************************/
+GT_STATUS gprtSetMessagePort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL		mode
+);
+
+/*******************************************************************************
+* gprtGetMessagePort
+*
+* DESCRIPTION:
+*		When the Learn2All bit is set to one, learning message frames are 
+*		generated. These frames will be sent out all ports whose Message Port is 
+*		set to one.
+* 		If this feature is used, it is recommended that all Marvell Tag ports, 
+*		except for the CPU's port, have their MessagePort bit set to one. 
+*		Ports that are not Marvell Tag ports should not have their Message Port
+*		bit set to one.
+*
+*		
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetMessagePort
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_LPORT	port,
+	OUT GT_BOOL 	*mode
+);
+
+
+/*******************************************************************************
+* gprtSetTrunkPort
+*
+* DESCRIPTION:
+*		This function enables/disables and sets the trunk ID.
+*		
+* INPUTS:
+*		port - the logical port number.
+*		en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+*			 GT_FALSE, otherwise.
+*		trunkId - valid ID is 0 ~ 15.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+*******************************************************************************/
+GT_STATUS gprtSetTrunkPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	IN GT_BOOL 		en,
+	IN GT_U32		trunkId
+);
+
+
+/*******************************************************************************
+* gprtGetTrunkPort
+*
+* DESCRIPTION:
+*		This function returns trunk state of the port.
+*		When trunk is disabled, trunkId field won't have valid value.
+*		
+* INPUTS:
+*		port - the logical port number.
+*
+* OUTPUTS:
+*		en - GT_TRUE, if the port is a member of a trunk,
+*			 GT_FALSE, otherwise.
+*		trunkId - 0 ~ 15, valid only if en is GT_TRUE
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+*******************************************************************************/
+GT_STATUS gprtGetTrunkPort
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT 	port,
+	OUT GT_BOOL 	*en,
+	OUT GT_U32		*trunkId
+);
+
+
+
+
+/*******************************************************************************
+* gprtGetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine reads Switch Global 2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetGlobal2Reg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32	     regAddr,
+    OUT GT_U16	     *data
+);
+
+/*******************************************************************************
+* gprtSetGlobal2Reg
+*
+* DESCRIPTION:
+*       This routine writes Switch Global2 Registers.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetGlobal2Reg
+(
+    IN  GT_QD_DEV		*dev,
+    IN  GT_U32			regAddr,
+    IN  GT_U16			data
+);
+
+/* gtSysCtrl.c */
+/*******************************************************************************
+* gsysSetARPDest
+*
+* DESCRIPTION:
+*		This routine sets ARP Monitor Destination Port. Tagged or untagged 
+*		frames that ingress Network ports with the Broadcast Destination Address 
+*		and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+*		should point to the port that directs these frames to the switch's CPU 
+*		that will process ARPs. This target port should be a Marvell Tag port so 
+*		that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+*		To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+*		Tag port will be sent to the port number definded in ARPDest.
+*
+*		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP 
+*		frames will be discarded.
+*
+* INPUTS:
+*		port  - the logical port number.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetARPDest
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_LPORT		port
+);
+
+/*******************************************************************************
+* gsysGetARPDest
+*
+* DESCRIPTION:
+*		This routine gets ARP Monitor Destination Port. Tagged or untagged 
+*		frames that ingress Network ports with the Broadcast Destination Address 
+*		and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+*		should point to the port that directs these frames to the switch's CPU 
+*		that will process ARPs. This target port should be a Marvell Tag port so 
+*		that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+*		To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+*		Tag port will be sent to the port number definded in ARPDest.
+*
+*		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP 
+*		frames will be discarded.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		port  - the logical port number.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetARPDest
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_LPORT  	*port
+);
+
+/*******************************************************************************
+* gsysSetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*		Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with 
+*		en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this 
+*		enBits(or register) are also set to a one, are treated as MGMT frames. 
+*		All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0, 
+*		bit 0 of this register is tested. When x = 0x2, bit 2 of this field is 
+*		tested and so on.
+*		If the tested bit in this register is cleared to a zero, the frame will 
+*		be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*		enBits - bit vector of enabled Reserved Multicast.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2CpuEnables
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		enBits
+);
+
+/*******************************************************************************
+* gsysGetRsvd2CpuEnables
+*
+* DESCRIPTION:
+*		Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with 
+*		en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this 
+*		enBits(or register) are also set to a one, are treated as MGMT frames. 
+*		All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0, 
+*		bit 0 of this register is tested. When x = 0x2, bit 2 of this field is 
+*		tested and so on.
+*		If the tested bit in this register is cleared to a zero, the frame will 
+*		be treated as a normal (non-MGMT) frame.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		enBits - bit vector of enabled Reserved Multicast.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2CpuEnables
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*enBits
+);
+
+/*******************************************************************************
+* gsysSetRsvd2Cpu
+*
+* DESCRIPTION:
+*		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+*		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+*		membership, will be considered MGMT frames and sent to the port's CPU 
+*		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+*		function) for the frames's DA is also set to a one.
+*
+* INPUTS:
+*		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetRsvd2Cpu
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+);
+
+/*******************************************************************************
+* gsysGetRsvd2Cpu
+*
+* DESCRIPTION:
+*		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+*		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+*		membership, will be considered MGMT frames and sent to the port's CPU 
+*		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+*		function) for the frames's DA is also set to a one.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetRsvd2Cpu
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+);
+
+/*******************************************************************************
+* gsysSetMGMTPri
+*
+* DESCRIPTION:
+*		These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+*
+* INPUTS:
+*		pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - If pri is not less than 8.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetMGMTPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		pri
+);
+
+/*******************************************************************************
+* gsysGetMGMTPri
+*
+* DESCRIPTION:
+*		These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetMGMTPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*pri
+);
+
+/*******************************************************************************
+* gsysSetUseDoubleTagData
+*
+* DESCRIPTION:
+*		This bit is used to determine if Double Tag data that is removed from a 
+*		Double Tag frame is used or ignored when making switching decisions on 
+*		the frame.
+*
+* INPUTS:
+*		en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetUseDoubleTagData
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+);
+
+/*******************************************************************************
+* gsysGetUseDoubleTagData
+*
+* DESCRIPTION:
+*		This bit is used to determine if Double Tag data that is removed from a 
+*		Double Tag frame is used or ignored when making switching decisions on 
+*		the frame.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetUseDoubleTagData
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+);
+
+/*******************************************************************************
+* gsysSetPreventLoops
+*
+* DESCRIPTION:
+*		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+*		field equals this device's Device Number, the following action will be 
+*		taken depending upon the value of this bit.
+*		GT_TRUE (1) - The frame will be discarded.
+*		GT_FALSE(0) - The frame will be prevented from going out its original 
+*						source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetPreventLoops
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+);
+
+/*******************************************************************************
+* gsysGetPreventLoops
+*
+* DESCRIPTION:
+*		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+*		field equals this device's Device Number, the following action will be 
+*		taken depending upon the value of this bit.
+*		GT_TRUE (1) - The frame will be discarded.
+*		GT_FALSE(0) - The frame will be prevented from going out its original 
+*						source port as defined by the frame's Src_Port field.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetPreventLoops
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+);
+
+/*******************************************************************************
+* gsysSetFlowControlMessage
+*
+* DESCRIPTION:
+*		When this bit is set to one, Marvell Tag Flow Control messages will be 
+*		generated when an output queue becomes congested and received Marvell Tag 
+*		Flow Control messages will pause MACs inside this device. When this bit 
+*		is cleared to a zero, Marvell Tag Flow Control messages will not be 
+*		generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFlowControlMessage
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+);
+
+/*******************************************************************************
+* gsysGetFlowControlMessage
+*
+* DESCRIPTION:
+*		When this bit is set to one, Marvell Tag Flow Control messages will be 
+*		generated when an output queue becomes congested and received Marvell Tag 
+*		Flow Control messages will pause MACs inside this device. When this bit 
+*		is cleared to a zero, Marvell Tag Flow Control messages will not be 
+*		generated and any received will be ignored at the target MAC.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowControlMessage
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+);
+
+/*******************************************************************************
+* gsysSetForceFlowControlPri
+*
+* DESCRIPTION:
+*		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+*		Flow Control frames will be set to the value of the FC Pri bits (set by 
+*		gsysSetFCPri function call). When this bit is cleared to a zero, generated 
+*		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+*		frames that caused the congestion. This bit will have no effect if the 
+*		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+*		cleared to a zero.
+*
+* INPUTS:
+*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetForceFlowControlPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+);
+
+/*******************************************************************************
+* gsysGetForceFlowControlPri
+*
+* DESCRIPTION:
+*		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+*		Flow Control frames will be set to the value of the FC Pri bits (set by 
+*		gsysSetFCPri function call). When this bit is cleared to a zero, generated 
+*		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+*		frames that caused the congestion. This bit will have no effect if the 
+*		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+*		cleared to a zero.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetForceFlowControlPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+);
+
+/*******************************************************************************
+* gsysSetFCPri
+*
+* DESCRIPTION:
+*		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+*		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*		is set to a one.
+*
+* INPUTS:
+*		pri - PRI[2:0] bits (should be less than 8)
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - If pri is not less than 8.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetFCPri
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U16		pri
+);
+
+/*******************************************************************************
+* gsysGetFCPri
+*
+* DESCRIPTION:
+*		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+*		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*		is set to a one.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		pri - PRI[2:0] bits (should be less than 8)
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFCPri
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_U16  	*pri
+);
+
+/*******************************************************************************
+* gsysSetFlowCtrlDelay
+*
+* DESCRIPTION:
+*		This function sets Flow control delay time for 10Mbps, 100Mbps, and 
+*		1000Mbps. 
+*
+* INPUTS:
+*		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*		delayTime - actual delay time will be (this value x 2.048uS).
+*					the value cannot exceed 0x1FFF (or 8191 in decimal).
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetFlowCtrlDelay
+(
+	IN GT_QD_DEV			*dev,
+	IN GT_PORT_SPEED_MODE	sp,
+	IN GT_U32				delayTime
+);
+
+/*******************************************************************************
+* gsysGetFlowCtrlDelay
+*
+* DESCRIPTION:
+*		This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+*		1000Mbps. 
+*
+* INPUTS:
+*		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*
+* OUTPUTS:
+*		delayTime - actual delay time will be (this value x 2.048uS).
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowCtrlDelay
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_PORT_SPEED_MODE	sp,
+	OUT GT_U32		*delayTime
+);
+
+/*******************************************************************************
+* gsysSetDevRoutingTable
+*
+* DESCRIPTION:
+*		This function sets Device to Port mapping (which device is connected to 
+*		which port of this device). 
+*
+* INPUTS:
+*		devNum - target device number.
+*		portNum - the logical port number.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if devNum >= 32 or port >= total number of ports.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDevRoutingTable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		devNum,
+	IN GT_LPORT 	port
+);
+
+/*******************************************************************************
+* gsysGetDevRoutingTable
+*
+* DESCRIPTION:
+*		This function gets Device to Port mapping (which device is connected to 
+*		which port of this device). 
+*
+* INPUTS:
+*		devNum - target device number.
+*
+* OUTPUTS:
+*		portNum - the logical port number.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if devNum >= 32
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDevRoutingTable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		devNum,
+	OUT GT_LPORT 	*port
+);
+
+/*******************************************************************************
+* gsysSetTrunkMaskTable
+*
+* DESCRIPTION:
+*		This function sets Trunk mask vector table for load balancing.
+*		This vector will be AND'ed with where the frame was originally egressed to.
+*		To insure all trunks are load balanced correctly, the data in this table
+*		needs to be correctly configured.
+*
+* INPUTS:
+*		trunkNum - one of the eight Trunk mask vectors.
+*		trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+*					bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkNum > 0x7 or trunMask > 0x7FF (or port vector).
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkMaskTable
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		trunkNum,
+	IN GT_U32		trunkMask
+);
+
+/*******************************************************************************
+* gsysGetTrunkMaskTable
+*
+* DESCRIPTION:
+*		This function sets Trunk mask vector table for load balancing.
+*		This vector will be AND'ed with where the frame was originally egressed to.
+*		To insure all trunks are load balanced correctly, the data in this table
+*		needs to be correctly configured.
+*
+* INPUTS:
+*		trunkNum - one of the eight Trunk mask vectors.
+*
+* OUTPUTS:
+*		trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+*					bit 1 for port 1 , etc.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkNum > 0x7.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkMaskTable
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		trunkNum,
+	OUT GT_U32		*trunkMask
+);
+
+/*******************************************************************************
+* gsysSetHashTrunk
+*
+* DESCRIPTION:
+*		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+*		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+*		When this bit is set to a one, the hashed computed for address table 
+*		lookups is used for the TrunkMask selection. When this bit is cleared to 
+*		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+*		select the TrunkMask to use.
+*
+* INPUTS:
+*		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetHashTrunk
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_BOOL		en
+);
+
+/*******************************************************************************
+* gsysGetHashTrunk
+*
+* DESCRIPTION:
+*		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+*		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+*		When this bit is set to a one, the hashed computed for address table 
+*		lookups is used for the TrunkMask selection. When this bit is cleared to 
+*		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+*		select the TrunkMask to use.
+*
+* INPUTS:
+*		None.
+*
+* OUTPUTS:
+*		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetHashTrunk
+(
+	IN  GT_QD_DEV	*dev,
+	OUT GT_BOOL  	*en
+);
+
+/*******************************************************************************
+* gsysSetTrunkRouting
+*
+* DESCRIPTION:
+*		This function sets routing information for the given Trunk ID.
+*
+* INPUTS:
+*		trunkId - Trunk ID.
+*		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*					bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*		None.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkId > 0xF or trunkRoute > 0x7FF(or port vector).
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkRouting
+(
+	IN GT_QD_DEV	*dev,
+	IN GT_U32  		trunkId,
+	IN GT_U32		trunkRoute
+);
+
+/*******************************************************************************
+* gsysGetTrunkRouting
+*
+* DESCRIPTION:
+*		This function retrieves routing information for the given Trunk ID.
+*
+* INPUTS:
+*		trunkId - Trunk ID.
+*
+* OUTPUTS:
+*		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*					bit 1 for port 1 , etc.
+*
+* RETURNS:
+*		GT_OK   - on success
+*		GT_FAIL - on error
+*		GT_BAD_PARAM - if trunkId > 0xF.
+*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*		None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkRouting
+(
+	IN  GT_QD_DEV	*dev,
+	IN  GT_U32 		trunkId,
+	OUT GT_U32		*trunkRoute
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __msApi_h */
diff -Naur u-boot-1.1.2/include/marvell/msApiTypes.h uboot-1.1.2hsv/include/marvell/msApiTypes.h
--- u-boot-1.1.2/include/marvell/msApiTypes.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/msApiTypes.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,124 @@
+/* 
+ * Copyright 2002, Marvell International Ltd.
+ * 
+ * THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.
+ * NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT
+ * OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE
+ * DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.
+ * THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESS, IMPLIED
+ * OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.
+ */
+
+/*
+ * FILENAME:    $Workfile: mv_types.h $
+ * REVISION:    $Revision: 1.1 $
+ * LAST UPDATE: $Modtime: 12/24/02 5:37p $
+ *
+ * DESCRIPTION:
+ *     This file defines common data types used on Host and NetGX sides.
+ */
+
+
+#ifndef MV_TYPES_H
+#define MV_TYPES_H
+
+
+/* general */
+
+#undef IN
+#define IN
+#undef OUT
+#define OUT
+#undef INOUT
+#define INOUT
+
+
+#ifndef NULL
+#define NULL ((void*)0)
+#endif
+
+typedef void  GT_VOID;
+typedef char  GT_8;
+typedef short GT_16; 
+typedef long  GT_32;
+
+typedef unsigned char  GT_U8;
+typedef unsigned short GT_U16;
+typedef unsigned long  GT_U32;
+typedef unsigned int   GT_UINT; 
+
+typedef union {
+	GT_U8	c[8];
+	GT_U16	s[4];
+	GT_U32	l[2];
+} GT_U64;
+
+
+typedef enum {
+    GT_FALSE = 0,
+    GT_TRUE  = 1
+} GT_BOOL;
+
+typedef void          (*GT_VOIDFUNCPTR) (void); /* ptr to function returning void */
+typedef unsigned int  (*GT_INTFUNCPTR)  (void); /* ptr to function returning int  */
+
+
+/* module state */
+typedef enum {
+	GT_STATE_NONE = 0,	/* Uninitialized */
+	GT_STATE_IDLE,		/* Initialized, but not started (or stopped) */
+	GT_STATE_ACTIVE		/* Started */
+} GT_STATE;
+
+
+#define	GT_ETHERNET_HEADER_SIZE		(6)
+
+typedef struct
+{
+    GT_U8       arEther[GT_ETHERNET_HEADER_SIZE];
+}GT_ETHERADDR;
+
+/* This macro checks for a multicast mac address    */
+#define GT_IS_MULTICAST_MAC(mac)  ((mac.arEther[0] & 0x1) == 1)
+
+
+/* This macro checks for an broadcast mac address     */
+#define GT_IS_BROADCAST_MAC(mac) (((mac).arEther[0] == 0xFF) && ((mac).arEther[1] == 0xFF) && ((mac).arEther[2] == 0xFF) && ((mac).arEther[3] == 0xFF) && ((mac).arEther[4] == 0xFF) && ((mac).arEther[5] == 0xFF))
+
+
+/* status / error codes */
+typedef int GT_STATUS;
+
+#define GT_ERROR		   (-1)
+#define GT_OK			   (0x00)	/* Operation succeeded                   */
+#define GT_FAIL			   (0x01)	/* Operation failed                      */
+#define GT_BAD_VALUE       (0x02)   /* Illegal value (general)               */
+#define GT_OUT_OF_RANGE    (0x03)   /* The value is out of range             */
+#define GT_BAD_PARAM       (0x04)   /* Illegal parameter in function called  */
+#define GT_BAD_PTR         (0x05)   /* Illegal pointer value                 */
+#define GT_BAD_SIZE        (0x06)   /* Illegal size                          */
+#define GT_BAD_STATE       (0x07)   /* Illegal state of state machine        */
+#define GT_SET_ERROR       (0x08)   /* Set operation failed                  */
+#define GT_GET_ERROR       (0x09)   /* Get operation failed                  */
+#define GT_CREATE_ERROR    (0x0A)   /* Fail while creating an item           */
+#define GT_NOT_FOUND       (0x0B)   /* Item not found                        */
+#define GT_NO_MORE         (0x0C)   /* No more items found                   */
+#define GT_NO_SUCH         (0x0D)   /* No such item                          */
+#define GT_TIMEOUT         (0x0E)   /* Time Out                              */
+#define GT_NO_CHANGE       (0x0F)   /* The parameter(s) is already in this value */
+#define GT_NOT_SUPPORTED   (0x10)   /* This request is not support           */
+#define GT_NOT_IMPLEMENTED (0x11)   /* This request is supported but not implemented */
+#define GT_NOT_INITIALIZED (0x12)   /* The item is not initialized           */
+#define GT_NO_RESOURCE     (0x13)   /* Resource not available (memory ...)   */
+#define GT_FULL            (0x14)   /* Item is full (Queue or table etc...)  */
+#define GT_EMPTY           (0x15)   /* Item is empty (Queue or table etc...) */
+#define GT_INIT_ERROR      (0x16)   /* Error occured while INIT process      */
+#define GT_HW_ERROR        (0x17)   /* Hardware error                        */
+#define GT_TX_ERROR        (0x18)   /* Transmit operation not succeeded      */
+#define GT_RCV_ERROR       (0x19)   /* Recieve operation not succeeded       */
+#define GT_NOT_READY	   (0x1A)	/* The other side is not ready yet       */
+#define GT_ALREADY_EXIST   (0x1B)   /* Tried to create existing item         */
+#define GT_OUT_OF_CPU_MEM  (0x1C)   /* Cpu memory allocation failed.         */
+
+
+#endif /* MV_TYPES_H */
diff -Naur u-boot-1.1.2/include/marvell/msApiWince.h uboot-1.1.2hsv/include/marvell/msApiWince.h
--- u-boot-1.1.2/include/marvell/msApiWince.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/msApiWince.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,556 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* msApiWince.h
+*
+* DESCRIPTION:
+*       Wince Application need to include only this header file.
+*
+* DEPENDENCIES:   None
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiFunc_h
+#define __msApiFunc_h
+
+#include "msApiDefs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef GT_STATUS (*FGT_PRT_ATUSIZE)(ATU_SIZE);
+typedef GT_STATUS (*FGT_PRT_U32_U32)(GT_U32*,GT_U32*);
+typedef GT_STATUS (*FGT_VALUE_U32)(GT_U32);
+typedef GT_STATUS (*FGT_PTR_U32)(GT_U32*);
+typedef GT_STATUS (*FGT_PTR_U16)(GT_U16*);
+typedef GT_STATUS (*FGT_PTR_U32_U32_U32)(GT_U32,GT_U32,GT_U32*);
+typedef GT_STATUS (*FGT_PTR_ATUENTRY)(GT_ATU_ENTRY*);
+typedef GT_STATUS (*FGT_PTR_ATUENTRY_BOOL)(GT_ATU_ENTRY*, GT_BOOL*);
+typedef GT_STATUS (*FGT_VALUE_FLUSHCMD)(GT_FLUSH_CMD);
+typedef GT_STATUS (*FGT_PTR_ETHERADDR)(GT_ETHERADDR*);
+typedef GT_STATUS (*FGT_PTR_BOOL)(GT_BOOL*);
+typedef GT_STATUS (*FGT_VALUE_BOOL)(GT_BOOL);
+typedef GT_STATUS (*FGT_VALUE_PORT_STPSTATE)(GT_LPORT,GT_PORT_STP_STATE);
+typedef GT_STATUS (*FGT_PTR_PORT_STPSTATE)(GT_LPORT,GT_PORT_STP_STATE*);
+typedef GT_STATUS (*FGT_VALUE_PORT_EGRESSMODE)(GT_LPORT,GT_EGRESS_MODE);
+typedef GT_STATUS (*FGT_PTR_PORT_EGRESSMODE)(GT_LPORT,GT_EGRESS_MODE*);
+typedef GT_STATUS (*FGT_VALUE_PORT_BOOL)(GT_LPORT,GT_BOOL);
+typedef GT_STATUS (*FGT_PTR_PORT_BOOL)(GT_LPORT,GT_BOOL*);
+typedef GT_STATUS (*FGT_VALUE_PORT_PORTS_U8)(GT_LPORT,GT_LPORT*,GT_U8);
+typedef GT_STATUS (*FGT_PTR_PORT_PORTS_U8)(GT_LPORT,GT_LPORT*,GT_U8*);
+typedef GT_STATUS (*FGT_VALUE_PORT_U16)(GT_LPORT,GT_U16);
+typedef GT_STATUS (*FGT_PTR_PORT_U16)(GT_LPORT,GT_U16*);
+typedef GT_STATUS (*FGT_VALUE_PORT_AUTOMODE)(GT_LPORT,GT_PHY_AUTO_MODE);
+
+typedef GT_STATUS (*FGT_VALUE_PORT)(GT_LPORT);
+typedef GT_STATUS (*FGT_VALUE_U8)(GT_U8);
+typedef GT_STATUS (*FGT_PTR_U8)(GT_U8*);
+typedef GT_STATUS (*FGT_VALUE_PORT_U8)(GT_LPORT,GT_U8);
+typedef GT_STATUS (*FGT_PTR_PORT_U8)(GT_LPORT,GT_U8*);
+typedef GT_STATUS (*FGT_VALUE_PORT_INGRESSMODE)(GT_LPORT,GT_INGRESS_MODE);
+typedef GT_STATUS (*FGT_PTR_PORT_INGRESSMODE)(GT_LPORT,GT_INGRESS_MODE*);
+typedef GT_STATUS (*FGT_VALUE_PORT_MCRATE)(GT_LPORT,GT_MC_RATE);
+typedef GT_STATUS (*FGT_PTR_PORT_MCRATE)(GT_LPORT,GT_MC_RATE*);
+typedef GT_STATUS (*FGT_VALUE_CTRMODE)(GT_CTR_MODE);
+typedef GT_STATUS (*FGT_PTR_CTRMODE)(GT_CTR_MODE*);
+typedef GT_STATUS (*FGT_VOID)(void);
+typedef GT_STATUS (*FGT_PTR_PORT_PORTSTAT)(GT_LPORT,GT_PORT_STAT*);
+typedef GT_STATUS (*FGT_VALUE_U8_U8)(GT_U8,GT_U8);
+typedef GT_STATUS (*FGT_PTR_U8_U8)(GT_U8,GT_U8*);
+typedef GT_STATUS (*FGT_PTR_CONFIG_INFO)(GT_SYS_CONFIG*,GT_SYS_INFO*);
+typedef GT_STATUS (*FGT_PTR_VERSION)(GT_VERSION*);
+typedef GT_STATUS (*FGT_PTR_REGISTER)(BSP_FUNCTIONS*);
+typedef GT_STATUS (*FGT_PTR_INT_HANDLER)(FGT_INT_HANDLER*);
+
+typedef GT_STATUS (*FGT_PTR_U32_U32_U16)(GT_U32,GT_U32,GT_U16);
+
+
+extern FGT_PRT_ATUSIZE 			gfdbSetAtuSize;
+extern FGT_PRT_U32_U32 			gfdbGetAgingTimeRange;
+extern FGT_VALUE_U32 			gfdbSetAgingTimeout;
+extern FGT_PTR_U32 				gfdbGetAtuDynamicCount;
+extern FGT_PTR_ATUENTRY 		gfdbGetAtuEntryFirst;
+extern FGT_PTR_ATUENTRY 		gfdbGetAtuEntryNext;
+extern FGT_PTR_ATUENTRY_BOOL 	gfdbFindAtuMacEntry;
+extern FGT_VALUE_FLUSHCMD 		gfdbFlush;
+extern FGT_PTR_ATUENTRY 		gfdbAddMacEntry; //liane
+extern FGT_PTR_ETHERADDR 		gfdbDelMacEntry;
+extern FGT_VALUE_BOOL 			gfdbLearnEnable;
+extern FGT_VALUE_BOOL 				gstpSetMode;
+extern FGT_VALUE_PORT_STPSTATE 		gstpSetPortState;
+extern FGT_PTR_PORT_STPSTATE 		gstpGetPortState;
+extern FGT_VALUE_PORT_EGRESSMODE 	gprtSetEgressMode;
+extern FGT_PTR_PORT_EGRESSMODE 		gprtGetEgressMode;
+extern FGT_VALUE_PORT_BOOL 			gprtSetVlanTunnel;
+extern FGT_PTR_PORT_BOOL 			gprtGetVlanTunnel;
+extern FGT_VALUE_PORT_PORTS_U8		gvlnSetPortVlanPorts;
+extern FGT_PTR_PORT_PORTS_U8		gvlnGetPortVlanPorts;
+extern FGT_VALUE_PORT_BOOL			gvlnSetPortUserPriLsb;
+extern FGT_PTR_PORT_BOOL			gvlnGetPortUserPriLsb;
+extern FGT_VALUE_PORT_U16			gvlnSetPortVid;
+extern FGT_PTR_PORT_U16				gvlnGetPortVid;
+extern FGT_VALUE_U32				eventSetActive;
+extern FGT_PTR_U16					eventGetIntStatus;
+extern FGT_VALUE_PORT				gprtPhyReset;
+extern FGT_VALUE_PORT_BOOL			gprtSetPortLoopback;
+extern FGT_VALUE_PORT_BOOL			gprtSetPortSpeed;
+extern FGT_VALUE_PORT_BOOL			gprtPortAutoNegEnable;
+extern FGT_VALUE_PORT_BOOL			gprtPortPowerDown;
+extern FGT_VALUE_PORT				gprtPortRestartAutoNeg;
+extern FGT_VALUE_PORT_BOOL			gprtSetPortDuplexMode;
+extern FGT_VALUE_PORT_AUTOMODE		gprtSetPortAutoMode;
+extern FGT_VALUE_PORT_BOOL			gprtSetPause;
+extern FGT_VALUE_PORT_U16			gprtPhyIntEnable;
+extern FGT_PTR_PORT_U16				gprtGetPhyIntStatus;
+extern FGT_PTR_U16					gprtGetPhyIntPortSummary;
+extern FGT_VALUE_PORT_BOOL			gprtSetForceFc;
+extern FGT_PTR_PORT_BOOL			gprtGetForceFc;
+extern FGT_VALUE_PORT_BOOL			gprtSetTrailerMode;
+extern FGT_PTR_PORT_BOOL			gprtGetTrailerMode;
+extern FGT_VALUE_PORT_INGRESSMODE	gprtSetIngressMode;
+extern FGT_PTR_PORT_INGRESSMODE		gprtGetIngressMode;
+extern FGT_VALUE_PORT_MCRATE		gprtSetMcRateLimit;
+extern FGT_PTR_PORT_MCRATE			gprtGetMcRateLimit;
+extern FGT_VALUE_CTRMODE			gprtSetCtrMode;
+extern FGT_VOID					gprtClearAllCtr;
+extern FGT_PTR_PORT_PORTSTAT	gprtGetPortCtr;
+extern FGT_PTR_PORT_BOOL		gprtGetPartnerLinkPause;
+extern FGT_PTR_PORT_BOOL		gprtGetSelfLinkPause;
+extern FGT_PTR_PORT_BOOL		gprtGetResolve;
+extern FGT_PTR_PORT_BOOL		gprtGetLinkState;
+extern FGT_PTR_PORT_BOOL		gprtGetPortMode;
+extern FGT_PTR_PORT_BOOL		gprtGetPhyMode;
+extern FGT_PTR_PORT_BOOL		gprtGetDuplex;
+extern FGT_PTR_PORT_BOOL		gprtGetSpeed;
+extern FGT_VALUE_PORT_U8		gcosSetPortDefaultTc;
+extern FGT_VALUE_PORT_BOOL		gqosSetPrioMapRule;
+extern FGT_PTR_PORT_BOOL		gqosGetPrioMapRule;
+extern FGT_VALUE_PORT_BOOL		gqosIpPrioMapEn;
+extern FGT_PTR_PORT_BOOL		gqosGetIpPrioMapEn;
+extern FGT_VALUE_PORT_BOOL		gqosUserPrioMapEn;
+extern FGT_PTR_PORT_BOOL		gqosGetUserPrioMapEn;
+extern FGT_PTR_U8_U8			gcosGetUserPrio2Tc;
+extern FGT_VALUE_U8_U8			gcosSetUserPrio2Tc;
+extern FGT_PTR_U8_U8			gcosGetDscp2Tc;
+extern FGT_VALUE_U8_U8			gcosSetDscp2Tc;
+extern FGT_PTR_CONFIG_INFO		sysConfig;
+extern FGT_VOID					sysEnable;
+extern FGT_VOID					gsysSwReset;
+extern FGT_VALUE_BOOL			gsysSetDiscardExcessive;
+extern FGT_PTR_BOOL				gsysGetDiscardExcessive;
+extern FGT_VALUE_BOOL			gsysSetSchedulingMode;
+extern FGT_PTR_BOOL				gsysGetSchedulingMode;
+extern FGT_VALUE_BOOL			gsysSetMaxFrameSize;
+extern FGT_PTR_BOOL				gsysGetMaxFrameSize;
+extern FGT_VOID					gsysReLoad;
+extern FGT_VALUE_BOOL			gsysSetWatchDog;
+extern FGT_PTR_BOOL				gsysGetWatchDog;
+extern FGT_PTR_ETHERADDR		gsysSetDuplexPauseMac;
+extern FGT_PTR_ETHERADDR		gsysGetDuplexPauseMac;
+extern FGT_VALUE_BOOL			gsysSetPerPortDuplexPauseMac;
+extern FGT_PTR_BOOL				gsysGetPerPortDuplexPauseMac;
+extern FGT_PTR_U32_U32_U32		gsysReadMiiReg;
+extern FGT_PTR_VERSION			gtVersion;
+extern FGT_PTR_REGISTER			gtRegister;
+
+extern FGT_PTR_U32_U32_U16		gsysWriteMiiReg;
+
+/*
+ * This function will get the all the MS APIs and assign to local function pointers.
+ */
+int qdGetMSApiFunc();
+
+GT_U32 gtStrlen
+(
+    IN const void * source
+);
+
+//*****************************************************************************
+//  I O C T L S
+//*****************************************************************************
+#include "windev.h"
+
+typedef struct _GT_IOCTL_PARAM
+{
+	union 
+	{
+		GT_LPORT	portList[8];
+		GT_LPORT	port;
+		GT_U8  		u8Data;
+		GT_U16  	u16Data;
+		GT_U32  	u32Data;
+		GT_BOOL 	boolData;
+
+		GT_CTR_MODE	ctrMode;
+		GT_PORT_STP_STATE	stpState;
+		GT_EGRESS_MODE		egressMode;
+		GT_INGRESS_MODE		ingressMode;
+		GT_MC_RATE		mcRate;
+		GT_PORT_STAT	portStat;
+		ATU_SIZE 		atuSize;
+		GT_FLUSH_CMD 	flushCmd;
+
+		GT_ATU_ENTRY 	atuEntry;
+		GT_ETHERADDR 	etherAddr;
+		GT_SYS_CONFIG 	sysConfig;
+		GT_SYS_INFO		sysInfo;
+
+	} FirstParam;
+
+	union 
+	{
+		GT_LPORT	port;
+		GT_LPORT	portList[8];
+		GT_U8		u8Data;
+		GT_U16		u16Data;
+		GT_U32		u32Data;
+		GT_BOOL		boolData;
+		GT_PORT_STP_STATE	stpState;
+		GT_EGRESS_MODE		egressMode;
+		GT_INGRESS_MODE		ingressMode;
+		GT_MC_RATE		mcRate;
+
+		GT_PORT_STAT	portStat;
+
+		GT_PHY_AUTO_MODE	phyAutoMode;
+
+	} SecondParam;
+
+	union
+	{
+		GT_U8	u8Data;
+		GT_U16	u16Data;
+		GT_U32	u32Data;
+
+	} ThirdParam;
+
+} GT_IOCTL_PARAM, *PGT_IOCTL_PARAM;
+
+#define GET_FUNC_FROM_CTL_CODE(_ioctl) ((_ioctl>>2) & 0xFFF)
+
+/*
+	Microsoft allows for us to use 0x800 ~ 0xFFF
+	So, our program is using 6 bits for function group,
+	and 6 bits for each function.
+*/
+#define SUB_FUNC_MASK		0xFC0
+#define SYS_CFG_FUNC_MASK	(1 << 6) | 0x800
+#define SYS_CTRL_FUNC_MASK	(2 << 6) | 0x800
+#define FDB_FUNC_MASK		(3 << 6) | 0x800
+#define VLAN_FUNC_MASK		(4 << 6) | 0x800
+#define STP_FUNC_MASK		(5 << 6) | 0x800
+#define PORT_CTRL_FUNC_MASK		(6 << 6) | 0x800
+#define PORT_STATUS_FUNC_MASK	(7 << 6) | 0x800
+#define PORT_STATS_FUNC_MASK	(8 << 6) | 0x800
+#define QOS_FUNC_MASK			(9 << 6) | 0x800
+#define PHY_CTRL_FUNC_MASK		(10 << 6) | 0x800
+#define SYS_EVENT_FUNC_MASK		(11 << 6) | 0x800
+#define PHY_INT_FUNC_MASK		(12 << 6) | 0x800
+
+/*
+	Functions for SYS Configuration
+*/
+#define IOCTL_sysConfig    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysReadMiiReg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysWriteMiiReg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gtVersion    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CFG_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+	Functions for ATU
+*/
+#define IOCTL_gfdbSetAtuSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAgingTimeRange    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbSetAgingTimeout    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuDynamicCount    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuEntryFirst    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbGetAtuEntryNext    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFindAtuMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbFlush    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbAddMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbDelMacEntry    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gfdbLearnEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , FDB_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+	Functions for STP
+*/
+#define IOCTL_gstpSetMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstpSetPortState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gstpGetPortState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , STP_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+	Functions for VLAN
+*/
+#define IOCTL_gprtSetEgressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetEgressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetVlanTunnel    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetVlanTunnel    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVlanPorts    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVlanPorts    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortUserPriLsb    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortUserPriLsb    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnSetPortVid    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gvlnGetPortVid    \
+    CTL_CODE(FILE_DEVICE_NETWORK , VLAN_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+	Functions for System Event
+*/
+#define IOCTL_eventSetActive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_EVENT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_eventGetIntStatus    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_EVENT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+	Functions for Phy Control
+*/
+#define IOCTL_gprtPhyReset    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortLoopback    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortSpeed    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortAutoNegEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortPowerDown    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtPortRestartAutoNeg    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortDuplexMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPortAutoMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/* 
+	Functions for Phy Interrupt
+*/
+#define IOCTL_gprtPhyIntEnable    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyIntStatus    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyIntPortSummary    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PHY_INT_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+	Functions for Port Control
+*/
+#define IOCTL_gprtSetForceFc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetForceFc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetTrailerMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetTrailerMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetIngressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetIngressMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtSetMcRateLimit    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetMcRateLimit    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+	Functions for Port Statistics
+*/
+#define IOCTL_gprtSetCtrMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtClearAllCtr    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPortCtr    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+	Functions for Port Status
+*/
+#define IOCTL_gprtGetPartnerLinkPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetSelfLinkPause    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetResolve    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetLinkState    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPortMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetPhyMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetDuplex    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gprtGetSpeed    \
+    CTL_CODE(FILE_DEVICE_NETWORK , PORT_STATUS_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+/*
+	Functions for QoS Mapping
+*/
+#define IOCTL_gcosSetPortDefaultTc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosSetPrioMapRule    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetPrioMapRule    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosIpPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetIpPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosUserPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gqosGetUserPrioMapEn    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetUserPrio2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosSetUserPrio2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosGetDscp2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gcosSetDscp2Tc    \
+    CTL_CODE(FILE_DEVICE_NETWORK , QOS_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+/*
+	Functions for Sys Control
+*/
+#define IOCTL_gsysSwReset    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetDiscardExcessive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetDiscardExcessive    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetSchedulingMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetSchedulingMode    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetMaxFrameSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetMaxFrameSize    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysReLoad    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetWatchDog    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetWatchDog    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysSetPerPortDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_gsysGetPerPortDuplexPauseMac    \
+    CTL_CODE(FILE_DEVICE_NETWORK , SYS_CTRL_FUNC_MASK + 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur u-boot-1.1.2/include/marvell/platformDeps.h uboot-1.1.2hsv/include/marvell/platformDeps.h
--- u-boot-1.1.2/include/marvell/platformDeps.h	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/include/marvell/platformDeps.h	2007-05-29 16:50:57.000000000 -0500
@@ -0,0 +1,31 @@
+#include <marvell/Copyright.h>
+
+/********************************************************************************
+* platformDeps.h
+*
+* DESCRIPTION:
+*       platform dependent definitions
+*
+* DEPENDENCIES:   Platform.
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __platformDepsh
+#define __platformDepsh
+
+#include <marvell/msApi.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+GT_BOOL defaultMiiRead (unsigned int portNumber , unsigned int miiReg, unsigned int* value);
+GT_BOOL defaultMiiWrite (unsigned int portNumber , unsigned int miiReg, unsigned int value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* platformDepsh */
+
diff -Naur u-boot-1.1.2/include/ns9750_bbus.h uboot-1.1.2hsv/include/ns9750_bbus.h
--- u-boot-1.1.2/include/ns9750_bbus.h	2004-02-26 17:46:23.000000000 -0600
+++ uboot-1.1.2hsv/include/ns9750_bbus.h	2007-05-29 16:51:02.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_bbus.h,v 1.1 2004/02/16 10:37:20 mpietrek Exp $
+ * $Id: ns9750_bbus.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @Descr: Definitions for BBus usage
  * @References: [1] NS9750 Hardware Reference Manual/December 2003 Chap. 10
diff -Naur u-boot-1.1.2/include/ns9750_eth.h uboot-1.1.2hsv/include/ns9750_eth.h
--- u-boot-1.1.2/include/ns9750_eth.h	2004-08-02 18:39:05.000000000 -0500
+++ uboot-1.1.2hsv/include/ns9750_eth.h	2007-05-29 16:51:02.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_eth.h,v 1.2 2004/02/24 13:25:39 mpietrek Exp $
+ * $Id: ns9750_eth.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @References: [1] NS9750 Hardware Reference, December 2003
  *              [2] Intel LXT971 Datasheet #249414 Rev. 02
diff -Naur u-boot-1.1.2/include/ns9750_mem.h uboot-1.1.2hsv/include/ns9750_mem.h
--- u-boot-1.1.2/include/ns9750_mem.h	2004-02-26 17:46:23.000000000 -0600
+++ uboot-1.1.2hsv/include/ns9750_mem.h	2007-05-29 16:51:02.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_mem.h,v 1.1 2004/02/16 10:37:20 mpietrek Exp $
+ * $Id: ns9750_mem.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @Descr: Definitions for Memory Control Module
  * @References: [1] NS9750 Hardware Reference Manual/December 2003 Chap. 5
diff -Naur u-boot-1.1.2/include/ns9750_ser.h uboot-1.1.2hsv/include/ns9750_ser.h
--- u-boot-1.1.2/include/ns9750_ser.h	2004-02-26 17:46:23.000000000 -0600
+++ uboot-1.1.2hsv/include/ns9750_ser.h	2007-05-29 16:51:02.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_ser.h,v 1.1 2004/02/16 10:37:20 mpietrek Exp $
+ * $Id: ns9750_ser.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @References: [1] NS9750 Hardware Reference, December 2003
  *
diff -Naur u-boot-1.1.2/include/ns9750_sys.h uboot-1.1.2hsv/include/ns9750_sys.h
--- u-boot-1.1.2/include/ns9750_sys.h	2004-02-26 17:46:23.000000000 -0600
+++ uboot-1.1.2hsv/include/ns9750_sys.h	2007-05-29 16:51:02.000000000 -0500
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_sys.h,v 1.1 2004/02/16 10:37:20 mpietrek Exp $
+ * $Id: ns9750_sys.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $
  * @Author: Markus Pietrek
  * @Descr: Definitions for SYS Control Module
  * @References: [1] NS9750 Hardware Reference Manual/December 2003 Chap. 4
diff -Naur u-boot-1.1.2/include/ppc_asm.tmpl uboot-1.1.2hsv/include/ppc_asm.tmpl
--- u-boot-1.1.2/include/ppc_asm.tmpl	2004-10-27 19:09:39.000000000 -0500
+++ uboot-1.1.2hsv/include/ppc_asm.tmpl	2007-05-29 16:51:02.000000000 -0500
@@ -248,6 +248,42 @@
  * r21, r22 (SRR0), and r23 (SRR1).
  */
 
+#if defined(CONFIG_BOOKE)
+/*
+ * Critical exception entry code.  This is just like the other exception
+ * code except that it uses CSRR0 and CSRR1 instead of SRR0 and SRR1.
+ */
+#define CRITICAL_EXCEPTION_PROLOG       \
+	mtspr   SPRG0,r20;      \
+	mtspr   SPRG1,r21;      \
+	mfcr    r20;            \
+	subi    r21,r1,INT_FRAME_SIZE+STACK_UNDERHEAD;  /* alloc exc. frame */\
+	stw     r20,_CCR(r21);          /* save registers */ \
+	stw     r22,GPR22(r21); \
+	stw     r23,GPR23(r21); \
+	mfspr   r20,SPRG0;      \
+	stw     r20,GPR20(r21); \
+	mfspr   r22,SPRG1;      \
+	stw     r22,GPR21(r21); \
+	mflr    r20;            \
+	stw     r20,_LINK(r21); \
+	mfctr   r22;            \
+	stw     r22,_CTR(r21);  \
+	mfspr   r20,XER;        \
+	stw     r20,_XER(r21);  \
+	mfspr   r22,CSRR0;        /* CSRR0 */      \
+	mfspr   r23,CSRR1;        /* CSRR1 */      \
+	stw     r0,GPR0(r21);   \
+	stw     r1,GPR1(r21);   \
+	stw     r2,GPR2(r21);   \
+	stw     r1,0(r21);      \
+	mr      r1,r21;                 /* set new kernel sp */ \
+	SAVE_4GPRS(3, r21);
+/*
+ * Note: code which follows this uses cr0.eq (set if from kernel),
+ * r21, r22 (CSRR0), and r23 (CSRR1).
+ */
+#else
 /*
  * Critical exception entry code.  This is just like the other exception
  * code except that it uses SRR2 and SRR3 instead of SRR0 and SRR1.
@@ -282,6 +318,44 @@
  * Note: code which follows this uses cr0.eq (set if from kernel),
  * r21, r22 (SRR2), and r23 (SRR3).
  */
+#endif /* BOOKE */
+
+#if defined(CONFIG_E500)
+/*
+ * Machine Check exception entry code.  This is just like the other exception
+ * code except that it uses MCSRR0 and MCSRR1 instead of SRR0 and SRR1.
+ */
+#define MACH_EXCEPTION_PROLOG       \
+	mtspr   SPRG0,r20;      \
+	mtspr   SPRG1,r21;      \
+	mfcr    r20;            \
+	subi    r21,r1,INT_FRAME_SIZE+STACK_UNDERHEAD;  /* alloc exc. frame */\
+	stw     r20,_CCR(r21);          /* save registers */ \
+	stw     r22,GPR22(r21); \
+	stw     r23,GPR23(r21); \
+	mfspr   r20,SPRG0;      \
+	stw     r20,GPR20(r21); \
+	mfspr   r22,SPRG1;      \
+	stw     r22,GPR21(r21); \
+	mflr    r20;            \
+	stw     r20,_LINK(r21); \
+	mfctr   r22;            \
+	stw     r22,_CTR(r21);  \
+	mfspr   r20,XER;        \
+	stw     r20,_XER(r21);  \
+	mfspr   r22,MCSRR0;        /* MCSRR0 */      \
+	mfspr   r23,MCSRR1;        /* MCSRR1 */      \
+	stw     r0,GPR0(r21);   \
+	stw     r1,GPR1(r21);   \
+	stw     r2,GPR2(r21);   \
+	stw     r1,0(r21);      \
+	mr      r1,r21;                 /* set new kernel sp */ \
+	SAVE_4GPRS(3, r21);
+/*
+ * Note: code which follows this uses cr0.eq (set if from kernel),
+ * r21, r22 (MCSRR0), and r23 (MCSRR1).
+ */
+#endif /* E500 */
 
 /*
  * Exception vectors.
@@ -319,4 +393,20 @@
 	.long   hdlr - _start + EXC_OFF_SYS_RESET;      \
 	.long   crit_return - _start + EXC_OFF_SYS_RESET
 
+#if defined(CONFIG_E500)
+#define MACH_EXCEPTION(n, label, hdlr)                  \
+	. = n;                                          \
+label:                                                  \
+	MACH_EXCEPTION_PROLOG;                      \
+	lwz     r3,GOT(transfer_to_handler);            \
+	mtlr    r3;                                     \
+	addi    r3,r1,STACK_FRAME_OVERHEAD;             \
+	li      r20,MSR_KERNEL;                         \
+	rlwimi  r20,r23,0,25,25;                        \
+	blrl    ;                                       \
+.L_ ## label :                                          \
+	.long   hdlr - _start + EXC_OFF_SYS_RESET;      \
+	.long   mach_return - _start + EXC_OFF_SYS_RESET
+#endif
+
 #endif	/* __PPC_ASM_TMPL__ */
diff -Naur u-boot-1.1.2/include/systemace.h uboot-1.1.2hsv/include/systemace.h
--- u-boot-1.1.2/include/systemace.h	2004-02-23 10:11:34.000000000 -0600
+++ uboot-1.1.2hsv/include/systemace.h	2007-05-29 16:51:02.000000000 -0500
@@ -19,7 +19,7 @@
  *    along with this program; if not, write to the Free Software
  *    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  */
-#ident "$Id:$"
+#ident "$Id: systemace.h,v 1.1.1.1 2005/02/05 03:15:31 yang Exp $"
 
 #ifdef CONFIG_SYSTEMACE
 
diff -Naur u-boot-1.1.2/lib_ppc/board.c uboot-1.1.2hsv/lib_ppc/board.c
--- u-boot-1.1.2/lib_ppc/board.c	2004-12-31 03:32:54.000000000 -0600
+++ uboot-1.1.2hsv/lib_ppc/board.c	2007-05-29 16:50:55.000000000 -0500
@@ -130,6 +130,7 @@
 
 	ulong dest_addr = CFG_MONITOR_BASE + gd->reloc_off;
 
+	debug("initing MALLOC structure\n");
 	mem_malloc_end = dest_addr;
 	mem_malloc_start = dest_addr - TOTAL_MALLOC_LEN;
 	mem_malloc_brk = mem_malloc_start;
@@ -236,7 +237,9 @@
 #if defined(CONFIG_WATCHDOG)
 static int init_func_watchdog_init (void)
 {
+#ifndef CONFIG_CYCLADES
 	puts ("       Watchdog enabled\n");
+#endif
 	WATCHDOG_RESET ();
 	return (0);
 }
@@ -451,6 +454,7 @@
 	addr_sp -= sizeof (bd_t);
 	bd = (bd_t *) addr_sp;
 	gd->bd = bd;
+	memset(bd, 0, sizeof(bd_t));
 	debug ("Reserving %d Bytes for Board Info at: %08lx\n",
 			sizeof (bd_t), addr_sp);
 	addr_sp -= sizeof (gd_t);
@@ -466,8 +470,8 @@
 	 */
 	addr_sp -= 16;
 	addr_sp &= ~0xF;
-	*((ulong *) addr_sp)-- = 0;
-	*((ulong *) addr_sp)-- = 0;
+	*((ulong *) addr_sp) = 0; addr_sp -= sizeof(ulong);
+	*((ulong *) addr_sp) = 0; addr_sp -= sizeof(ulong);
 	debug ("Stack Pointer at: %08lx\n", addr_sp);
 
 	/*
@@ -521,7 +525,7 @@
 	WATCHDOG_RESET ();
 	bd->bi_intfreq = gd->cpu_clk;	/* Internal Freq, in Hz */
 	bd->bi_busfreq = gd->bus_clk;	/* Bus Freq,      in Hz */
-#if defined(CONFIG_8260) || defined(CONFIG_MPC8560)
+#if defined(CONFIG_8260) || defined(CONFIG_MPC8560) || defined(CONFIG_MPC8555) || defined(CONFIG_MPC8541)
 	bd->bi_cpmfreq = gd->cpm_clk;
 	bd->bi_brgfreq = gd->brg_clk;
 	bd->bi_sccfreq = gd->scc_clk;
@@ -533,6 +537,7 @@
 #endif /* CONFIG_MPC5xxx */
 	bd->bi_baudrate = gd->baudrate;	/* Console Baudrate     */
 
+	/* cyclades: should we pass pci bus freq in bd_t to kernel? */
 #ifdef CFG_EXTBDINFO
 	strncpy (bd->bi_s_version, "1.2", sizeof (bd->bi_s_version));
 	strncpy (bd->bi_r_version, U_BOOT_VERSION, sizeof (bd->bi_r_version));
@@ -547,6 +552,10 @@
 #endif
 #endif
 
+#if defined(CONFIG_KVMMAX) || defined(CONFIG_DEB)
+	bd->bi_pci1_busfreq = gd->pci1_clk;
+	bd->bi_pci2_busfreq = gd->pci2_clk;
+#endif
 	debug ("New Stack Pointer is: %08lx\n", addr_sp);
 
 	WATCHDOG_RESET ();
@@ -597,7 +606,7 @@
 
 	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
 
-	debug ("Now running in RAM - U-Boot at: %08lx\n", dest_addr);
+	printf ("Now running in RAM - U-Boot at: %08lx\n", dest_addr);
 
 	WATCHDOG_RESET ();
 
@@ -616,6 +625,8 @@
 	/*
 	 * We have to relocate the command table manually
 	 */
+	/* cyclades: cmd_table needs manually relocate because function ptr not point to RAM version of the funtion, 
+		instead it point to Flash addr, so does name string ptr, usage string ptr, help string ptr. */
 	for (cmdtp = &__u_boot_cmd_start; cmdtp !=  &__u_boot_cmd_end; cmdtp++) {
 		ulong addr;
 		addr = (ulong) (cmdtp->cmd) + gd->reloc_off;
@@ -783,6 +794,7 @@
 #endif	/* CONFIG_405GP, CONFIG_405EP */
 #endif	/* CFG_EXTBDINFO */
 
+	debug("setting ethaddr/ipaddr to bdinfo struct.\n");
 	s = getenv ("ethaddr");
 #if defined (CONFIG_MBX) || defined (CONFIG_RPXCLASSIC) || defined(CONFIG_IAD210)
 	if (s == NULL)
@@ -986,6 +998,7 @@
 	pcmcia_init ();
 #endif
 
+	/* cyclades: in board_config, we need to define CFG_CMD_IDE */
 #if (CONFIG_COMMANDS & CFG_CMD_IDE)
 	WATCHDOG_RESET ();
 # ifdef	CONFIG_IDE_8xx_PCCARD
diff -Naur u-boot-1.1.2/Makefile uboot-1.1.2hsv/Makefile
--- u-boot-1.1.2/Makefile	2004-12-19 03:58:11.000000000 -0600
+++ uboot-1.1.2hsv/Makefile	2007-05-29 16:51:25.000000000 -0500
@@ -54,7 +54,8 @@
 CROSS_COMPILE =
 else
 ifeq ($(ARCH),ppc)
-CROSS_COMPILE = ppc_8xx-
+CROSS_COMPILE = /opt/montavista/pro/devkit/ppc/85xx/bin/ppc_85xx-
+# CROSS_COMPILE = ppc_8xx-
 endif
 ifeq ($(ARCH),arm)
 CROSS_COMPILE = arm-linux-
@@ -116,6 +117,7 @@
 LIBS += dtt/libdtt.a
 LIBS += drivers/libdrivers.a
 LIBS += drivers/sk98lin/libsk98lin.a
+LIBS += drivers/marvell/libmarvell.a
 LIBS += post/libpost.a post/cpu/libcpu.a
 LIBS += common/libcommon.a
 .PHONY : $(LIBS)
@@ -1135,6 +1137,15 @@
 MPC8555CDS_config:	unconfig
 	@./mkconfig $(@:_config=) ppc mpc85xx mpc8555cds cds
 
+AMAZON_config:	unconfig
+	@./mkconfig $(@:_config=) ppc mpc85xx amazon
+
+DEBV1_config:	unconfig
+	@./mkconfig $(@:_config=) ppc mpc85xx debmax
+
+KVMMAXV1_config:	unconfig
+	@./mkconfig $(@:_config=) ppc mpc85xx debmax
+
 sbc8540_config \
 sbc8540_33_config \
 sbc8540_66_config:	unconfig
diff -Naur u-boot-1.1.2/mkimage.sh uboot-1.1.2hsv/mkimage.sh
--- u-boot-1.1.2/mkimage.sh	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/mkimage.sh	2007-05-29 16:51:25.000000000 -0500
@@ -0,0 +1,3 @@
+dd bs=1k count=16384 if=/dev/zero | tr '\0' '\377' >u-boot.img
+dd bs=1k seek=7680 conv=notrunc if=u-boot.bin of=u-boot.img
+dd bs=1k seek=15872 conv=notrunc if=u-boot.bin of=u-boot.img
diff -Naur u-boot-1.1.2/mknewboot.sh uboot-1.1.2hsv/mknewboot.sh
--- u-boot-1.1.2/mknewboot.sh	1969-12-31 18:00:00.000000000 -0600
+++ uboot-1.1.2hsv/mknewboot.sh	2007-05-29 16:51:25.000000000 -0500
@@ -0,0 +1 @@
+tools/mkimage -n 'Amazon U-Boot' -A ppc -O u-boot -T firmware -C none -d u-boot.bin newboot.img
diff -Naur u-boot-1.1.2/net/eth.c uboot-1.1.2hsv/net/eth.c
--- u-boot-1.1.2/net/eth.c	2004-12-16 11:49:38.000000000 -0600
+++ uboot-1.1.2hsv/net/eth.c	2007-05-29 16:51:02.000000000 -0500
@@ -25,6 +25,15 @@
 #include <command.h>
 #include <net.h>
 
+#undef DEBUG 
+#undef debug
+#ifdef	DEBUG
+#define debug(fmt,args...)	printf (fmt ,##args)
+#else
+#define debug(fmt,args...)
+#endif
+
+
 #if (CONFIG_COMMANDS & CFG_CMD_NET) && defined(CONFIG_NET_MULTI)
 
 #ifdef CFG_GT_6426x
@@ -54,6 +63,10 @@
 extern int skge_initialize(bd_t*);
 extern int tsec_initialize(bd_t*, int);
 
+#if defined(CONFIG_MV88E6095)
+extern int sw6095_initialize(bd_t*);
+#endif
+
 static struct eth_device *eth_devices, *eth_current;
 
 struct eth_device *eth_get_dev(void)
@@ -108,6 +121,29 @@
 	return 0;
 }
 
+static void dump_ethdev(struct eth_device *dev)
+{
+	if (!dev) {
+		debug("ERROR: passed in dev is NULL. \n");
+		return;
+	}
+	debug("\nDumping eth_device struct:\n");
+	debug("	char name[NAMESIZE]; [%s]\n", dev->name);
+	debug("	unsigned char enetaddr[6]; [%02X:%02X:%02X:%02X:%02X:%02X]\n", dev->enetaddr[0], dev->enetaddr[1], dev->enetaddr[2], dev->enetaddr[3], dev->enetaddr[4], dev->enetaddr[5]);
+	debug("	int iobase; [0x%08X]\n", dev->iobase);
+	debug("	int state; [0x%08X]\n", dev->state);
+
+	debug("	int  (*init) (struct eth_device*, bd_t*); [0x%08X]\n", (void*)dev->init);
+	debug("	int  (*send) (struct eth_device*, volatile void* pachet, int length); [0x%08X]\n", (void*)dev->send);
+	debug("	int  (*recv) (struct eth_device*); [0x%08X]\n", (void*)dev->recv);
+	debug("	void (*halt) (struct eth_device*); [0x%08X]\n", (void*)dev->halt);
+
+	debug("	struct eth_device *next; [0x%08X]\n", (void*)dev->next);
+	debug("	void *priv; [0x%08X]\n", dev->priv);
+
+	return;
+}
+
 int eth_initialize(bd_t *bis)
 {
 	unsigned char enetvar[32], env_enetaddr[6];
@@ -157,9 +193,11 @@
 #if defined(CONFIG_MPC85XX_TSEC1)
 	tsec_initialize(bis, 0);
 #endif
+#ifndef CONFIG_DEBV1		/* in DEB, TSEC2 is eth2, Failover is eth1, so put TSEC2 to the end. */
 #if defined(CONFIG_MPC85XX_TSEC2)
 	tsec_initialize(bis, 1);
 #endif
+#endif
 #if defined(CONFIG_MPC85XX_FEC)
 	tsec_initialize(bis, 2);
 #endif
@@ -196,6 +234,16 @@
 #if defined(CONFIG_RTL8169)
 	rtl8169_initialize(bis);
 #endif
+#ifdef CONFIG_DEBV1		/* in DEB, TSEC2 is eth2, Failover is eth1, so put TSEC2 to the end. */
+#if defined(CONFIG_MPC85XX_TSEC2)
+	tsec_initialize(bis, 1);
+#endif
+#endif
+#ifndef CONFIG_AMAZON
+#if defined(CONFIG_MV88E6095)	/* 88E6095 should always be after TSEC2 */
+	sw6095_initialize(bis);
+#endif
+#endif
 
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
@@ -243,7 +291,7 @@
 
 				memcpy(dev->enetaddr, env_enetaddr, 6);
 			}
-
+			dump_ethdev(dev);
 			eth_number++;
 			dev = dev->next;
 		} while(dev != eth_devices);
@@ -261,6 +309,12 @@
 		putc ('\n');
 	}
 
+#ifdef CONFIG_AMAZON
+#if defined(CONFIG_MV88E6095)	/* 88E6095 should always be after TSEC2 */
+	sw6095_initialize(bis);
+#endif
+#endif
+
 	return eth_number;
 }
 
diff -Naur u-boot-1.1.2/net/net.c uboot-1.1.2hsv/net/net.c
--- u-boot-1.1.2/net/net.c	2004-10-11 17:51:14.000000000 -0500
+++ uboot-1.1.2hsv/net/net.c	2007-05-29 16:51:02.000000000 -0500
@@ -1495,7 +1495,7 @@
 
 	xsum = 0;
 	while (len-- > 0)
-		xsum += *((ushort *)ptr)++;
+		{ xsum += *((ushort *)ptr); ptr += sizeof(ushort); }
 	xsum = (xsum & 0xffff) + (xsum >> 16);
 	xsum = (xsum & 0xffff) + (xsum >> 16);
 	return (xsum & 0xffff);
diff -Naur u-boot-1.1.2/net/tftp.c uboot-1.1.2hsv/net/tftp.c
--- u-boot-1.1.2/net/tftp.c	2004-04-15 16:48:55.000000000 -0500
+++ uboot-1.1.2hsv/net/tftp.c	2007-05-29 16:51:02.000000000 -0500
@@ -23,6 +23,9 @@
 #endif
 					/* (for checking the image size)	*/
 #define HASHES_PER_LINE	65		/* Number of "loading" hashes per line	*/
+#define BLOCKS_PER_TICK	10
+#define TICKS_PER_HASH	10
+#define BLOCKS_PER_HASH (TICKS_PER_HASH * BLOCKS_PER_TICK)
 
 /*
  *	TFTP operations.
@@ -117,7 +120,7 @@
 
 	case STATE_RRQ:
 		xp = pkt;
-		*((ushort *)pkt)++ = htons(TFTP_RRQ);
+		*((ushort *)pkt) = htons(TFTP_RRQ); 		pkt += sizeof(ushort);
 		strcpy ((char *)pkt, tftp_filename);
 		pkt += strlen(tftp_filename) + 1;
 		strcpy ((char *)pkt, "octet");
@@ -135,15 +138,15 @@
 	case STATE_DATA:
 	case STATE_OACK:
 		xp = pkt;
-		*((ushort *)pkt)++ = htons(TFTP_ACK);
-		*((ushort *)pkt)++ = htons(TftpBlock);
+		*((ushort *)pkt) = htons(TFTP_ACK); 		pkt += sizeof(ushort);
+		*((ushort *)pkt) = htons(TftpBlock); 		pkt += sizeof(ushort);
 		len = pkt - xp;
 		break;
 
 	case STATE_TOO_LARGE:
 		xp = pkt;
-		*((ushort *)pkt)++ = htons(TFTP_ERROR);
-		*((ushort *)pkt)++ = htons(3);
+		*((ushort *)pkt) = htons(TFTP_ERROR); 		pkt += sizeof(ushort);
+		*((ushort *)pkt) = htons(3); 			pkt += sizeof(ushort);
 		strcpy ((char *)pkt, "File too large");
 		pkt += 14 /*strlen("File too large")*/ + 1;
 		len = pkt - xp;
@@ -151,8 +154,8 @@
 
 	case STATE_BAD_MAGIC:
 		xp = pkt;
-		*((ushort *)pkt)++ = htons(TFTP_ERROR);
-		*((ushort *)pkt)++ = htons(2);
+		*((ushort *)pkt) = htons(TFTP_ERROR);		pkt += sizeof(ushort);
+		*((ushort *)pkt) = htons(2);			pkt += sizeof(ushort);
 		strcpy ((char *)pkt, "File has bad magic");
 		pkt += 18 /*strlen("File has bad magic")*/ + 1;
 		len = pkt - xp;
@@ -167,6 +170,7 @@
 TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
 {
 	ushort proto;
+	int spinner;
 
 	if (dest != TftpOurPort) {
 		return;
@@ -180,7 +184,7 @@
 	}
 	len -= 2;
 	/* warning: don't use increment (++) in ntohs() macros!! */
-	proto = *((ushort *)pkt)++;
+	proto = *((ushort *)pkt);	pkt += sizeof(ushort);
 	switch (ntohs(proto)) {
 
 	case TFTP_RRQ:
@@ -215,9 +219,16 @@
 			TftpBlockWrapOffset += TFTP_BLOCK_SIZE * TFTP_SEQUENCE_SIZE;
 			printf ("\n\t %lu MB reveived\n\t ", TftpBlockWrapOffset>>20);
 		} else {
-			if (((TftpBlock - 1) % 10) == 0) {
-				putc ('#');
-			} else if ((TftpBlock % (10 * HASHES_PER_LINE)) == 0) {
+			if (((TftpBlock - 1) % BLOCKS_PER_TICK) == 0) {
+				/* At each "tick", update a progress spinner. */
+				spinner = ((TftpBlock - 1) / BLOCKS_PER_TICK) % TICKS_PER_HASH;
+				if (spinner == (TICKS_PER_HASH - 1))
+					putc ('#');
+				else {
+					putc("/-\\|"[spinner % 4]);
+					putc(0x08);
+				}
+			} else if ((TftpBlock % (BLOCKS_PER_HASH * HASHES_PER_LINE)) == 0) {
 				puts ("\n\t ");
 			}
 		}
@@ -250,11 +261,16 @@
 			/*
 			 *	Same block again; ignore it.
 			 */
+#if 1 /* DHS - fix from www.bitshrine.org */
+			NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout); 
+  		TftpSend ();
+#endif
 			break;
 		}
 
 		TftpLastBlock = TftpBlock;
 		NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
+		TftpTimeoutCount = 0;
 
 		store_block (TftpBlock - 1, pkt + 2, len);
 
@@ -269,7 +285,7 @@
 			 *	We received the whole thing.  Try to
 			 *	run it.
 			 */
-			puts ("\ndone\n");
+			puts ("#\ndone\n");
 			NetState = NETLOOP_SUCCESS;
 		}
 		break;
diff -Naur u-boot-1.1.2/tools/Makefile uboot-1.1.2hsv/tools/Makefile
--- u-boot-1.1.2/tools/Makefile	2004-09-28 16:39:46.000000000 -0500
+++ uboot-1.1.2hsv/tools/Makefile	2007-05-29 16:50:53.000000000 -0500
@@ -185,15 +185,13 @@
 endif
 
 environment.c:
-		@rm -f environment.c
-		ln -s ../common/environment.c environment.c
+		@ln -sf ../common/environment.c environment.c
 
 environment.o: environment.c
 		$(CC) -g $(HOST_ENVIRO_CFLAGS) $(CPPFLAGS) -c $<
 
 crc32.c:
-		@rm -f crc32.c
-		ln -s ../lib_generic/crc32.c crc32.c
+		@ln -sf ../lib_generic/crc32.c crc32.c
 
 $(LOGO_H):	bmp_logo $(LOGO_BMP)
 		./bmp_logo $(LOGO_BMP) >$@
