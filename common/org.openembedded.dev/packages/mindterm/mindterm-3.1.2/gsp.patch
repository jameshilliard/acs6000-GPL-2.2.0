diff -ruN mindterm_3.1.2.org/build.xml mindterm_3.1.2/build.xml
--- mindterm_3.1.2.org/build.xml	2005-12-21 00:09:11.000000000 -0800
+++ mindterm_3.1.2/build.xml	2009-06-18 12:10:45.000000000 -0700
@@ -1,23 +1,28 @@
 <?xml version="1.0"?>
 
-<!DOCTYPE project [
-    <!ENTITY filesets SYSTEM "file:./filesets.xml">
-]>
-
 <project name="MindTerm" default="build" basedir=".">
     <description>
         MindTerm, an SSH (v1 and v2) client in pure Java
     </description>
+    
   <!-- set global properties for this build -->
-  <property name="build" location="build"/>
-  <property name="build.mindterm" location="build/mindterm"/>
-  <property name="build.examples" location="build/examples"/>
-  <property name="build.tests"    location="build/tests"/>
+  <property name="mindterm.build.dir" location="build"/>
+  <property name="build" location="${mindterm.build.dir}"/>
+  <property name="build.mindterm" location="${build}/mindterm"/>
+  <property name="build.examples" location="${build}/examples"/>
+  <property name="build.tests"    location="${build}/tests"/>
   <property name="doc"   location="javadoc"/>
   <property name="src"   location="."/>
   <property name="tests" location="tests"/>
+  
+  <!-- [CYCLADES-START] -->
+  <property environment="env"/>
+  <property name="compat.java.home" value="${env.JAVA_HOME}"/>
+  <property name="extra.libs" value="${compat.java.home}/jre/lib/plugin.jar"/>
+  <property name="mindtermjar" value="mindterm.jar"/>
+  <!-- [CYCLADES-END] -->
 
-  &filesets;
+  <import file="filesets.xml"/>
 
   <target name="init">
     <!-- Create the time stamp -->
@@ -30,33 +35,35 @@
   </target>
 
   <target name="compile" depends="init">
-    <depend destdir="${build.mindterm}" srcdir="."
+    <depend destdir="${build.mindterm}" srcdir="${src}"
             cache="${build.mindterm}/mindterm.depcache">
        <include name="com/**"/>
     </depend>
     <condition property="filter.exclude" value="com/mindbright/terminal/filter/Filter.java" else="">
        <not> <available classname="java.nio.charset.Charset"/> </not>
     </condition>
-    <javac destdir="${build.mindterm}" srcdir="."
+    <javac destdir="${build.mindterm}" srcdir="${src}"
            debug="on"
            debuglevel="lines,source"
            deprecation="off"
            target="1.1"
            source="1.2"
+           classpath="${extra.libs}"
            includes="com/**"
+    	   encoding="utf-8"
            excludes="${filter.exclude}"/>
   </target>
 
   <target name="compile_examples" depends="init, mindterm.jar">
-    <depend destdir="${build.examples}" srcdir="."
-            classpath="mindterm.jar"
+    <depend destdir="${build.examples}" srcdir="${src}"
+            classpath="${mindterm.build.dir}/${mindtermjar}"
             cache="${build.examples}/examples.depcache">	
        <include name="examples/**"/>
     </depend>
-    <javac destdir="${build.examples}" srcdir="."
+    <javac destdir="${build.examples}" srcdir="${src}"
            debug="on"
            debuglevel="lines,source"
-           classpath="mindterm.jar"
+           classpath="${mindterm.build.dir}/${mindtermjar}"
            target="1.1"
            source="1.2"
            includes="examples/**"/>
@@ -64,12 +71,13 @@
 
   <target name="mindterm.jar" depends="compile"
     description="Main MindTerm application">
-    <jar destfile="mindterm.jar">
+    <jar destfile="${mindterm.build.dir}/${mindtermjar}">
       <manifest>
-        <attribute
-	  name="Main-Class" value="com.mindbright.application.MindTerm"/>
+	<attribute
+	  name="Main-Class" value="com.cyclades.application.CycladesTerm"/>  
       </manifest>
-      <fileset dir="." includes="defaults/license.txt defaults/logo.gif"/>
+      <fileset dir="${src}" includes="defaults/license.txt defaults/logo.gif defaults/default.properties"/>
+     
       <fileset refid="base_classes_common"/>
       <fileset refid="base_classes_awt"/>
       <fileset refid="base_classes_swing"/>
@@ -77,6 +85,7 @@
       <fileset refid="mindterm_classes_awt"/>
       <fileset refid="mindterm_classes_swing"/>
     </jar>
+    
   </target>
 
   <target name="mindterm_awt.jar" depends="compile"
@@ -86,7 +95,7 @@
         <attribute
 	  name="Main-Class" value="com.mindbright.application.MindTerm"/>
       </manifest>
-      <fileset dir="." includes="defaults/license.txt defaults/logo.gif"/>
+      <fileset dir="${src}" includes="defaults/license.txt defaults/logo.gif"/>
       <fileset refid="base_classes_common"/>
       <fileset refid="base_classes_awt"/>
       <fileset refid="mindterm_classes_common"/>
@@ -101,7 +110,7 @@
         <attribute
 	  name="Main-Class" value="com.mindbright.application.MindTerm"/>
       </manifest>
-      <fileset dir="." includes="defaults/license.txt defaults/logo.gif"/>
+      <fileset dir="${src}" includes="defaults/license.txt defaults/logo.gif"/>
       <fileset refid="base_classes_common"/>
       <fileset refid="base_classes_swing"/>
       <fileset refid="mindterm_classes_common"/>
@@ -116,7 +125,7 @@
         <attribute
 	  name="Main-Class" value="com.mindbright.application.MindTermLite"/>
       </manifest>
-      <fileset dir="." includes="defaults/settings.txt"/>
+      <fileset dir="${src}" includes="defaults/settings.txt"/>
       <fileset refid="base_classes_common"/>
       <fileset refid="base_classes_awt"/>
       <fileset refid="lite_main_classes"/>
@@ -131,7 +140,7 @@
         <attribute
 	  name="Main-Class" value="com.mindbright.application.MindTermLite"/>
       </manifest>
-      <fileset dir="." includes="defaults/settings.txt"/>
+      <fileset dir="${src}" includes="defaults/settings.txt"/>
       <fileset refid="base_classes_common"/>
       <fileset refid="base_classes_awt"/>
       <fileset refid="lite_main_classes"/>
@@ -209,7 +218,7 @@
            debuglevel="lines,source"
            srcdir="${tests}"
            deprecation="off"
-           classpath="mindterm.jar"
+           classpath="${mindterm.build.dir}/${mindtermjar}"
            target="1.1"
            source="1.2"
            includes="tests/**
@@ -219,7 +228,7 @@
   <target name="runtests" depends="compiletests">
     <junit fork="yes" haltonfailure="no" printsummary="withOutAndErr" >
       <classpath>
-        <pathelement location="mindterm.jar" />
+        <pathelement location="${mindterm.build.dir}/${mindtermjar}" />
         <pathelement location="${build.tests}" />
       </classpath>
       <formatter type="plain" usefile="no"/>
@@ -232,7 +241,7 @@
     </junit>
   </target>
 
-  <target name="build" depends="mindterm.jar"
+  <target name="build" depends="mindterm.jar, sign_jar"
           description="Build main MindTerm application"/>
   <target name="lite"
           depends="mindtermlite.jar,lite_term.jar,lite_proxy.jar"
@@ -254,5 +263,28 @@
       <fileset dir="." includes="*.jar"/>
     </delete>
   </target>
+  
+   <!-- [CYCLADES-START] -->
+  <target name="gencert">    
+  	<exec executable="${compat.java.home}/bin/keytool" os="Linux">
+  	    <arg line="-genkey -alias cyc -keystore keystore -storepass cyclades -keypass cyclades -dname CN=Cyclades_Corporation,OU=APM_team,O=Cyclades.com,C=US -validity 3650"/>
+	</exec>
+	
+  <!-- genkey alias="cyc" keystore="./keystore" storepass="cyclades"
+  	  dname="CN=Cyclades Corporation, OU=APM team, O=Cyclades.com, C=US"/ -->
+  </target>    
+  
+  
+    <target name="sign_jar" depends="mindterm.jar" description="Signing mindterm.jar">
+	<!--	For official jar file, 
+		copy the official keystore to this directory, specify correct storepass below, then run ant -->
+    	<exec executable="${compat.java.home}/bin/jarsigner" os="Linux">
+  		<arg line="-verbose -keystore keystore -storepass cyclades ${mindterm.build.dir}/${mindtermjar} cyc" />
+  	</exec>
+   
+   <!-- signjar jar="${mindtermjar}" alias="cyc" keystore="./keystore" storepass="cyclades"></signjar -->
+  </target>
+
+   <!-- [CYCLADES-END] -->
 </project>
 
diff -ruN mindterm_3.1.2.org/com/cyclades/application/CycladesTerm.java mindterm_3.1.2/com/cyclades/application/CycladesTerm.java
--- mindterm_3.1.2.org/com/cyclades/application/CycladesTerm.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/application/CycladesTerm.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,559 @@
+package com.cyclades.application;
+
+import java.awt.Dimension;
+import java.awt.event.ComponentAdapter;
+import java.awt.event.ComponentEvent;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.net.URL;
+import java.util.Properties;
+import java.util.StringTokenizer;
+
+import netscape.javascript.JSObject;
+import netscape.javascript.JSException;
+
+import com.cyclades.util.CYProps;
+import com.mindbright.application.MindTerm;
+import com.mindbright.ssh.SSHPropertyHandler;
+import com.mindbright.terminal.DisplaySwing;
+
+/**
+ * MindTerm applet powered with specific Cyclades business logic.
+ *
+ * SESSION TIMEOUT is explained bellow :
+ *
+ * HttpSession ID is passed to the SSH server by setting it in Mindterm version attribute.
+ * This approach is OK since this setting is done very early in the Mindterm startup.
+ * Thus be carefull regarding the setMindtermVersion method call - now it is placed
+ * in strategic points of the code allowing Applet and Application to work fine.
+ *
+ * This sessionId is received by SSHD daemon and exported to the SSH_CLIENT environment variable.
+ * Then such variable is used inside the security profiles shells to pass it to the Java counter part (SecurityProfilesCommand).
+ * Conserver calls apm_conserver.security_profile.sh every minute to check user access.
+ *
+ * SecurityProfilesCommand returns false ou true verifying if session timed out as well.
+ * Depending on column USERS.cliTimeoutEnabled value (0 or 1), APM session timeout can be propagated to Mindterm or not.
+ *
+ *
+ * Applet parameters :
+ * 
+ * app : contains all parameters and properties restored from database/static file.
+ * 		 Warning: These parameters will be moved to paramSSHProps in the methods 
+ * 				getAppletParams and getApplicationParams however any code running
+ * 				before such calls will not see any parameter provided by 'app'.
+ * 				For this reason, parma and parmb were put in separated applet parameters
+ * 				(they are accessed before 'app' parse). 
+ * 				Applet.getParameter method was overriden to lookup in paramSSHProps.
+ *   
+ * parma: hash of session-id 
+ * parmb: crypted authentication information
+ * 
+ * @author Eduardo Murai Soares / Cyclades
+ * @since October/2005
+ */
+public class CycladesTerm extends MindTerm
+{
+    private static final String APPLETID_START="CycladesTerm-";
+
+	private final String CLOSE_PAGE = "close.html";	
+	private boolean debugMode;
+	
+	private boolean ie = false;
+	
+//	private String URL_CHECK_SESSION="/cli-service/checkSessionId?id=$1";
+//	private String URL_SAVE_USER_PREFS="/cli-service/saveCLIPreferences?uid=$1";
+
+	
+	public CycladesTerm() {
+		super();
+		// setting sshhome to ' ' prevents from storing local keys
+		// Do not comment this code. 	
+		setSshHomeDir(" ");
+		getParamSSHProps().setProperty(CYProps.SSH_HOME," ");
+		}
+
+	public CycladesTerm(Properties sshProps, Properties termProps) {
+		super(sshProps, termProps);
+		// setting sshhome to ' ' prevents from storing local keys
+		// Do not comment this code. 
+		setSshHomeDir(" ");
+		getParamSSHProps().setProperty(CYProps.SSH_HOME," ");
+	}
+
+	private void setDebugMode() {
+		String sdebug = getParamSSHProps().getProperty(CYProps.DEBUG_CYCLADES);
+		debugMode = sdebug!=null && sdebug.equalsIgnoreCase("true");
+	}
+	
+	public void init() {
+		// mindterm version set up with sessionId for Applet
+		// TODO: [ACS6K] Not sure if we still need this
+		setMindtermVersion( getParameter(CYProps.PARMA) );	
+		super.init();
+	}
+
+	/**
+	 * Override the default getParameter method.
+	 * APM will sent all properties in a single applet parameter called 'app'.
+	 * getAppletParams method will parse 'app' parameter into paramSSHProps.
+	 * Firstly, the parameter is looked up in paramSSHProps. if not found, it goes 
+	 * to Applet.getParameter method.
+	 * Notice: VDN 11/12/07: Change the order. 
+	 *         Get from Base (applet) first, SSHProp later, to avoid static memory
+	 */
+	public String getParameter(String pname) {				
+		String pvalue = super.getParametersFromBaseClass(pname);            //** getParamSSHProps().getProperty(pname);
+		if (pvalue==null) pvalue = getParamSSHProps().getProperty(pname);   //** super.getParametersFromBaseClass(pname); 
+		return pvalue;	
+	}
+	
+	/*public void actionPerformed(ActionEvent ae) {
+		String ac = ae.getActionCommand();
+		if(ac.equals("Disconnect")) {
+			System.out.println("Pressed the "+ac+" button");
+		}
+		else if(ac.equals("Send Break")) {
+			System.out.println("Pressed the "+ac+" button");
+		}
+		else	System.out.println("Unknown event intercepted");
+	}*/
+	
+	public void initGUI() {
+		super.initGUI();
+		String wsize = getClient().propsHandler.getProperty(CYProps.WINDOW_SIZE);
+		
+		// Handle window resizing for Swing window
+		if (super.getTerm().getDisplayView() instanceof DisplaySwing) {
+		  final DisplaySwing display = (DisplaySwing) super.getTerm().getDisplayView();						
+		  int width=0,height=0;
+		  
+		  if (wsize!=null && !wsize.equals("")) {
+			  wsize = wsize.trim();
+			  StringTokenizer tklist = new StringTokenizer(wsize,"x",false);
+			  String sdim[] = new String[tklist.countTokens()];
+			  int s=0;
+			  
+			  if (tklist.hasMoreTokens()) sdim[s++]= tklist.nextToken();  
+			  if (tklist.hasMoreTokens()) sdim[s++]= tklist.nextToken();			  
+			
+			  if (sdim!=null && sdim.length==2) {
+					width = Integer.parseInt(sdim[0],10);
+					height = Integer.parseInt(sdim[1],10);
+					}
+		  		}		  
+		   
+		  if (isAppletMode()) { 
+			  if (width>0 && height>0) 
+				  display.setSize(width, height);  
+		  }		  
+		  else if (!isAppletMode()) {
+			    if (width>0 && height>0) {
+			    	// restore the window size		
+			    	if (debugMode) System.out.println("initGUI, restoring window size: "+wsize);				
+					super.getFrame().setSize(width, height);
+					}			
+		  
+			// register window resizing event in order to store the new size as property
+			// this property can be saved as user preferences 
+			display.addComponentListener(new ComponentAdapter() {
+				public void componentResized(ComponentEvent e) {					
+					Dimension dim = display.getSize();
+					int w = (int) dim.getWidth();
+					int h = (int) dim.getHeight();
+					getClient().propsHandler.setProperty(CYProps.WINDOW_SIZE, w+"x"+h);
+					if (debugMode) System.out.println("DisplaySwing.componentResized: RESIZE HAPPENED, PROPERTY UPDATED: "+
+							getClient().propsHandler.getProperty(CYProps.WINDOW_SIZE));
+					}
+			});			
+		  	}
+		}		
+	}	
+
+	private void setMindtermVersion(String id) {
+		// the code bellow does not work well for Applets at second time
+		//Version.version = "Cyclades-"+id;
+
+		// WARNING: Do not change the prefix stored in APPLETID_START because it is recognized by
+		// APMWEB (SecurityProfilesCommand)
+		SSHPropertyHandler.defaultProperties.put("package-version", APPLETID_START+id);
+	}
+
+   /**
+	 * Validates session-id and retrieve login information from applet parameters.
+	 */
+	public void getAppletParams() {
+		super.getAppletParams();
+		setDebugMode();
+		try {
+		//decryptParams();
+		
+		// this method has no effect here
+		// setMindtermVersion( getParameter("parma") );
+		// Test: We no longer need to decrypt the username and password
+	
+		String username = null, password=null, unit=null;
+			username = getParamSSHProps().getProperty(CYProps.PARMA);
+			password = getParamSSHProps().getProperty(CYProps.PARMB);
+			unit =  getParamSSHProps().getProperty(CYProps.UNIT);	
+			
+			getParamSSHProps().put("username", username);
+			if (debugMode) System.out.println("Fake Username: "+ username);
+			
+			getParamSSHProps().put("password", password);
+			if (debugMode) System.out.println("Fake Password: "+ password);			
+		}
+		catch (Exception e) {
+			StringWriter sw = new StringWriter();			
+			e.printStackTrace(new PrintWriter(sw));			
+			throw new RuntimeException(sw.getBuffer().toString());
+		}
+	}
+
+//	public void getApplicationParams() throws Exception {
+//		super.getApplicationParams();
+//		setDebugMode();
+//		decryptParams();
+//		setMindtermVersion( getParamSSHProps().getProperty(CYProps.PARMA) );
+//	}
+
+	private String[] getTokens(String s, String sep) {
+		StringTokenizer tokens = new StringTokenizer(s, sep,false);
+		String t;
+		String resp[] = new String[tokens.countTokens()];
+		int i=0;
+		while (tokens.hasMoreTokens())
+			resp[i++] = tokens.nextToken();
+
+		return resp;
+	}
+	
+//	/**
+//	 * Decrypt authentication parameters.
+//	 * @throws UnsupportedEncodingException 
+//	 */
+//	public void decryptParams() throws UnsupportedEncodingException  {
+//        String parma = null,parmb=null,unit=null;
+//        parma = getParamSSHProps().getProperty(CYProps.PARMA);
+//		parmb = getParamSSHProps().getProperty(CYProps.PARMB);
+//		unit =  getParamSSHProps().getProperty(CYProps.UNIT);
+//
+//		if (debugMode) System.out.println("parma="+parma+", parmb="+parmb);
+//		// check if sessionid is valid
+//		if ((!unit.equals("acs"))&&(!unit.equals("apm"))) {
+//			if (parma!=null) checkSessionId(parma);							
+//			
+//			if (parmb!=null)
+//				try {			
+//				String dec[] = CryptoUtil.getInstance().decryptMindterm(parmb, parma);
+//				if (debugMode && dec!=null) 
+//					for (int x=0; x<dec.length; x++) 
+//						System.out.println("decrypted DATA: #"+dec[x]+"#,");	
+//				
+//				if (dec!=null && dec.length>0) {
+//					String usrinfo ="";
+//	
+//					if (dec.length>=3) {
+//						usrinfo = dec[0] + ":" + dec[2];
+//						}
+//					else usrinfo = dec[0];
+//	
+//					getParamSSHProps().put("username", usrinfo);
+//					if (debugMode) System.out.println("decrypted username: "+usrinfo);
+//					
+//					if (dec.length>=2) {
+//						getParamSSHProps().put("password", dec[1]);
+//						if (debugMode) System.out.println("decrypted password: "+dec[1]);
+//						}
+//					
+//					if (dec.length>=4) {
+//						getParamSSHProps().put("userid", dec[3]);
+//						if (debugMode) System.out.println("decrypted userId: "+dec[3]);
+//						}
+//					}
+//				} 
+//				catch (Exception e) {
+//					AlertDialog.show("Error","An error ocurred while decrypting parameters. Check the java console for details.", new java.awt.Frame());
+//					System.out.println("Error when decrypting parma/parmb: ");
+//					e.printStackTrace();
+//				}
+//			}
+//			else {
+//				if ((unit.equals("apm") && parma != null) && (parmb != null)) {
+//		           String[] dec = Utils.decrypt(parmb, parma);
+//		           String consoleChosen = dec[2];
+//					getParamSSHProps().put("username", dec[0]);
+//					getParamSSHProps().put("password", dec[1]);
+//		        }
+//
+//		        if (unit != null && unit.equals("acs")) {
+//		           boolean noAuthPopup = true;
+//		           byte[] myByte1 = Utils.hexDecode(parma);
+//		           parma = new String(myByte1);
+//		           parma = Utils.myDecrypt(null, parma, true);
+//		           if(debugMode) System.out.println("Decrypted parma: " + parma); 
+//
+//
+//		           byte[] myByte2 = Utils.hexDecode(parmb);
+//		           parmb = new String(myByte2);
+//		           if(debugMode) System.out.println("Decrypt hex parmb: [" + parmb + "]");
+//		           String password = Utils.myDecrypt(parma, parmb, false);
+//		           if(debugMode) System.out.println("Decrypt Password: [" + password + "]");
+//					getParamSSHProps().put("password", password);
+//		        }
+//			}
+//		}
+
+	public String getHTTPProtocol() {
+		String flag = getParamSSHProps().getProperty(CYProps.HTTPS_FLAG);
+		
+		if (flag!=null && flag.trim().equalsIgnoreCase("true")) 
+			return "https://";
+		else return "http://";						
+	}
+	
+//	/**
+//	 * Check if user session is valid, avoiding bogus connection.
+//	 * 
+//	 * @param parma Crypted session-id.
+//	 */
+//	private void checkSessionId(String parma) {
+//		//AlertDialog.show("Message","checkSessionId", new java.awt.Frame());
+//		
+//	      int returnCode = 404;
+//	      URL url = null;	      
+//	      try {
+//	    	  String urlParams = StringUtil.replaceAll(URL_CHECK_SESSION,"$1",parma);
+//	    	  
+//	    	  if (debugMode) System.out.println("checkSessionId, JWS server: "+getParamSSHProps().getProperty(CYProps.SERVER));
+//	    	  url = new URL(getHTTPProtocol()+getParamSSHProps().getProperty(CYProps.SERVER)+urlParams);   
+//
+//	    	  if (debugMode) System.out.println("checkSessionId, url: "+url.toExternalForm());
+//
+//	        HttpURLConnection con = (HttpURLConnection)url.openConnection();
+//	        returnCode = con.getResponseCode();
+//	        
+//	        if (debugMode) System.out.println("checkSessionId, returnCode: "+returnCode);
+//	      } catch (Exception ex) {
+//	    	  ex.printStackTrace();
+//	    	  //StringWriter buf = new StringWriter();	    	   
+//	          //ex.printStackTrace(new PrintWriter(buf));
+//	          //AlertDialog.show("STACK TRACE",buf.getBuffer().toString(), new java.awt.Frame());
+//	      }
+//
+//	      if (returnCode != 200) {
+//	    	  AlertDialog.show("Connection Failed","This session is invalid. Make sure you are logged in. returnCode="+returnCode, new java.awt.Frame());
+//	          throw new RuntimeException("Connection Failed");
+//	      }
+//	   }
+
+		private String getWindowSizeJS() {
+			int windowWidth=0, windowHeight=0;
+			JSObject window = JSObject.getWindow(this);
+			if (window==null) return null;
+			
+			// try Mozilla
+			Object jsobj = window.eval("window.innerWidth");						
+			if (jsobj!=null) windowWidth= ((Number) jsobj).intValue();
+			else { 
+				System.out.println("getWidth-IE ...");
+				// try IE
+				jsobj = window.eval("document.body.clientWidth");
+				if (jsobj==null) return null;
+				windowWidth= ((Number) jsobj).intValue();
+				}											
+			
+			// try Mozilla
+			jsobj = window.eval("window.innerHeight");						
+			if (jsobj!=null) windowHeight= ((Number) jsobj).intValue();
+			else {
+				System.out.println("getHeight-IE ...");
+				// try IE
+				jsobj = window.eval("document.body.clientHeight");			
+				
+				if (jsobj==null) return null;
+				else windowHeight= ((Number) jsobj).intValue();																			
+				}
+			
+			System.out.println("window-size: "+windowWidth+"x"+windowHeight);
+			return (windowWidth+"x"+windowHeight);
+		}
+		
+		/**
+		 * Handle window size for Applet.
+		 * 
+		 * @param propsToSave
+		 */
+		private void handleWindowSizeForApplet(Properties propsToSave) {
+			try {
+				// capture current window size
+				String wsize = getWindowSizeJS();
+				
+				if (wsize!=null) propsToSave.setProperty(CYProps.WINDOW_SIZE, wsize);
+				else System.out.println("Warning: it was not possible to capture browser window size- JS problems");
+				
+				} catch (Exception ex) {
+					System.out.println("Warning: It was not possible to capture browser window size - ");
+					ex.printStackTrace();
+				}
+		}
+//		/**
+//		 * Save mindterm preferences into APM.
+//		 */
+//		public void savePreferences(Properties propsToSave) {
+//			int returnCode=404;
+//			String msg=null;
+//			String[] excludeParams={"parma","parmb","userid","password","username","server","debug"};
+//			try {
+//			if (isAppletMode()) handleWindowSizeForApplet(propsToSave);
+//			
+//			if (debugMode) System.out.println("Saving window-size: "+propsToSave.getProperty(CYProps.WINDOW_SIZE));
+//			//------------------------------------------------------------------
+//			// get parameters	
+//			Enumeration keys = propsToSave.keys();
+//			String k,v;
+//			int i=0;
+//			StringBuffer params = new StringBuffer();
+//			
+//			PARAMS_LOOP: 
+//			while (keys.hasMoreElements()) {
+//				k = keys.nextElement().toString();
+//				
+//				if (excludeParams!=null)
+//					for (i=0; i<excludeParams.length; i++) 
+//						if (excludeParams[i].equals(k)) continue PARAMS_LOOP;				
+//				
+//				v = propsToSave.getProperty(k);
+//				params.append(k);
+//				params.append("=");
+//				params.append(URLEncoder.encode(v)); //,"utf-8"));
+//				params.append("&");
+//				}
+//			
+//			// get the userID
+//			String userid = (String) getParamSSHProps().get("userid");
+//			if (userid==null || Integer.parseInt(userid,10)<=0) 
+//				throw new InvalidUserException("Invalid userid sent by APM : "+userid);
+//				
+//			// call the service URL to save the data into database
+//			URL url = new URL(getHTTPProtocol()+getParamSSHProps().getProperty(CYProps.SERVER)+
+//					StringUtil.replaceAll(URL_SAVE_USER_PREFS,"$1",userid)+"&"+params.toString());      	  	
+//
+//			if (debugMode) System.out.println("savePreferences, url: "+url.toExternalForm());
+//
+//			HttpURLConnection con = (HttpURLConnection)url.openConnection();
+//			returnCode = con.getResponseCode();			
+//			msg = con.getResponseMessage();
+//			
+//			if (debugMode) System.out.println("savePreferences, returnCode: "+returnCode+", msg: "+msg);
+//			} 
+//			catch (InvalidUserException e) {
+//				throw e;
+//			}
+//			catch (Exception e) {
+//				System.out.println("Error in CycladesTerm.savePreferences");
+//				e.printStackTrace();
+//			}
+//			
+//			 if (returnCode != 200) 
+//		          throw new RuntimeException("Failed to save preferences in APM");		      	
+//			 else AlertDialog.show("Message","Preferences has been saved successfully!", new java.awt.Frame());
+//		}
+	/**
+	 * Release allocated resources
+	 */
+	public void destroy() {
+		// original destroy method would close all windows :
+		// When you start two applets by clicking twice on the CLI button in the webpage
+		// if you exit one applet, the second would be killed as well.
+		// Calling close method prevents from such behavior
+		setConfirmedClose(true);
+		super.close();
+	}
+	
+	/**
+	 * Method called by Mindterm.close().
+	 * It checks if is necessary to call the regular close method or close the html page in case of
+	 * main Applet window.
+	 */	
+	public void checkAppletWindow(MindTerm mt) { 
+		if (mt.isAppletMode() && mt.isMainWindow() && !mt.isClosed()) {
+			try {
+
+				mt.getParamSSHProps().clear();
+			
+				//	Do not close browser window through JSObject
+				// because it leads Firefox to hang
+				// OBS: In case you need to use the netscape library, put ${java.home}/lib/plugin.jar in the CLASSPATH
+				JSObject window = JSObject.getWindow(this);
+				
+				if (!(window instanceof netscape.javascript.JSObject)) {
+					window.eval("self.close();");
+				} else if (mt.getAppletContext()!=null) {
+					mt.getAppletContext().showDocument(new URL(mt.getCodeBase(), CLOSE_PAGE));
+				}
+				mt.setClosedFlag();
+
+			} catch (Exception e) {
+				//e.printStackTrace();
+				try { 
+					if (mt.getAppletContext()!=null) {
+						mt.getAppletContext().showDocument(new URL(mt.getCodeBase(), CLOSE_PAGE));
+						mt.setClosedFlag();
+					}
+				} catch (Exception ee) {
+					ee.printStackTrace();
+				}
+			}
+		}
+	}
+	
+	public void cloneWindow() {
+        CycladesTerm mindterm = new CycladesTerm(getSshProps(), getTermProps());
+        mindterm.initParams(this);
+        mindterm.setupClone( getClient() );
+
+        // cloned window is child of the main window
+        mindterm.setMainWindow(false);
+        (new Thread(mindterm, "MindTerm.clone")).start();
+    }
+
+    public void newWindow() {
+    	CycladesTerm mindterm = new CycladesTerm(getParamSSHProps(), getParamTermProps());
+        mindterm.initParams(this);
+
+        // new window is child of the main window
+        mindterm.setMainWindow(false);
+        (new Thread(mindterm, "MindTerm.window")).start();
+    }
+
+	 public static void main(String[] argv) {
+	        CycladesTerm controller    = new CycladesTerm(getParamSSHProps(), getParamTermProps());
+	        controller.cmdLineArgs = argv;        
+	        try {
+	            controller.getApplicationParams();
+	            
+	            /* System.out.println("---- PARAMETERS ----");
+                Enumeration keys = controller.getParamSSHProps().keys();
+                String k,v;
+                while (keys.hasMoreElements()) {
+                    k = keys.nextElement().toString();
+                    v = controller.getParamSSHProps().getProperty(k);
+                    System.out.println(k+"=."+v+".");
+                }
+                            */	            
+	        } catch (Exception e) {
+	            System.out.println("Error: ");
+	            e.printStackTrace();
+	            System.exit(1);
+	        }
+
+	        try {
+	            controller.run();
+	        } catch (Exception e) {
+	            System.out.println("Internal error running controller");
+	            e.printStackTrace();
+	        }
+	    }
+
+
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/exception/InvalidUserException.java mindterm_3.1.2/com/cyclades/exception/InvalidUserException.java
--- mindterm_3.1.2.org/com/cyclades/exception/InvalidUserException.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/exception/InvalidUserException.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,8 @@
+package com.cyclades.exception;
+
+public class InvalidUserException extends RuntimeException {	
+	
+	public InvalidUserException(String msg) { 
+		super(msg);
+	}
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/CryptoUtil.java mindterm_3.1.2/com/cyclades/util/CryptoUtil.java
--- mindterm_3.1.2.org/com/cyclades/util/CryptoUtil.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/CryptoUtil.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,151 @@
+package com.cyclades.util;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+import com.mindbright.jca.security.InvalidKeyException;
+import com.mindbright.jca.security.NoSuchAlgorithmException;
+import com.mindbright.util.Base64;
+
+//import sun.misc.BASE64Decoder;
+
+/**
+ * Cryptography utility which provides access to Mindterm crypto classes. 
+ * 
+ * WARNING: APMWEB JCECrypto class will encrypt login data and pass it to Mindterm. 
+ * Mindterm CryptoUtil class will decrypt this data.
+ * Thus if you modify this class, take a look at JCECrypto to keep it in sync.    
+ *  
+ * This class must be compliant with JDK 1.2.2.
+ *  
+ * @author eduardo.soares@cyclades.com
+ * @see [APMWEB PROJECT]: com.cyclades.utils.crypto.JCECrypto
+ */
+public class CryptoUtil {
+	private static CryptoUtil singleton = new CryptoUtil();
+	public final int KEY_SIZE_BITS = 128;  
+	public final String ALGORITHM = "AES/ECB";  
+	
+	private  CryptoUtil() { }
+	
+	public static CryptoUtil getInstance() {
+		return singleton;
+	}
+	
+	/**
+	 * Set the String size to the nearest multiple number.
+	 * 
+	 * @param m
+	 * @param mult
+	 * @param ch Character to fill
+	 * @return
+	 */
+	private String ajustMultipleChars(String m, int mult, char ch) {
+		if (m==null) return null;
+		
+		int r = m.length() % mult;
+		if (r != 0) {
+			int div = m.length() / mult;			
+			return ajustSize(m, (mult * (div+1)), ch); 
+			}
+		else return m;
+	}
+	
+
+	/**
+	 * Truncate or fill the 'information' to reach the size provided.
+	 * 
+	 * @param m Information
+	 * @param size 
+	 * @return Information modified to the size provided.
+	 */
+	private String ajustSize(String m, int size, char ch) {
+		if (m==null) return null;
+		
+		if (m.length()<size) {			
+			StringBuffer buf = new StringBuffer(m);
+			
+			for (int i=0; i<(size-m.length()); i++) {
+				if (ch=='\0') buf.append(m.charAt( i % (m.length()-1) ));
+				else buf.append(ch);
+				}
+			
+			return buf.toString();
+			}			
+		else if (m.length()>size) 
+			return m.substring(0, size);		
+		else return m;		
+	}	
+
+	/**
+	 * Use characters of string m to fill.
+	 * 
+	 * @param m
+	 * @param mult
+	 * @return
+	 */
+	private String ajustSize(String m, int size) {
+		return ajustSize(m, size, '\0');
+	}
+	
+	/**
+	 * Decrypts data previously encrypted by JCE API.
+	 * 
+	 * @param encdata encrypted data with base64 encoding
+	 * @param password Flat string
+	 * @return decrypted values
+	 * @throws NoSuchAlgorithmException 
+	 * @throws IOException 
+	 * @throws NoSuchAlgorithmException 
+	 * @throws InvalidKeyException 
+	 * @throws IOException 
+	 * @throws ClassNotFoundException 
+	 * @throws Exception
+	 */
+	public String[] decryptMindterm(String encdata, String password) throws NoSuchAlgorithmException, InvalidKeyException, IOException, ClassNotFoundException   {
+		// set key size of 128 bits (16 bytes)
+		password  = ajustSize(password, KEY_SIZE_BITS/8);
+		
+		// decode the base64 encoded data
+		byte[] bx = Base64.decode(encdata.getBytes());		
+		//-----------------------------------
+		// decrypts the data
+		com.mindbright.jce.crypto.Cipher cipher = com.mindbright.jce.crypto.Cipher.getInstance(ALGORITHM);
+		cipher.init(com.mindbright.jce.crypto.Cipher.DECRYPT_MODE,
+             new com.mindbright.jce.crypto.spec.SecretKeySpec(password.getBytes(), cipher.getAlgorithm()));           
+		
+		byte[] dx = cipher.doFinal(bx, 0, bx.length);
+		//-----------------------------------
+		// convert decrypted bytes into an Object 
+		String str[] = null;
+		ByteArrayInputStream bin = new ByteArrayInputStream(dx);
+        ObjectInputStream oin = new ObjectInputStream(bin);
+        try {
+        	return (String[])oin.readObject();
+        } finally {
+        	bin.close();
+        	}        		
+	}		
+
+	// WARNING: the data to be encrypted must be multiple of 8
+	// PROBLEM: Not possible to encrypt a serialized array of bytes, just Strings
+	// For this reason, APMWEB uses JCECrypto to encrypt	
+/*	public String encryptMindterm(String data, String password) throws InvalidKeyException, NoSuchAlgorithmException, IOException  {	 
+		data = ajustMultipleChars(data,KEY_SIZE_BITS/8, ' ');
+
+		byte objData[] = data.getBytes(); 
+		//----------------------------------------------------
+		password  = ajustSize(password, KEY_SIZE_BITS/8,'\0');
+		
+		com.mindbright.jce.crypto.Cipher cipher = com.mindbright.jce.crypto.Cipher.getInstance(ALGORITHM);
+		cipher.init(com.mindbright.jce.crypto.Cipher.ENCRYPT_MODE,
+             new com.mindbright.jce.crypto.spec.SecretKeySpec(password.getBytes(), cipher.getAlgorithm()));             
+
+		byte[] dx = cipher.doFinal(objData, 0, objData.length);
+		return new String(Base64.encode(dx));
+	}
+*/	
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/CYProps.java mindterm_3.1.2/com/cyclades/util/CYProps.java
--- mindterm_3.1.2.org/com/cyclades/util/CYProps.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/CYProps.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,32 @@
+package com.cyclades.util;
+
+/**
+ * Property names passed to Mindterm from APMWEB.
+ * It does not contain all available properties here;
+ * just the ones used in Cyclades modified sources.
+ * 
+ * @author Eduardo Murai Soares 
+ */
+public class CYProps {
+	public static final String SKIP_PASSWD_METHOD="skipPasswordMethod";
+	public static final String WINDOW_SIZE="window-size";
+	public static final String HTTPS_FLAG="httpsFlag";
+	public static final String SSH_HOME="sshhome";
+	public static final String FORCE_SWING = "force-swing";
+	public static final String BREAK_SEQ="breakseq";
+	public static final String LOCK_OUTLET="lockOutlet";
+	public static final String UNLOCK_OUTLET="unlockOutlet";
+	public static final String POWER_ON = "powerOn";
+	public static final String POWER_OFF = "powerOff";
+	public static final String POWER_CYCLE = "powerCycle";
+	public static final String POWER_STATUS = "powerStatus";
+	public static final String DEBUG_CYCLADES = "debug-cyclades";
+	public static final String SERVER = "server";
+	public static final String PARMA = "parma";
+	public static final String PARMB = "parmb";
+	public static final String UNIT = "unit";
+	public static final String PHYS_PORT_AUTH = "phys-port-auth";
+	public static final String IE = "firefox";
+}
+
+// com.cyclades.util.CYProps.
\ No newline at end of file
diff -ruN mindterm_3.1.2.org/com/cyclades/util/Formatter.java mindterm_3.1.2/com/cyclades/util/Formatter.java
--- mindterm_3.1.2.org/com/cyclades/util/Formatter.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/Formatter.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,86 @@
+package com.cyclades.util;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.net.URLEncoder;
+import java.util.Enumeration;
+import java.util.Properties;
+import java.util.StringTokenizer;
+
+/**
+ * Data formatter class.
+ * 
+ * @author Eduardo Murai Soares
+ */
+public class Formatter {
+	/**
+	 * DO NOT use '&' as delimiter. It has a issue in Windows which will interpret 
+	 * any string with '&copy' and convert to another char. 
+	 */
+	public static String DELIM_PARAM="#";
+	//public static String ENCODING="utf-8";
+	
+	/**
+	 * Mount an URL of all parameters stored in appParams, encoding the values.
+	 * @param appParams
+	 * @param excludePattern
+	 * @return mounted URL
+	 * @throws UnsupportedEncodingException
+	 */
+	public static String encodeParams(Properties appParams, String excludePattern) throws UnsupportedEncodingException {
+		 Enumeration keys = appParams.keys();
+		 String k, v;
+		 StringBuffer buffer = new StringBuffer();
+		 		  
+		 while (keys.hasMoreElements()) {
+			k = keys.nextElement().toString();
+			if (excludePattern!=null && k.startsWith(excludePattern)) continue;
+			
+			v = appParams.getProperty(k);					
+			
+			buffer.append(k);
+			buffer.append("=");
+			buffer.append(URLEncoder.encode(v)); //,ENCODING));
+			buffer.append(DELIM_PARAM);
+		  	}
+		 
+		 if (buffer.length()>0) buffer.setLength(buffer.length()-1); // remove last DELIM
+		 return buffer.toString();
+	}
+	
+	/**
+	 * Parse the URL parameters back to the targets properties.
+	 * @param rawParams URL 
+	 * @param targets List of Properties 
+	 * @throws UnsupportedEncodingException
+	 */
+	public static void parseCycladesParams(String rawParams, Properties targets[]) throws UnsupportedEncodingException {
+		if (targets==null) return;
+		
+		String pname="",pvalue="",v="",token="";
+    	StringTokenizer tkparams;
+    	StringTokenizer tklist = new StringTokenizer(rawParams,DELIM_PARAM,false);    	
+    	//System.out.println("#2 - parseCycladesParams, rawParams: "+rawParams);
+    	
+		int itarg=0;		
+    	while (tklist.hasMoreTokens()) {
+    		token = tklist.nextToken();
+    		//System.out.println("parseCycladesParams, token: "+token);
+    		
+    		tkparams= new StringTokenizer(token,"=",false);                    		
+    		pname = (tkparams.hasMoreTokens()?tkparams.nextToken():"");
+    		pvalue = (tkparams.hasMoreTokens()?tkparams.nextToken():"");
+    		tkparams= null;
+    		
+    		if (pvalue!=null) v = URLDecoder.decode(pvalue); //,ENCODING);
+    		else v="";
+    		
+    		//System.out.println("parseCycladesParams, key: "+pname+", value: ("+v+")");
+    		
+    		if (v==null || v.trim().equals("")) continue;    		
+    		
+    		for (itarg=0; itarg<targets.length; itarg++)              		
+    			targets[itarg].setProperty(pname, v);    		
+    		}		
+	}
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/OptionPane.java mindterm_3.1.2/com/cyclades/util/OptionPane.java
--- mindterm_3.1.2.org/com/cyclades/util/OptionPane.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/OptionPane.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,269 @@
+package com.cyclades.util;
+
+import java.applet.Applet;
+import java.awt.*;
+import java.awt.event.*;
+import java.util.StringTokenizer;
+
+
+/** <P>OptionPane makes it easy to pop up a standard dialog box that prompts users
+  * for a value or informs them of something.</P>
+  *
+  * <P>While the OptionPane class may appear complex because of the large number of methods,
+  * almost all uses of this class are one-line calls to one of the static showXxxDialog
+  * methods shown below: </P>
+  *
+  * <P><UL><LI>showConfirmDialog asks a confirming question, like yes/no/cancel.</LI>
+  * <LI>showInputDialog prompts for some input.</LI>
+  * <LI>showMessageDialog tells the user about something that has happened.</LI></UL></P>
+  *
+  *
+  */
+public class OptionPane extends Dialog implements ActionListener, ItemListener {
+    // constants
+    /** This constant is returned by OptionPane.showConfirmDialog when the user clicks the Yes button. */
+    public static final int YES_OPTION = 0;
+
+    /** This constant is returned by OptionPane.showConfirmDialog when the user clicks the No button. */
+    public static final int NO_OPTION = 1;
+
+    /** This constant is returned by OptionPane.showConfirmDialog and
+      * OptionPane.showInputDialog when the user clicks the Cancel button. */
+    public static final int CANCEL_OPTION = -1;
+
+    public static final int YES_NO_OPTION = 3;
+
+    public static final int YES_NO_CANCEL_OPTION = 4;
+
+    public static final int OK_OPTION = 5;
+
+    public static final int OK_CANCEL_OPTION = 6;
+
+    public static final int INFORMATION_MESSAGE = 7;
+
+    public static final int QUESTION_MESSAGE = 8;
+
+    public static final int ERROR_MESSAGE = 9;
+
+    public static final int PLAIN_MESSAGE = 10;
+
+    public static final int WARNING_MESSAGE = 11;
+
+
+  // instance vars
+  private static int CONFIRM_TYPE = 0;
+  private static int INPUT_TYPE = 1;
+  private static int MESSAGE_TYPE = 2;
+  private static int OPTION_TYPE = 3;
+
+  private Dialog my_dialog;
+  private Button   my_yesButton, my_noButton, my_okButton, my_cancelButton;
+  private Checkbox[] my_choiceButtons;
+  private int my_type;
+  private int my_selectedIndex = CANCEL_OPTION;
+  private TextField my_field;
+  private Object   my_choice = null;
+  private Object[] my_options;
+
+
+  /* Constructs a new OptionPane of the given type with the given Frame as
+   * its parent, with the given window title, displaying the given message.
+   *
+   * If parent is non-null, the OptionPane will center itself with respect
+   * to the parent.  Otherwise, the OptionPane will locate itself at (0, 0).
+   *
+   * Acceptable types are OptionPane.CONFIRM_TYPE, OptionPane.INPUT_TYPE, and OptionPane.MESSAGE_TYPE.
+   */
+  private OptionPane(Component parent, String message, String title, int type, int subtype) {
+    super((parent instanceof Frame) ? (Frame)parent : new Frame(), title, true);
+    init(parent, message, title, type, subtype, null, null);
+  }
+
+  private OptionPane(Component parent, String message, String title, int type, int subtype, Object[] options, Object initialOption) {
+    super((parent instanceof Frame) ? (Frame)parent : new Frame(), title, true);
+    init(parent, message, title, type, subtype, options, initialOption);
+  }
+
+  private void init(Component parent, String message, String title, int type, int subtype, Object[] options, Object initialOption) {
+    my_type = type;
+    my_options = options;
+
+    // set initial option selected
+    if (options != null) {
+      for (int ii = 0;  ii < options.length;  ii++) {
+        if (options[ii].equals(initialOption)) {
+          my_selectedIndex = ii;
+          my_choice = new Integer(ii);
+        }
+      }
+
+      if (my_choice == null)
+        my_choice = new Integer(CANCEL_OPTION);
+    }
+    setResizable(false);
+
+    // construct components
+    my_yesButton    = new Button("Yes");
+    my_noButton     = new Button("No");
+    my_okButton     = new Button("OK");
+    my_cancelButton = new Button("Cancel");
+    my_field = new TextField(10);
+
+    // event listening
+    my_yesButton.addActionListener(this);
+    my_noButton.addActionListener(this);
+    my_okButton.addActionListener(this);
+    my_cancelButton.addActionListener(this);
+    my_field.addActionListener(this);
+
+    // layout
+    Panel contentPane = new Panel(new BorderLayout());
+    Panel centerPanel = new Panel();
+    Panel southPanel = new Panel();
+
+    Panel labelPanel = new Panel(new GridLayout(0, 1));
+    StringTokenizer tokenizer = new StringTokenizer(message, "\n");
+    while (tokenizer.hasMoreTokens())
+      labelPanel.add(new Label(tokenizer.nextToken()));
+
+    if (type == CONFIRM_TYPE) {
+      centerPanel.add(labelPanel);
+      southPanel.add(my_yesButton);
+      southPanel.add(my_noButton);
+      if (subtype == YES_NO_CANCEL_OPTION)
+        southPanel.add(my_cancelButton);
+    }
+    else if (type == INPUT_TYPE) {
+      centerPanel.setLayout(new BorderLayout());
+      centerPanel.add(labelPanel, BorderLayout.CENTER);
+      centerPanel.add(my_field, BorderLayout.SOUTH);
+      southPanel.add(my_okButton);
+      if (subtype == OK_CANCEL_OPTION)
+        southPanel.add(my_cancelButton);
+    }
+    else if (type == MESSAGE_TYPE) {
+      centerPanel.add(labelPanel);
+      southPanel.add(my_okButton);
+    }
+    else if (type == OPTION_TYPE) {
+      if (options == null)
+        throw new IllegalArgumentException("null options list");
+
+      centerPanel.setLayout(new GridLayout(0, 1));
+      centerPanel.add(labelPanel);
+      CheckboxGroup cbg = new CheckboxGroup();
+
+      int numOptions = options.length;
+      my_choiceButtons = new Checkbox[numOptions];
+      for (int ii = 0;  ii < numOptions;  ii++) {
+        my_choiceButtons[ii] = new Checkbox(options[ii].toString(), options[ii] == initialOption, cbg);
+        my_choiceButtons[ii].addItemListener(this);
+        centerPanel.add(my_choiceButtons[ii]);
+      }
+
+      southPanel.add(my_okButton);
+      if (subtype == OK_CANCEL_OPTION)
+        southPanel.add(my_cancelButton);
+    }
+
+    contentPane.add(centerPanel, BorderLayout.CENTER);
+    contentPane.add(southPanel, BorderLayout.SOUTH);
+    add(contentPane);
+    pack();
+
+    // set location to center of parent
+    int x = 0;
+    int y = 0;
+
+    Point p = parent != null ? parent.getLocation() : new Point(0, 0);
+    Dimension parentSize = parent != null ? parent.getSize() : Toolkit.getDefaultToolkit().getScreenSize();
+    Dimension mySize = getSize();
+    x = p.x + (parentSize.width  - mySize.width ) / 2;
+    y = p.y + (parentSize.height - mySize.height) / 2;
+
+    setLocation(x, y);
+  }
+
+
+  /** Processes ActionEvents in this OptionPane. */
+  public void actionPerformed(ActionEvent event) {
+    Object source = event.getSource();
+
+    if (source == my_yesButton)
+      my_choice = new Integer(YES_OPTION);
+    if (source == my_noButton)
+      my_choice = new Integer(NO_OPTION);
+    else if (source == my_okButton  ||  source == my_field) {
+      if (my_type == OPTION_TYPE)
+        my_choice = new Integer(my_selectedIndex);
+      else
+        my_choice = my_field.getText();
+    } else if (source == my_cancelButton)
+      my_choice = null;
+
+    hide();
+    dispose();
+  }
+
+  /** Processes ItemEvents in this OptionPane. */
+  public void itemStateChanged(ItemEvent event) {
+    Object source = event.getSource();
+    for (int ii = 0;  ii < my_choiceButtons.length;  ii++)
+      if (source == my_choiceButtons[ii]) {
+        my_selectedIndex = ii;
+      }
+  }
+
+
+  /** Shows this OptionPane and returns the resulting input, if any. */
+  private Object showDialog() {
+    show();
+    return my_choice;
+  }
+
+
+  /** Shows a confirmation dialog with the given message, using the given component as its parent.
+    * @return an integer corresponding to the button the user pressed.  The integer may be one of
+    * OptionPane.YES_OPTION, OptionPane.NO_OPTION, or OptionPane.CANCEL_OPTION.
+    */
+  public static int showConfirmDialog(Component parent, Object message) {
+    return showConfirmDialog(parent, message, "Confirm", YES_NO_CANCEL_OPTION);
+  }
+
+  public static int showConfirmDialog(Component parent, Object message, String title, int type) {
+    Integer i = (Integer)(new OptionPane(parent, (String)message, title, CONFIRM_TYPE, type).showDialog());
+    return (i != null) ? i.intValue() : CANCEL_OPTION;
+  }
+
+  /** Shows a dialog asking for input, with the given message, using the given component as its parent.
+    * @return the input text typed by the user; null if the user presses Cancel.
+    */
+  public static String showInputDialog(Component parent, Object message) {
+    return showInputDialog(parent, message, "Enter Input", OK_CANCEL_OPTION);
+  }
+
+  public static String showInputDialog(Component parent, Object message, String title, int type) {
+    return (String)(new OptionPane(parent, (String)message, title, INPUT_TYPE, type).showDialog());
+  }
+
+  /** Shows a dialog displaying the given message, using the given component as its parent. */
+  public static void showMessageDialog(Component parent, Object message) {
+    showMessageDialog(parent, message, "Message", OK_OPTION);
+  }
+
+  public static void showMessageDialog(Component parent, Object message, String title, int type) {
+    new OptionPane(parent, (String)message, title, MESSAGE_TYPE, type).showDialog();
+  }
+
+  public static int showOptionDialog(Component parent, String message, String title, int type, int unused, Object unusedIcon, Object[] options, Object initialValue) {
+    Integer i = (Integer)new OptionPane(parent, (String)message, title, OPTION_TYPE, type, options, initialValue).showDialog();
+    return (i != null) ? i.intValue() : CANCEL_OPTION;
+  }
+
+  public static void main(String[] args) {
+    String[] items = new String[] {"Fred", "Barney", "Wilma", "Dino"};
+    int index = OptionPane.showOptionDialog(null, "Pick one!", "Title here", OptionPane.OK_OPTION, 0, null, items, items[1]);
+    System.out.println("index: " + index);
+  }
+}
+
diff -ruN mindterm_3.1.2.org/com/cyclades/util/ssh/ExecResponse.java mindterm_3.1.2/com/cyclades/util/ssh/ExecResponse.java
--- mindterm_3.1.2.org/com/cyclades/util/ssh/ExecResponse.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/ssh/ExecResponse.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,63 @@
+package com.cyclades.util.ssh;
+
+/**
+ * Used to return the outcome of a process execution by the {@link SSHSession} class.
+ */
+public class ExecResponse
+{
+  /**
+   * The standard output bytes.
+   */  
+  private byte out[];
+  
+  /**
+   * The standard error bytes.
+   */  
+  private byte err[];
+  
+  /**
+   * The return code.
+   */
+  private int code;
+  
+  /**
+   * Constructs this object.
+   * @param out the standard output
+   * @param err the standard error
+   * @param code the return code
+   */
+  ExecResponse(byte[] out, byte[] err, int code)
+  {
+    this.out = out;
+    this.err = err;
+    this.code = code;
+  }
+  
+  /**
+   * returns the standard output bytes.
+   */
+  public byte[] getOut()
+  {
+    return out;
+  }
+  
+  /**
+   * returns the standard error bytes.
+   */
+  public byte[] getErr()
+  {
+    return err;
+  }
+  
+  /**
+   * returns the return code.
+   */
+  public int getCode()
+  {
+    return code;
+  }
+
+    public String toString() {
+        return "[" + code + " - '" + (new String(out)) + "' - '" + (new String(err)) + "']"; 
+    }
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/ssh/SSH2SessionImpl.java mindterm_3.1.2/com/cyclades/util/ssh/SSH2SessionImpl.java
--- mindterm_3.1.2.org/com/cyclades/util/ssh/SSH2SessionImpl.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/ssh/SSH2SessionImpl.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,234 @@
+/*
+ * SSH2SessionImpl.java
+ *
+ * Created on 18 de Abril de 2006, 17:15
+ *
+ */
+
+package com.cyclades.util.ssh;
+
+import com.mindbright.jca.security.SecureRandom;
+import com.mindbright.ssh2.SSH2SCP1Client;
+import com.mindbright.ssh2.SSH2SimpleClient;
+import com.mindbright.ssh2.SSH2Transport;
+import com.mindbright.util.RandomSeed;
+import com.mindbright.util.SecureRandomAndPad;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.Socket;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Class used to issue SSH and SCP commands.
+ * @author Constantino
+ */
+public class SSH2SessionImpl implements SSHSession {
+
+    /**
+     * Logger for this class.
+     */
+    private static Logger log = Logger.getLogger(SSH2SessionImpl.class.getName());
+    
+    /**
+     * Class used to do SCP.
+     */
+    private SSH2SCP1Client sshClient;
+    
+    /**
+     * SSH transport.
+     */
+    private SSH2Transport transport;
+    
+    /**
+     * Socket connection to the SSH server.
+     */
+    private Socket serverSocket;
+    
+    /**
+     * Counter used to generated temporary file names.
+     */
+    private static int tmpCounter = 0;
+    
+    /**
+     * Current class loader hash code used to generated temporary file names.
+     */
+    private static String classLoaderHashCode = 
+            "" + SSH2SessionImpl.class.getClassLoader().hashCode();
+    
+    /**
+     * Establishes a new SSH connection to the default port (22).
+     */
+    SSH2SessionImpl(String hostname, String username, String password) 
+            throws Exception {
+        this(hostname,username,password,SSH_PORT);
+    }
+    
+    /**
+     * Establishes a new SSH connection.
+     * In a near future it will receive a certificate instead of a password.
+     */
+    SSH2SessionImpl(String hostname, String username, String password, int port) 
+            throws Exception {
+        
+            serverSocket = new Socket(hostname, port);
+            transport       = new SSH2Transport(serverSocket,createSecureRandom());
+            
+            SSH2SimpleClient client = new SSH2SimpleClient(transport,username,password);
+
+            // there is no point in setting the stderr because when a command
+            // is executed is is changed
+            sshClient = new SSH2SCP1Client(
+                    new File(System.getProperty("user.dir")), 
+                    client.getConnection(), null, false);
+        
+    }
+    
+    /**
+     * Close the conection.
+     */
+    public void disconnect() {
+        
+        if(sshClient != null) sshClient.close();
+        
+        if(transport != null) transport.normalDisconnect(MSG_DISCONNECT);
+        
+        try {
+            serverSocket.close();
+        } catch(Exception ex) {
+            log.log(Level.WARNING,"error closing SSH socket",ex);
+        }
+    }
+
+    /*
+     * Method used when the given command needs to read something from the
+     * standard input. This works with the creation of a temporary file in
+     * the appliance that is then redirected to the given command.
+     * It was not possible to send data directly to the command because
+     * it would not be possible for the command to know when there is no more
+     * data to read. That happens because if we close the output stream, that
+     * would make the command receive an EOF, the entire connection is closed 
+     * and then it is not possible to read the output of the command. I don't
+     * know if this is something specific to Mindterm of if this is SSH regular
+     * behaviour.
+     */
+    public ExecResponse execute(String command, InputStream in, long timeout) throws TimeoutException, IOException {
+                
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        ByteArrayOutputStream berr = new ByteArrayOutputStream();
+        
+        int rc = -1;
+        String cmdPrefix = "";
+        String cmdSufix = "";
+        
+        if (in != null) {
+            String tmpFileName = createTempFileName();
+            cmdPrefix = "cat " + tmpFileName + " | ";
+            cmdSufix = " ; rm -f " + tmpFileName;
+            
+            sshClient.command("cat > " + tmpFileName, bout, berr);
+            
+            OutputStream out = sshClient.getStdIn();
+            byte buffer[] = new byte[512];
+            int n;
+            while ((n = in.read(buffer)) >= 0) {
+                out.write(buffer,0,n);
+            }
+            
+            out.flush();
+            out.close(); // send EOF
+            try {
+                rc = sshClient.waitForExitStatus(timeout);
+            } catch (com.mindbright.sshcommon.TimeoutException ex) {
+                throw new TimeoutException(ex.getMessage() + berr.toString(),ex);
+            }
+            if (rc != 0) {
+                throw new IOException("error creating temporary file " + tmpFileName + 
+                        " - " + berr.toString() + " - " + bout.toString());
+            }
+        }
+        
+        bout.reset();
+        berr.reset();
+        
+        sshClient.command(cmdPrefix + command + cmdSufix, bout, berr);
+        
+        rc = -1;
+        
+        try {
+            rc = sshClient.waitForExitStatus(timeout);
+        } catch (com.mindbright.sshcommon.TimeoutException ex) {
+            throw new TimeoutException(ex.getMessage(),ex);
+        }
+        
+        return new ExecResponse(bout.toByteArray(),berr.toByteArray(),rc);
+    }
+
+    /**
+     * Executes the given command waiting at most the given amount of time.
+     */
+    public ExecResponse execute(String command, long timeout) throws TimeoutException, IOException {
+        return execute(command,null,timeout);
+    }
+
+    /**
+     * Copy a file or files from the local machine to the remote machine.
+     */
+    public void sendFile(String localFile, String remoteFile, boolean recursive) 
+            throws IOException {
+        
+        if(sshClient == null) {
+            throw new NullPointerException("object not initialized properly");
+        }
+            
+        sshClient.scp1().copyToRemote(localFile, remoteFile, recursive);
+    }
+
+    /**
+     * Copy a file or files from the remote machine to the local machine.
+     */
+    public void receiveFile(String localFile, String remoteFile, boolean recursive) 
+            throws IOException {
+        
+        if(sshClient == null) {
+            throw new NullPointerException("object not initialized properly");
+        }
+        
+        sshClient.scp1().copyToLocal(localFile, remoteFile, recursive);
+    }
+    
+   /**
+     * Create a random number generator. This implementation uses the
+     * system random device if available to generate good random
+     * numbers. Otherwise it falls back to some low-entropy garbage.
+     */
+    private SecureRandomAndPad createSecureRandom() {
+   
+        byte[] seed;
+        File devRandom = new File("/dev/random");
+        if (devRandom.exists()) {
+            RandomSeed rs = new RandomSeed("/dev/random", "/dev/urandom");
+            seed = rs.getBytesBlocking(20);
+        } else {
+            seed = RandomSeed.getSystemStateHash();
+        }
+        return new SecureRandomAndPad(new SecureRandom(seed));
+    }
+
+    /**
+     * Create a temporary file name to be used when there is some data to be 
+     * sent to the command's standard input.
+     * The file name has a hash code of the current class loader, a timestamp
+     * and a counter to make sure it is unique.
+     */
+    synchronized private String createTempFileName() {
+        String name = "/tmp/tmp_" + classLoaderHashCode +
+                "_" + System.currentTimeMillis() + "_" + tmpCounter;
+        tmpCounter ++;
+        return name;
+    }
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/ssh/SSHSessionFactory.java mindterm_3.1.2/com/cyclades/util/ssh/SSHSessionFactory.java
--- mindterm_3.1.2.org/com/cyclades/util/ssh/SSHSessionFactory.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/ssh/SSHSessionFactory.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,32 @@
+/*
+ * SSHSessionFactory.java
+ *
+ * Created on 18 de Abril de 2006, 17:24
+ *
+ * To change this template, choose Tools | Template Manager
+ * and open the template in the editor.
+ */
+
+package com.cyclades.util.ssh;
+
+/**
+ *
+ * @author Constantino
+ */
+public class SSHSessionFactory {
+    
+    private static SSHSessionFactory instance = new SSHSessionFactory();
+    
+    /** Creates a new instance of SSHSessionFactory */
+    private SSHSessionFactory() {
+    }
+    
+    public static SSHSessionFactory getInstance() {
+        return instance;
+    }
+    
+    public SSHSession createSession(String hostname, String username, String password) 
+            throws Exception {
+        return new SSH2SessionImpl(hostname,username,password);
+    }
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/ssh/SSHSession.java mindterm_3.1.2/com/cyclades/util/ssh/SSHSession.java
--- mindterm_3.1.2.org/com/cyclades/util/ssh/SSHSession.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/ssh/SSHSession.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,67 @@
+/*
+ * SSHSession.java
+ *
+ * Created on April 13, 2006, 11:37 AM
+ *
+ * Copyright 2006, Avocent Corporation
+ */
+
+package com.cyclades.util.ssh;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Class used to issue SSH and SCP commands.
+ * @author Constantino
+ */
+public interface SSHSession {
+
+    /**
+     * Default SSH port;
+     */
+    static int SSH_PORT = 22;
+    
+    /**
+     * String sent when the transport is disconnected.
+     */
+    static String MSG_DISCONNECT = "Disconnected by user";
+    
+    /**
+     * Close the conection.
+     */
+    public void disconnect();
+    
+    /**
+     * Executes the given command waiting at most for the given amount of time.
+     */
+    public ExecResponse execute(String command, long timeout) 
+        throws TimeoutException, IOException;
+    
+    /*
+     * Method used when the given command needs to read something from the
+     * standard input. This works with the creation of a temporary file in
+     * the appliance that is then redirected to the given command.
+     * It was not possible to send data directly to the command because
+     * it would not be possible for the command to know when there is no more
+     * data to read. That happens because if we close the output stream, that
+     * would make the command receive an EOF, the entire connection is closed 
+     * and then it is not possible to read the output of the command. I don't
+     * know if this is something specific to Mindterm of if this is SSH regular
+     * behaviour.
+     */
+    public ExecResponse execute(String command, InputStream in, long timeout)
+        throws TimeoutException, IOException;
+    
+    /**
+     * Copy a file or files from the local machine to the remote machine.
+     */
+    public void sendFile(String localFile, String remoteFile, boolean recursive) 
+        throws IOException;
+    
+    /**
+     * Copy a file or files from the remote machine to the local machine.
+     */
+    public void receiveFile(String localFile, String remoteFile, boolean recursive) 
+        throws IOException;
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/ssh/TimeoutException.java mindterm_3.1.2/com/cyclades/util/ssh/TimeoutException.java
--- mindterm_3.1.2.org/com/cyclades/util/ssh/TimeoutException.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/ssh/TimeoutException.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,22 @@
+/*
+ * TimeoutException.java
+ *
+ * Created on April 3, 2006, 11:43 AM
+ *
+ * To change this template, choose Tools | Template Manager
+ * and open the template in the editor.
+ */
+
+package com.cyclades.util.ssh;
+
+/**
+ * Exception thrown when a command does not finish in the given period of time.
+ * @author Constantino
+ */
+public class TimeoutException extends Exception {
+    
+    /** Creates a new instance of TimeoutException */
+    public TimeoutException(String message, Throwable cause) {
+        super(message,cause);
+    }
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/StringUtil.java mindterm_3.1.2/com/cyclades/util/StringUtil.java
--- mindterm_3.1.2.org/com/cyclades/util/StringUtil.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/StringUtil.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,18 @@
+package com.cyclades.util;
+
+public class StringUtil {
+
+	private static String replaceStr(int idx0, String s, String olds, String news) {
+		if (idx0==-1) return s;
+			
+		if (idx0>=0) 
+			s = s.substring(0, idx0)+ news + s.substring(idx0+olds.length());
+			
+		return replaceStr(s.indexOf(olds), s, olds,news);
+	}
+	
+	public static String replaceAll(String s, String olds, String news) {
+		return replaceStr(s.indexOf(olds), s, olds,news);
+	}
+	
+}
diff -ruN mindterm_3.1.2.org/com/cyclades/util/Utils.java mindterm_3.1.2/com/cyclades/util/Utils.java
--- mindterm_3.1.2.org/com/cyclades/util/Utils.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/cyclades/util/Utils.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,231 @@
+package com.cyclades.util;
+
+import java.io.*;
+import java.lang.*;
+import java.util.*;
+
+import java.security.*;
+import java.security.spec.*;
+import java.security.interfaces.*;
+import javax.crypto.*;
+import javax.crypto.spec.*;
+import javax.crypto.interfaces.*;
+import com.sun.crypto.provider.SunJCE;
+import java.math.BigInteger;
+import java.lang.Character;
+
+
+
+
+/**
+ * utils for apm
+ */
+public class Utils {
+    public static boolean DEBUG = false;       
+    /** This array is used to convert from bytes to hexadecimal numbers */
+    static final char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7',
+                                        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
+    /**
+     * Encyrpts str (an array of strings) using key supplied. Uses some predfined salt
+     * and an MD5 digest and DES encryption
+     */
+    public static String encrypt(String[] str, String key) {
+        try {
+            PBEKeySpec pbeKeySpec;
+            PBEParameterSpec pbeParamSpec;
+            SecretKeyFactory keyFac;
+            
+            // Salt
+            byte[] salt = {
+                (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,
+                (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99
+            };
+            
+            // Iteration count
+            int count = 20;
+            //sessionId = "abc4592";
+            
+            // Create PBE parameter set
+            pbeParamSpec = new PBEParameterSpec(salt, count);
+            char[] sa = new char[key.length()];
+            key.getChars(0, key.length(), sa, 0);
+            pbeKeySpec = new PBEKeySpec(sa);
+            keyFac = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
+            SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);
+            
+            // Create PBE Cipher
+            Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES");
+            
+            // Initialize PBE Cipher with key and parameters
+            pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);
+            
+            // Our cleartext
+            String cleartextStr = "";
+            for (int i = 0; i < str.length; i++) {
+                cleartextStr = cleartextStr + str[i] + ";";
+            }
+            
+            byte[] cleartext = cleartextStr.getBytes();
+            if (DEBUG) {
+                System.out.println("v5. unencrpyted text = >" + cleartextStr + "<");
+            }
+            // Encrypt the cleartext
+            byte[] ciphertext = pbeCipher.doFinal(cleartext);
+            String ciphertextStr = new String(Utils.hexEncode(ciphertext));
+            //String ciphertextStr = new String(ciphertext, "ISO-8859-1");
+            if (DEBUG) {
+                System.out.println("v5. encrypted text = >" + ciphertextStr + "<");
+                System.out.println("length = " + ciphertextStr.length());
+            }
+            
+            return ciphertextStr;
+            
+        } catch (Exception e) {
+            System.out.println("exception= " + e);
+        }
+        
+        return null;
+    }
+    
+    public static String[] decrypt(String ciphertextStr, String key) {
+        try {
+            byte[] ciphertext = ciphertextStr.getBytes();
+            
+            PBEKeySpec pbeKeySpec;
+            PBEParameterSpec pbeParamSpec;
+            SecretKeyFactory keyFac;
+            
+            // Salt
+            byte[] salt = {
+                (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,
+                (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99
+            };
+            
+            // Iteration count
+            int count = 20;
+            //sessionId = "abc4592";
+            
+            // Create PBE parameter set
+            pbeParamSpec = new PBEParameterSpec(salt, count);
+            char[] sa = new char[key.length()];
+            key.getChars(0, key.length(), sa, 0);
+            pbeKeySpec = new PBEKeySpec(sa);
+            keyFac = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
+            SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);
+            
+            // Create PBE Cipher
+            Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES");
+            
+            // Initialize PBE Cipher with key and parameters
+            pbeCipher.init(Cipher.DECRYPT_MODE, pbeKey, pbeParamSpec);
+            if (DEBUG) {
+                System.out.println("v5. decrypting= >" + ciphertextStr + "<");
+                System.out.println("v5. length = " + ciphertextStr.length());
+            }
+            byte[] ciphertextDecrypt = pbeCipher.doFinal(Utils.hexDecode(ciphertextStr));
+            //byte[] ciphertextDecrypt = pbeCipher.doFinal(ciphertextStr.getBytes("ISO-8859-1"));
+            String decrpytedStr = new String(ciphertextDecrypt);
+            if (DEBUG) {
+                System.out.println("v5. decrpyted text= >" + decrpytedStr + "<");
+            }
+            //split it up
+            StringTokenizer st = new StringTokenizer(decrpytedStr, ";");
+            Vector v = new Vector();
+            while (st.hasMoreElements()) {
+                v.addElement((String) st.nextElement());
+            }
+            String[] res = new String[v.size()];
+            v.copyInto(res);
+            return res;
+            
+        } catch (Exception e) {
+            System.out.println("exception= " + e);
+        }
+        
+        return null;
+    }
+
+    public static String hexEncode(byte[] bytes) {
+        StringBuffer s = new StringBuffer(bytes.length * 2);
+        for (int i = 0; i < bytes.length; i++) {
+            byte b = bytes[i];
+            s.append(digits[(b & 0xf0) >> 4]);
+            s.append(digits[b & 0x0f]);
+        }
+        return s.toString();
+    }
+
+    /**
+     * A convenience method to convert in the other direction, from a string
+     * of hexadecimal digits to an array of bytes.
+     **/
+    public static byte[] hexDecode(String s) throws IllegalArgumentException {
+        try {
+            int len = s.length();
+            byte[] r = new byte[len/2];
+            for (int i = 0; i < r.length; i++) {
+                int digit1 = s.charAt(i*2);
+                int digit2 = s.charAt(i*2 + 1);
+                if ((digit1 >= '0') && (digit1 <= '9')) {
+                    digit1 -= '0';
+                } else if ((digit1 >= 'a') && (digit1 <= 'f')) {
+                    digit1 -= 'a' - 10;
+                }
+                if ((digit2 >= '0') && (digit2 <= '9')) {
+                    digit2 -= '0'; 
+                } else if ((digit2 >= 'a') && (digit2 <= 'f')) digit2 -= 'a' - 10;
+                    r[i] = (byte)((digit1 << 4) + digit2);
+                }
+                return r;
+        } catch (Exception e) {
+            throw new IllegalArgumentException("hexDecode(): invalid input");
+        }
+    }
+
+    public static String myDecrypt(String key, String text, boolean def) {
+        try {
+            String enMask;
+            short nChar;
+            char   enChar;
+            int    numChars = 0, minLen,numMask=0;
+            String textString = "";
+
+            
+            if (def) {
+               key = "ioHrEw(L#yZfjsfSdfHfSgGjMjq;Ss;d)(*&^#@$avsig";
+            }
+            //minLen = Math.min(text.length(), key.length());
+            minLen = text.length();
+            enMask = key;
+
+				//System.out.println("Key: " + key);
+				//System.out.println("Text: " + text);
+            
+            while (numChars < minLen) { 
+               nChar = (short)((short)text.charAt(numChars) ^ (short)enMask.charAt(numMask));
+               //System.out.println("nChar: " + nChar);
+               enChar = (char)nChar;
+					//enChar = Character.forDigit(nChar, 10);
+               //System.out.println("enChar: [" + enChar + "]");
+               
+               textString += enChar;
+		if (++numMask == key.length()) {
+			numMask=0;
+		}
+               numChars++;
+           
+            }
+            
+            return (textString);
+                     
+        } catch (Exception e) {
+            System.out.println("exception= " + e);
+        }
+        
+        return null;
+    }	
+    
+}
+
+
diff -ruN mindterm_3.1.2.org/com/mindbright/application/CustomJTextField.java mindterm_3.1.2/com/mindbright/application/CustomJTextField.java
--- mindterm_3.1.2.org/com/mindbright/application/CustomJTextField.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/application/CustomJTextField.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,52 @@
+package com.mindbright.application;
+
+import java.awt.event.KeyEvent;
+import javax.swing.JTextField;
+
+/**
+ *
+ * @author ivan.gardino
+ */
+public class CustomJTextField extends JTextField {
+
+    private CustomJTextField next;
+    
+    private boolean isProcesses = true;
+    
+    public CustomJTextField(){
+        super();
+    }
+
+    protected void processKeyEvent(KeyEvent ke){
+        if( ke.getKeyCode() == KeyEvent.VK_ENTER){
+            if(next != null){
+                if(!next.isProcesses()){
+                    next.grabFocus();
+                    next.setIsProcesses(true);
+                    return;
+                }else{
+                    next.setIsProcesses(false);
+                }
+            }
+        }
+
+        super.processKeyEvent(ke);
+    }
+    
+    
+    public CustomJTextField getNext() {
+        return next;
+    }
+
+    public void setNext(CustomJTextField next) {
+        this.next = next;
+    }
+
+    public boolean isProcesses() {
+        return isProcesses;
+    }
+
+    public void setIsProcesses(boolean isProcesses) {
+        this.isProcesses = isProcesses;
+    }
+}
\ No newline at end of file
diff -ruN mindterm_3.1.2.org/com/mindbright/application/MindTermApp.java mindterm_3.1.2/com/mindbright/application/MindTermApp.java
--- mindterm_3.1.2.org/com/mindbright/application/MindTermApp.java	2005-09-06 06:00:48.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/application/MindTermApp.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,7 @@
 
 package com.mindbright.application;
 
+import java.applet.Applet;
 import java.util.Properties;
 import java.applet.AppletContext;
 import java.awt.Frame;
@@ -44,6 +45,7 @@
 
     public boolean isApplet();
     public AppletContext getAppletContext();
+    public Applet getApplet();
 
     public SSH2Transport    getTransport();
     public SSH2Connection   getConnection();
diff -ruN mindterm_3.1.2.org/com/mindbright/application/MindTerm.java mindterm_3.1.2/com/mindbright/application/MindTerm.java
--- mindterm_3.1.2.org/com/mindbright/application/MindTerm.java	2007-01-21 09:50:06.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/application/MindTerm.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,7 @@
 
 package com.mindbright.application;
 
+import java.awt.event.FocusEvent;
 import java.io.*;
 
 import java.applet.Applet;
@@ -25,22 +26,49 @@
 import java.awt.Component;
 import java.awt.Container;
 import java.awt.Frame;
-
+import java.awt.Button;
+import java.awt.Panel;
+import java.awt.event.ActionListener;
+import java.awt.event.ActionEvent;
 import java.awt.event.WindowEvent;
 import java.awt.event.WindowListener;
-
-import java.util.Properties;
-import java.util.Hashtable;
+import javax.swing.JButton;
+import javax.swing.JFrame;
+import java.net.URLDecoder;
 import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Properties;
+import java.util.StringTokenizer;
+import java.net.URL;
+
+import com.cyclades.application.CycladesTerm;
+import com.cyclades.util.Formatter;
+import com.cyclades.util.CYProps;
 
 import com.mindbright.gui.AWTConvenience;
+import com.mindbright.gui.AlertDialog;
+import com.mindbright.gui.GUI;
 
 import com.mindbright.ssh.*;
 import com.mindbright.sshcommon.*;
 import com.mindbright.terminal.*;
+import java.awt.event.FocusListener;
+import javax.swing.JLabel;
 
 public class MindTerm extends Applet implements Runnable, WindowListener {
 
+	// [CYCLADES-START]
+	/**
+	 * Container of the Swing/AWT main component.
+	 * Added by Eduardo Murai Soares 
+	 */
+	private Container appContainer;	
+	
+	private boolean mainWindow = true;
+	
+	private Properties cycladesProps = new Properties(); 
+    // [CYCLADES-END]
+	
     static Properties paramTermProps = new Properties();
     static Properties paramSSHProps  = new Properties();
 
@@ -61,7 +89,10 @@
     Properties sshProps;
     Properties termProps;
 
-    String[]   cmdLineArgs;
+	// [CYCLADES-START]
+    public 
+    //  [CYCLADES-END]
+    	String[]   cmdLineArgs;
 
     String  commandLine = null;
     String  sshHomeDir  = null;
@@ -87,11 +118,30 @@
     int     popButtonNum = 3;
 
     boolean isClosing  = false;
+    boolean closed     = false;
 
     // !!!
     boolean        separateFrame = true;
     public boolean weAreAnApplet = false;
     boolean        useAWT = false;
+    
+    //Text fields used for getting information to send to the server
+    CustomJTextField jTextField1 = new CustomJTextField();
+    CustomJTextField jTextField2 = new CustomJTextField();
+    CustomJTextField jTextField3 = new CustomJTextField();
+    CustomJTextField jTextField4 = new CustomJTextField();
+    CustomJTextField jTextField5 = new CustomJTextField();
+    CustomJTextField jTextField6 = new CustomJTextField();
+    CustomJTextField jTextField7 = new CustomJTextField();
+    CustomJTextField jTextField8 = new CustomJTextField();
+    CustomJTextField jTextField9 = new CustomJTextField();
+    CustomJTextField jTextField10 = new CustomJTextField();
+    CustomJTextField jTextField11 = new CustomJTextField();        
+    CustomJTextField jTextField12 = new CustomJTextField();
+    CustomJTextField jTextField13 = new CustomJTextField();
+    CustomJTextField jTextField14 = new CustomJTextField();
+    CustomJTextField jTextField15 = new CustomJTextField();
+    CustomJTextField jTextField16 = new CustomJTextField();
 
     static Hashtable terminals = new Hashtable();
 
@@ -153,7 +203,7 @@
         try {
             if(sshClone != null) {
                 if(!sshClone.isSSH2) {
-                    client = new SSHInteractiveClient(sshClone);
+                    client = new SSHInteractiveClient(sshClone, this);
                     sshClone = null;
                 } else {
                     client = null;
@@ -171,6 +221,10 @@
 
                 SSHPropertyHandler propsHandler =
                     new SSHPropertyHandler(sshProps, true);
+					
+				// [CYCLADES-START] 
+                propsHandler.mergeAPMProperties(cycladesProps);                                
+                // [CYCLADES-END]					
 
                 if(propsFile != null) {
                     try {
@@ -184,7 +238,7 @@
                 }
 
                 client = new SSHInteractiveClient(quiet, exitOnLogout,
-                                                  propsHandler);
+                                                  propsHandler, this);
             }
 
             SSHPropertyHandler props = client.getPropertyHandler();
@@ -225,7 +279,10 @@
             // First we initialize the GUI if we have one (to be able to set
             // properties to terminal
             //
-            if(haveGUI) {
+            
+            String proto = getParameter("proto");
+            
+            if(haveGUI&&proto.equals("89")) {
                 initGUI();
                 console.setTerminal(term);
                 console.setOwnerContainer(frame);
@@ -285,7 +342,7 @@
                         scp.scp1().copyToLocal(target, source, recursiveSCP);
                     }
                 }
-            } else {
+            } else if(proto.equals("89")) {
                 try {
                     clientThread = new Thread(client, "MindTerm");
                     clientThread.start();
@@ -293,6 +350,28 @@
                 } catch(InterruptedException e) {
                     // !!!
                 }
+            } else {
+            	Properties telnetProps = new Properties();
+                String name, value;
+                Enumeration e = termProps.keys();
+                while(e.hasMoreElements()) {
+                    name  = (String)e.nextElement();
+                    value = termProps.getProperty(name);
+                    if(value != null) {
+                        telnetProps.put(name, value);
+                    }
+                }
+            	telnetProps.put("username", props.getProperty("username"));
+            	telnetProps.put("password", props.getProperty("password"));
+            	telnetProps.put(CYProps.PHYS_PORT_AUTH, props.getProperty(CYProps.PHYS_PORT_AUTH));
+            	telnetProps.put("typed-input", proto.equals("86")? "raw" : "buffered");
+            	
+                ModuleTelnetImpl telnet = new ModuleTelnetImpl(telnetProps);
+                telnet.activate(client);
+                client.forcedDisconnect();
+                telnetProps = null;
+                termProps= null;
+                close();
             }
 
         } catch (IllegalArgumentException ae) {
@@ -324,6 +403,16 @@
         String    param;
         int       i;
 
+        // [CYCLADES-START]
+        String cvalue="";
+        try {        
+        cvalue = getParametersFromBaseClass("app");
+        if (cvalue!=null) parseCycladesParams(cvalue);
+        } catch (Exception e) {
+        	System.out.println("Error while parsing parameters sent by APM : "+cvalue+":");
+        	e.printStackTrace();
+        }
+        // [CYCLADES-END]
         try {
             useAWT = (new Boolean(getParameter("useAWT"))).booleanValue();
         } catch (Exception e) {
@@ -454,6 +543,10 @@
         // ssh/terminal-properties)
         //
         try {
+        	// [CYCLADES-START]
+        	if (cmdLineArgs==null) return;
+        	// [CYCLADES-END]
+        	
             for(i = 0; i < cmdLineArgs.length; i++) {
                 String arg = cmdLineArgs[i];
                 if(!arg.startsWith("--"))
@@ -550,6 +643,13 @@
                     printHelp();
                     System.exit(0);
                 default:
+				// [CYCLADES-START]              
+                	// --app receives application parameters in form <paramName>=<paramValue>&
+                	// sample: -app parma=xxx&parmb=yyy
+                    if ("--app".equals(arg.trim())) 
+                    	parseCycladesParams(cmdLineArgs[++i]);
+                    	                    
+                    else // [CYCLADES-END]
                     throw new Exception("unknown parameter '" + arg + "'");
                 }
             }
@@ -683,6 +783,11 @@
             useSwing = false;
         }
 
+		// [CYCLADES-START] 
+        // appContainer added by Eduardo Murai Soares
+        this.appContainer = container; 
+        // [CYCLADES-END]
+
         term = new TerminalWin(frame, termProps, (sshClone == null));
         if (separateFrame) {
             term.setIgnoreClose();
@@ -690,7 +795,35 @@
 
         if(mergedTermProps)
             term.setPropsChanged(true);
+		
+        // [CYCLADES-START]
+        // Panel setup moved here by Eduardo Murai Soares
+        // This action was necessary because menus.setupMenuBar will add MenuBar to 
+        // the main panel in case of Swing API
+        AWTConvenience.getContentPane(container).setLayout(new BorderLayout());
+        AWTConvenience.getContentPane(container).add(term.getPanelWithScrollbar(), BorderLayout.CENTER);
+        
+        Panel  p = new Panel();
+        
+        if("enable".equals(getParameter("ems").toUpperCase()))
+            term.setProperty("backspace-send", "bs", true);
+            
+        boolean specialKey = false;
+        try{
+            specialKey = "UTF-8".equals(getParameter("encoding"));
+        }catch (Exception e){
+            specialKey = false;
+        }
+        
+        //[CYCLADES-START]
+        term.setSpecialKeysUTF8(specialKey);
+        addButtons(p, createActionListener(), "enable".equals(getParameter("ems")));
+        //[CYCLADES-END]
+        
+        AWTConvenience.getContentPane(container).add(p, BorderLayout.SOUTH);
 
+        // [CYCLADES-END]
+        		
         if(haveMenus) {
             SSHMenuHandler      menus;
             TerminalMenuHandler tmenus;
@@ -701,7 +834,11 @@
                 tmenus.setTerminalWin(term);
                 term.setMenus(tmenus);
                 client.setMenus(menus);
-                menus.setupMenuBar(usePopMenu);
+                menus.setupMenuBar(usePopMenu
+					// [CYCLADES-START]	
+                	,isAppletMode()
+                	// [CYCLADES-STOP]
+					);
                 tmenus.setTerminalMenuListener(menus);
                 term.setClipboard(GlobalClipboard.getClipboardHandler(tmenus));
             } catch (Throwable t) {
@@ -717,30 +854,38 @@
         }
 
         term.addAsEntropyGenerator(client.randomSeed());
-        
-        AWTConvenience.getContentPane(container).setLayout(new BorderLayout());
-        AWTConvenience.getContentPane(container).add
-            (term.getPanelWithScrollbar(), BorderLayout.CENTER);
 
+		// [CYCLADES-START]
+        // lines comented because they were moved to be before "if (haveMenus)"        
+        // AWTConvenience.getContentPane(container).setLayout(new BorderLayout());
+        // AWTConvenience.getContentPane(container).add(term.getPanelWithScrollbar(), BorderLayout.CENTER);
+		// [CYCLADES-END]        
+        
         frame.pack();
         frame.setVisible(true);
-
+        AWTConvenience.getContentPane(container).setVisible(true);
+        p.setVisible(true);
+        p.repaint();
         term.requestFocus();
     }
 
     public void doExit() {
-        System.out.println("Thank you for using MindTerm...");
+        
         if(!separateFrame && term != null) {
-            term.clearScreen();
-            term.setAttributeBold(true);
-            term.write("Thank you for using MindTerm...");
+        	// [CYCLADES-START] : clear screen commented
+            // term.clearScreen();
+             
+            
+            //term.setAttributeBold(true);
+            //term.write("Thank you for using MindTerm...");
+            // [CYCLADES-END]
         }
         if(!weAreAnApplet) {
             System.exit(0);
         }
     }
 
-    boolean confirmedClose = false;
+    boolean confirmedClose = true;
     public boolean confirmClose() {
         if(client != null && !confirmedClose) {
             try {
@@ -761,7 +906,10 @@
         return confirmedClose;
     }
 
-    void initParams(MindTerm mindterm) {
+    // [CYCLADES-START]
+    public
+    //  [CYCLADES-END]
+    	void initParams(MindTerm mindterm) {
         this.sshHomeDir     = mindterm.sshHomeDir;
         this.propsFile      = mindterm.propsFile;
         this.usePopMenu     = mindterm.usePopMenu;
@@ -779,12 +927,22 @@
         MindTerm mindterm = new MindTerm(this.sshProps, this.termProps);
         mindterm.initParams(this);
         mindterm.sshClone = this.client;
+        //  [CYCLADES-START]
+        //  new window is child of the main window
+        mindterm.setMainWindow(false);
+        // [CYCLADES-END]        
         (new Thread(mindterm, "MindTerm.clone")).start();
     }
 
     public void newWindow() {
         MindTerm mindterm = new MindTerm(paramSSHProps, paramTermProps);
         mindterm.initParams(this);
+        
+        //  [CYCLADES-START]
+        //  new window is child of the main window
+        mindterm.setMainWindow(false);
+        // [CYCLADES-END]
+        
         (new Thread(mindterm, "MindTerm.window")).start();
     }
 
@@ -795,20 +953,45 @@
             if(mt.client != null && mt.client.isSSH2) {
                 mt.client.transport.normalDisconnect("User exited");
             }
+            
+            // [CYCLADES-START]
+            checkAppletWindow(mt);
+            // [CYCLADES-END]
+            
             if(mt.clientThread != null) {
                 mt.clientThread.stop();
             }
         }
     }
 
+    
+    //  [CYCLADES-START]
+    public void checkAppletWindow(MindTerm term) { }
+    //  [CYCLADES-END]  
+    
     public void close() {
         if(!confirmClose())
             return;
+        
+        // [CYCLADES-START]
+        if (client!=null)
+        // [CYCLADES-END]        
+        
         if(client.isSSH2) {
             client.transport.normalDisconnect("User closed connection");
         }
+        
+        // [CYCLADES-START]
+        checkAppletWindow(this);
+        //  [CYCLADES-END]
+        
         if(clientThread != null)
             clientThread.stop();
+        
+        if(separateFrame && haveGUI && frame != null) {
+            frame.dispose();
+        }
+
     }
 
     public void exit() {
@@ -827,20 +1010,594 @@
             return;
         }
 
+        // [CYCLADES-START]: close the current connection
+        close();
+        // [CYCLADES-STOP]
+        
         if(separateFrame && haveGUI && frame != null) {
             frame.dispose();
         }
 
-        if(clientThread != null && clientThread.isAlive())
-            clientThread.stop();
+        // [CYCLADES-START]: task done inside the close method
+        //if(clientThread != null && clientThread.isAlive())
+        //   clientThread.stop();
+        // [CYCLADES-STOP]
+        
+        removeTerminal(this);        
+    }
 
-        removeTerminal(this);
+    public void windowDeiconified(WindowEvent e) {
+        term.requestFocus();
     }
 
-    public void windowDeiconified(WindowEvent e) {}
     public void windowOpened(WindowEvent e) {}
     public void windowClosed(WindowEvent e) {}
     public void windowIconified(WindowEvent e) {}
     public void windowActivated(WindowEvent e) {}
     public void windowDeactivated(WindowEvent e) {}
+	
+	 // [CYCLADES-START]
+    class StateTO {    	
+    	public StateTO(MindTerm parent) {
+    		sshHomeDir     = parent.sshHomeDir;
+            propsFile      = parent.propsFile;
+            usePopMenu     = parent.usePopMenu;
+            haveMenus      = parent.haveMenus;
+            haveGUI        = parent.haveGUI;
+            exitOnLogout   = parent.exitOnLogout;
+            quiet          = parent.quiet;
+            separateFrame  = true;
+            weAreAnApplet  = parent.weAreAnApplet;
+            autoLoadProps  = parent.autoLoadProps;
+            popButtonNum   = parent.popButtonNum;    		
+    		}
+    	
+        public String sshHomeDir;
+        public String propsFile;
+        public boolean usePopMenu;
+        public boolean haveMenus;
+        public boolean haveGUI;
+        public boolean exitOnLogout;
+        public boolean quiet;
+        public boolean separateFrame;
+        public boolean weAreAnApplet;
+        public boolean autoLoadProps;
+        public int popButtonNum;    	
+    }
+    
+    public void initParams(StateTO src) {
+        this.sshHomeDir     = src.sshHomeDir;
+        this.propsFile      = src.propsFile;
+        this.usePopMenu     = src.usePopMenu;
+        this.haveMenus      = src.haveMenus;
+        this.haveGUI        = src.haveGUI;
+        this.exitOnLogout   = src.exitOnLogout;
+        this.quiet          = src.quiet;
+        this.separateFrame  = src.separateFrame;
+        this.weAreAnApplet  = src.weAreAnApplet;
+        this.autoLoadProps  = src.autoLoadProps;
+        this.popButtonNum   = src.popButtonNum;
+    }
+    
+	// ------------------------------------------------------------------------------
+    // the reason of these methods is to export some attributes
+    // necessary for custom codes done by Cyclades' staff
+    /**
+     * Export SSH properties. 
+     * @return Properties
+     * @author Eduardo Murai Soares
+     */
+	public static Properties getParamSSHProps() {
+		return paramSSHProps;
+	}
+
+    /**
+     * Export Terminal properties. 
+     * @return Properties
+     * @author Eduardo Murai Soares
+     */
+	public static Properties getParamTermProps() {
+		return paramTermProps;
+	}
+	
+	/**
+	 * @return Frame which holds this applet
+	 * @author Eduardo Murai Soares
+	 */
+	public Frame getFrame() {
+		return frame;
+	}
+
+	/**
+	 * @return Container which holds Swing/AWT main  panel/component
+	 * @author Eduardo Murai Soares
+	 */
+	public Container getAppContainer() {
+		return appContainer;
+	}
+	
+	/**
+	 * @return True if user confirmed close 
+	 * @author Eduardo Murai Soares
+	 */
+	public boolean getConfirmedClose() {
+		return this.confirmedClose;
+	}
+	
+	public void setConfirmedClose(boolean v) {
+		this.confirmedClose = v;
+	}
+	
+	public SSHInteractiveClient getClient() {
+		return client;	
+	}
+	
+	public boolean isAppletMode() {
+		return weAreAnApplet;
+	}
+	
+	public boolean isClosed() {
+		return closed;
+	}
+	
+	public void setClosedFlag() {
+		closed = true;
+	}
+	
+	public void setSshHomeDir(String path) {
+		this.sshHomeDir = path;
+	}
+	
+	public void setupClone(SSHInteractiveClient client) {
+		this.sshClone = client;
+	}	
+
+	public Properties getSshProps() {
+		return sshProps;
+	}
+
+	public Properties getTermProps() {
+		return termProps;
+	}
+	
+	public TerminalWindow getTerm() {
+		return term;
+	}	
+	
+	public boolean isMainWindow() {
+		return mainWindow;
+	}
+
+	public void setMainWindow(boolean mainWindow) {
+		this.mainWindow = mainWindow;
+	}
+	
+	/**
+	 * Save mindterm preferences into APM.
+	 * 
+	 * @see CycladesTerm.savePreferences
+	 */
+	public void savePreferences(Properties propsToSave) { }
+
+	/**
+	 * Parse parameters sent by APM and merge them into Mindterm. 
+	 * 
+	 * @param rawParams
+	 * @throws UnsupportedEncodingException
+	 */
+    private void parseCycladesParams(String rawParams) throws UnsupportedEncodingException {
+    	Formatter.parseCycladesParams(rawParams, new Properties[] {paramSSHProps, cycladesProps});
+    }
+	
+    public String getParametersFromBaseClass(String pname) {
+    	return super.getParameter(pname);
+    }       
+    //  [CYCLADES-END]0
+    
+    private void addButtons(Panel p, ActionListener al, boolean isEMS){
+        
+        if (!isEMS){
+            JButton b1 = new JButton("Send Break");
+            JButton b2 = new JButton("Disconnect");
+            
+            b1.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+            b2.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+
+            b1.addActionListener(al);
+            b2.addActionListener(al);
+            
+            p.add(b1, BorderLayout.WEST); p.add(b2, BorderLayout.EAST);
+            return;
+        }
+        JLabel jLabel1 = new JLabel();
+        JLabel jLabel2 = new JLabel();
+        JLabel jLabel3 = new JLabel();
+        JLabel jLabel4 = new JLabel();
+        JLabel jLabel5 = new JLabel();        
+        JButton jButton1 = new JButton();
+        JButton jButton2 = new JButton();
+        JButton jButton3 = new JButton();
+        JButton jButton4 = new JButton();
+        JButton jButton5 = new JButton();
+        JButton jButton6 = new JButton();
+        JButton jButton7 = new JButton();
+        JButton jButton8 = new JButton();
+        JButton jButton9 = new JButton();
+        JButton jButton10 = new JButton();
+        JButton jButton11 = new JButton();
+        JButton jButton12 = new JButton();
+        JButton jButton13 = new JButton();
+        JButton jButton14 = new JButton();
+        JButton jButton15 = new JButton();
+        JButton jButton16 = new JButton();
+        JButton jButton17 = new JButton();
+        JButton jButton18 = new JButton();
+        JButton jButton19 = new JButton();
+        JButton jButton20 = new JButton();
+        JButton jButton21 = new JButton();
+        JButton jButton22 = new JButton();
+        
+        p.setSize(this.getWidth(), 285);
+        p.setLayout(null);
+
+        this.setSize(this.getWidth(), this.getHeight() + 285);
+        
+        jLabel1.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jLabel1.setText("System Information:");
+        p.add(jLabel1);
+        jLabel1.setBounds(0, 0, 130, 15);
+
+        jButton1.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton1.setText("Server");
+        p.add(jButton1);
+        jButton1.setBounds(0, 20, 140, 20);
+
+        jButton2.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton2.setText("getTimeDate");
+        p.add(jButton2);
+        jButton2.setBounds(140, 20, 140, 20);
+
+        jButton3.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton3.setText("IP");
+        p.add(jButton3);
+        jButton3.setBounds(280, 20, 130, 20);
+
+        jButton4.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton4.setText("KernelLog");
+        p.add(jButton4);
+        jButton4.setBounds(410, 20, 170, 20);
+
+        jLabel2.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jLabel2.setText("System Settings:");
+        p.add(jLabel2);
+        jLabel2.setBounds(0, 50, 130, 15);
+
+        jButton5.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton5.setText("TimeDate");
+        p.add(jButton5);
+        jButton5.setBounds(0, 70, 130, 20);
+
+        jButton6.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton6.setText("IPInfo");
+        p.add(jButton6);
+        jButton6.setBounds(0, 90, 130, 20);
+
+        jTextField1.setText("#");
+        p.add(jTextField1);
+        jTextField1.setBounds(370, 140, 60, 20);
+
+        jTextField2.setText("dd");
+        p.add(jTextField2);
+        jTextField2.setBounds(230, 70, 80, 20);
+        jTextField2.setNext(jTextField3);
+
+        jTextField10.setText("mm");
+        p.add(jTextField10);
+        jTextField10.setBounds(140, 70, 80, 20);
+        jTextField10.setNext(jTextField2);
+        
+        jTextField3.setText("yyyy");
+        p.add(jTextField3);
+        jTextField3.setBounds(320, 70, 80, 20);
+        jTextField3.setNext(jTextField4);
+
+        jTextField4.setText("hh");
+        p.add(jTextField4);
+        jTextField4.setBounds(410, 70, 80, 20);
+        jTextField4.setNext(jTextField5);
+
+        jTextField5.setText("mm");
+        p.add(jTextField5);
+        jTextField5.setBounds(500, 70, 80, 20);
+        jTextField5.setNext(jTextField6);
+
+        jTextField6.setText("interface#");
+        p.add(jTextField6);
+        jTextField6.setBounds(140, 90, 80, 20);
+        jTextField6.setNext(jTextField7);
+
+        jTextField7.setText("ip");
+        p.add(jTextField7);
+        jTextField7.setBounds(230, 90, 80, 20);
+        jTextField7.setNext(jTextField8);
+
+        jTextField8.setText("subnet");
+        p.add(jTextField8);
+        jTextField8.setBounds(320, 90, 80, 20);
+        jTextField8.setNext(jTextField9);
+
+        jTextField9.setText("gateway");
+        p.add(jTextField9);
+        jTextField9.setBounds(410, 90, 170, 20);
+
+        jLabel3.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jLabel3.setText("Channels:");
+        p.add(jLabel3);
+        jLabel3.setBounds(0, 120, 130, 15);
+
+        jButton7.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton7.setText("ChannelList");
+        p.add(jButton7);
+        jButton7.setBounds(0, 140, 100, 20);
+
+        jButton8.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton8.setText("Create");
+        p.add(jButton8);
+        jButton8.setBounds(100, 140, 90, 20);
+
+        jButton9.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton9.setText("Lock");
+        p.add(jButton9);
+        jButton9.setBounds(190, 140, 90, 20);
+
+        jButton10.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton10.setText("Close");
+        p.add(jButton10);
+        jButton10.setBounds(440, 140, 70, 20);
+
+        jButton11.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton11.setText("Switch");
+        p.add(jButton11);
+        jButton11.setBounds(290, 140, 80, 20);
+
+        jTextField11.setText("#");
+        p.add(jTextField11);
+        jTextField11.setBounds(510, 140, 70, 20);
+
+        jLabel4.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jLabel4.setText("Tasks:");
+        p.add(jLabel4);
+        jLabel4.setBounds(0, 170, 130, 15);
+
+        jButton12.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton12.setText("TaskList");
+        p.add(jButton12);
+        jButton12.setBounds(0, 190, 110, 20);
+
+        jButton13.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton13.setText("DetailOnOff");
+        p.add(jButton13);
+        jButton13.setBounds(110, 190, 130, 20);
+
+        jButton14.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton14.setText("PageOnOff");
+        p.add(jButton14);
+        jButton14.setBounds(240, 190, 120, 20);
+
+        jButton15.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton15.setText("Kill");
+        p.add(jButton15);
+        jButton15.setBounds(360, 190, 90, 20);
+
+        jTextField12.setText("pid");
+        p.add(jTextField12);
+        jTextField12.setBounds(450, 190, 130, 20);
+
+        jButton16.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton16.setText("Lower");
+        p.add(jButton16);
+        jButton16.setBounds(0, 210, 110, 20);
+
+        jTextField13.setText("pid");
+        p.add(jTextField13);
+        jTextField13.setBounds(110, 210, 60, 20);
+
+        jTextField14.setText("pid");
+        p.add(jTextField14);
+        jTextField14.setBounds(280, 210, 60, 20);
+
+        jButton17.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton17.setText("Raise");
+        p.add(jButton17);
+        jButton17.setBounds(170, 210, 110, 20);
+
+        jButton18.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton18.setText("Limit");
+        p.add(jButton18);
+        jButton18.setBounds(340, 210, 110, 20);
+
+        jTextField15.setText("pid");
+        p.add(jTextField15);
+        jTextField15.setBounds(450, 210, 60, 20);
+
+        jTextField16.setText("mb");
+        p.add(jTextField16);
+        jTextField16.setBounds(510, 210, 70, 20);
+
+        jLabel5.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jLabel5.setText("Administrative Tasks:");
+        p.add(jLabel5);
+        jLabel5.setBounds(0, 240, 140, 15);
+
+        jButton19.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton19.setText("Restart");
+        p.add(jButton19);
+        jButton19.setBounds(0, 260, 130, 20);
+
+        jButton20.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton20.setText("Shutdown");
+        p.add(jButton20);
+        jButton20.setBounds(130, 260, 150, 20);
+
+        jButton21.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton21.setText("CrashDump");
+        p.add(jButton21);
+        jButton21.setBounds(280, 260, 140, 20);
+
+        jButton22.setFont(new java.awt.Font("MS Sans Serif", 1, 11));
+        jButton22.setText("Disconnect");
+        p.add(jButton22);
+        jButton22.setBounds(420, 260, 160, 20);
+        
+        jButton1.addActionListener(al);
+        jButton2.addActionListener(al);
+        jButton3.addActionListener(al);
+        jButton4.addActionListener(al);
+        jButton5.addActionListener(al);
+        jButton6.addActionListener(al);
+        jButton7.addActionListener(al);
+        jButton8.addActionListener(al);
+        jButton9.addActionListener(al);
+        jButton10.addActionListener(al);
+        jButton11.addActionListener(al);
+        jButton12.addActionListener(al);
+        jButton13.addActionListener(al);
+        jButton14.addActionListener(al);
+        jButton15.addActionListener(al);
+        jButton16.addActionListener(al);
+        jButton17.addActionListener(al);
+        jButton18.addActionListener(al);
+        jButton19.addActionListener(al);
+        jButton20.addActionListener(al);
+        jButton21.addActionListener(al);
+        jButton22.addActionListener(al);
+    }
+    
+    private ActionListener createActionListener(){
+        ActionListener al = new ActionListener() {
+            public void actionPerformed(ActionEvent ae) {
+                String ac = ae.getActionCommand();
+                
+                try{
+                    if(ac.toUpperCase().equals("DISCONNECT")) {
+                        client.forcedDisconnect();
+                        close();
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("SEND BREAK")) {
+                	 String breakseq = sshProps.getProperty(com.cyclades.util.CYProps.BREAK_SEQ);  //** Changed from termProps.getProperty
+                        if (breakseq==null) {
+                        // send Telnet BREAK following RFC spec rules
+                        //byte IAC  = (byte) 255; // TELNET COMMAND BYTE
+                        //byte CMD_BREAK = (byte) 243; // COMMAND IDENTIFIER : NVT character BRK                			
+                        //term.sendBytes(new byte[] {IAC, CMD_BREAK});
+                            term.sendBreak();
+                        } else {
+                            int lastKey = term.getLastKeyTyped();
+                            if (lastKey!=13 && lastKey!=10) {                			
+                                term.sendBytes(new byte[] {13});
+                            }
+                	     term.sendBytes( breakseq.getBytes() );  // send break sequence
+                        }   term.requestFocus();
+                        return; 
+                    }
+                    if(ac.toUpperCase().equals("SERVER")){
+                        term.sendBytes("id\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("GETTIMEDATE")){
+                        term.sendBytes("s\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("IP")){
+                        term.sendBytes("i\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("KERNELLOG")){
+                        term.sendBytes("d\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("TIMEDATE")){
+                        term.sendString("s " + jTextField10.getText() + "/" + jTextField2.getText()
+                                        + "/" + jTextField3.getText() + " " + jTextField4.getText()
+                                        + ":" + jTextField5.getText() + "\r");
+                        return;
+                    }
+                    
+                    if(ac.toUpperCase().equals("IPINFO")){
+                        term.sendString("i " + jTextField6.getText() + " " + jTextField7.getText()
+                                        + " " + jTextField8.getText() + " " + jTextField9.getText()
+                                        + "\r");
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("CHANNELLIST")){
+                        term.sendBytes("ch\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("CREATE")){
+                        term.sendBytes("cmd\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("LOCK")){
+                        term.sendBytes("lock\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("SWITCH")){
+                        term.sendBytes(String.valueOf("ch -si " + jTextField1.getText()+ "\r").getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("CLOSE")){
+                        term.sendBytes(String.valueOf("ch -ci " + jTextField11.getText()+ "\r").getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("TASKLIST")){
+                        term.sendBytes("t\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("DETAILONOFF")){
+                        term.sendBytes("f\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("PAGEONOFF")){
+                        term.sendBytes("p\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("KILL")){
+                        term.sendBytes(String.valueOf("k " + jTextField12.getText()+ "\r").getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("LOWER")){
+                        term.sendBytes(String.valueOf("l " + jTextField13.getText()+ "\r").getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("RAISE")){
+                        term.sendBytes(String.valueOf("r " + jTextField14.getText()+ "\r").getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("LIMIT")){
+                        term.sendBytes(String.valueOf("m " + jTextField15.getText()+ " " + jTextField16.getText() +"\r").getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("RESTART")){
+                        term.sendBytes("restart\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("SHUTDOWN")){
+                        term.sendBytes("shutdown\r".getBytes());
+                        return;
+                    }
+                    if(ac.toUpperCase().equals("CRASHDUMP")){
+                        term.sendBytes("crashdump\r".getBytes());
+                        return;
+                    }
+                }
+                catch (Exception e) {
+                    e.printStackTrace();
+                }
+                //if comes here, command unknown recivied
+                System.out.println("Unknown event intercepted");
+            }
+        };
+        return al;
+    }
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/application/MindTermLite.java mindterm_3.1.2/com/mindbright/application/MindTermLite.java
--- mindterm_3.1.2.org/com/mindbright/application/MindTermLite.java	2007-03-07 01:39:08.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/application/MindTermLite.java	2009-06-18 12:10:45.000000000 -0700
@@ -915,4 +915,8 @@
     throws IOException {
         return getProperty("proxy-password");
     }
+    
+    public Applet getApplet() {
+        return this;
+    }
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/application/ModuleBaseTerminal.java mindterm_3.1.2/com/mindbright/application/ModuleBaseTerminal.java
--- mindterm_3.1.2.org/com/mindbright/application/ModuleBaseTerminal.java	2006-07-31 23:49:04.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/application/ModuleBaseTerminal.java	2009-06-18 12:10:45.000000000 -0700
@@ -37,7 +37,9 @@
     implements MindTermModule, Runnable, TerminalMenuListener {
 
     protected MindTermApp mindterm;
-    private Vector instances;
+    protected Thread      myThread;
+
+    protected Vector instances;
 
     public void init(MindTermApp mindterm) {
         this.mindterm = mindterm;
@@ -62,6 +64,12 @@
         bt.init(mindterm);
         Thread t = new Thread(bt, "Terminal_" + this.getClass());
         t.start();
+        try {
+            t.join();
+        } catch (InterruptedException ex) {
+            ex.printStackTrace();
+            bt.doClose();
+        }
     }
 
     public void run() {
diff -ruN mindterm_3.1.2.org/com/mindbright/application/ModuleTelnetImpl.java mindterm_3.1.2/com/mindbright/application/ModuleTelnetImpl.java
--- mindterm_3.1.2.org/com/mindbright/application/ModuleTelnetImpl.java	2005-09-06 06:00:50.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/application/ModuleTelnetImpl.java	2009-06-18 12:10:45.000000000 -0700
@@ -16,19 +16,44 @@
 package com.mindbright.application;
 
 import java.net.Socket;
+import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 import java.io.InputStream;
 import java.io.IOException;
 
+import java.util.Properties;
+
+import java.applet.Applet;
+import java.awt.BorderLayout;
+import java.awt.Component;
+import java.awt.Container;
 import java.awt.Frame;
+import java.awt.Image;
+import java.awt.Panel;
+import java.awt.Toolkit;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JFrame;
+import javax.swing.JButton;
+import javax.swing.JMenuBar;
 
+import com.mindbright.gui.AWTConvenience;
+import com.mindbright.gui.SwingConvenience;
 import com.mindbright.net.telnet.TelnetTerminalAdapter;
 import com.mindbright.ssh2.SSH2InternalChannel;
 import com.mindbright.ssh2.SSH2Channel;
+import com.mindbright.terminal.GlobalClipboard;
+import com.mindbright.terminal.TerminalMenuHandler;
+import com.mindbright.terminal.TerminalMenuHandlerFull;
+import com.mindbright.terminal.TerminalWin;
 import com.mindbright.terminal.TerminalWindow;
 import com.mindbright.terminal.LineReaderTerminal;
 import com.mindbright.terminal.TerminalFrameTitle;
 
+import com.cyclades.util.CYProps;
+
+
 public class ModuleTelnetImpl extends ModuleBaseTerminal {
     private String                remoteHost;
     private int                   remotePort;
@@ -39,7 +64,9 @@
     private LineReaderTerminal    lineReader;
     private boolean               localConnect;
     private Socket                socket;
-
+    private Properties            telnetProps;
+    private TerminalWin           terminal;
+    
     protected class ChaffedTelnet extends TelnetTerminalAdapter {
 
         public ChaffedTelnet(InputStream in, OutputStream out,
@@ -47,6 +74,13 @@
             super(in, out, terminalWin);
         }
 
+        public ChaffedTelnet(InputStream in, OutputStream out,
+                TerminalWindow terminalWin,
+                String username, String password, 
+                String phys_port_auth, String typed_input) {
+        	super(in, out, terminalWin, username, password, phys_port_auth, typed_input);
+        }
+
         protected void sendFakeChar() {
             if(channel != null) {
                 /*
@@ -60,11 +94,174 @@
 
     }
 
+    public ModuleTelnetImpl() {super();}
+    
+    public ModuleTelnetImpl(Properties props) {
+    	this.telnetProps = props;
+    }
+
+    public Frame initJFrame(Applet applet) {
+        boolean separateFrame = false;
+        Frame frame = null;
+        boolean useAWT = false;
+        boolean useSwing = true;
+        if (separateFrame) {
+            if (!useAWT) {
+                frame = AWTConvenience.tryToAllocateJFrame();
+            }
+            if (frame == null) { // fallback to use AWT
+                useSwing = false;
+                frame = new Frame();
+            } else {
+                useSwing = true;
+            }
+            frame.addWindowListener(this);
+        } else {
+            Component comp = applet;
+            do {
+                comp = comp.getParent();
+            } while(!(comp instanceof Frame));
+            frame = (Frame)comp;
+            // Force AWT-layout when embedded in a webpage since this
+            // class still extends Applet
+            useSwing = false;
+        }
+        return frame;
+    }
+    
+    public void run() {
+        
+        Applet applet = mindterm.getApplet();
+        
+        //Frame frame = AWTConvenience.tryToAllocateJFrame();
+        Frame frame = initJFrame(applet);
+        
+        if (frame == null) {
+            frame = haveMenus() ? AWTConvenience.newFrameWithMenuBar() : new Frame();
+        } /*else {
+            if (haveMenus()) {
+                try {
+                    Class c = Class.forName("com.mindbright.gui.SwingConvenience");
+                    java.lang.reflect.Method m = c.getMethod
+                        ("newJFrameWithMenuBar", new Class[] {});
+                    frame = (Frame)m.invoke(c, (Object[])null);
+                    frame.setMenuBar(new MenuBar());
+                    frame.validate();
+                } catch (Throwable t) {
+                }
+            }
+        }*/
+        frame.validate();
+
+        /*TerminalWin*/terminal = new TerminalWin(frame, this.telnetProps!=null ? this.telnetProps
+                                                                             : mindterm.getProperties());
+        
+        installLogo(this.terminal);
+        
+        terminal.addAsEntropyGenerator(mindterm.getRandomSeed());
+
+        AWTConvenience.getContentPane(applet/*frame*/).setLayout(new BorderLayout());
+        AWTConvenience.getContentPane(applet/*frame*/).add(
+            terminal.getPanelWithScrollbar(), BorderLayout.CENTER);
+        AWTConvenience.getContentPane(applet/*frame*/).add(
+                new JMenuBar(),BorderLayout.NORTH);
+
+        ActionListener al = new ActionListener() {
+        	public void actionPerformed(ActionEvent ae) {
+        		String ac = ae.getActionCommand();
+        		if(ac.equals("Disconnect")) {
+        			doClose();
+        		}
+        		else if(ac.equals("Send Break")) {
+            		try {
+                		String breakseq = mindterm.getProperty(com.cyclades.util.CYProps.BREAK_SEQ);  //** Changed from telnetProps.getProperty               		
+                		if (breakseq==null) {
+                			// send Telnet BREAK following RFC spec rules
+                			//byte IAC  = (byte) 255; // TELNET COMMAND BYTE
+                			//byte CMD_BREAK = (byte) 243; // COMMAND IDENTIFIER : NVT character BRK                			
+                			//terminal.sendBytes(new byte[] {IAC, CMD_BREAK});
+                			terminal.sendBreak();
+                		}
+                		else {
+                			//System.out.println("LastTypedChar: "+((int) term.getDisplay().getLastKeyTyped()));
+                			int lastKey = terminal.getLastKeyTyped();
+                			if (lastKey!=13 && lastKey!=10) {                			
+                				terminal.sendBytes(new byte[] {13});
+                			}
+                			terminal.sendBytes( breakseq.getBytes() );  // send break sequence
+                		}       terminal.requestFocus();
+            		}
+                	catch (Exception e) {
+               			e.printStackTrace();                			
+               		}               		
+        		}
+        		else {
+        			System.out.println("Unknown event intercepted");
+        		}
+        	}
+        };
+        
+        Panel  p = new Panel();
+        JButton b1 = new JButton("Send Break");
+        JButton b2 = new JButton("Disconnect");
+
+        b1.addActionListener(al);
+        b2.addActionListener(al);
+
+        p.add(b1, BorderLayout.WEST); p.add(b2, BorderLayout.EAST);
+        AWTConvenience.getContentPane(applet).add(p, BorderLayout.SOUTH);
+
+        TerminalFrameTitle frameTitle =
+            new TerminalFrameTitle(frame, getTitle());
+        frameTitle.attach(terminal);
+
+        TerminalMenuHandler tmenus = null;
+
+        if(haveMenus()) {
+            try {
+                tmenus = getTerminalMenuHandler(frame);
+                tmenus.setTitleName(mindterm.getAppName());
+                tmenus.addBasicMenus(terminal, applet/*frame*/);
+                tmenus.setTerminalMenuListener(this);
+            } catch (Throwable t) {
+                /* no menus... */
+                t.printStackTrace();
+            }
+        } else {
+            terminal.setClipboard(GlobalClipboard.getClipboardHandler());
+        }
+
+        frame.addWindowListener(this);
+
+        frame.pack();
+        frame.setVisible(true);
+        terminal.requestFocus();
+
+        try {
+            runTerminal(mindterm, terminal, frame, frameTitle);
+        } finally {
+            frame.dispose();
+            if(haveMenus() && tmenus != null) {
+                GlobalClipboard.getClipboardHandler().removeMenuHandler(tmenus);
+            }
+            instances = null;
+            mindterm = null;
+            doClose();
+        }
+    }
+
+    protected TerminalMenuHandler getTerminalMenuHandler(Frame frame) {
+        try {
+            return TerminalMenuHandlerFull.getInstance(frame);
+        } catch (Throwable t) {}
+        return null;
+    }
+
     public void runTerminal(MindTermApp mindterm, TerminalWindow terminal,
                             Frame frame, TerminalFrameTitle frameTitle) {
         try {
-            remoteHost = mindterm.getProperty("module.telnet.host");
-            remotePort = getPort(mindterm.getProperty("module.telnet.port"));
+            remoteHost = mindterm.getProperty("server");
+            remotePort = getPort(mindterm.getProperty("port"));
 
             localConnect = true;
 
@@ -95,12 +292,36 @@
 
                 lineReader.detach();
             }
-
+/*
             int i = remoteHost.indexOf(':');
             if(i != -1) {
                 remotePort = getPort(remoteHost.substring(i + 1));
                 remoteHost = remoteHost.substring(0, i);
             }
+*/
+			// [CYCLADES-START]
+			int i;
+			if (remoteHost.startsWith("["))	//*** Is it an IPv6 address?
+			{
+				i = remoteHost.indexOf("]:");
+				if (i > 0)
+				{
+					remotePort = getPort(remoteHost.substring(i+2));
+				}
+				i = remoteHost.indexOf(']');
+				if (i < 0) return;
+				remoteHost = remoteHost.substring(1,i);
+			}
+			else
+			{
+				i = remoteHost.indexOf(':');
+				if(i >= 0) 
+				{
+					remotePort = getPort(remoteHost.substring(i + 1));
+					remoteHost = remoteHost.substring(0, i);
+				}
+			} 
+			// [CYCLADES-END]
 
             if(localConnect) {
                 try {
@@ -108,7 +329,7 @@
                     telnetIn  = socket.getInputStream();
                     telnetOut = socket.getOutputStream();
                 } catch (Exception e) {
-                    mindterm.alert("Local connection failed: " +
+                    mindterm.alert("Local Connection Failed: " +
                                    e.getMessage());
                     return;
                 }
@@ -130,7 +351,11 @@
                                     (":" + remotePort)
                                     : ""));
 
-            telnetAdapter = new ChaffedTelnet(telnetIn, telnetOut, terminal);
+            telnetAdapter = new ChaffedTelnet(telnetIn, telnetOut, terminal,
+            		                          telnetProps.getProperty("username"),
+            		                          telnetProps.getProperty("password"),
+            		                          telnetProps.getProperty(CYProps.PHYS_PORT_AUTH),
+            		                          telnetProps.getProperty("typed-input"));
 
             if(!localConnect && useChaff()) {
                 telnetAdapter.startChaff();
@@ -202,7 +427,59 @@
     }
 
     protected ModuleBaseTerminal newInstance() {
-        return new ModuleTelnetImpl();
+    	if(this.telnetProps.getProperty("username")!=null){
+    		return this;
+    	}
+    	else{
+    		return new ModuleTelnetImpl();
+    	}
     }
-
+	
+	public boolean installLogo(TerminalWin terminal) {
+	    boolean isPresent = false;
+	
+	    if(terminal != null) {
+	        ByteArrayOutputStream baos = readResource("/defaults/logo.gif");
+	        if(baos != null) {
+	            byte[] img = baos.toByteArray();
+	            Image logo = Toolkit.getDefaultToolkit().createImage(img);
+	            int width  = -1;
+	            int height = -1;
+	            boolean ready = false;
+	
+	            while (!ready) {
+	                width  = logo.getWidth(null);
+	                height = logo.getHeight(null);
+	                if(width != -1 && height != -1) {
+	                    ready = true;
+	                }
+	                Thread.yield();
+	            }
+	
+	            terminal.setLogo(logo, -1, -1, width, height);
+	
+	            isPresent = true;
+	        }
+	    }
+	
+	    return isPresent;
+	}
+	
+	public ByteArrayOutputStream readResource(String name) {
+	    InputStream in = getClass().getResourceAsStream(name);
+	    ByteArrayOutputStream baos = null;
+	    if(in != null) {
+	        baos = new ByteArrayOutputStream();
+	        try {
+	            int c;
+	            while((c = in.read()) >= 0)
+	                baos.write(c);
+	        } catch(IOException e) {
+	            // !!!
+	            System.err.println("ERROR reading resource " + name + " : " + e);
+	        }
+	    }
+	    return baos;
+	}
+	
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/gui/AWTConvenience.java mindterm_3.1.2/com/mindbright/gui/AWTConvenience.java
--- mindterm_3.1.2.org/com/mindbright/gui/AWTConvenience.java	2005-10-06 06:59:47.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/gui/AWTConvenience.java	2009-06-18 12:10:45.000000000 -0700
@@ -18,6 +18,8 @@
 import java.awt.*;
 import java.awt.event.*;
 
+import javax.swing.JFrame;
+
 import java.lang.reflect.Method;
 
 public abstract class AWTConvenience {
@@ -172,7 +174,21 @@
     }
 
     public final static boolean isSwingJFrame(Frame f) {
-        try {
+		// [CYCLADES-START]
+        	// force-swing added by Eduardo Murai Soares
+    		String forceSwing = com.cyclades.application.CycladesTerm.getParamSSHProps().getProperty(com.cyclades.util.CYProps.FORCE_SWING);
+
+    		if (forceSwing!=null && forceSwing.equalsIgnoreCase("true"))
+        		try {
+        		Class.forName("javax.swing.JFrame").newInstance();
+        		return true;
+        		} catch (Exception e) {
+        			// Swing recognition failed!
+        		}
+        	//}
+        	// [CYCLADES-END]
+        	//---------------------------------------------------------	
+        try {			
             Method m = f.getClass().getMethod("getJMenuBar", (Class[])null);
             return m != null;
         } catch (Throwable t) {
@@ -182,7 +198,14 @@
 
     public final static Frame tryToAllocateJFrame() {
         try {
-            String deflaf = null;
+        	// [CYCLADES-START]
+        	// force-swing added by Eduardo Murai Soares
+        	String deflaf = null; // moved
+    		String forceSwing = com.cyclades.application.CycladesTerm.getParamSSHProps().getProperty(com.cyclades.util.CYProps.FORCE_SWING);
+
+    		if (forceSwing!=null && forceSwing.equalsIgnoreCase("false")) {                		
+            //String deflaf = null;
+    			// [CYCLADES-END]	
             try {
                 String p = System.getProperty("useAWT");
                 if (p != null && Boolean.valueOf(p).booleanValue())
@@ -190,7 +213,9 @@
                 deflaf = System.getProperty("swing.defaultlaf");
             } catch (Throwable tt) {
             }
-
+            // [CYCLADES-START]
+    		} 
+            // [CYCLADES-END]
             try {
                 Class c = Class.forName("com.mindbright.gui.GUISwing");
             } catch (Throwable tt) {
@@ -218,7 +243,12 @@
                 }
             }
             
-            return (Frame)Class.forName("javax.swing.JFrame").newInstance();
+            // [CYCLADES-START] : set default close operation to NOTHING
+            //return (Frame)Class.forName("javax.swing.JFrame").newInstance();            
+            JFrame fr = (JFrame) Class.forName("javax.swing.JFrame").newInstance();
+            fr.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
+            return fr;
+            // [CYCLADES-STOP]
         } catch (Throwable t) {
         }
         return null;
diff -ruN mindterm_3.1.2.org/com/mindbright/gui/GUIAWT.java mindterm_3.1.2/com/mindbright/gui/GUIAWT.java
--- mindterm_3.1.2.org/com/mindbright/gui/GUIAWT.java	2005-10-03 07:17:56.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/gui/GUIAWT.java	2009-06-18 12:10:45.000000000 -0700
@@ -23,6 +23,17 @@
 public class GUIAWT implements GUIInterface {
     public GUIAWT() { }
 
+	 // [CYCLADES-START]    
+    /**
+     * Added by Eduardo Murai Soares.
+     * @see GUIInterface.showOptionPane for documentation
+     */
+    public int showOptionPane(Frame parentComp, String title, String message) {
+    	AlertDialog.show(title, "WARNING- This should not be called in AWT!", parentComp);
+    	return -1;
+    }
+    // [CYCLADES-END]
+	
     public void showAlert(String title, String message, Frame parent) {
         AlertDialog.show(title, message, parent);
     }
diff -ruN mindterm_3.1.2.org/com/mindbright/gui/GUIInterface.java mindterm_3.1.2/com/mindbright/gui/GUIInterface.java
--- mindterm_3.1.2.org/com/mindbright/gui/GUIInterface.java	2005-09-27 07:36:52.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/gui/GUIInterface.java	2009-06-18 12:10:45.000000000 -0700
@@ -18,6 +18,21 @@
 import java.awt.Frame;
 
 public interface GUIInterface {
+ // [CYCLADES-START]   	
+    /**
+     * Shows JOptionPane to user with three buttons : OK, NO and CANCEL.
+     * Added by Eduardo Murai Soares.
+     * 
+     * @param parent
+     * @param title
+     * @param message
+     * @return 0: button OK chosen
+     * 		   1: button NO chosen
+     * 		   2: button CANCEL chosen	
+     */
+	public int showOptionPane(Frame parent, String title, String message);
+	// [CYCLADES-END]
+	
     public void showAlert(String title, String message, Frame parent);
     
     public boolean showConfirm(String title, String message,
diff -ruN mindterm_3.1.2.org/com/mindbright/gui/GUI.java mindterm_3.1.2/com/mindbright/gui/GUI.java
--- mindterm_3.1.2.org/com/mindbright/gui/GUI.java	2005-12-21 00:10:58.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/gui/GUI.java	2009-06-18 12:10:45.000000000 -0700
@@ -24,7 +24,11 @@
     private static void init(Frame parent) {
         if (impl != null || parent == null) return;
         try {
-            if (parent instanceof javax.swing.JFrame) {
+			//  [CYCLADES-START]  
+			// if (parent instanceof javax.swing.JFrame) {
+			if (AWTConvenience.isSwingJFrame(parent)) {
+			// [CYCLADES-END]
+            
                 impl = new GUISwing();
             }
         } catch (Throwable t) {}
@@ -51,8 +55,19 @@
                                       boolean defAnswer, Frame parent,
                                       boolean xscroll, boolean yscroll) {
         init(parent);
+		
+		 // [CYCLADES-START] : 	showConfig causes error when Mindterm runs in the same window as applet
+		 // 					thus a try/catch block was added.
+        // Done by Eduardo Murai Soares
+        try {
         return impl.showConfirm(title, message, rows, cols, yesLbl, noLbl, 
                                 defAnswer, parent, xscroll, yscroll);
+        }
+        catch (Exception e) {
+        	System.out.println("WARNING in GUI.showConfirm: "+e.getMessage());
+        	return true;
+        }
+        // [CYCLADES-END]
     }
 
     public static java.io.File selectFile(Frame parent, String title, boolean save) {
@@ -88,6 +103,24 @@
     }
 
     public static String[] getFontList() {
-        return java.awt.Toolkit.getDefaultToolkit().getFontList();
+        //return java.awt.Toolkit.getDefaultToolkit().getFontList();
+        return java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
+    }
+	
+    //  [CYCLADES-START]    
+    /**
+     * Shows JOptionPane to user.
+     * Added by Eduardo Murai Soares.
+     * 
+     * @param parent
+     * @param title
+     * @param message
+     * @return Options done by user
+     */
+    public static int showOptionPane(Frame parent, String title, String message) {
+    	init(parent);    	
+    	return impl.showOptionPane(parent, title, message);    	
     }
+    // [CYCLADES-END]
+	
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/gui/GUISwing.java mindterm_3.1.2/com/mindbright/gui/GUISwing.java
--- mindterm_3.1.2.org/com/mindbright/gui/GUISwing.java	2005-11-04 05:20:22.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/gui/GUISwing.java	2009-06-18 12:10:45.000000000 -0700
@@ -33,6 +33,18 @@
 public class GUISwing implements GUIInterface {
     public GUISwing() { }
     
+ // [CYCLADES-START]    
+    /**
+     * Added by Eduardo Murai Soares.
+     * @see GUIInterface.showOptionPane for documentation
+     */
+    public int showOptionPane(Frame parent, String title, String message) {
+    	int opt = JOptionPane.showConfirmDialog(parent, message, title, JOptionPane.YES_NO_CANCEL_OPTION,
+    		JOptionPane.QUESTION_MESSAGE);
+    	return opt;
+    }
+    // [CYCLADES-END]
+	
     public void showAlert(String title, String message, Frame parent) {
         JOptionPane.showMessageDialog(parent, message, title,
                                       JOptionPane.ERROR_MESSAGE);
diff -ruN mindterm_3.1.2.org/com/mindbright/net/telnet/TelnetNVT.java mindterm_3.1.2/com/mindbright/net/telnet/TelnetNVT.java
--- mindterm_3.1.2.org/com/mindbright/net/telnet/TelnetNVT.java	2006-10-03 02:23:03.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/net/telnet/TelnetNVT.java	2009-06-18 12:10:45.000000000 -0700
@@ -146,6 +146,7 @@
     private OutputStream       optionOut = null;
     private Thread             myThread;
     private int                reqCode;
+    private boolean            sentCR;
     private StringBuffer       sendBuffer;
 
     /**
@@ -164,6 +165,7 @@
         this.in           = in;
         this.out          = out;
         this.myThread     = new Thread(this, "TelnetNVT");
+        this.sentCR       = false;
         this.sendBuffer   = new StringBuffer();
     }
 
@@ -258,27 +260,50 @@
         // Create one big chunk of data and send it
         while(off < lastOff) {
             b = data[off++];
+            /*if(sentCR) {
+                if(b != CODE_LF) {
+                    sendBuffer.append((char) 0);
+                }
+                sentCR = false;
+            }*/
             if(b == CODE_IAC) {
                 sendBuffer.append((char) b);
-            }
+            } /*else if(b == CODE_CR) {
+                sentCR = true;
+            }*/
             sendBuffer.append((char) b);
         }
         out.write(sendBuffer.toString().getBytes());
         sendBuffer.setLength(0);
     }
 
-    public synchronized void sendData(int b) throws IOException {
+    public synchronized void sendData(int b)
+    throws IOException {
+        /*if(sentCR) {
+            if(b != CODE_LF) {
+                out.write(0);
+            }
+            sentCR = false;
+        }*/
         if(b == CODE_IAC) {
             out.write(b);
-        }
+        } /*else if(b == CODE_CR) {
+            sentCR = true;
+        }*/
         out.write(b);
     }
 
     private void sendBuffer() throws IOException {}
 
-    public synchronized void sendBreak() throws IOException {
-        String data = String.valueOf((char) CODE_IAC) + (char) CODE_BREAK;
-        out.write(data.getBytes());
+    public synchronized void sendCR()
+    throws IOException {
+        out.write(new byte[] { (byte)CODE_CR, (byte)0 }, 0, 2);
+    }
+
+    public synchronized void sendBreak()
+    throws IOException {
+        //String data = String.valueOf((char) CODE_IAC) + (char) CODE_BREAK;
+        out.write(new byte[] {(byte) CODE_IAC, (byte) CODE_BREAK});
     }
 
     public synchronized void doOption(int option) throws IOException {
diff -ruN mindterm_3.1.2.org/com/mindbright/net/telnet/TelnetTerminalAdapter.java mindterm_3.1.2/com/mindbright/net/telnet/TelnetTerminalAdapter.java
--- mindterm_3.1.2.org/com/mindbright/net/telnet/TelnetTerminalAdapter.java	2006-10-03 02:23:04.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/net/telnet/TelnetTerminalAdapter.java	2009-06-18 12:30:35.000000000 -0700
@@ -15,6 +15,7 @@
 
 package com.mindbright.net.telnet;
 
+import com.mindbright.terminal.TerminalOutputListener;
 import java.util.NoSuchElementException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -23,6 +24,8 @@
 import com.mindbright.terminal.TerminalWindow;
 import com.mindbright.terminal.TerminalInputChaff;
 
+import com.cyclades.util.CYProps;
+
 /**
  * Glue class which connects a <code>TerminalWindow</code> to a
  * telnet server.
@@ -32,7 +35,7 @@
  * @see TerminalInputChaff
  */
 public class TelnetTerminalAdapter extends TerminalInputChaff
-    implements TelnetEventHandler {
+    implements TelnetEventHandler, TerminalOutputListener {
     private TelnetNVT      telnet;
     private TerminalWindow terminal;
     private StringBuffer   lineBuffer;
@@ -41,7 +44,10 @@
     private boolean        doBinary = false;
     private boolean        crmod;
     private boolean        crlf = false;
-
+    
+    private String         userName;
+    private String         passWord;
+    
     /**
      * Connects the given <code>TerminalWindow</code> to a telnet
      * server at the other end of the provided streams.
@@ -70,6 +76,43 @@
     }
 
     /**
+     * Connects the given <code>TerminalWindow</code> to a telnet
+     * server at the other end of the provided streams.
+     *
+     * @param in stream from which data from the telnet server is read
+     * @param out stream over which to send data to the telnet server
+     * @param terminal instance of terminal window to connect to
+     * @param username name of appliance user for auto-login
+     * @param password password of appliance user for auto-login
+     */
+    public TelnetTerminalAdapter(InputStream in, OutputStream out,
+                                 TerminalWindow terminal, 
+                                 String username, String password, 
+                                 String phys_port_auth, String typed_input) {
+        this.telnet        = new TelnetNVT(this, in, out);
+        this.terminal      = terminal;
+        this.lineBuffer    = new StringBuffer();
+        if ((typed_input != null) & typed_input.equals("buffered"))
+       		bufferedInput = true;
+       	else
+       		bufferedInput = false;
+
+       	if ((phys_port_auth != null) & !phys_port_auth.equals("none"))
+       		doAutoLogin(username, password);
+
+       	terminal.addInputListener(this);
+        try {
+            crmod = bufferedInput;
+            terminal.setProperty("auto-linefeed", bufferedInput? "true" : "false");
+        } catch (NoSuchElementException e) {}
+        try {
+            crlf = Boolean.getBoolean(terminal.getProperty("crlf"));
+        } catch (NoSuchElementException e) {}
+
+        telnet.start();
+    }
+
+    /**
      * Get the underlying telnet protocol instance.
      */
     public TelnetNVT getTelnetNVT() {
@@ -301,4 +344,34 @@
 
     }
 
+    public void doAutoLogin(String userName, String password) {
+        this.userName = userName+"\n";
+        this.passWord = ((password == null) || (password.trim().length() == 0)) ? null : (password+"\n");
+        buffer = new StringBuffer(80*24);
+        terminal.addOutputListener(this);
+    }
+    
+    private StringBuffer buffer;
+    
+    public void write(char c) {
+        buffer.append(c);
+        if (userName != null && buffer.indexOf("ogin: ") >= 0) {
+                byte [] usr  = com.mindbright.ssh2.SSH2DataBuffer.String2UTF8(userName);
+                for (int i=0; i < usr.length; i++) {
+                        sendTypedChar(usr[i]);
+                }
+		userName = null;
+        } else if (passWord != null && buffer.indexOf("Password: ") >= 0) {
+		sendBytes(passWord.getBytes());
+		passWord = null;
+        }
+        if ((userName == null) && (passWord == null)) {
+		terminal.removeOutputListener(this);
+		buffer = null;
+		return;
+        }
+        if (c == '\n' || c == '\r') {
+		buffer.setLength(0);
+        }
+    }
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHChannelController.java mindterm_3.1.2/com/mindbright/ssh/SSHChannelController.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHChannelController.java	2005-11-04 05:10:50.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh/SSHChannelController.java	2009-06-18 12:10:45.000000000 -0700
@@ -90,7 +90,11 @@
     public void waitForExit(long msWait) throws InterruptedException {
         if(rxChan != null)
             rxChan.join(msWait);
-        Thread.sleep(100);
+        
+        // Cyclades change. I don't think we need this wait here. Why do we need
+        // to give more 100 ms ?
+        //Thread.sleep(100);
+        
         killAll();
     }
 
@@ -262,6 +266,8 @@
                 }
                 transmit(exitPdu);
                 sshAsClient().disconnect(true);
+                // Cyclades change.
+                sshAsClient().setExitStatus(status);
                 break;
             case SMSG_X11_OPEN:
                 // Fallthrough
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHClient.java mindterm_3.1.2/com/mindbright/ssh/SSHClient.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHClient.java	2006-11-08 02:59:16.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh/SSHClient.java	2009-06-18 12:10:45.000000000 -0700
@@ -190,6 +190,11 @@
     protected boolean activateTunnels = true;
     // !!! KLUDGE
 
+    /**
+     * Exit code. Added by Cyclades.
+     */
+    protected Integer exitStatus = null;
+
     public SSHClient(SSHAuthenticator authenticator, SSHClientUser user) {
         this.user           = user;
         this.authenticator  = authenticator;
@@ -376,6 +381,10 @@
     public void doSingleCommand(String commandLine, boolean background, long msTimeout)
     throws IOException {
         this.commandLine = commandLine;
+
+        // Cyclades change.
+        this.exitStatus = null;
+
         bootSSH(false);
         if(background)
             startExitMonitor(msTimeout);
@@ -555,6 +564,22 @@
         }
     }
 
+    /**
+     * Called from SSHChannelController to set the exit status.
+     * Cyclades change.
+     */
+    protected void setExitStatus(int status) {
+        exitStatus = new Integer(status);
+    }
+    
+    /**
+     * Returns the exit status if it was set or null otherwise.
+     * Cyclades change.
+     */
+    public Integer getExitStatus() {
+        return exitStatus;
+    }
+    
     protected void disconnect(boolean graceful) {
         if(!isConnected)
             return;
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHConsoleClient.java mindterm_3.1.2/com/mindbright/ssh/SSHConsoleClient.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHConsoleClient.java	2006-10-04 05:44:43.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/ssh/SSHConsoleClient.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,7 @@
 
 package com.mindbright.ssh;
 
+import com.mindbright.sshcommon.TimeoutException;
 import java.io.OutputStream;
 import java.io.InputStream;
 import java.io.IOException;
@@ -39,6 +40,12 @@
     protected OutputStream      stdout;
     protected TerminalOutStream stdin;
 
+    /**
+     * Where to store standard error bytes.
+     * Cyclades change.
+     */
+    protected OutputStream      stderr;
+
     final class TerminalOutStream extends OutputStream {
         public void write(int b) throws IOException {
             byte[] buf = new byte[1];
@@ -92,6 +99,27 @@
         return true;
     }
 
+    /**
+     * Send a command and wait for a given timeout for the it to finish.
+     * Cyclades change.
+     */
+    public int command(String command, long timeout) throws TimeoutException, IOException {
+        try {
+            client.doSingleCommand(command, false, timeout);
+            Integer exitStatus = client.getExitStatus();
+            if (exitStatus != null) {
+                return exitStatus.intValue();
+            } else {
+                throw new TimeoutException("command did not finish after " + timeout + " milliseconds");
+            }
+        } catch (IOException e) {
+            if(interactor != null) {
+                interactor.alert("Error connecting: " + e.getMessage());
+            }
+            throw e;
+        }
+    }
+
     public boolean shell() {
         try {
             client.bootSSH(false, false);
@@ -124,6 +152,14 @@
         inTop       = null;
     }
 
+    /**
+     * Where to store standard error bytes.
+     * Cyclades change.
+     */
+    public void changeStdErr(OutputStream err) {
+        this.stderr = err;
+    }
+
     public OutputStream getStdIn() {
         return stdin;
     }
@@ -151,8 +187,24 @@
     }
 
     public void stderrWriteString(byte[] str) {
-        if(interactor != null)
-            interactor.alert("Remote warning/error: " + new String(str));
+        // Cyclades change - start.
+        if (stderr != null) {
+            try {
+                stderr.write(str);
+            } catch(IOException e) {
+                try {
+                    stderr.close();
+                } catch (IOException ee) {
+                    // !!!
+                }
+                if(interactor != null)
+                    interactor.alert("Error writing data to stderr-pipe");
+            }
+        // Cyclades change - end.
+        } else {
+            if(interactor != null)
+                interactor.alert("Remote warning/error: " + new String(str));
+        }
     }
 
     public TerminalWindow getTerminal() {
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHInteractiveClient.java mindterm_3.1.2/com/mindbright/ssh/SSHInteractiveClient.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHInteractiveClient.java	2006-12-12 07:12:38.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh/SSHInteractiveClient.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,7 @@
 
 package com.mindbright.ssh;
 
+import java.applet.Applet;
 import java.io.File;
 import java.io.InputStream;
 import java.io.ByteArrayOutputStream;
@@ -32,6 +33,7 @@
 import java.awt.Toolkit;
 
 
+import com.cyclades.util.CYProps;
 import com.mindbright.ssh2.*;
 
 import com.mindbright.terminal.*;
@@ -57,21 +59,36 @@
     SSH2Connection       connection;
     SSH2TerminalAdapter  termAdapter;
 
-    public boolean wantHelpInfo       = true;
+	// [CYCLADES-START] : Default value changed to false
+    public boolean wantHelpInfo       = false; //true;
+    //  [CYCLADES-END]
+    
     public String  customStartMessage = null;
 
     SSHMenuHandler     menus;
     SSHStdIO           sshStdIO;
-    SSHPropertyHandler propsHandler;
+    
+    //  [CYCLADES-START] 
+    // state if it is the splash screen was already displayed.
+    private boolean splashFlag = false;
+    
+    public 
+    //  [CYCLADES-END]    
+    	SSHPropertyHandler propsHandler;
 
     public boolean quiet;
     public boolean exitOnLogout;
     boolean        initQuiet;
     boolean        isFirstPasswdAuth;
+    
+    private Applet applet;
 
     public SSHInteractiveClient(boolean quiet, boolean exitOnLogout,
-                                SSHPropertyHandler propsHandler) {
+                                SSHPropertyHandler propsHandler, Applet applet) {
+        
         super(propsHandler, propsHandler);
+        
+        this.applet = applet;
 
         this.propsHandler = propsHandler;
         this.interactor   = this; // !!! OUCH
@@ -88,8 +105,8 @@
         sshStdIO.setClient(this);
     }
 
-    public SSHInteractiveClient(SSHInteractiveClient clone) {
-        this(true, true, new SSHPropertyHandler(clone.propsHandler));
+    public SSHInteractiveClient(SSHInteractiveClient clone, Applet applet) {
+        this(true, true, new SSHPropertyHandler(clone.propsHandler),applet);
 
         this.activateTunnels = false;
 
@@ -113,12 +130,18 @@
     public void splashScreen() {
         TerminalWin t = getTerminalWin();
 
+        // [CYCLADES-START] : in the second time avoid clearing the screen. It is important to see what problem may have ocurred.
+        if (!splashFlag) 
+        // [CYCLADES-END]
+        	
         if(t != null) {
             t.clearScreen();
             t.setCursorPos(0, 0);
         }
 
-        console.println("MindTerm version " + Version.version);
+		// [CYCLADES-START]  : Console output commented        
+		
+        /* console.println("MindTerm version " + Version.version);
         console.println(Version.copyright);
         console.println(Version.licenseMessage);
 
@@ -142,6 +165,10 @@
             t.setCursorPos(t.rows() - 1, 0);
             t.clearLine();
         }
+		*/
+        
+        splashFlag = true;
+		// [CYCLADES-END]
     }
 
     public boolean installLogo() {
@@ -195,9 +222,13 @@
 
     void initRandomSeed() {
         if(!haveSecureRandom()) {
-            console.print("Initializing random generator, please wait...");
+			// [CYCLADES-START] : code commented
+            //console.print("Initializing random generator, please wait...");
+			
             initSeedGenerator();
-            console.print("done");
+			
+            //console.print("done");
+			// [CYCLADES-END]
         }
     }
 
@@ -214,17 +245,32 @@
 
     public void run() {
         boolean gotExtMsg;
-
+        boolean skipPassword;
+        
         installLogo();
 
         boolean keepRunning = true;
         while(keepRunning) {
             gotExtMsg = false;
+            skipPassword = propsHandler.getProperty(CYProps.SKIP_PASSWD_METHOD).trim().equalsIgnoreCase("true");
             try {
                 splashScreen();
 
                 initRandomSeed();
 
+                if(!skipPassword) {
+                	int i;
+                	String Username = propsHandler.getProperty("username");
+                	String Port = "";
+                	if((i = Username.indexOf(":")) > 0) {
+                		Port = Username.substring(i+1,Username.length());
+                		Username = Username.substring(0,i);
+                		Username = this.promptLine("SSH Authorization required\n\rUsername: ", Username);
+                		Username = Username+":"+Port;
+                		propsHandler.setProperty("username",Username);
+                	}
+                }
+
                 startSSHClient(true);
 
                 if(sshStdIO.isConnected()) {
@@ -246,9 +292,14 @@
                 }
 
             } catch(SSHClient.AuthFailException e) {
-                alert("Authentication failed, " + e.getMessage());
                 propsHandler.clearPasswords();
-
+            	if(!skipPassword) {
+            		alert("Authentication failed, " + e.getMessage());
+            	}
+            	else {
+            		propsHandler.setProperty(CYProps.SKIP_PASSWD_METHOD,"false");
+                    continue;
+            	}
             } catch(WebProxyException e) {
                 alert(e.getMessage());
                 propsHandler.clearPasswords();
@@ -274,6 +325,7 @@
                 alert("File not found: " + e.getMessage());
 
             } catch(Exception e) {
+                e.printStackTrace();
                 String msg = e.getMessage();
                 if(msg == null || msg.trim().length() == 0)
                     msg = e.toString();
@@ -314,6 +366,20 @@
 
             keepRunning = !exitOnLogout;
         }
+        
+        // [CYCLADES-START]: keep a loop until user closes the window
+        boolean errorFlag=false;
+        while (!errorFlag) {        	
+         try {
+			Thread.sleep(10000);
+			Thread.yield();
+		} catch (InterruptedException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+			errorFlag = true;
+			}        	
+        }
+        // [CYCLADES-STOP]
     }
 
     public long getConnectTimeout() {
@@ -550,7 +616,9 @@
 
     public void connected(SSHClient client) {
         updateMenus();
-        console.println("Connected to server running " + srvVersionStr);
+		// [CYCLADES-START] : code commented
+        // console.println("Connected to server running " + srvVersionStr);
+		// [CYCLADES-END]
     }
 
     public void open(SSHClient client) {
@@ -721,6 +789,12 @@
             authenticator.setUsername(propsHandler.getUsername(null));
 
             SSH2UserAuth userAuth = new SSH2UserAuth(transport, authenticator);
+
+            // [CYCLADES-START]
+            String skipPasswordMethod = propsHandler.getProperty(CYProps.SKIP_PASSWD_METHOD);
+            authenticator.setSkipPasswordMethod(skipPasswordMethod!=null && skipPasswordMethod.trim().equalsIgnoreCase("true"));
+            // [CYCLADES-END]
+            
             if(!userAuth.authenticateUser("ssh-connection")) {
                 throw new AuthFailException("permission denied");
             }
@@ -838,10 +912,16 @@
             throw new IOException("Error in ssh2: " + e.getMessage() +
                                   "{" + e + "}");
         } finally {
-            ((SSHMenuHandlerFull)menus).modulesDisconnect();
+        	if(menus!=null)
+        		((SSHMenuHandlerFull)menus).modulesDisconnect();
             connection = null;
             transport = null;
             isSSH2 = false;
+            if (exitOnLogout)  //Close on the logout VDN 11/13/07
+            {
+                this.applet.stop();
+                this.applet.destroy();
+            }
         }
     }
 
@@ -937,7 +1017,9 @@
                     }
                     String p = getProperty("username") + "@" +
                         getProperty("server") + "'s password: ";
-                    authenticator.addModule(new SSH2AuthPassword(this, p));
+                    //Test: Should call the method that don't always prompt password
+                    //System.out.println("*******Password is " + getProperty("password"));
+                    authenticator.addModule(new SSH2AuthPassword(this, p, getProperty("password")));
                     break;
                 case AUTH_HOSTBASED: {
                     String keyFile = propsHandler.getProperty("private-host-key");
@@ -1142,4 +1224,7 @@
         return remote;
     }
 
+    public Applet getApplet() {
+        return applet;
+    }
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSH.java mindterm_3.1.2/com/mindbright/ssh/SSH.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSH.java	2007-03-07 01:39:07.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh/SSH.java	2009-06-18 12:10:45.000000000 -0700
@@ -34,8 +34,8 @@
     public final static int    SSH_VER_MINOR = 5;
     public final static String VER_MINDTERM  = "MindTerm_" + Version.version;
     public final static String VER_MINDTUNL  = "MindTunnel_" + Version.version;
-    public final static String CVS_NAME      = "$Name: v3_1_2 $";
-    public final static String CVS_DATE      = "$Date: 2007/03/07 09:39:07 $";
+    public final static String CVS_NAME      = "$Name:  $";
+    public final static String CVS_DATE      = "$Date: 2007/04/10 13:02:00 $";
 
     public final static int    DEFAULTPORT        = 22;
     public final static int    SESSION_KEY_LENGTH = 256; // !!! Must be multiple of 8
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHMenuHandlerFullAWT.java mindterm_3.1.2/com/mindbright/ssh/SSHMenuHandlerFullAWT.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHMenuHandlerFullAWT.java	2006-03-06 13:51:11.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh/SSHMenuHandlerFullAWT.java	2009-06-18 12:10:45.000000000 -0700
@@ -35,7 +35,11 @@
 //         super();
 //     }
     
-    public void setupMenuBar(boolean usePopupMenu) { 
+    public void setupMenuBar(boolean usePopupMenu
+	    	// [CYCLADES-START]	
+        	, boolean appletMode
+        	//  [CYCLADES-END]
+		) { 
         if (usePopupMenu) {
             PopupMenu pm = new PopupMenu(MENU_HEADER_POPUP);
             preparePopupMenu(pm);
@@ -51,11 +55,11 @@
 	mb.add((Menu)((TerminalMenuHandlerFull)term.getMenus()).getMenu
                (TerminalMenuHandlerFull.MENU_EDIT));
 	mb.add(getMenu(MENU_SETTINGS));
-	Menu pm = getPluginMenu();
+	/*Menu pm = getPluginMenu();
 	if (pm != null) {
 	    mb.add(pm);
 	}
-	mb.add(getMenu(MENU_TUNNELS));
+	mb.add(getMenu(MENU_TUNNELS));*/
 	mb.setHelpMenu(getMenu(MENU_HELP));
 	term.updateMenus();
     }
@@ -66,10 +70,10 @@
 	popupmenu.add((Menu)((TerminalMenuHandlerFull)term.getMenus()).getMenu
                       (TerminalMenuHandlerFull.MENU_EDIT));
 	popupmenu.add(getMenu(MENU_SETTINGS));
-	Menu pm = getPluginMenu();
+	/*Menu pm = getPluginMenu();
 	if (pm != null) 
 	    popupmenu.add(pm);
-	popupmenu.add(getMenu(MENU_TUNNELS));
+	popupmenu.add(getMenu(MENU_TUNNELS));*/
 	popupmenu.addSeparator();
 	popupmenu.add(getMenu(MENU_HELP));
         term.getMenus().setPopupMenu(popupmenu);
@@ -277,7 +281,7 @@
     private Checkbox  cbSaveAlias;
     private TextField textSrv, textPort, textUser, textAlias, textPrivateKey, textPrivateHostKey;
     private TextField textPwd;
-    private Button    customBtn;
+    private Button    customBtn, browseBtn;
     private CardLayout authLabelCL, authCL;
     private Panel     authLabelCP, authCP;
     private String    customAuth;
@@ -1091,6 +1095,21 @@
 	cbForcPty.setState(ph.getPropertyB("forcpty"));
     }
 
+    private void updateCheckedText(Checkbox cb, TextField text,
+                                   String propName) {
+	if (!text.isEnabled()) {
+	    if (cb.getState()) {
+		text.setText(ph.getProperty(propName));
+	    } else {
+		text.setText(ph.getDefaultProperty(propName));
+	    }
+	}
+	text.setEnabled(cb.isEnabled() && cb.getState());
+	if (!text.isEnabled()) {
+	    text.setText(ph.getDefaultProperty(propName));
+	}
+    }
+
     private void checkSupportedByPeer() throws Exception {
 	checkSupportedByPeer(SSH2Preferences.CIPHERS_C2S, comboCipherC2S);
 	checkSupportedByPeer(SSH2Preferences.CIPHERS_S2C, comboCipherS2C);
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHMenuHandlerFull.java mindterm_3.1.2/com/mindbright/ssh/SSHMenuHandlerFull.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHMenuHandlerFull.java	2006-01-23 04:12:48.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh/SSHMenuHandlerFull.java	2009-06-18 12:10:45.000000000 -0700
@@ -19,11 +19,13 @@
 import java.awt.event.*;
 
 import java.io.File;
+import java.util.StringTokenizer;
 
 import com.mindbright.application.MindTerm;
 import com.mindbright.application.MindTermModule;
 
 import com.mindbright.gui.AWTConvenience;
+import com.mindbright.gui.AlertDialog;
 import com.mindbright.gui.GUI;
 
 import com.mindbright.ssh2.SSH2ListUtil;
@@ -38,12 +40,17 @@
         TerminalMenuListener {
 
     private final static String aboutText =
-        SSH.VER_MINDTERM + "\n" +
-        Version.licenseMessage + "\n" +
-        "\n" +
-        Version.copyright + "\n" +
-        "\thttp://www.appgate.com/mindterm/\n" +
-        "\n" +
+    	// [CYCLADES-START]
+        //SSH.VER_MINDTERM + "\n" +
+        //Version.licenseMessage + "\n" +
+        //"\n" +
+        //Version.copyright + "\n" +    	
+        //"\thttp://www.appgate.com/mindterm/\n" +
+    	
+    	"Copyright (c) 2007 - Avocent Corporation \n"+ 
+    	"http://www.avocent.com \n" +
+    	
+        "\n"+
         "This product includes cryptographic software written by,\n" +
         "Eric Young (eay@cryptsoft.com)\n" +
         "\n" +
@@ -80,7 +87,7 @@
     protected final static int MENU_FILE     = 0;
     protected final static int MENU_SETTINGS = 1;
     protected final static int MENU_TUNNELS  = 2;
-    protected final static int MENU_HELP     = 3;
+    protected final static int MENU_HELP     = 2;//3;
 
     private final static int M_FILE_NEW          = 1;
     private final static int M_FILE_CLONE        = 2;
@@ -91,17 +98,31 @@
     private final static int M_FILE_SAVEAS       = 8;
     private final static int M_FILE_CREATID      = 10;
     private final static int M_FILE_EDITPKI      = 11;
-    private final static int M_FILE_PRINT_SCREEN = 13;
-    private final static int M_FILE_PRINT_BUFFER = 14;
-    private final static int M_FILE_CAPTURE      = 16;
-    private final static int M_FILE_SEND         = 17;
-    private final static int M_FILE_CLOSE        = 19;
+    private final static int M_FILE_PRINT_SCREEN = 1;//13;
+    private final static int M_FILE_PRINT_BUFFER = 2;//14;
+    private final static int M_FILE_CAPTURE      = 3;//16;
+    private final static int M_FILE_SEND         = 4;//17;
+    private final static int M_FILE_CLOSE        = 6;//19;
     private final static int M_FILE_EXIT         = 20;
 
+    // CYCLADES NEW ITENS
+    /**
+     * Menu ID for "send break" feature
+     * Done by Eduardo Murai Soares
+     */
+    private final static int M_FILE_SENDBREAKSEQ = 16+6; // 15 is the separator!!
+    private final static int M_FILE_LOCK = 17+6; 
+    private final static int M_FILE_UNLOCK = 18+6; 
+    private final static int M_FILE_POWER_ON = 19+6; 
+    private final static int M_FILE_POWER_OFF = 20+6; 
+    private final static int M_FILE_POWER_CYCLE = 21+6; 
+    private final static int M_FILE_POWER_STATUS = 22+6;
+    //  [CYCLADES-END]
+
     private final static int M_SET_SSH_NEW  = 1;
     private final static int M_SET_SSH_PREF = 2;
 
-    private final static int M_SET_TERM     = 3;
+    private final static int M_SET_TERM     = 1;//3;
 
     private final static int M_SET_RESET    = 4;
     private final static int M_SET_AUTOSAVE = 6;
@@ -118,22 +139,28 @@
 
     protected final static String[][] menuTexts = {
 	{ "File",
-	  "New Terminal", "Clone Terminal", "Connect...", "Disconnect", null,
+	  /*"New Terminal", "Clone Terminal", "Connect...", "Disconnect", null,
 	  "Load Settings...", "Save Settings", "Save Settings As...", null,
-	  "Create Keypair...", "Edit/Convert Keypair...", null,
-          "Print screen...", "Print buffer...", null,
-	  "_Capture To File...", "Send ASCII File...", null, "Close", "Exit"
+	  "Create Keypair...", "Edit/Convert Keypair...", null,*/
+          "Print screen...", "Print buffer...",/* null,*/
+	  "_Capture To File...", "Send ASCII File...", null, "Close"/*, "Exit"
+	  // [CYCLADES-START]
+	  // Menu separator and "Send break" menu item 
+	  // added by Eduardo Murai Soares 
+	  , null, "Send break", "Lock outlet","Unlock outlet","Power on","Power off",
+	  "Power cycle","Power status"*/
+	  // [CYCLADES-END]
 	},
 
 	{ "Settings",
-	  "New Server...", "Connection...", 
-          "Terminal...", "Reset To Defaults", null,
-	  "_Auto Save Settings", "_Auto Load Settings", "_Save Passwords"
+	  /*"New Server...", "Connection...",*/ 
+          "Terminal..."/*, "Reset To Defaults", null,
+	  "_Auto Save Settings", "_Auto Load Settings", "_Save Passwords"*/
 	},
 
-	{ "Tunnels",
+	/*{ "Tunnels",
 	  "Setup...", null, "Current Connections..."
-	},
+	},*/
 
 	{ "Help",
 	  "About MindTerm"
@@ -142,12 +169,23 @@
 
     protected final static int NO_SHORTCUT = -1;
     private final static int[][] menuShortCuts = {
-	{ NO_SHORTCUT, KeyEvent.VK_N, KeyEvent.VK_O, KeyEvent.VK_C, NO_SHORTCUT,
+	/*{ NO_SHORTCUT, KeyEvent.VK_N, KeyEvent.VK_O, KeyEvent.VK_C, NO_SHORTCUT,
 	  NO_SHORTCUT, NO_SHORTCUT, KeyEvent.VK_S, NO_SHORTCUT, NO_SHORTCUT, NO_SHORTCUT, 
 	  NO_SHORTCUT, NO_SHORTCUT, NO_SHORTCUT, NO_SHORTCUT,
-	  NO_SHORTCUT, KeyEvent.VK_E, KeyEvent.VK_X },
-
-	{ NO_SHORTCUT, KeyEvent.VK_H, NO_SHORTCUT, KeyEvent.VK_T }
+	  NO_SHORTCUT, KeyEvent.VK_E, KeyEvent.VK_X 
+  	  // [CYCLADES-START]
+	  // Shortcuts setup for Menu separator and "send break" item
+	  // added by Eduardo Murai Soares
+	  ,NO_SHORTCUT, 
+	  NO_SHORTCUT ,NO_SHORTCUT,NO_SHORTCUT,
+	  NO_SHORTCUT,NO_SHORTCUT,
+	  NO_SHORTCUT,NO_SHORTCUT
+	  // [CYCLADES-END]
+},
+
+	{ NO_SHORTCUT, KeyEvent.VK_H, NO_SHORTCUT, KeyEvent.VK_T }*/
+    	{NO_SHORTCUT, NO_SHORTCUT, NO_SHORTCUT, NO_SHORTCUT,
+    	 NO_SHORTCUT, NO_SHORTCUT, KeyEvent.VK_E}
     };
 
     protected static int getMenuShortCut(int m, int s) {
@@ -229,7 +267,7 @@
     public static SSHMenuHandler getInstance(Frame frame) {
         try {
             Class c = Class.forName(
-                AWTConvenience.isSwingJFrame(frame) ? 
+                /*AWTConvenience.isSwingJFrame(frame)*/ true ? 
                 "com.mindbright.ssh.SSHMenuHandlerFullSwing" :
                 "com.mindbright.ssh.SSHMenuHandlerFullAWT");
             return (SSHMenuHandler)c.newInstance();
@@ -335,10 +373,104 @@
 	handleMenuAction(mapAction((String)e.getItem()));
     }
 
+    // [CYCLADES-START]
+    /**
+     * Parse the property as byte sequence and transmit them to the console.
+     */
+    public void sendBytesFromAPMProperty(String property) {
+    	byte seq[] = this.getBytesFromProperty(property);
+    	
+    	//alertDialog("sendBytesFromAPMProperty, prop="+property+", value="+
+    	//		mindterm.getParamSSHProps().getProperty(property));
+    	
+		if (seq==null) 
+			alertDialog("The property "+property+" is undefined. Please configure it at TOMCAT_HOME/apm/WEB-INF/jnlp/mindterm.properties");               			                			
+		else term.sendBytes(seq);    	
+    }
+    
+    /**
+     * Parse bytes sequence from one single property.
+     * sample: #5,c,O,l
+     * 
+     * The preceding character '#' states that the item should be handled as number.
+     * 
+     * @param propertyName
+     * @return result
+     */
+    private byte[] getBytesFromProperty(String propertyName) {
+        String aux = mindterm.getParamSSHProps().getProperty(propertyName);
+        if (aux==null || aux.trim().equals("")) return null;
+        
+        StringTokenizer tokenlist = new StringTokenizer(aux,",",false);
+        String character="";
+        byte[] result = new byte[tokenlist.countTokens()];
+        int i=0;
+        
+        while (tokenlist.hasMoreTokens()) {
+        	character = tokenlist.nextToken().trim();
+        	
+        	if (character.startsWith("#"))
+        		result[i] = Byte.parseByte(character.substring(1));
+        	else 
+        		result[i] = (byte) character.charAt(0);
+        	
+        	i++;
+        	}        
+        
+        return result;
+    }
+    
+    // [CYCLADES-STOP]
+    public void menuSendBreak() {
+		try {
+    		String breakseq = mindterm.getParamSSHProps().getProperty(com.cyclades.util.CYProps.BREAK_SEQ);                		
+    		if (breakseq==null) {
+    			// send Telnet BREAK following RFC spec rules
+    			byte IAC  = (byte) 255; // TELNET COMMAND BYTE
+    			byte CMD_BREAK = (byte) 243; // COMMAND IDENTIFIER : NVT character BRK                			
+    			term.sendBytes(new byte[] {IAC, CMD_BREAK});
+    			}
+    		else {
+    			//System.out.println("LastTypedChar: "+((int) term.getDisplay().getLastKeyTyped()));
+    			int lastKey = term.getLastKeyTyped();
+    			if (lastKey!=13 && lastKey!=10) {                			
+    				final int opt = GUI.showOptionPane(parent, "break sequence", "The break sequence needs to be sent at the beginning of a line.\nDo you want to send an [enter] before the break sequence?");
+    				switch (opt) {
+    					// user chose 'YES' : send CR
+    					case 0 : term.sendBytes(new byte[] {13});
+    						 break;
+    						 
+    					case 1:  break; // user chose 'NO': do not send CR               				                				
+    					case 2:  return; // user chose 'CANCEL': abort operation
+   					}                				
+   				}
+    			// send break sequence
+   				sendBytesFromAPMProperty(com.cyclades.util.CYProps.BREAK_SEQ);
+   			}
+   		}
+		catch (Exception e) {
+   			e.printStackTrace();                			
+   			alertDialog("Error: break failed!");
+   		}                		
+    }
+    
+    public void menuDisconnect() {
+        if(mindterm.confirmClose()) {
+            client.forcedDisconnect();
+            client.quiet = client.initQuiet;
+        }
+    }
+
     private void handleMenuAction(int[] id) {
 	switch(id[0]) {
             case MENU_FILE:
                 switch(id[1]) {
+                // [CYCLADES-START]
+          	  	    // "Send break" action handler added by Eduardo Murai Soares
+                	/*case M_FILE_SENDBREAKSEQ:
+            			menuSendBreak();
+                		break;         
+                // [CYCLADES-END]
                     case M_FILE_NEW:
                         mindterm.newWindow();
                         break;
@@ -350,10 +482,7 @@
                         connectDialog("MindTerm - Connect");
                         break;
                     case M_FILE_DISC:
-                        if(mindterm.confirmClose()) {
-                            client.forcedDisconnect();
-                            client.quiet = client.initQuiet;
-                        }
+                    	menuDisconnect();
                         break;
                     case M_FILE_LOAD:
                         loadFileDialog();
@@ -383,7 +512,7 @@
                         break;
                     case M_FILE_EDITPKI:
                         keyGenerationDialogEdit();
-                        break;
+                        break;*/
                     case M_FILE_CAPTURE:
                         if(getState(MENU_FILE, M_FILE_CAPTURE)) {
                             if(!((TerminalMenuHandlerFull)term.getMenus()).captureToFileDialog()) {
@@ -404,26 +533,32 @@
                         break;
                     case M_FILE_CLOSE:
                         mindterm.close();
+                        //mindterm.exit();
                         break;
-                    case M_FILE_EXIT:
+                    /*case M_FILE_EXIT:
                         mindterm.exit();
-                        break;
+                        break;*/
                 }
                 break;
 
             case MENU_SETTINGS:
                 switch(id[1]) {
-                    case M_SET_SSH_NEW:
+                    /*case M_SET_SSH_NEW:
                         sshNewServerDialog();
                         break;
                     case M_SET_SSH_PREF:
                         sshPreferencesDialog();
-                        break;
+                        break;*/
                     case M_SET_TERM:
                         ((TerminalMenuHandlerFull)term.getMenus()).termSettingsDialog();
                         break;
-                    case M_SET_RESET:
-                        client.propsHandler.resetToDefaults();
+                    /*case M_SET_RESET:
+                    	// [CYCLADES-START]
+                    	if (client.isOpened()) 
+                    		alertDialog("You must disconnect from server before performing this task.");
+                    	else
+                        // [CYCLADES-END]
+                    	client.propsHandler.resetToDefaults();
                         break;
                     case M_SET_AUTOSAVE:
                         client.propsHandler.setAutoSaveProps
@@ -452,11 +587,11 @@
                             }
                             client.propsHandler.setPropertyPassword(pwd);
                         }
-                        break;
+                        break;*/
                 }
                 break;
 
-            case MENU_TUNNELS:
+            /*case MENU_TUNNELS:
                 switch(id[1]) {
                     case M_TUNL_SETUP:
                         setupTunnelsDialog();
@@ -465,7 +600,7 @@
                         currentTunnelsDialog();
                         break;
                 }
-                break;
+                break;*/
 
             case MENU_HELP:
                 switch(id[1]) {
@@ -483,16 +618,27 @@
     protected abstract void setState(int i, int j, boolean v);
     protected abstract boolean getState(int i, int j);
     protected abstract void updatePluginMenu();
-    public abstract void setupMenuBar(boolean usePopupMenu);    
+    public abstract void setupMenuBar(boolean usePopupMenu, boolean appletMode);    
     protected abstract String getMenuLabel(Object o);
 
+	
+	 // [CYCLADES-START]
+    /**
+     * @return MindTerm reference. 
+     * @author Eduardo Murai Soares/Cyclades Brasil
+     */
+	public MindTerm getMindterm() {
+		return mindterm;
+	}	
+	// [CYCLADES-END]
+	
     public void update() {
 	boolean isOpen      = client.isOpened();
 	boolean isConnected = client.isConnected();
 	boolean hasHomeDir  = (client.propsHandler.getSSHHomeDir() != null);
         boolean allowNew =client.propsHandler.getPropertyB("allow-new-server");
 
-	setEnabled(MENU_FILE, M_FILE_NEW, allowNew);
+	/*setEnabled(MENU_FILE, M_FILE_NEW, allowNew);
 	setEnabled(MENU_FILE, M_FILE_CLONE, isOpen);
 	setEnabled(MENU_FILE, M_FILE_SEND, isOpen);
 	setEnabled(MENU_FILE, M_FILE_SAVEAS, isOpen && hasHomeDir);
@@ -519,9 +665,20 @@
                  client.propsHandler.savePasswords);
 
 	setEnabled(MENU_TUNNELS, M_TUNL_CURRENT, isOpen);
-	setEnabled(MENU_TUNNELS, M_TUNL_SETUP, isOpen);
+	setEnabled(MENU_TUNNELS, M_TUNL_SETUP, isOpen);*/
+
+	// [CYCLADES-START]
+	// Added by Eduardo Murai Soares	 
+	/*setEnabled(MENU_FILE, M_FILE_SENDBREAKSEQ, isConnected);
+	setEnabled(MENU_FILE, M_FILE_LOCK, isConnected);
+	setEnabled(MENU_FILE, M_FILE_UNLOCK, isConnected);
+	setEnabled(MENU_FILE, M_FILE_POWER_ON, isConnected);
+	setEnabled(MENU_FILE, M_FILE_POWER_OFF, isConnected);
+	setEnabled(MENU_FILE, M_FILE_POWER_CYCLE, isConnected);
+	setEnabled(MENU_FILE, M_FILE_POWER_STATUS, isConnected);*/
+	// [CYCLADES-END]
 
-	updatePluginMenu();
+	//updatePluginMenu();
     }
 
     public void close() {
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHMenuHandlerFullSwing.java mindterm_3.1.2/com/mindbright/ssh/SSHMenuHandlerFullSwing.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHMenuHandlerFullSwing.java	2006-03-06 13:51:11.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh/SSHMenuHandlerFullSwing.java	2009-06-18 12:10:45.000000000 -0700
@@ -50,14 +50,33 @@
 //         super();
 //     }
 
-    public void setupMenuBar(boolean usePopupMenu) { 
+    public void setupMenuBar(boolean usePopupMenu, boolean appletMode) { 
         if (usePopupMenu) {
             JPopupMenu pm = new JPopupMenu(MENU_HEADER_POPUP);
             preparePopupMenu(pm);
         } else {
             JMenuBar mb = new JMenuBar();
             prepareMenuBar(mb);
-            ((JFrame)parent).setJMenuBar(mb);
+            
+	      // [CYCLADES-START]
+            // Modified by Eduardo Murai Soares 
+            // Swing Menu is no longer set directly in the Frame but
+            // it is added to the container instead (for applet).
+            
+            //((JFrame)parent).setJMenuBar(mb); // CODE COMMENTED
+            
+            if (appletMode) {
+            	if (super.getMindterm().getAppContainer() instanceof javax.swing.JFrame) {
+            		javax.swing.JFrame frm = (javax.swing.JFrame) super.getMindterm().getAppContainer();
+            		frm.getContentPane().add(mb, BorderLayout.NORTH);
+            		}            		
+            	else super.getMindterm().getAppContainer().add(mb, BorderLayout.NORTH);
+            	}
+            else 
+            //((JFrame)parent).setJMenuBar(mb);
+            mindterm.add(mb,BorderLayout.NORTH);
+            // [CYCLADES-END]
+	    
         }        
     }
 
@@ -66,10 +85,10 @@
 	mb.add((JMenuItem) ((TerminalMenuHandlerFull)term.getMenus()).getMenu
                (TerminalMenuHandlerFull.MENU_EDIT));
 	mb.add(getMenu(MENU_SETTINGS));
-	JMenu pm = getPluginMenu();
+	/*JMenu pm = getPluginMenu();
 	if (pm != null)
 	    mb.add(pm);
-	mb.add(getMenu(MENU_TUNNELS));
+	mb.add(getMenu(MENU_TUNNELS));*/
 	mb.add(getMenu(MENU_HELP));
 	term.updateMenus();
     }
@@ -81,11 +100,11 @@
             (JMenuItem)((TerminalMenuHandlerFull)term.getMenus()).getMenu
             (TerminalMenuHandlerFull.MENU_EDIT));
 	popupmenu.add(getMenu(MENU_SETTINGS));
-	JMenu pm = getPluginMenu();
+	/*JMenu pm = getPluginMenu();
 	if (pm != null) {
 	    popupmenu.add(pm);
 	}
-	popupmenu.add(getMenu(MENU_TUNNELS));
+	popupmenu.add(getMenu(MENU_TUNNELS));*/
 	popupmenu.addSeparator();
 	popupmenu.add(getMenu(MENU_HELP));
         term.getMenus().setPopupMenu(popupmenu);
@@ -159,7 +178,9 @@
     }
 
     protected void setEnabled(int i, int j, boolean v) {
-        ((JMenuItem)menuItems[i][j]).setEnabled(v);
+    	if(menuItems!=null) {
+    		((JMenuItem)menuItems[i][j]).setEnabled(v);
+    	}
     }
 
     protected void setState(int i, int j, boolean v) {
@@ -173,7 +194,14 @@
     protected void updatePluginMenu() {
 	for (int i = 0; i < modCnt; i++)
 	    if (getModuleLabel(i) != null)
-		modMenuItems[i].setEnabled(modules[i].isAvailable(client));
+			// [CYCLADES-START] : this code is necessary to avoid NullPointer exception (!??)
+			{
+			if (modMenuItems[i]==null || modules[i]==null) continue;
+	    	// [CYCLADES-END]
+			modMenuItems[i].setEnabled(modules[i].isAvailable(client));
+			// [CYCLADES-START]
+			}
+			// [CYCLADES-END]
     }
 
     protected String getMenuLabel(Object o) {
@@ -205,7 +233,7 @@
     private JCheckBox   cbSaveAlias;
     private JTextField  textPort, textUser, textAlias, textPrivateKey, textPrivateHostKey;
     private JPasswordField textPwd;
-    private JButton     customBtn;
+    private JButton     customBtn, browseBtn;
     private CardLayout  authLabelCL, authCL;
     private JPanel      authLabelCP, authCP;
     private String      customAuth;
@@ -1078,6 +1106,21 @@
 	cbForcPty.setSelected(ph.getPropertyB("forcpty"));
     }
 
+    private void updateCheckedText(JCheckBox cb, JTextField text,
+                                   String propName) {
+	if (!text.isEnabled()) {
+	    if (cb.isSelected()) {
+		text.setText(ph.getProperty(propName));
+	    } else {
+		text.setText(ph.getDefaultProperty(propName));
+	    }
+	}
+	text.setEnabled(cb.isEnabled() && cb.isSelected());
+	if (!text.isEnabled()) {
+	    text.setText(ph.getDefaultProperty(propName));
+	}
+    }
+
     private void checkSupportedByPeer() throws Exception {
 	checkSupportedByPeer(SSH2Preferences.CIPHERS_C2S, comboCipherC2S);
 	checkSupportedByPeer(SSH2Preferences.CIPHERS_S2C, comboCipherS2C);
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHMenuHandler.java mindterm_3.1.2/com/mindbright/ssh/SSHMenuHandler.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHMenuHandler.java	2005-10-07 03:10:44.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/ssh/SSHMenuHandler.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,7 @@
 
 package com.mindbright.ssh;
 
+import java.awt.Container;
 import java.awt.Frame;
 // import java.awt.MenuBar;
 // import java.awt.PopupMenu;
@@ -31,7 +32,11 @@
                               Frame parent, TerminalWin term);
     public abstract void update();    
     public void close(TerminalMenuHandler originMenu) {}
-    public abstract void setupMenuBar(boolean usePopupMenu);
+    public abstract void setupMenuBar(boolean usePopupMenu
+		//  [CYCLADES-START]	
+        	, boolean appletMode
+       	//  [CYCLADES-END]	
+		);
     
     public abstract void setPopupButton(int popButtonNum);
     public abstract int getPopupButton();
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh/SSHPropertyHandler.java mindterm_3.1.2/com/mindbright/ssh/SSHPropertyHandler.java
--- mindterm_3.1.2.org/com/mindbright/ssh/SSHPropertyHandler.java	2006-12-08 00:15:12.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh/SSHPropertyHandler.java	2009-06-18 12:10:45.000000000 -0700
@@ -25,6 +25,7 @@
 import java.net.Socket;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.net.URL;
 
 import java.util.Hashtable;
 import java.util.Properties;
@@ -58,10 +59,35 @@
     "3des-ctr,3des-cbc," +
     "arcfour128,arcfour256,arcfour";
 
+    private Properties privateProperties = new Properties(); //VDN 2/4/08: Use this to go around the global defaultProperties
+
     static public final Properties defaultProperties = new Properties();
     static public final Hashtable  defaultPropNames  = new Hashtable();
     static public final Hashtable  oldPropNames      = new Hashtable();
-    static public final String[][] defaultPropDesc = {
+    
+    static public 
+    //  [CYCLADES-START] 
+    // final 
+    //  [CYCLADES-END]
+    	String[][] defaultPropDesc = {
+			//  [CYCLADES-START] : it is necessary to register the mindterm parameters (applet or application)			
+    			{ "breakseq", ""},
+    			{"lockOutlet",""}, 
+    			{"unlockOutlet",""},
+    			{"powerOn",""},
+    			{"powerOff",""}, 
+    			{"powerCycle",""}, 
+    			{"powerStatus",""},
+    			{ "unit", ""},
+    			{ "parma", ""},
+    			{ "parmb", ""},
+    			{ "force-swing", "false"},
+    			{ "window-size", ""},
+    			{ "skipPasswordMethod", "false"},
+    			{ "phys-port-auth", "single" },
+    			{ "ie", "false" },
+    			{ "ems", "disable" },
+    			// [CYCLADES-END]	
                 { "protocol",         "auto"                                },
                 { "server",           null                                  },
                 { "real-server",      null                                  },
@@ -122,24 +148,29 @@
 
                 { "allow-new-server", "true"},
                 { "jar-path", "."},
-                { "module0", "com.mindbright.application.ModuleTelnet" },
-                { "module1", "com.mindbright.application.ModuleSFTP" },
-                { "module2", "com.mindbright.application.ModuleSCP" },
-                { "module3", "com.mindbright.application.ModuleFTPOverSFTP" },
-                { "module4", "com.mindbright.application.ModuleSocksProxy" },
-                { "module5", "com.mindbright.application.ModuleTelnetProxy" },
-                { "module6", "com.mindbright.application.ModuleTerminal" },
-                { "module0.label", "Telnet Terminal" },
-                { "module1.label", "SFTP File Transfer..." },
-                { "module2.label", "SCP File Transfer..." },
-                { "module3.label", "FTP To SFTP Bridge..." },
-                { "module4.label", "SOCKS Proxy..." },
-                { "module5.label", "Telnet Proxy..." },
+                //{ "module0", "com.mindbright.application.ModuleTelnet" },
+                { "module0", "com.mindbright.application.ModuleSFTP" },
+                { "module1", "com.mindbright.application.ModuleSCP" },
+                { "module2", "com.mindbright.application.ModuleFTPOverSFTP" },
+                { "module3", "com.mindbright.application.ModuleSocksProxy" },
+                { "module4", "com.mindbright.application.ModuleTelnetProxy" },
+                { "module5", "com.mindbright.application.ModuleTerminal" },
+                //{ "module0.label", "Telnet Terminal" },
+                { "module0.label", "SFTP File Transfer..." },
+                { "module1.label", "SCP File Transfer..." },
+                { "module2.label", "FTP To SFTP Bridge..." },
+                { "module3.label", "SOCKS Proxy..." },
+                { "module4.label", "Telnet Proxy..." },
                 { "module.telnet.inhibit", "false" },
                 { "module.telnet.havemenus", "true" },
                 { "module.terminal.havemenus", "true" },
                 { "module.scp.cwd-local", null },
-                { "module.sftp.cwd-local", null }
+                { "module.sftp.cwd-local", null },
+                { "module.telnet.host", null },
+                { "module.telnet.port", null },
+                { "fg-color",     "white" },
+                { "bg-color",     "black" },
+                { "cursor-color", "green" }
             };
 
     static {
@@ -169,7 +200,7 @@
         oldPropNames.put("display", "x11-display");
     }
 
-    public static String backwardCompatProp(String key) {
+    private static String backwardCompatProp(String key) {
         String newName = (String)oldPropNames.get(key);
         if(newName != null) {
             key = newName;
@@ -177,13 +208,14 @@
         return key;
     }
 
-    public static void setAsDefault(Properties props) {
+    private void setAsDefault(Properties props) {
         Enumeration e = props.keys();
         while(e.hasMoreElements()) {
             String name  = (String)e.nextElement();
             String value = props.getProperty(name);
             name = backwardCompatProp(name);
-            defaultProperties.put(name, value);
+            //defaultProperties.put(name, value);
+            privateProperties.put(name, value);		// VDN
         }
     }
 
@@ -210,6 +242,7 @@
     public Properties initTermProps;
 
     protected boolean propsChanged;
+	private Properties apmProps;
 
     public SSHPropertyHandler(Properties initProps, boolean setAsDefault) {
         this.knownHosts = SSH.KNOWN_HOSTS_FILE;
@@ -236,10 +269,43 @@
     public static SSHPropertyHandler fromFile(String fileName, String password) throws IOException {
         SSHPropertyHandler fileProps = new SSHPropertyHandler(new Properties(),
                                        false);
+
+        if(SSH.DEBUG) System.out.println("filename: \""+fileName+"\"");
+        // [CYCLADES-START] : This is called when using properties file, e.g. Application in JavaWebStart
+        SSHPropertyHandler defaultProps = new SSHPropertyHandler(new Properties(), false);
+        defaultProps.resetToDefaults();
+        // [CYCLADES-END]
+	
         fileProps.setPropertyPassword(password);
         fileProps.loadAbsoluteFile(fileName, false);
 
-        setAsDefault(fileProps.props);
+	// [CYCLADES-START]
+        fileProps.mergeProperties(defaultProps.getProperties());
+        // [CYCLADES-END]
+	
+        //setAsDefault(fileProps.props);
+
+        return fileProps;
+    }
+
+    public static SSHPropertyHandler fromURL(URL url, String password) throws IOException {
+        SSHPropertyHandler fileProps = new SSHPropertyHandler(new Properties(),
+                                       false);
+
+        if(SSH.DEBUG) System.out.println("URL: \""+url.toString()+"\"");
+        // [CYCLADES-START] : This is called when using properties file, e.g. Application in JavaWebStart
+        SSHPropertyHandler defaultProps = new SSHPropertyHandler(new Properties(), false);
+        defaultProps.resetToDefaults();
+        // [CYCLADES-END]
+	
+        fileProps.setPropertyPassword(password);
+        fileProps.loadURL(url, false);
+
+	// [CYCLADES-START]
+        fileProps.mergeProperties(defaultProps.getProperties());
+        // [CYCLADES-END]
+	
+        //setAsDefault(fileProps.props);
 
         return fileProps;
     }
@@ -356,7 +422,8 @@
         Enumeration e = defaultPropNames.keys();
         while(e.hasMoreElements()) {
             String name  = (String)e.nextElement();
-            String value = defaultProperties.getProperty(name);
+            String value = privateProperties.getProperty(name);
+            if(value == null) value = defaultProperties.getProperty(name);
             if(value != null) {
                 setProperty(name, value);
             } else {
@@ -367,6 +434,18 @@
         if(term != null) {
             term.resetToDefaults();
         }
+        
+        // [CYCLADES-START]
+        Properties defaultPropsFromJAR = new Properties();
+        try {        	
+        	defaultPropsFromJAR.load(this.getClass().getResourceAsStream("/defaults/default.properties"));
+        	mergeProperties(defaultPropsFromJAR);
+        	term.setProperties(defaultPropsFromJAR, true);
+        } catch (Exception ex) {
+        	System.out.println("Warning: it was not possible to load default properties - ");
+        	ex.printStackTrace();
+        }
+        // [CYCLADES-END]
     }
 
     public static boolean isProperty(String key) {
@@ -381,7 +460,9 @@
 
     public String getProperty(String key) {
         key = backwardCompatProp(key);
-        return props.getProperty(key);
+	String value = (String) props.getProperty(key);
+	if (value == null) value = getDefaultProperty(key);
+	return value;
     }
 
     public boolean getPropertyB(String key) {
@@ -396,12 +477,15 @@
 
     public String getDefaultProperty(String key) {
         key = backwardCompatProp(key);
-        return (String)defaultProperties.get(key);
+	String value = (String) privateProperties.get(key);
+	if (value == null) value = (String) defaultProperties.get(key);
+	return value;
     }
 
     public void setDefaultProperty(String key, String value) {
         key = backwardCompatProp(key);
-        defaultProperties.put(key, value);
+	//defaultProperties.put(key, value);
+	privateProperties.put(key, value);
     }
 
     public void resetProperty(String key) {
@@ -585,6 +669,7 @@
     public void setProperties(Properties newProps) throws IllegalArgumentException,
         NoSuchElementException {
         props = new EncryptedProperties(defaultProperties);
+	mergeProperties(privateProperties);
         mergeProperties(newProps);
     }
 
@@ -651,6 +736,23 @@
         activeProps = false;
     }
 
+    // [CYCLADES-START] : new method to export the properties
+    public Properties getPropsForSaving() {
+    TerminalWindow   term      = getTerminal();
+    Properties       termProps = (term != null ? term.getProperties() : null);
+
+    if(termProps != null) {
+        Enumeration e = termProps.keys();
+        while(e.hasMoreElements()) {
+            String key = (String)e.nextElement();
+            String val = termProps.getProperty(key);
+            props.put(key, val);
+        	}
+    	}
+    return props;
+    }    
+    // [CYCLADES-END]
+    
     private void saveProperties(String fname) throws IOException {
         FileOutputStream f;
         TerminalWindow   term      = getTerminal();
@@ -701,17 +803,41 @@
         interactor.propsStateChanged(this);
     }
 
+    // [CYCLADES-START] 
+    /**
+     * Emulate 'load properties' for APM properties.
+     * 
+     * @param papmProps Properties loaded from APM database
+     */
+    public void mergeAPMProperties(Properties papmProps) throws IOException {
+    	try {
+    	apmProps = papmProps;    	
+    	loadProperties(null, false);
+    	} finally {
+    		apmProps = null;
+    	}
+    }
+    // [CYCLADES-END]
+    
     private void loadProperties(String fname, boolean promptPwd) throws IOException {
         TerminalWindow term = getTerminal();
-
+    
+        // [CYCLADES-START]
+        EncryptedProperties loadProps = new EncryptedProperties();
+        
+        if (apmProps!=null) 
+        	loadProps.putAll(apmProps);        
+        else {
+        //  [CYCLADES-END]
+        
         FileInputStream f     = new FileInputStream(fname);
         byte[]          bytes = new byte[f.available()];
         f.read(bytes);
         ByteArrayInputStream bytein = new ByteArrayInputStream(bytes);
         f.close();
-
-        EncryptedProperties loadProps = new EncryptedProperties();
-
+        
+        // CYCLADES: CODE MOVED TO THE BEGINNING
+        // EncryptedProperties loadProps = new EncryptedProperties();
         try {
             loadProps.load(bytein, "");
         } catch (SSHAccessDeniedException e) {
@@ -735,7 +861,10 @@
         }
 
         savePasswords = !loadProps.isNormalPropsFile();
-
+        // [CYCLADES-START]
+        }
+        // [CYCLADES-END]
+        
         String      name;
         String      value;
 
@@ -780,6 +909,96 @@
             interactor.propsStateChanged(this);
     }
 
+    private void loadPropertiesURL(URL url, boolean promptPwd) throws IOException {
+        TerminalWindow term = getTerminal();
+    
+        // [CYCLADES-START]
+        EncryptedProperties loadProps = new EncryptedProperties();
+        
+        if (apmProps!=null) 
+        	loadProps.putAll(apmProps);        
+        else {
+        //  [CYCLADES-END]
+        
+        InputStream u   = url.openStream();
+        byte[]          bytes = new byte[u.available()];
+        u.read(bytes);
+        ByteArrayInputStream bytein = new ByteArrayInputStream(bytes);
+        u.close();
+        
+        // CYCLADES: CODE MOVED TO THE BEGINNING
+        // EncryptedProperties loadProps = new EncryptedProperties();
+        try {
+            loadProps.load(bytein, "");
+        } catch (SSHAccessDeniedException e) {
+            try {
+                bytein.reset();
+                loadProps.load(bytein, propertyPassword);
+            } catch (SSHAccessDeniedException ee) {
+                try {
+                    if(promptPwd) {
+                        bytein.reset();
+                        propertyPassword = interactor.promptPassword("URL " + url.toString() + " password: ");
+                        loadProps.load(bytein, propertyPassword);
+                    } else {
+                        throw new SSHAccessDeniedException("");
+                    }
+                } catch (SSHAccessDeniedException eee) {
+                    clearServerSetting();
+                    throw new SSHClient.AuthFailException("Access denied for '" + url.toString() + "'");
+                }
+            }
+        }
+
+        savePasswords = !loadProps.isNormalPropsFile();
+        // [CYCLADES-START]
+        }
+        // [CYCLADES-END]
+        
+        String      name;
+        String      value;
+
+        Properties sshProps  = new Properties();
+        Properties termProps = new Properties();
+
+        Enumeration e = loadProps.keys();
+        while(e.hasMoreElements()) {
+            name  = (String)e.nextElement();
+            value = loadProps.getProperty(name);
+
+            if(isProperty(name)) {
+                name = backwardCompatProp(name);
+                sshProps.put(name, value);
+            } else if(TerminalWin.isProperty(name)) {
+                name = TerminalDefProps.backwardCompatProp(name);
+                termProps.put(name, value);
+            } else {
+                if(interactor != null)
+                    interactor.report("Unknown property '" + name + "' found in URL: " + url.toString());
+                else
+                    System.out.println("Unknown property '" + name + "' found in URL: " + url.toString());
+            }
+        }
+
+        if(client != null)
+            client.clearAllForwards();
+
+        passivateProperties();
+
+        setProperties(sshProps);
+
+        initTermProps = termProps;
+
+        if(term != null) {
+            term.setProperties(initTermProps, false);
+            term.setPropsChanged(false);
+        }
+
+        propsChanged = false;
+        if(interactor != null)
+            interactor.propsStateChanged(this);
+    }
+
     final void clearPasswords() {
         props.remove("password");
         props.remove("tispassword");
@@ -847,6 +1066,15 @@
             interactor.propsStateChanged(this);
     }
 
+    public void loadURL(URL url, boolean promptPwd) throws IOException {
+        currentAlias     = null;
+        currentPropsFile = url.toString();
+
+        loadPropertiesURL(url, promptPwd);
+        if(interactor != null)
+            interactor.propsStateChanged(this);
+    }
+
     public void setAlias(String alias) {
         if(sshHomeDir == null)
             return;
@@ -1337,14 +1565,16 @@
     void showFingerprint(byte[] blob, String type) {
         StringBuffer msg = new StringBuffer();
 
-        msg.append("\r\nServer's hostkey (" + type + ") fingerprint:\r\n");
-        msg.append("openssh md5:  ");
-        msg.append(SSH2KeyFingerprint.md5Hex(blob));
-
-        msg.append("\r\nbubblebabble: ");
-        msg.append(SSH2KeyFingerprint.bubbleBabble(blob));
-
-        interactor.report(msg.toString());
+	// [CYCLADES-START] : Lines commented
+        // msg.append("\r\nServer's hostkey (" + type + ") fingerprint:\r\n");
+        //msg.append("openssh md5:  ");
+        //msg.append(SSH2KeyFingerprint.md5Hex(blob));
+
+        //msg.append("\r\nbubblebabble: ");
+        //msg.append(SSH2KeyFingerprint.bubbleBabble(blob));
+	// [CYCLADES-END]
+	
+       // interactor.report(msg.toString());
     }
 
     //
@@ -1488,11 +1718,13 @@
 
         activateProperties();
 
-        if(currentPropsFile != null) {
-            interactor.report("Current settings file: '" +
-                              currentPropsFile + "'");
-        }
-
+	// [CYCLADES-START]: code commented
+        // if(currentPropsFile != null) {
+        //    interactor.report("Current settings file: '" +
+        //                      currentPropsFile + "'");
+        // }
+	// [CYCLADES-END]
+	
         return host;
     }
 
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2Authenticator.java mindterm_3.1.2/com/mindbright/ssh2/SSH2Authenticator.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2Authenticator.java	2005-10-04 01:07:57.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2Authenticator.java	2009-06-18 12:10:45.000000000 -0700
@@ -39,7 +39,15 @@
     private Vector    methodList  = new Vector();
 
     private String username;
-
+    
+//  [CYCLADES-START]
+    private boolean skipPasswordMethod;
+    
+	public void setSkipPasswordMethod(boolean v) {
+		skipPasswordMethod = v;
+	}
+//	 [CYCLADES-END]
+	
     /**
      * Special constructor for creating an "anonymouse" authenticator. Note,
      * when using this constructor the username has to be set before
@@ -64,9 +72,17 @@
     public synchronized String getMethods() {
         StringBuffer buf = new StringBuffer();
         for(int i = 0; i < methodList.size(); i++) {
-            buf.append(methodList.elementAt(i));
+            
+        	// [CYCLADES-START] : password method was removed because it does not use the PAM in the server side.
+        	if (skipPasswordMethod) {
+        		String m = (String) methodList.elementAt(i);
+        		if (m!=null && m.equals("password")) continue;
+        		}
+        	// [CYCLADES-STOP]
+        	
+        	buf.append(methodList.elementAt(i));        	
             if(i < methodList.size() - 1)
-                buf.append(",");
+                buf.append(",");        	        	
         }
         return buf.toString();
     }
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2AuthHostBased.java mindterm_3.1.2/com/mindbright/ssh2/SSH2AuthHostBased.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2AuthHostBased.java	2006-01-03 02:53:45.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2AuthHostBased.java	2009-06-18 12:10:45.000000000 -0700
@@ -66,7 +66,7 @@
         pdu.writeString(signer.getAlgorithmName());
         pdu.writeString(keyBlob);
         pdu.writeString(userAuth.getTransport().getLocalHostName());
-        pdu.writeString(System.getProperty("user.name", ""));
+        pdu.writeUTF8String(System.getProperty("user.name", ""));
         
         signPDU(userAuth, pdu, signer, keyBlob);
 
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2AuthKbdInteract.java mindterm_3.1.2/com/mindbright/ssh2/SSH2AuthKbdInteract.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2AuthKbdInteract.java	2005-09-06 06:02:39.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2AuthKbdInteract.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,8 @@
 
 package com.mindbright.ssh2;
 
+import com.mindbright.ssh.SSHInteractiveClient;
+
 /**
  * This class implements a module for keyboard-interactive authentication as
  * defined in the auth-kbdinteract protocol spec. It uses the interface
@@ -75,13 +77,28 @@
                 echos[i]   = pdu.readBoolean();
             }
 
-            String[] answers = interactor.promptMultiFull(name, instruction,
-                               prompts, echos);
+            // [CYCLADES-START] : Prompt blocked. Client must use keyboard-interactive instead of password authentication method.
+            //                    However the password is provided by APMWEB. If such password is not null, it is gonna be used.            
+            // String[] answers = interactor.promptMultiFull(name, instruction,
+            //                   prompts, echos);
+            String[] answers = null;
+            
+            if (numPrompts>0 && interactor instanceof SSHInteractiveClient) {
+            	SSHInteractiveClient intSSH = (SSHInteractiveClient) interactor;
+            	String passwd = intSSH.propsHandler.getProperty("password");
+            	
+            	if (passwd!=null && !passwd.trim().equals("")) {
+            		 answers = new String[] { passwd };
+            	}
+            }            
+            while (answers == null) answers = interactor.promptMultiFull(name, instruction, prompts, echos);
+            // [CYCLADES-END]
+            
             pdu = SSH2TransportPDU.
                   createOutgoingPacket(SSH2.MSG_USERAUTH_INFO_RESPONSE);
             pdu.writeInt(answers.length);
             for(i = 0; i < answers.length; i++) {
-                pdu.writeString(answers[i]);
+                pdu.writeUTF8String(answers[i]);
                 answers[i] = null;
             }
             break;
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2AuthPassword.java mindterm_3.1.2/com/mindbright/ssh2/SSH2AuthPassword.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2AuthPassword.java	2005-11-17 05:34:33.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2AuthPassword.java	2009-06-18 12:10:45.000000000 -0700
@@ -120,7 +120,7 @@
     throws SSH2UserCancelException {
         switch(pdu.getType()) {
         case SSH2.MSG_USERAUTH_PASSWD_CHANGEREQ:
-            String prompt   = pdu.readJavaString();
+            String prompt   = pdu.readJavaString(); // FIXME: should be: readUTF8String()
             String language = pdu.readJavaString();
             pdu = createChangeRequest(userAuth, prompt, language);
             break;
@@ -139,7 +139,7 @@
     throws SSH2UserCancelException {
         SSH2TransportPDU pdu = userAuth.createUserAuthRequest(STANDARD_NAME);
         pdu.writeBoolean(false);
-        pdu.writeString(getPassword());
+        pdu.writeUTF8String(getPassword());
         return pdu;
     }
 
@@ -150,8 +150,8 @@
         SSH2TransportPDU pdu = userAuth.createUserAuthRequest(STANDARD_NAME);
         pdu.writeBoolean(true);
         if (password != null && newPassword != null) {
-            pdu.writeString(getPassword());
-            pdu.writeString(getNewPassword(prompt, language));
+            pdu.writeUTF8String(getPassword());
+            pdu.writeUTF8String(getNewPassword(prompt, language));
         } else {
             String prompts[] = new String[3];
             boolean echos[] = { false, false, false };
@@ -170,8 +170,8 @@
                     prompts, echos);            
                 badpass = "New passwords differs. ";
             } while ( false == passwords[1].equals(passwords[2]));
-            pdu.writeString(passwords[0]);
-            pdu.writeString(passwords[1]);
+            pdu.writeUTF8String(passwords[0]);
+            pdu.writeUTF8String(passwords[1]);
 
         }
         return pdu;
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2ConsoleRemote.java mindterm_3.1.2/com/mindbright/ssh2/SSH2ConsoleRemote.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2ConsoleRemote.java	2006-10-04 05:44:44.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2ConsoleRemote.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,7 @@
 
 package com.mindbright.ssh2;
 
+import com.mindbright.sshcommon.TimeoutException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
@@ -313,6 +314,23 @@
         return status;
     }
 
+    /**
+     * Waits for the command to finish within the given time.
+     * Cyclades change.
+     */
+    public int waitForExitStatus(long timeout) throws TimeoutException {
+        int status = session.waitForExit(timeout);
+        
+        if (!session.isFinished()) {
+            session.close();
+            throw new TimeoutException("command did not finish after " + timeout + " milliseconds");
+        }
+        
+        if(session != null) {
+            session.waitUntilClosed();
+        }
+        return status;
+    }
 
     /**
      * Send a BREAK to the remote session 
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2DataBuffer.java mindterm_3.1.2/com/mindbright/ssh2/SSH2DataBuffer.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2DataBuffer.java	2006-09-11 06:56:53.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2DataBuffer.java	2009-06-18 12:30:35.000000000 -0700
@@ -16,6 +16,9 @@
 package com.mindbright.ssh2;
 
 import java.math.BigInteger;
+import java.io.UnsupportedEncodingException;
+
+import com.mindbright.util.HexDump;
 
 /**
  * This class implements a read/write buffer with all protocol specific
@@ -26,6 +29,16 @@
     public final static int BOOLEAN_TRUE  = 1;
     public final static int BOOLEAN_FALSE = 0;
 
+    // UTF8-related constants
+    private static int UTF8_TWO_BYTE_ENCODING        = 0xC0;
+    private static int UTF8_THREE_BYTE_ENCODING      = 0xE0;
+    private static int UTF8_FOUR_BYTE_ENCODING       = 0xF0;
+    private static int UTF8_FIVE_BYTE_ENCODING       = 0xF8;
+    private static int UTF8_SIX_BYTE_ENCODING        = 0xFC;
+    private static int UTF8_EXTENDED_BYTE_ENCODING   = 0x80;
+
+
+
     protected byte[] data;
     protected int    rPos;
     protected int    wPos;
@@ -179,6 +192,7 @@
         }
     }
 
+
     public final String readJavaString() {
         int len = readInt();
         if(len < 0 || len > (data.length - rPos)) {
@@ -220,6 +234,86 @@
         System.arraycopy(str, off, data, wPos, len);
         wPos += len;
     }
+    public final void writeUTF8String(String str) {
+	byte [] result = String2UTF8(str);	
+        writeString(result, 0, result.length);
+    }
+
+    public static byte[] String2UTF8(String str) {
+        byte[] result;
+	try {
+		result = str.getBytes("UTF-8");
+		return result;
+	}
+	catch (UnsupportedEncodingException e) { }
+	
+        int len = str.length();
+        int p = 0;
+        byte[] t = new byte[6 * len];
+        /*
+         * U-00000000 U-0000007F: 0xxxxxxx
+         * U-00000080 U-000007FF: 110xxxxx 10xxxxxx
+         * U-00000800 U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
+         * U-00010000 U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+         * U-00200000 U-03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
+         * U-04000000 U-7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
+         */
+        for (int i = 0; i < len; i++) {
+            long chVal = str.charAt(i);
+
+            if (       (chVal >= 0x00000000) && (chVal <= 0x0000007F)) {
+                t[p++] = (byte)chVal;
+            } else if ((chVal >= 0x00000080) && (chVal <= 0x000007FF)) {
+                t[p++] = (byte) (UTF8_TWO_BYTE_ENCODING |
+                                       ((chVal >> 6)  & 0x1F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                        (chVal        & 0x3F));
+            } else if ((chVal >= 0x00000800) && (chVal <= 0x0000FFFF)) {
+                t[p++] = (byte) (UTF8_THREE_BYTE_ENCODING |
+                                       ((chVal >> 12) & 0x0F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >>  6) & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       (chVal         & 0x3F));
+            } else if ((chVal >= 0x00010000) && (chVal <= 0x001FFFFF)) {
+                t[p++] = (byte) (UTF8_FOUR_BYTE_ENCODING |
+                                       ((chVal >> 18) & 0x07));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 12) & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 6)  & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       (chVal         & 0x3F));
+            } else if ((chVal >= 0x00200000) && (chVal <= 0x03FFFFFF)) {
+                t[p++] = (byte) (UTF8_FIVE_BYTE_ENCODING |
+                                       ((chVal >> 24) & 0x03));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 18) & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 12) & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 6)  & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       (chVal         & 0x3F));
+            } else if ((chVal >= 0x04000000) && (chVal <= 0x7FFFFFFF)) {
+                t[p++] = (byte) (UTF8_SIX_BYTE_ENCODING |
+                                       ((chVal >> 30) & 0x01));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 24) & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 18) & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 12) & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       ((chVal >> 6)  & 0x3F));
+                t[p++] = (byte) (UTF8_EXTENDED_BYTE_ENCODING |
+                                       (chVal         & 0x3F));
+            }
+        }
+        result = new byte[p];
+	System.arraycopy(t,0,result,0,p);
+	return result;
+    }
 
     public final byte[] readRestRaw() {
         return readRaw(wPos - rPos);
@@ -244,5 +338,4 @@
         System.arraycopy(raw, off, data, wPos, len);
         wPos += len;
     }
-
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2Preferences.java mindterm_3.1.2/com/mindbright/ssh2/SSH2Preferences.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2Preferences.java	2006-12-08 00:15:12.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2Preferences.java	2009-06-18 12:10:45.000000000 -0700
@@ -222,7 +222,11 @@
         while(names.hasMoreElements()) {
             String name  = (String)names.nextElement();
             String value = props.getProperty(name);
-            preferences.put(name, value);
+	    
+	     // [CYCLADES-START]
+            if (value!=null)
+            //	[CYCLADES-STOP]
+            	preferences.put(name, value);
         }
     }
 
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2SessionChannel.java mindterm_3.1.2/com/mindbright/ssh2/SSH2SessionChannel.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2SessionChannel.java	2007-01-07 12:19:44.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2SessionChannel.java	2009-06-18 12:10:45.000000000 -0700
@@ -126,6 +126,19 @@
         }
     }
 
+    /**
+     * Checks if the last command has already finished.
+     * This can be used with the waitForExit(long timeout) method to know if
+     * that method has exited because the command was finished or because
+     * a the timeout.
+     * Cyclades change.
+     */
+    public boolean isFinished() {
+        synchronized (exitMonitor) {
+            return exited;
+        }
+    }
+
     public void changeStdOut(OutputStream out) {
         this.out = out;
     }
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2Transport.java mindterm_3.1.2/com/mindbright/ssh2/SSH2Transport.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2Transport.java	2006-12-08 00:15:13.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2Transport.java	2009-06-18 12:10:45.000000000 -0700
@@ -1744,8 +1744,30 @@
                          pdu.getData(),
                          pdu.getPayloadOffset(),
                          pdu.getPayloadLength());
+        /*try {
+            //IVAN: FAZER AQUI O TRATAMENTO PARA O XML DO EMS, POIS O EVENTO  INTERCEPTADO ANTES
+            //DE IR PARA O DISPLAY
+            //System.out.println(pdu.readJavaString());
+            String msg = new String (pdu.getData(), pdu.getPayloadOffset(),pdu.getPayloadLength());
+            
+            //TESTE !!!!!!!
+            if (msg.indexOf("<machine-info>") > -1){
+                javax.swing.JOptionPane.showMessageDialog(null, msg);
+            }
+            
+            //System.out.println("received message: " + msg);
+        }catch(Throwable er){
+        }*/
         return pdu;
     }
+    
+    public String readJavaStringLocal(SSH2TransportPDU pdu) {
+        int len = pdu.readInt();
+
+        String ret = new String(pdu.getData(), pdu.getRPos(), len);
+        //rPos += len;
+        return ret;
+    }
 
     private void shutdownTx() {
         if(isTxUp) {
diff -ruN mindterm_3.1.2.org/com/mindbright/ssh2/SSH2UserAuth.java mindterm_3.1.2/com/mindbright/ssh2/SSH2UserAuth.java
--- mindterm_3.1.2.org/com/mindbright/ssh2/SSH2UserAuth.java	2006-07-31 23:46:49.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/ssh2/SSH2UserAuth.java	2009-06-18 12:10:45.000000000 -0700
@@ -146,7 +146,14 @@
                         peerMethods = pdu.readJavaString();
                         partial     = pdu.readBoolean();
                         authenticator.peerMethods(peerMethods);
+                        
+                    // [CYCLADES-START] 
+                    /*Forces a password authentication*/
+                    if (peerMethods!=null && peerMethods.indexOf("password")==-1)
+                        peerMethods+=",password"; 
                     }
+                    // [CYCLADES-END]
+                    
                     retry = false;
 
                     transport.getLog().info("SSH2UserAuth",
@@ -197,7 +204,7 @@
                     break;
 
                 case SSH2.MSG_USERAUTH_BANNER:
-                    String msg = pdu.readJavaString();
+                    String msg = pdu.readJavaString(); // FIXME: should be: readUTF8String()
                     transport.getLog().warning("SSH2UserAuth", "banner: " +
                                                msg);
                     authenticator.displayBanner(msg);
@@ -297,7 +304,7 @@
     public SSH2TransportPDU createUserAuthRequest(String method) {
         SSH2TransportPDU pdu =
             SSH2TransportPDU.createOutgoingPacket(SSH2.MSG_USERAUTH_REQUEST);
-        pdu.writeString(user);
+        pdu.writeUTF8String(user);
         pdu.writeString(service);
         pdu.writeString(method);
         return pdu;
diff -ruN mindterm_3.1.2.org/com/mindbright/sshcommon/TimeoutException.java mindterm_3.1.2/com/mindbright/sshcommon/TimeoutException.java
--- mindterm_3.1.2.org/com/mindbright/sshcommon/TimeoutException.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/sshcommon/TimeoutException.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,36 @@
+/*
+ * TimeoutException.java
+ *
+ * Created on April 3, 2006, 11:43 AM
+ *
+ * To change this template, choose Tools | Template Manager
+ * and open the template in the editor.
+ */
+
+package com.mindbright.sshcommon;
+
+/**
+ * Exception thrown when a command does not finish in the given period of time.
+ * @author Constantino
+ */
+public class TimeoutException extends Exception {
+    
+    /** Creates a new instance of TimeoutException */
+ 
+    public TimeoutException() {
+        super();
+    }
+
+    public TimeoutException(String message) {
+        super(message);
+    }
+    
+    public TimeoutException(String message, Throwable cause) {
+        super(message,cause);
+    }
+
+    public TimeoutException(Throwable cause) {
+        super(cause);
+    }
+
+}
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/DisplayAWT.java mindterm_3.1.2/com/mindbright/terminal/DisplayAWT.java
--- mindterm_3.1.2.org/com/mindbright/terminal/DisplayAWT.java	2007-03-07 01:25:05.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/terminal/DisplayAWT.java	2009-06-18 12:10:45.000000000 -0700
@@ -18,6 +18,7 @@
 import java.awt.*;
 import java.awt.event.*;
 
+import java.util.Hashtable;
 
 public class DisplayAWT extends Canvas
     implements DisplayView, AdjustmentListener, MouseListener,
@@ -864,14 +865,19 @@
                         bgColor = origFgColor;
                     }
                     if ((attr & DisplayModel.ATTR_BGCOLOR) != 0) {
-                        fgColor = termColors[(attr & DisplayModel.MASK_BGCOL) 
-                                             >>> DisplayModel.SHIFT_BGCOL];
+                        fgColor = (attr & DisplayModel.ATTR_INVISIBLE)!=0 ?
+                        		  bgColor :
+                        		  termColors[(attr & DisplayModel.MASK_BGCOL) 
+                                               >>> DisplayModel.SHIFT_BGCOL];
                     } else {
-                        fgColor = origBgColor;
+                        fgColor = (attr & DisplayModel.ATTR_INVISIBLE)!=0 ?
+                        		  bgColor :
+                        		  origBgColor;
                     }
 
-                    if ((attr & DisplayModel.ATTR_LOWINTENSITY) != 0) {
-                        bgColor = DisplayUtil.makeDimmerColor(bgColor);
+                    if ((attr & DisplayModel.ATTR_LOWINTENSITY) != 0 &
+                    	(attr & DisplayModel.ATTR_INVISIBLE) == 0) {
+                        bgColor = makeDimmerColor(bgColor);
                     }
                     doDraw = true;
                 } else {
@@ -881,12 +887,15 @@
                         doDraw = true;
                     }
                     if((attr & DisplayModel.ATTR_FGCOLOR) != 0) {
-                        fgColor = termColors[(attr & DisplayModel.MASK_FGCOL) 
-                                             >>> DisplayModel.SHIFT_FGCOL];
+                        fgColor = (attr & DisplayModel.ATTR_INVISIBLE) != 0 ?
+                        		  bgColor :
+                        	      termColors[(attr & DisplayModel.MASK_FGCOL)  
+                                               >>> DisplayModel.SHIFT_FGCOL];
                     }
 
-                    if ((attr & DisplayModel.ATTR_LOWINTENSITY) != 0) {
-                        fgColor = DisplayUtil.makeDimmerColor(fgColor);
+                    if ((attr & DisplayModel.ATTR_LOWINTENSITY) != 0 &
+                    	(attr & DisplayModel.ATTR_INVISIBLE) == 0) {
+                        fgColor = makeDimmerColor(fgColor);
                     }
                 }
 
@@ -972,6 +981,215 @@
         }
     }
 
+    protected Hashtable dimmmedColors = new Hashtable();
+
+    protected Color makeDimmerColor(Color orgColor) {
+        if (orgColor == null) {
+            return null;
+        }
+
+        Color dimColor = (Color) dimmmedColors.get(orgColor);
+        if (dimColor != null) {
+            return dimColor;
+        }
+
+        // Can't use darker() method in Color, since it don't make
+        // black dimmer.
+
+        float hsbComps[] = Color.RGBtoHSB(orgColor.getRed(),
+                                          orgColor.getGreen(),
+                                          orgColor.getBlue(), null);
+        float hue = hsbComps[0];
+        float saturation = hsbComps[1];
+        float brightness = hsbComps[2];
+
+        if ((saturation*saturation + brightness*brightness) < 0.1) {
+            // orgColor is very dark, increate saturation and brightness
+            // to make it appear dimmer
+            saturation = (float) 0.3;
+            brightness = (float) 0.3;
+        } else {
+            brightness *= 0.50;
+        }
+
+        dimColor = Color.getHSBColor(hue, saturation, brightness);
+        dimmmedColors.put(orgColor, dimColor);
+
+        return dimColor;
+    }
+
+    private void drawTuplet(Graphics g, int x, int y, int x2, int y2, int bi,
+                            String s1, String s2) {
+        Font font = g.getFont();
+        g.setFont(new Font(font.getName(), font.getStyle(), font.getSize()/2));
+        g.drawString(s1, x+1, y+1 + bi/2);
+        g.drawString(s2, x2, y2 + bi/2);
+        g.setFont(font);
+    }
+
+    final void drawLineDrawChar(Graphics g, int x, int y, int bi, char c) {
+        int x2 = (x + (charWidth  / 2));
+        int y2 = (y + (charHeight / 2));
+        int xx = (x + charWidth);
+        int yy = (y + charHeight);
+
+        switch(c) {
+        case ' ': // Blank
+        case '_': // Blank
+            break;
+        case '`': // Diamond
+            int[] polyX = new int[4];
+            int[] polyY = new int[4];
+            polyX[0] = x2;
+            polyY[0] = y;
+            polyX[1] = xx;
+            polyY[1] = y2;
+            polyX[2] = x2;
+            polyY[2] = yy;
+            polyX[3] = x;
+            polyY[3] = y2;
+            g.fillPolygon(polyX, polyY, 4);
+            break;
+        case 'a': // Checker board (stipple)
+            for (int i=x; i<xx; i++) {
+                for (int j=y; j<yy; j++) {
+                    if ( ((i+j)%2) == 0) {
+                        g.fillRect(i, j, 1, 1);
+                    }
+                }
+            }
+            break;
+        case 'b': // Horizontal tab
+            drawTuplet(g, x, y, x2, y2, bi, "H", "T");
+            break;
+        case 'c': // Form Feed
+            drawTuplet(g, x, y, x2, y2, bi, "F", "F");
+            break;
+        case 'd': // Carriage Return
+            drawTuplet(g, x, y, x2, y2, bi, "C", "R");
+            break;
+        case 'e': // Line Feed
+            drawTuplet(g, x, y, x2, y2, bi, "L", "F");
+            break;
+        case 'f': { // Degrees
+            char[] ca = new char[1];
+            ca[0] = (char)0x00b0;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case 'g': { // Plus/Minus
+            char[] ca = new char[1];
+            ca[0] = (char)0x00b1;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case 'h': // New line
+            drawTuplet(g, x, y, x2, y2, bi, "N", "L");
+            break;
+        case 'i': // Vertical Tab
+            drawTuplet(g, x, y, x2, y2, bi, "V", "T");
+            break;
+        case 'j': // Lower right corner
+            g.drawLine(x2, y, x2, y2);
+            g.drawLine(x2, y2, x, y2);
+            break;
+        case 'k': // Upper right corner
+            g.drawLine(x, y2, x2, y2);
+            g.drawLine(x2, y2, x2, yy);
+            break;
+        case 'l': // Upper left corner
+            g.drawLine(x2, yy, x2, y2);
+            g.drawLine(x2, y2, xx, y2);
+            break;
+        case 'm': // Lower left corner
+            g.drawLine(x2, y, x2, y2);
+            g.drawLine(x2, y2, xx, y2);
+            break;
+        case 'n': // Cross center lines
+            g.drawLine(x2, y, x2, yy);
+            g.drawLine(x, y2, xx, y2);
+            break;
+        case 'o': // Horizontal line (top)
+            g.drawLine(x, y, xx, y);
+            break;
+        case 'p': // Horizontal line (top-half)
+            g.drawLine(x, (y+y2)/2, xx, (y+y2)/2);
+            break;
+        case 'q': // Horizontal line (center)
+            g.drawLine(x, y2, xx, y2);
+            break;
+        case 'r': // Horizontal line (bottom-half)
+            g.drawLine(x, (yy+y2)/2, xx, (yy+y2)/2);
+            break;
+        case 's': // Horizontal line (bottom)
+            g.drawLine(x, yy, xx, yy);
+            break;
+        case 't': // Left tee
+            g.drawLine(x2, y, x2, yy);
+            g.drawLine(x2, y2, xx, y2);
+            break;
+        case 'u': // Right tee
+            g.drawLine(x2, y, x2, yy);
+            g.drawLine(x, y2, x2, y2);
+            break;
+        case 'v': // Bottom tee
+            g.drawLine(x, y2, xx, y2);
+            g.drawLine(x2, y2, x2, y);
+            break;
+        case 'w': // Top tee
+            g.drawLine(x, y2, xx, y2);
+            g.drawLine(x2, y2, x2, yy);
+            break;
+        case 'x': // Vertical line
+            g.drawLine(x2, y, x2, yy);
+            break;
+        case 'y': { // Less than or equal
+            int dx = charWidth/5;
+            int dy = charHeight/5;
+            g.drawLine(x+dx, y2, xx-dx, y+2*dy);
+            g.drawLine(x+dx, y2, xx-dx, yy-2*dy);
+            g.drawLine(x+dx, y2+dy, xx-dx, yy-dy);
+            break;
+        }
+        case 'z': { // Greater than or equal
+            int dx = charWidth/5;
+            int dy = charHeight/5;
+            g.drawLine(xx-dx, y2, x+dx, y+2*dy);
+            g.drawLine(xx-dx, y2, x+dx, yy-2*dy);
+            g.drawLine(xx-dx, y2+dy, x+dx, yy-dy);
+            break;
+        }
+        case '{': { // Pi
+            char[] ca = new char[1];
+            ca[0] = (char)0x03c0;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case '|': { // Not equal
+            char[] ca = new char[1];
+            ca[0] = (char)0x2260;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case '}': { // UK pound
+            char[] ca = new char[1];
+            ca[0] = (char)0x00a3;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case '~': { // Center dot
+            char[] ca = new char[1];
+            ca[0] = (char)0x00b7;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        default:
+            if(DEBUG)
+                System.out.println("Unknown line-draw-char: " + c + " (" + ((int)c) + ")");
+            break;
+        }
+    }
+
     public void setPosition(int xPos, int yPos) {
         Dimension sDim  = Toolkit.getDefaultToolkit().getScreenSize();
         Dimension tDim  = getDimensionOfText(rows, cols);
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/DisplaySwing.java mindterm_3.1.2/com/mindbright/terminal/DisplaySwing.java
--- mindterm_3.1.2.org/com/mindbright/terminal/DisplaySwing.java	2007-03-07 01:25:05.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/terminal/DisplaySwing.java	2009-06-18 12:10:45.000000000 -0700
@@ -26,6 +26,9 @@
 import javax.swing.SwingUtilities;
 import javax.swing.WindowConstants;
 
+
+import java.util.Hashtable;
+
 public class DisplaySwing extends JPanel
     implements DisplayView, AdjustmentListener, MouseListener,
                MouseMotionListener, ComponentListener, FocusListener,
@@ -48,8 +51,13 @@
     private volatile boolean updateScrollbar = false;
 
     protected Container myPanel;
-    private JFrame  ownerFrame;
-
+    
+    
+    // [CYCLADES-START] : ownerFrame must be Frame otherwise will occur an error in Applet 
+    // 	private JFrame  ownerFrame;
+    	private Frame  ownerFrame;
+    //  [CYCLADES-END]
+    
     private boolean logoDraw;
     private Image   logoImg;
     private int     logoX;
@@ -185,8 +193,12 @@
 
         isDirty = false;
 
-        this.ownerFrame  = (JFrame)ownerFrame;
-
+        
+        // [CYCLADES-START] : ownerFrame must be Frame otherwise will occur an error in Applet
+        // this.ownerFrame  = (JFrame)ownerFrame;
+        this.ownerFrame  = ownerFrame;
+        // [CYCLADES-END] 
+        
         // !!! We don't receive the proper component-events on the Canvas IMHO?
         //
         ownerFrame.addComponentListener(this);
@@ -813,7 +825,6 @@
             Dimension dim = getSize();
             vpixels = dim.height;
             hpixels = dim.width;
-            System.out.println("h="+hpixels+" v="+vpixels);
             if (hpixels == 0 || vpixels == 0) {
                 return;
             }
@@ -905,14 +916,19 @@
                         bgColor = origFgColor;
                     }
                     if ((attr & DisplayModel.ATTR_BGCOLOR) != 0) {
-                        fgColor = termColors[(attr & DisplayModel.MASK_BGCOL)
-                                             >>> DisplayModel.SHIFT_BGCOL];
+                        fgColor = (attr & DisplayModel.ATTR_INVISIBLE)!=0 ?
+                        		  bgColor :
+                        		  termColors[(attr & DisplayModel.MASK_BGCOL)
+                                               >>> DisplayModel.SHIFT_BGCOL];
                     } else {
-                        fgColor = origBgColor;
+                        fgColor = (attr & DisplayModel.ATTR_INVISIBLE)!=0 ?
+                        		  bgColor :
+                        		  origBgColor;
                     }
 
-                    if ((attr & DisplayModel.ATTR_LOWINTENSITY) != 0) {
-                        bgColor = DisplayUtil.makeDimmerColor(bgColor);
+                    if ((attr & DisplayModel.ATTR_LOWINTENSITY) != 0 &
+                    	(attr & DisplayModel.ATTR_INVISIBLE) == 0 ) {
+                        bgColor = makeDimmerColor(bgColor);
                     }
                     doDraw = true;
                 } else {
@@ -922,13 +938,16 @@
                         doDraw = true;
                     }
                     if ((attr & DisplayModel.ATTR_FGCOLOR) != 0) {
-                        fgColor = termColors[(attr & DisplayModel.MASK_FGCOL)
-                                             >>> DisplayModel.SHIFT_FGCOL];
+                        fgColor = (attr & DisplayModel.ATTR_INVISIBLE)!=0 ?
+                        		  bgColor :
+                        	      termColors[(attr & DisplayModel.MASK_FGCOL)
+                                               >>> DisplayModel.SHIFT_FGCOL];
                         doDraw = true;
                     }
 
-                    if ((attr & DisplayModel.ATTR_LOWINTENSITY) != 0) {
-                        fgColor = DisplayUtil.makeDimmerColor(fgColor);
+                    if ((attr & DisplayModel.ATTR_LOWINTENSITY) != 0 &
+                    	(attr & DisplayModel.ATTR_INVISIBLE) == 0 ) {
+                        fgColor = makeDimmerColor(fgColor);
                         doDraw = true;
                     }
                 }
@@ -1072,6 +1091,214 @@
         }
     }
     
+    protected Hashtable dimmmedColors = new Hashtable();
+
+    protected Color makeDimmerColor(Color orgColor) {
+        if (orgColor == null) {
+            return null;
+        }
+
+        Color dimColor = (Color) dimmmedColors.get(orgColor);
+        if (dimColor != null) {
+            return dimColor;
+        }
+
+        // Can't use darker() method in Color, since it don't make
+        // black dimmer.
+
+        float hsbComps[] = Color.RGBtoHSB(orgColor.getRed(),
+                                          orgColor.getGreen(),
+                                          orgColor.getBlue(), null);
+        float hue = hsbComps[0];
+        float saturation = hsbComps[1];
+        float brightness = hsbComps[2];
+
+        if ((saturation*saturation + brightness*brightness) < 0.1) {
+            // orgColor is very dark, increate saturation and brightness
+            // to make it appear dimmer
+            saturation = (float) 0.3;
+            brightness = (float) 0.3;
+        } else {
+            brightness *= 0.50;
+        }
+
+        dimColor = Color.getHSBColor(hue, saturation, brightness);
+        dimmmedColors.put(orgColor, dimColor);
+
+        return dimColor;
+    }
+
+    private void drawTuplet(Graphics g, int x, int y, int x2, int y2, int bi,
+                            String s1, String s2) {
+        Font font = g.getFont();
+        g.setFont(new Font(font.getName(), font.getStyle(), font.getSize()/2));
+        g.drawString(s1, x+1, y+1 + bi/2);
+        g.drawString(s2, x2, y2 + bi/2);
+        g.setFont(font);
+    }
+
+    final void drawLineDrawChar(Graphics g, int x, int y, int bi, char c) {
+        int x2 = (x + (charWidth  / 2));
+        int y2 = (y + (charHeight / 2));
+        int xx = (x + charWidth);
+        int yy = (y + charHeight);
+
+        switch(c) {
+        case ' ': // Blank
+        case '_': // Blank
+            break;
+        case '`': // Diamond
+            int[] polyX = new int[4];
+            int[] polyY = new int[4];
+            polyX[0] = x2;
+            polyY[0] = y;
+            polyX[1] = xx;
+            polyY[1] = y2;
+            polyX[2] = x2;
+            polyY[2] = yy;
+            polyX[3] = x;
+            polyY[3] = y2;
+            g.fillPolygon(polyX, polyY, 4);
+            break;
+        case 'a': // Checker board (stipple)
+            for (int i=x; i<xx; i++) {
+                for (int j=y; j<yy; j++) {
+                    if ( ((i+j)%2) == 0) {
+                        g.fillRect(i, j, 1, 1);
+                    }
+                }
+            }
+            break;
+        case 'b': // Horizontal tab
+            drawTuplet(g, x, y, x2, y2, bi, "H", "T");
+            break;
+        case 'c': // Form Feed
+            drawTuplet(g, x, y, x2, y2, bi, "F", "F");
+            break;
+        case 'd': // Carriage Return
+            drawTuplet(g, x, y, x2, y2, bi, "C", "R");
+            break;
+        case 'e': // Line Feed
+            drawTuplet(g, x, y, x2, y2, bi, "L", "F");
+            break;
+        case 'f': { // Degrees
+            char[] ca = new char[1];
+            ca[0] = (char)0x00b0;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case 'g': { // Plus/Minus
+            char[] ca = new char[1];
+            ca[0] = (char)0x00b1;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case 'h': // New line
+            drawTuplet(g, x, y, x2, y2, bi, "N", "L");
+            break;
+        case 'i': // Vertical Tab
+            drawTuplet(g, x, y, x2, y2, bi, "V", "T");
+            break;
+        case 'j': // Lower right corner
+            g.drawLine(x2, y, x2, y2);
+            g.drawLine(x2, y2, x, y2);
+            break;
+        case 'k': // Upper right corner
+            g.drawLine(x, y2, x2, y2);
+            g.drawLine(x2, y2, x2, yy);
+            break;
+        case 'l': // Upper left corner
+            g.drawLine(x2, yy, x2, y2);
+            g.drawLine(x2, y2, xx, y2);
+            break;
+        case 'm': // Lower left corner
+            g.drawLine(x2, y, x2, y2);
+            g.drawLine(x2, y2, xx, y2);
+            break;
+        case 'n': // Cross center lines
+            g.drawLine(x2, y, x2, yy);
+            g.drawLine(x, y2, xx, y2);
+            break;
+        case 'o': // Horizontal line (top)
+            g.drawLine(x, y, xx, y);
+            break;
+        case 'p': // Horizontal line (top-half)
+            g.drawLine(x, (y+y2)/2, xx, (y+y2)/2);
+            break;
+        case 'q': // Horizontal line (center)
+            g.drawLine(x, y2, xx, y2);
+            break;
+        case 'r': // Horizontal line (bottom-half)
+            g.drawLine(x, (yy+y2)/2, xx, (yy+y2)/2);
+            break;
+        case 's': // Horizontal line (bottom)
+            g.drawLine(x, yy, xx, yy);
+            break;
+        case 't': // Left tee
+            g.drawLine(x2, y, x2, yy);
+            g.drawLine(x2, y2, xx, y2);
+            break;
+        case 'u': // Right tee
+            g.drawLine(x2, y, x2, yy);
+            g.drawLine(x, y2, x2, y2);
+            break;
+        case 'v': // Bottom tee
+            g.drawLine(x, y2, xx, y2);
+            g.drawLine(x2, y2, x2, y);
+            break;
+        case 'w': // Top tee
+            g.drawLine(x, y2, xx, y2);
+            g.drawLine(x2, y2, x2, yy);
+            break;
+        case 'x': // Vertical line
+            g.drawLine(x2, y, x2, yy);
+            break;
+        case 'y': { // Less than or equal
+            int dx = charWidth/5;
+            int dy = charHeight/5;
+            g.drawLine(x+dx, y2, xx-dx, y+2*dy);
+            g.drawLine(x+dx, y2, xx-dx, yy-2*dy);
+            g.drawLine(x+dx, y2+dy, xx-dx, yy-dy);
+            break;
+        }
+        case 'z': { // Greater than or equal
+            int dx = charWidth/5;
+            int dy = charHeight/5;
+            g.drawLine(xx-dx, y2, x+dx, y+2*dy);
+            g.drawLine(xx-dx, y2, x+dx, yy-2*dy);
+            g.drawLine(xx-dx, y2+dy, x+dx, yy-dy);
+            break;
+        }
+        case '{': { // Pi
+            char[] ca = new char[1];
+            ca[0] = (char)0x03c0;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case '|': { // Not equal
+            char[] ca = new char[1];
+            ca[0] = (char)0x2260;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case '}': { // UK pound
+            char[] ca = new char[1];
+            ca[0] = (char)0x00a3;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        case '~': { // Center dot
+            char[] ca = new char[1];
+            ca[0] = (char)0x00b7;
+            g.drawChars(ca, 0, 1, x, y + bi);
+            break;
+        }
+        default:
+            if(DEBUG)
+                System.out.println("Unknown line-draw-char: " + c + " (" + ((int)c) + ")");
+            break;
+        }
+    }
 
     public void setPosition(final int x, final int y) {
         SwingUtilities.invokeLater(new Runnable() {
@@ -1268,8 +1495,11 @@
     public Component getAWTComponent() { return this; }
 
     public void setIgnoreClose() {
-        ownerFrame.setDefaultCloseOperation(
-            WindowConstants.DO_NOTHING_ON_CLOSE);
+    	
+    	// [CYCLADES-START]: code commented due to ownerFrame datatype change 
+        // ownerFrame.setDefaultCloseOperation(
+        //    WindowConstants.DO_NOTHING_ON_CLOSE);
+    	//  [CYCLADES-END]
     }
 
     public void windowClosed() {
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/SpecialKeysUTF8.java mindterm_3.1.2/com/mindbright/terminal/SpecialKeysUTF8.java
--- mindterm_3.1.2.org/com/mindbright/terminal/SpecialKeysUTF8.java	1969-12-31 16:00:00.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/terminal/SpecialKeysUTF8.java	2009-06-18 12:10:45.000000000 -0700
@@ -0,0 +1,177 @@
+/*
+ * SpecialKeysUTF8.java
+ *
+ * Created on May 11, 2007, 11:27
+ *
+ */
+
+package com.mindbright.terminal;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ *
+ * @author ivan.gardino
+ */
+public class SpecialKeysUTF8 {
+    
+    private static Map map = null;
+
+    static{
+        map = new HashMap();
+        //map for ctrl+key events...
+        map.put(new Character(((char)(byte)1)), new Character('a'));
+        map.put(new Character(((char)(byte)2)), new Character('b'));
+        map.put(new Character(((char)(byte)3)), new Character('c'));
+        map.put(new Character(((char)(byte)4)), new Character('d'));
+        map.put(new Character(((char)(byte)5)), new Character('e'));
+        map.put(new Character(((char)(byte)6)), new Character('f'));
+        map.put(new Character(((char)(byte)7)), new Character('g'));
+        map.put(new Character(((char)(byte)8)), new Character('h'));
+        map.put(new Character(((char)(byte)9)), new Character('i'));
+        map.put(new Character(((char)(byte)10)), new Character('j'));
+        map.put(new Character(((char)(byte)11)), new Character('k'));
+        map.put(new Character(((char)(byte)12)), new Character('l'));
+        map.put(new Character(((char)(byte)13)), new Character('m'));
+        map.put(new Character(((char)(byte)14)), new Character('n'));
+        map.put(new Character(((char)(byte)15)), new Character('o'));
+        map.put(new Character(((char)(byte)16)), new Character('p'));
+        map.put(new Character(((char)(byte)17)), new Character('q'));
+        map.put(new Character(((char)(byte)18)), new Character('r'));
+        map.put(new Character(((char)(byte)19)), new Character('s'));
+        map.put(new Character(((char)(byte)20)), new Character('t'));
+        map.put(new Character(((char)(byte)21)), new Character('u'));
+        map.put(new Character(((char)(byte)22)), new Character('v'));
+        map.put(new Character(((char)(byte)24)), new Character('x'));
+        map.put(new Character(((char)(byte)23)), new Character('w'));
+        map.put(new Character(((char)(byte)25)), new Character('y'));
+        map.put(new Character(((char)(byte)26)), new Character('z'));
+        map.put(new Character(((char)(byte)27)), new Character('['));
+        map.put(new Character(((char)(byte)28)), new Character(']'));
+        map.put(new Character(((char)(byte)29)), new Character(''));
+        map.put(new Character(((char)(byte)31)), new Character('-'));
+
+        //map for alt+key events
+        map.put(new Character(((char)(byte)97)), new Character('a'));
+        map.put(new Character(((char)(byte)98)), new Character('b'));
+        map.put(new Character(((char)(byte)99)), new Character('c'));
+        map.put(new Character(((char)(byte)100)), new Character('d'));
+        map.put(new Character(((char)(byte)101)), new Character('e'));
+        map.put(new Character(((char)(byte)102)), new Character('f'));
+        map.put(new Character(((char)(byte)103)), new Character('g'));
+        map.put(new Character(((char)(byte)104)), new Character('h'));
+        map.put(new Character(((char)(byte)105)), new Character('i'));
+        map.put(new Character(((char)(byte)106)), new Character('j'));
+        map.put(new Character(((char)(byte)107)), new Character('k'));
+        map.put(new Character(((char)(byte)108)), new Character('l'));
+        map.put(new Character(((char)(byte)109)), new Character('m'));
+        map.put(new Character(((char)(byte)110)), new Character('n'));
+        map.put(new Character(((char)(byte)111)), new Character('o'));
+        map.put(new Character(((char)(byte)112)), new Character('p'));
+        map.put(new Character(((char)(byte)113)), new Character('q'));
+        map.put(new Character(((char)(byte)114)), new Character('r'));
+        map.put(new Character(((char)(byte)115)), new Character('s'));
+        map.put(new Character(((char)(byte)116)), new Character('t'));
+        map.put(new Character(((char)(byte)117)), new Character('u'));
+        map.put(new Character(((char)(byte)118)), new Character('v'));
+        map.put(new Character(((char)(byte)119)), new Character('w'));
+        map.put(new Character(((char)(byte)120)), new Character('x'));
+        map.put(new Character(((char)(byte)121)), new Character('y'));
+        map.put(new Character(((char)(byte)122)), new Character('z'));
+        map.put(new Character(((char)(byte)39)), new Character('\''));
+        map.put(new Character(((char)(byte)49)), new Character('1'));
+        map.put(new Character(((char)(byte)50)), new Character('2'));
+        map.put(new Character(((char)(byte)51)), new Character('3'));
+        map.put(new Character(((char)(byte)52)), new Character('4'));
+        map.put(new Character(((char)(byte)53)), new Character('5'));
+        map.put(new Character(((char)(byte)54)), new Character('6'));
+        map.put(new Character(((char)(byte)55)), new Character('7'));
+        map.put(new Character(((char)(byte)56)), new Character('8'));
+        map.put(new Character(((char)(byte)57)), new Character('9'));
+        map.put(new Character(((char)(byte)48)), new Character('0'));
+        map.put(new Character(((char)(byte)45)), new Character('-'));
+        map.put(new Character(((char)(byte)61)), new Character('='));
+        map.put(new Character(((char)(byte)92)), new Character('\\'));
+        map.put(new Character(((char)(byte)-76)), new Character(''));
+        map.put(new Character(((char)(byte)91)), new Character('['));
+        map.put(new Character(((char)(byte)126)), new Character('~'));
+        map.put(new Character(((char)(byte)93)), new Character(']'));
+        map.put(new Character(((char)(byte)44)), new Character(','));
+        map.put(new Character(((char)(byte)46)), new Character('.'));
+        map.put(new Character(((char)(byte)59)), new Character(';'));
+        map.put(new Character(((char)(byte)47)), new Character('/'));
+        //numpad keys...
+        map.put(new Character(((char)(byte)58)), new Character('1'));
+        map.put(new Character(((char)(byte)59)), new Character('2'));
+        map.put(new Character(((char)(byte)101)), new Character('3'));
+        map.put(new Character(((char)(byte)102)), new Character('4'));
+        map.put(new Character(((char)(byte)99)), new Character('5'));
+        map.put(new Character(((char)(byte)96)), new Character('6'));
+        map.put(new Character(((char)(byte)34)), new Character('7'));
+        map.put(new Character(((char)(byte)-40)), new Character('8'));
+        map.put(new Character(((char)(byte)-53)), new Character('9'));
+        map.put(new Character(((char)(byte)47)), new Character('/'));
+        map.put(new Character(((char)(byte)42)), new Character('*'));
+        map.put(new Character(((char)(byte)43)), new Character('+'));
+        map.put(new Character(((char)(byte)46)), new Character('.'));
+        map.put(new Character(((char)(byte)44)), new Character(','));
+
+        //shift+key events...
+        map.put(new Character(((char)(byte)65)), new Character('a'));
+        map.put(new Character(((char)(byte)66)), new Character('b'));
+        map.put(new Character(((char)(byte)67)), new Character('c'));
+        map.put(new Character(((char)(byte)68)), new Character('d'));
+        map.put(new Character(((char)(byte)69)), new Character('e'));
+        map.put(new Character(((char)(byte)70)), new Character('f'));
+        map.put(new Character(((char)(byte)71)), new Character('g'));
+        map.put(new Character(((char)(byte)72)), new Character('h'));
+        map.put(new Character(((char)(byte)73)), new Character('i'));
+        map.put(new Character(((char)(byte)74)), new Character('j'));
+        map.put(new Character(((char)(byte)75)), new Character('k'));
+        map.put(new Character(((char)(byte)76)), new Character('l'));
+        map.put(new Character(((char)(byte)77)), new Character('m'));
+        map.put(new Character(((char)(byte)78)), new Character('n'));
+        map.put(new Character(((char)(byte)79)), new Character('o'));
+        map.put(new Character(((char)(byte)80)), new Character('p'));
+        map.put(new Character(((char)(byte)81)), new Character('q'));
+        map.put(new Character(((char)(byte)82)), new Character('r'));
+        map.put(new Character(((char)(byte)83)), new Character('s'));
+        map.put(new Character(((char)(byte)84)), new Character('t'));
+        map.put(new Character(((char)(byte)85)), new Character('u'));
+        map.put(new Character(((char)(byte)86)), new Character('v'));
+        map.put(new Character(((char)(byte)87)), new Character('w'));
+        map.put(new Character(((char)(byte)88)), new Character('x'));
+        map.put(new Character(((char)(byte)89)), new Character('y'));
+        map.put(new Character(((char)(byte)90)), new Character('z'));
+        map.put(new Character(((char)(byte)-57)), new Character(''));
+        map.put(new Character(((char)(byte)124)), new Character('|'));
+        map.put(new Character(((char)(byte)33)), new Character('!'));
+        map.put(new Character(((char)(byte)64)), new Character('@'));
+        map.put(new Character(((char)(byte)35)), new Character('#'));
+        map.put(new Character(((char)(byte)36)), new Character('$'));
+        map.put(new Character(((char)(byte)37)), new Character('%'));
+        map.put(new Character(((char)(byte)-88)), new Character(''));
+        map.put(new Character(((char)(byte)38)), new Character('&'));
+        map.put(new Character(((char)(byte)40)), new Character('('));
+        map.put(new Character(((char)(byte)41)), new Character(')'));
+        map.put(new Character(((char)(byte)95)), new Character('_'));
+        map.put(new Character(((char)(byte)96)), new Character('`'));
+        map.put(new Character(((char)(byte)123)), new Character('{'));
+        map.put(new Character(((char)(byte)94)), new Character('^'));
+        map.put(new Character(((char)(byte)125)), new Character('}'));
+        map.put(new Character(((char)(byte)58)), new Character(':'));
+        map.put(new Character(((char)(byte)63)), new Character('?'));
+        map.put(new Character(((char)(byte)60)), new Character('<'));
+        map.put(new Character(((char)(byte)62)), new Character('>'));
+        map.put(new Character(((char)(byte)47)), new Character('/'));
+        map.put(new Character(((char)(byte)42)), new Character('*'));
+        map.put(new Character(((char)(byte)45)), new Character('-'));
+        map.put(new Character(((char)(byte)43)), new Character('+'));
+        map.put(new Character(((char)(byte)46)), new Character('.'));
+    }
+    
+    public static char getKeyValue(char key){
+        return ((Character) map.get(new Character(key))).charValue();
+    }
+}
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/TerminalMenuHandlerFullAWT.java mindterm_3.1.2/com/mindbright/terminal/TerminalMenuHandlerFullAWT.java
--- mindterm_3.1.2.org/com/mindbright/terminal/TerminalMenuHandlerFullAWT.java	2006-11-08 03:22:20.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/terminal/TerminalMenuHandlerFullAWT.java	2009-06-18 12:10:45.000000000 -0700
@@ -21,6 +21,7 @@
 import com.mindbright.gui.AWTConvenience;
 import com.mindbright.gui.BorderDialog;
 import com.mindbright.gui.TabPanel;
+import com.mindbright.gui.Logo;
 
 /**
  * Implements AWT-style menus for a terminal window.
@@ -31,6 +32,8 @@
 public class TerminalMenuHandlerFullAWT extends TerminalMenuHandlerFull {
     private Menu vtOptionsMenu;
 
+    private static final boolean BOX_APPLET = false;
+    
     protected void setEnabled(int i, int j, boolean v) {
         ((MenuItem)menuItems[i][j]).setEnabled(v);
     }
@@ -50,6 +53,7 @@
 	menubar.add((Menu)getMenu(MENU_FILE));
 	menubar.add((Menu)getMenu(MENU_EDIT));
 	menubar.add((Menu)getMenu(MENU_SETTINGS));
+	menubar.add((Menu)getMenu(MENU_HELP));
 	frame.addWindowListener(new AWTConvenience.
 	    CloseAdapter((MenuItem)menuItems[MENU_FILE][M_FILE_CLOSE]));
     }
@@ -178,7 +182,7 @@
     private TextField textFS, textRows, textCols, textInitPos;
     private TextField textSL, textSD;
     private TextField textFG, textBG, textCC;
-    private Label lblAlert;
+    private Label lblAlert, labelTE;
     private Checkbox checkIN;
 
     public void termSettingsDialog(String title) {
@@ -198,34 +202,38 @@
         gridcr.gridwidth = GridBagConstraints.REMAINDER;
         gridcr.weightx   = 1.0;
 
-        choiceTE = AWTConvenience.newChoice(TERMINAL_TYPES);
-        mp.add(new Label(LBL_TERMINAL_TYPE, Label.RIGHT), gridcl);
-        mp.add(choiceTE, gridcr);
-        
-        textCols = new TextField("", 3);
-        mp.add(new Label(LBL_COLUMNS, Label.RIGHT), gridcl);
-        mp.add(textCols, gridcr);
-
-        textRows = new TextField("", 3);
-        mp.add(new Label(LBL_ROWS, Label.RIGHT), gridcl);
-        mp.add(textRows, gridcr);
-
-        choiceEN = AWTConvenience.newChoice(ENCODINGS);
-        mp.add(new Label(LBL_ENCODING, Label.RIGHT), gridcl);
-        mp.add(choiceEN, gridcr);
-
-        choiceFN = AWTConvenience.newChoice(FONT_LIST);
-        mp.add(new Label(LBL_FONT, Label.RIGHT), gridcl);
-        mp.add(choiceFN, gridcr);
-
-        textFS = new TextField("", 3);
-        mp.add(new Label(LBL_SIZE, Label.RIGHT), gridcl);
-        mp.add(textFS, gridcr);
-
-        textSL = new TextField("", 4);
-        mp.add(new Label(LBL_SCROLLBACK_BUFFER, Label.RIGHT), gridcl);
-        mp.add(textSL, gridcr);
-
+	    //choiceTE = AWTConvenience.newChoice(TERMINAL_TYPES);
+	    mp.add(new Label(LBL_TERMINAL_TYPE, Label.RIGHT), gridcl);
+	    //mp.add(choiceTE, gridcr);
+	    labelTE = new Label(getProperty("term-type"), Label.LEFT);
+	    mp.add(labelTE, gridcr);
+	        
+        if(!BOX_APPLET) {
+	        textCols = new TextField("", 3);
+	        mp.add(new Label(LBL_COLUMNS, Label.RIGHT), gridcl);
+	        mp.add(textCols, gridcr);
+	
+	        textRows = new TextField("", 3);
+	        mp.add(new Label(LBL_ROWS, Label.RIGHT), gridcl);
+	        mp.add(textRows, gridcr);
+	
+	        choiceEN = AWTConvenience.newChoice(ENCODINGS);
+	        mp.add(new Label(LBL_ENCODING, Label.RIGHT), gridcl);
+	        mp.add(choiceEN, gridcr);
+	
+	        choiceFN = AWTConvenience.newChoice(FONT_LIST);
+	        mp.add(new Label(LBL_FONT, Label.RIGHT), gridcl);
+	        mp.add(choiceFN, gridcr);
+	
+	        textFS = new TextField("", 3);
+	        mp.add(new Label(LBL_SIZE, Label.RIGHT), gridcl);
+	        mp.add(textFS, gridcr);
+	
+	        textSL = new TextField("", 4);
+	        mp.add(new Label(LBL_SCROLLBACK_BUFFER, Label.RIGHT), gridcl);
+	        mp.add(textSL, gridcr);
+        }
+        
         choiceSB = AWTConvenience.newChoice(SCROLLBAR_POS);
         mp.add(new Label(LBL_SCROLLBAR_POS, Label.RIGHT), gridcl);
         mp.add(choiceSB, gridcr);
@@ -345,18 +353,20 @@
                 try {
                     setVTOptions();
 
-                    setProperty("term-type",
-                                TERMINAL_TYPES[choiceTE.getSelectedIndex()]);
-                    setProperty("encoding",
-                                ENCODINGS[choiceEN.getSelectedIndex()]);
-                    setProperty("font-name",
-                                FONT_LIST[choiceFN.getSelectedIndex()]);
-                    setProperty("font-size", textFS.getText());
+	                //setProperty("term-type",
+	                //            TERMINAL_TYPES[choiceTE.getSelectedIndex()]);
+                    if(!BOX_APPLET){
+	                    setProperty("encoding",
+	                                ENCODINGS[choiceEN.getSelectedIndex()]);
+	                    setProperty("font-name",
+	                                FONT_LIST[choiceFN.getSelectedIndex()]);
+	                    setProperty("font-size", textFS.getText());
+	                    setProperty("geometry",
+	                            textCols.getText() + "x" + textRows.getText());
+                    }
                     setProperty("scrollbar",
                                 SCROLLBAR_POS[choiceSB.getSelectedIndex()]);
                     setProperty("save-lines", textSL.getText());
-                    setProperty("geometry",
-                                textCols.getText() + "x" + textRows.getText());
                     setProperty("paste-button",
                                 PASTE_BUTTON[choicePB.getSelectedIndex()]);
                     setProperty("select-delim", textSD.getText());
@@ -385,12 +395,14 @@
 
         AWTConvenience.setBackgroundOfChildren(dialog);
 
-	choiceTE.select(getProperty("term-type"));
-	choiceEN.select(getProperty("encoding"));
-	choiceFN.select(getProperty("font-name"));
-	textFS.setText(getProperty("font-size"));
-	textCols.setText(String.valueOf(term.cols()));
-	textRows.setText(String.valueOf(term.rows()));
+	//choiceTE.select(getProperty("term-type"));
+	if(!BOX_APPLET) {
+		choiceEN.select(getProperty("encoding"));
+		choiceFN.select(getProperty("font-name"));
+		textFS.setText(getProperty("font-size"));
+		textCols.setText(String.valueOf(term.cols()));
+		textRows.setText(String.valueOf(term.rows()));
+	}
 	choiceSB.select(getProperty("scrollbar"));
 	textSL.setText(getProperty("save-lines"));
 
@@ -422,7 +434,8 @@
 
 	AWTConvenience.placeDialog(dialog);
 
-	choiceTE.requestFocus();
+	textSL.requestFocus();
+
 	dialog.setVisible(true);
     }
 
@@ -558,4 +571,44 @@
             popupMenu.show(term.ownerFrame, x, y);
         }
     }
+
+    protected void addBasicMenusInternal(Container frame) {
+        throw new RuntimeException("not implemented");
+    }
+
+    protected void aboutDialog(Frame parent, TerminalWin terminal, 
+            String title, String aboutText) {
+    	Dialog dialog = new BorderDialog(parent, title, true);
+
+    	Component logo = new Logo((Image)terminal.getLogo());
+    	if (logo != null) {
+    		Panel p = new Panel();
+    		p.add(logo);
+    		dialog.add(p, BorderLayout.NORTH);
+    	}
+
+    	TextArea textArea =
+    		new TextArea(aboutText, 12, 40, TextArea.SCROLLBARS_VERTICAL_ONLY);
+    	textArea.setEditable(false);
+    	dialog.add(textArea, BorderLayout.CENTER);
+
+    	Button okTextBut = new Button(LBL_BTN_OK);
+    	okTextBut.addActionListener(new AWTConvenience.CloseAction(dialog));
+
+    	Panel p = new Panel(new FlowLayout(FlowLayout.RIGHT));
+    	p.add(okTextBut);
+    	dialog.add(p, BorderLayout.SOUTH);
+
+    	dialog.addWindowListener(new AWTConvenience.CloseAdapter(okTextBut));
+
+    	AWTConvenience.setBackgroundOfChildren(dialog);
+
+    	dialog.setResizable(true);
+    	dialog.pack();
+
+    	AWTConvenience.placeDialog(dialog);
+    	okTextBut.requestFocus();
+    	dialog.setVisible(true);
+    }
+
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/TerminalMenuHandlerFull.java mindterm_3.1.2/com/mindbright/terminal/TerminalMenuHandlerFull.java
--- mindterm_3.1.2.org/com/mindbright/terminal/TerminalMenuHandlerFull.java	2006-09-29 00:16:57.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/terminal/TerminalMenuHandlerFull.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,8 @@
 
 package com.mindbright.terminal;
 
+import java.awt.Component;
+import java.awt.Container;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -26,8 +28,10 @@
 import java.awt.print.PrinterException;
 import java.awt.print.PrinterJob;
 
+import com.mindbright.application.MindTerm;
 import com.mindbright.gui.AWTConvenience;
 import com.mindbright.gui.GUI;
+import com.mindbright.ssh.SSH;
 
 /**
  * The actual implementation of the standard terminal menus. Or rather
@@ -57,13 +61,37 @@
         return term.getProperty(key);
     }
 
+    private final static String aboutText =
+    	// [CYCLADES-START]
+        //SSH.VER_MINDTERM + "\n" +
+        //Version.licenseMessage + "\n" +
+        //"\n" +
+        //Version.copyright + "\n" +    	
+        //"\thttp://www.appgate.com/mindterm/\n" +
+    	
+    	"Copyright (c) 2007 - Avocent Corporation \n"+ 
+    	"http://www.avocent.com \n" +
+    	
+        "\n"+
+        "This product includes cryptographic software written by,\n" +
+        "Eric Young (eay@cryptsoft.com)\n" +
+        "\n" +
+        "JVM vendor:\t" + MindTerm.javaVendor  + "\n" +
+        "JVM version:\t" + MindTerm.javaVersion  + "\n" +
+        "OS name:\t" + MindTerm.osName  + "\n" +
+        "OS arch.:\t" + MindTerm.osArch  + "\n" +
+        "OS version:\t" + MindTerm.osVersion  + "\n";
+    
     protected TerminalWin term;
     protected String titleName;
     private TerminalMenuListener listener;
+    
+    protected Frame frame;
 
     public final static int MENU_FILE     = 0;
     public final static int MENU_EDIT     = 1;
     public final static int MENU_SETTINGS = 2;
+    public final static int MENU_HELP     = 3;
 
     final static int M_FILE_PRINT_SCREEN = 1;
     final static int M_FILE_PRINT_BUFFER = 2;
@@ -81,6 +109,8 @@
     final static int M_EDIT_CLS     = 7;
     final static int M_EDIT_CLEARSB = 8;
     final static int M_EDIT_VTRESET = 9;
+    
+    final static int M_HELP_ABOUT   = 1;
 
     protected final static String[][] menuTexts = {
 	{ "File", 
@@ -94,6 +124,9 @@
 	},
 	{ "Settings",
 	  "Terminal...", 
+	},
+	{ "Help",
+		  "About MindTerm", 
 	}
     };
 
@@ -136,7 +169,7 @@
     public static TerminalMenuHandler getInstance(Frame frame) {
         try {
             Class c = Class.forName(
-                AWTConvenience.isSwingJFrame(frame) ? 
+                /*AWTConvenience.isSwingJFrame(frame)*/ true ? 
                 "com.mindbright.terminal.TerminalMenuHandlerFullSwing" :
                 "com.mindbright.terminal.TerminalMenuHandlerFullAWT");
             return (TerminalMenuHandler)c.newInstance();
@@ -158,12 +191,17 @@
 	this.listener = listener;
     }
 
-    public void addBasicMenus(TerminalWin terminal, Frame frame) {
-	setTerminalWin(terminal);
-        addBasicMenusInternal(frame);
-	terminal.setMenus(this);
-	terminal.setClipboard(GlobalClipboard.getClipboardHandler(this));
-	terminal.updateMenus();
+    public void addBasicMenus(TerminalWin terminal, Container frame) {
+        Component comp = frame;
+        do {
+            comp = comp.getParent();
+        } while(!(comp instanceof Frame));
+        this.frame = (Frame)comp;
+    	setTerminalWin(terminal);
+    	addBasicMenusInternal(frame);
+    	terminal.setMenus(this);
+    	terminal.setClipboard(GlobalClipboard.getClipboardHandler(this));
+    	terminal.updateMenus();
     }
 
     public void updateSelection(boolean selectionAvailable) {
@@ -331,7 +369,7 @@
     protected abstract void setEnabled(int i, int j, boolean v);
     protected abstract void setState(int i, int j, boolean v);
     protected abstract boolean getState(int i, int j);
-    protected abstract void addBasicMenusInternal(Frame frame);
+    protected abstract void addBasicMenusInternal(Container frame);
     public abstract Object getMenu(int idx);
 
     private int[] mapAction(Object o) {
@@ -373,7 +411,13 @@
 	switch(id[0]) {
             case MENU_FILE:
                 switch(id[1]) {
-                    case M_FILE_CAPTURE:
+	                case M_FILE_PRINT_SCREEN:
+	                    printScreen();
+	                    break;
+	                case M_FILE_PRINT_BUFFER:
+	                    printBuffer();
+	                    break;
+                	case M_FILE_CAPTURE:
                         if (getState(MENU_FILE, M_FILE_CAPTURE)) {
                             if(!captureToFileDialog())
                                 setState(MENU_FILE, M_FILE_CAPTURE, false);
@@ -429,6 +473,16 @@
                         break;
                 }
                 break;
+                
+            case MENU_HELP:
+                switch(id[1]) {
+                    case M_HELP_ABOUT:
+                        aboutDialog((Frame)frame, term,
+                                "About " + SSH.VER_MINDTERM, aboutText);
+                        break;
+                }
+                break;
+           
 	}
     }
 
@@ -495,4 +549,8 @@
             }
         }
     }
+
+    protected abstract void aboutDialog(Frame parent, TerminalWin terminal, 
+            String title, String aboutText);
+
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/TerminalMenuHandlerFullSwing.java mindterm_3.1.2/com/mindbright/terminal/TerminalMenuHandlerFullSwing.java
--- mindterm_3.1.2.org/com/mindbright/terminal/TerminalMenuHandlerFullSwing.java	2006-11-08 03:22:20.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/terminal/TerminalMenuHandlerFullSwing.java	2009-06-18 12:10:45.000000000 -0700
@@ -17,20 +17,24 @@
 
 import java.awt.BorderLayout;
 import java.awt.Component;
+import java.awt.Container;
 import java.awt.FlowLayout;
 import java.awt.Frame;
 import java.awt.GridBagConstraints;
 import java.awt.GridBagLayout;
 import java.awt.GridLayout;
+import java.awt.Image;
 import java.awt.Insets;
 import java.awt.SystemColor;
 
 import java.awt.event.*;
+import java.util.Arrays;
 
 import javax.swing.*;
 
 import com.mindbright.gui.AWTConvenience;
 import com.mindbright.gui.SwingConvenience;
+import com.mindbright.gui.Logo;
 
 /**
  * Implements Swing-style menus for a terminal window.
@@ -40,6 +44,8 @@
  */
 public class TerminalMenuHandlerFullSwing extends TerminalMenuHandlerFull {
     private JMenu vtOptionsMenu;
+    
+    private static final boolean BOX_APPLET = false;
 
     protected void setEnabled(int i, int j, boolean v) {
         ((JMenuItem)menuItems[i][j]).setEnabled(v);
@@ -53,13 +59,21 @@
         return ((JCheckBoxMenuItem)menuItems[i][j]).isSelected();
     }
 
-    protected void addBasicMenusInternal(Frame frame) {
-	JMenuBar menubar = ((JFrame)frame).getJMenuBar();
-        if (menubar == null)
-            ((JFrame)frame).setJMenuBar(menubar = new JMenuBar());
+    protected void addBasicMenusInternal(Container frame) {
+        JMenuBar menubar = null;
+        if (frame instanceof JFrame) {
+            menubar = ((JFrame)frame).getJMenuBar();
+            if (menubar == null) {
+                ((JFrame)frame).setJMenuBar(menubar = new JMenuBar());
+            }
+        } else {
+            menubar = new JMenuBar();
+            frame.add(menubar,BorderLayout.NORTH);
+        }
 	menubar.add((JMenu)getMenu(MENU_FILE));
 	menubar.add((JMenu)getMenu(MENU_EDIT));
 	menubar.add((JMenu)getMenu(MENU_SETTINGS));
+	menubar.add((JMenu)getMenu(MENU_HELP));
     }
 
     public Object getMenu(int idx) {
@@ -181,7 +195,7 @@
     private JTextField textFS, textRows, textCols, textInitPos;
     private JTextField textSL, textSD;
     private JTextField textFG, textBG, textCC;
-    private JLabel lblAlert;
+    private JLabel lblAlert, labelTE;
     private JCheckBox checkIN;
 
     public void termSettingsDialog(String title) {
@@ -201,32 +215,35 @@
         gridcr.gridwidth = GridBagConstraints.REMAINDER;
         gridcr.weightx   = 1.0;
 
-
-        comboTE = new JComboBox(TERMINAL_TYPES);
-        mp.add(new JLabel(LBL_TERMINAL_TYPE, SwingConstants.RIGHT), gridcl);
-        mp.add(comboTE, gridcr);
+	    //comboTE = new JComboBox(TERMINAL_TYPES);
+	    mp.add(new JLabel(LBL_TERMINAL_TYPE, SwingConstants.RIGHT), gridcl);
+	    //mp.add(comboTE, gridcr);
+	    labelTE = new JLabel(getProperty("term-type"), SwingConstants.LEFT);
+	    mp.add(labelTE, gridcr);
+	        
+        if(!BOX_APPLET) {
+	        textCols = new JTextField("", 3);
+	        mp.add(new JLabel(LBL_COLUMNS, SwingConstants.RIGHT), gridcl);
+	        mp.add(textCols, gridcr);
+	
+	        textRows = new JTextField("", 3);
+	        mp.add(new JLabel(LBL_ROWS, SwingConstants.RIGHT), gridcl);
+	        mp.add(textRows, gridcr);
+	
+	        comboEN = new JComboBox(ENCODINGS);
+	        comboEN.setEditable(true);
+	        mp.add(new JLabel(LBL_ENCODING, SwingConstants.RIGHT), gridcl);
+	        mp.add(comboEN, gridcr);
+	
+	        comboFN = new JComboBox(FONT_LIST);
+	        mp.add(new JLabel(LBL_FONT, SwingConstants.RIGHT), gridcl);
+	        mp.add(comboFN, gridcr);
+	
+	        textFS = new JTextField("", 3);
+	        mp.add(new JLabel(LBL_SIZE, SwingConstants.RIGHT), gridcl);
+	        mp.add(textFS, gridcr);
+        }
         
-        textCols = new JTextField("", 3);
-        mp.add(new JLabel(LBL_COLUMNS, SwingConstants.RIGHT), gridcl);
-        mp.add(textCols, gridcr);
-
-        textRows = new JTextField("", 3);
-        mp.add(new JLabel(LBL_ROWS, SwingConstants.RIGHT), gridcl);
-        mp.add(textRows, gridcr);
-
-        comboEN = new JComboBox(ENCODINGS);
-        comboEN.setEditable(true);
-        mp.add(new JLabel(LBL_ENCODING, SwingConstants.RIGHT), gridcl);
-        mp.add(comboEN, gridcr);
-
-        comboFN = new JComboBox(FONT_LIST);
-        mp.add(new JLabel(LBL_FONT, SwingConstants.RIGHT), gridcl);
-        mp.add(comboFN, gridcr);
-
-        textFS = new JTextField("", 3);
-        mp.add(new JLabel(LBL_SIZE, SwingConstants.RIGHT), gridcl);
-        mp.add(textFS, gridcr);
-
         textSL = new JTextField("", 3);
         mp.add(new JLabel(LBL_SCROLLBACK_BUFFER, SwingConstants.RIGHT),gridcl);
         mp.add(textSL, gridcr);
@@ -353,17 +370,19 @@
                 try {
                     setVTOptions();
 
-                    setProperty("term-type",
-                                TERMINAL_TYPES[comboTE.getSelectedIndex()]);
-                    setProperty("encoding", (String)comboEN.getSelectedItem());
-                    setProperty("font-name",
-                                FONT_LIST[comboFN.getSelectedIndex()]);
-                    setProperty("font-size", textFS.getText());
+	                //setProperty("term-type",
+	                //            TERMINAL_TYPES[comboTE.getSelectedIndex()]);
+                    if(!BOX_APPLET) {
+	                    setProperty("encoding", (String)comboEN.getSelectedItem());
+	                    setProperty("font-name",
+	                                FONT_LIST[comboFN.getSelectedIndex()]);
+	                    setProperty("font-size", textFS.getText());
+	                    setProperty("geometry",
+	                            textCols.getText() + "x" + textRows.getText());
+                    }
                     setProperty("scrollbar",
                                 SCROLLBAR_POS[comboSB.getSelectedIndex()]);
                     setProperty("save-lines", textSL.getText());
-                    setProperty("geometry",
-                                textCols.getText() + "x" + textRows.getText());
                     setProperty("paste-button",
                                 PASTE_BUTTON[comboPB.getSelectedIndex()]);
                     setProperty("select-delim", textSD.getText());
@@ -383,12 +402,14 @@
         
         dialog.getContentPane().add(bp, BorderLayout.SOUTH);
 
-	comboTE.setSelectedItem(getProperty("term-type"));
-	comboEN.setSelectedItem(getProperty("encoding"));
-	comboFN.setSelectedItem(getProperty("font-name"));
-	textFS.setText(getProperty("font-size"));
-	textCols.setText(String.valueOf(term.cols()));
-	textRows.setText(String.valueOf(term.rows()));
+	//comboTE.setSelectedItem(getProperty("term-type"));
+    if(!BOX_APPLET) {
+		comboEN.setSelectedItem(getProperty("encoding"));
+		comboFN.setSelectedItem(getProperty("font-name"));
+		textFS.setText(getProperty("font-size"));
+		textCols.setText(String.valueOf(term.cols()));
+		textRows.setText(String.valueOf(term.rows()));
+    }
 	comboSB.setSelectedItem(getProperty("scrollbar"));
 	textSL.setText(getProperty("save-lines"));
 
@@ -420,8 +441,9 @@
 
         AWTConvenience.placeDialog(dialog);
 
-	comboTE.requestFocus();
-        dialog.addWindowListener(SwingConvenience.getWindowDisposer());        
+    textSD.requestFocus();
+
+	dialog.addWindowListener(SwingConvenience.getWindowDisposer());        
 	dialog.setVisible(true);
     }
 
@@ -524,4 +546,41 @@
             popupMenu.show(term.ownerFrame, x, y);
         }
     }
+
+    protected void aboutDialog(Frame parent, TerminalWin terminal, 
+            String title, String aboutText) {
+    	final JDialog dialog = SwingConvenience.newBorderJDialog(parent,
+                                              title, true);
+
+    	Component logo = new Logo((Image)terminal.getLogo());
+    	if (logo != null) {
+    		JPanel p = new JPanel();
+    		p.add(logo);
+    		dialog.getContentPane().add(p, BorderLayout.NORTH);
+    	}
+
+    	JTextArea textArea = new JTextArea(aboutText, 12, 40);
+    	textArea.setEditable(false);
+    	JScrollPane sp = new JScrollPane
+    					(textArea, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, 
+    								ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
+
+    	dialog.getContentPane().add(sp, BorderLayout.CENTER);
+
+    	JButton okTextBut = new JButton(LBL_BTN_OK);
+    	okTextBut.addActionListener(new AWTConvenience.CloseAction(dialog));
+
+    	JPanel p = new JPanel(new FlowLayout(FlowLayout.RIGHT));
+    	p.add(okTextBut);
+    	dialog.getContentPane().add(p, BorderLayout.SOUTH);
+
+    	dialog.setResizable(true);
+    	dialog.pack();
+
+    	AWTConvenience.placeDialog(dialog);
+    	okTextBut.requestFocus();
+    	dialog.addWindowListener(SwingConvenience.getWindowDisposer());
+    	dialog.setVisible(true);
+    }
+
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/TerminalMenuHandler.java mindterm_3.1.2/com/mindbright/terminal/TerminalMenuHandler.java
--- mindterm_3.1.2.org/com/mindbright/terminal/TerminalMenuHandler.java	2005-10-08 14:19:39.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/terminal/TerminalMenuHandler.java	2009-06-18 12:10:45.000000000 -0700
@@ -15,6 +15,8 @@
 
 package com.mindbright.terminal;
 
+import java.awt.Component;
+import java.awt.Container;
 import java.awt.Frame;
 
 /**
@@ -55,7 +57,7 @@
      * @param terminal terminal window to attach to
      * @param frame frame to install menus in
      */
-    public abstract void addBasicMenus(TerminalWin terminal, Frame frame);
+    public abstract void addBasicMenus(TerminalWin terminal, Container frame);
 
     /**
      * Gets called when the selection state is changed
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/TerminalVT100Style.java mindterm_3.1.2/com/mindbright/terminal/TerminalVT100Style.java
--- mindterm_3.1.2.org/com/mindbright/terminal/TerminalVT100Style.java	2006-07-31 23:49:02.000000000 -0700
+++ mindterm_3.1.2/com/mindbright/terminal/TerminalVT100Style.java	2009-06-18 12:10:45.000000000 -0700
@@ -80,7 +80,7 @@
 
     private static String terminalTypes[] = {
         "xterm", "linux", "scoansi",  "att6386", "sun", "aixterm",
-        "vt220", "vt100", "ansi",  "vt52", "xterm-color", "linux-lat",
+        "vt220", "vt100", "ansi",  "vt52", "ibm3151", "xterm-color", "linux-lat",
         "at386", "vt320", "vt102"
                                             };
 
@@ -95,6 +95,7 @@
         TerminalXTerm.EMUL_VT100,
         TerminalXTerm.EMUL_ANSI,
         TerminalXTerm.EMUL_VT52,
+        TerminalXTerm.EMUL_IBM3151,
         TerminalXTerm.EMUL_XTERMCOL,
         TerminalXTerm.EMUL_LINUXLAT,
         TerminalXTerm.EMUL_AT386,
@@ -569,7 +570,7 @@
 
     public void typedChar(char c) {
         if (termWin != null) {
-            termWin.typedChar(c);
+        	termWin.typedChar(c);
         }
     }
     public void sendBytes(byte[] b) {
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/TerminalWindow.java mindterm_3.1.2/com/mindbright/terminal/TerminalWindow.java
--- mindterm_3.1.2.org/com/mindbright/terminal/TerminalWindow.java	2005-10-31 05:29:36.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/terminal/TerminalWindow.java	2009-06-18 12:10:45.000000000 -0700
@@ -329,4 +329,8 @@
      * effects without knowing which terminal emulation is active.
      */
     public void clearLine();
+    
+    // [CYCLADES-START]
+    public DisplayView getDisplayView();
+    //  [CYCLADES-END]    
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/TerminalWin.java mindterm_3.1.2/com/mindbright/terminal/TerminalWin.java
--- mindterm_3.1.2.org/com/mindbright/terminal/TerminalWin.java	2007-02-21 00:39:53.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/terminal/TerminalWin.java	2009-06-18 12:10:45.000000000 -0700
@@ -31,7 +31,9 @@
 import java.util.Vector;
 
 import com.mindbright.gui.AWTConvenience;
+import com.mindbright.gui.AlertDialog;
 import com.mindbright.util.RandomSeed;
+import javax.swing.KeyStroke;
 
 /**
  * The actual implementation of a terminal window. The terminal window
@@ -40,6 +42,12 @@
 public final class TerminalWin extends WindowAdapter
     implements TerminalWindow, DisplayController, KeyListener {
 
+	// [CYCLADES-START]
+	private char lastKeyTyped='\0';
+    private int lastSpecialKeyTyped = '\0';
+    private boolean specialKeysUTF8 = false;
+	// [CYCLADES-END]
+	
     final static boolean DEBUG         = false;
     final static boolean DEBUGKEYEVENT = false;
 
@@ -166,7 +174,7 @@
 
     // Settings
     static private TerminalOption optEncoding =
-    new TerminalOption("encoding", "Character encoding to use", "iso-8859-1");
+    new TerminalOption("encoding", "Character encoding to use", "utf-8");//"iso-8859-1");
     static private TerminalOption optIgnNull =
     new TerminalOption("ignore-null", "Ignore null characters", "true");
     static private TerminalOption optCRLF =
@@ -179,17 +187,17 @@
     static private TerminalOption optGeometry =
     new TerminalOption("geometry", "", "80x24");
     static private TerminalOption optTermType =
-    new TerminalOption("term-type", "", "xterm");
+    new TerminalOption("term-type", "", "vt100");
     static private TerminalOption optSaveLines =
     new TerminalOption("save-lines", "", "512");
     static private TerminalOption optScrollBar =
     new TerminalOption("scrollbar", "", "right");
     static private TerminalOption optBgColor =
-    new TerminalOption("bg-color", "", "white");
+    new TerminalOption("bg-color", "", "black");
     static private TerminalOption optFgColor =
-    new TerminalOption("fg-color", "", "black");
+    new TerminalOption("fg-color", "", "white");
     static private TerminalOption optCursorColor =
-    new TerminalOption("cursor-color", "", "i_blue");
+    new TerminalOption("cursor-color", "", "green");
     static private TerminalOption optSelectDelim =
     new TerminalOption("select-delim", "", "\" \"");
     static private TerminalOption optPasteButton =
@@ -313,8 +321,7 @@
                 if (ret != null) {
                     break;
                 }
-            } catch (Exception e) {
-            }
+            } catch (Exception e) { }
         }
         
         return ret;
@@ -437,7 +444,7 @@
         title         = null;
         termOptions   = new boolean[OPT_LAST_OPT];
         writeLock     = new Object();
-        terminal      = getTerminal("xterm");
+        terminal      = getTerminal(optTermType.getValue());
 
         if(setAsDefault) {
             Enumeration e = initProps.keys();
@@ -448,7 +455,7 @@
                 defaultProperties.put(name, value);
             }
         }
-
+        
         savedGeomPos = "";
 
         this.ownerFrame = ownerFrame;
@@ -916,12 +923,19 @@
             } else if(key.equals(optTermType.getKey())) {
                 if (!terminal.terminalType().equals(value)) {
                     // try to reset the existing terminal to new type
+                	String default_term = terminal.terminalType();
                     if (!terminal.setTerminalType(value)) {
                         // A new terminal type, initialize it
-                        Terminal newTerm = getTerminal(value);
+                        Terminal newTerm = getTerminal(value);//to implement a new term type, if needed
                         if (newTerm == null) {
-                            throw new IllegalArgumentException(
-                                "terminal type '" + value + "' unknown");
+                            AlertDialog.show("Error", "Terminal type \"" + value + "\" is unknown." +
+                                 " Initializing as \"" + default_term + "\" (default)", ownerFrame);
+                            value = default_term;
+                        	newTerm = getTerminal(value);
+                        	if (newTerm == null) {
+                                throw new IllegalArgumentException(
+                                "Terminal type \"" + value + "\" is unknown.");
+                        	}
                         }
                         terminal = newTerm;
                     }
@@ -1489,7 +1503,7 @@
     }
 
     public final void sendBytes(byte[] b) {
-        if(DEBUG) System.out.println("Sending " + b.length + " bytes: " + com.mindbright.util.HexDump.toString(b));
+        if(DEBUG) System.out.println("Sending " + b.length + " bytes");
         if (filter != null && !dumbMode) {
             b = filter.convertTo(b);
             if (b.length > 0) {
@@ -1964,13 +1978,17 @@
             } else {
                 altKeyKludge = true;
             }
+            //verify the needed for having special tratament for ctrl + alt buttons
+            lastSpecialKeyTyped = KeyEvent.VK_ALT;
             return;
 
         case KeyEvent.VK_CONTROL:
             ctrlKeyKludge = true;
+            lastSpecialKeyTyped = KeyEvent.VK_CONTROL;
             return;
 
         case KeyEvent.VK_SHIFT:
+            lastSpecialKeyTyped = KeyEvent.VK_SHIFT;
         case KeyEvent.VK_CAPS_LOCK:
             // For some reason there seems to be characters in
             // keyevents with shift/caps, better filter them out
@@ -2004,6 +2022,97 @@
             }
         }
 
+        if (isSpecialKeysUTF8()){
+            String cmd = "";
+            switch(e.getKeyCode()){
+                case KeyEvent.VK_INSERT:
+                    cmd = "+";
+                    break;
+                case KeyEvent.VK_HOME:
+                    cmd = "h";
+                    break;
+                case KeyEvent.VK_PAGE_UP:
+                    cmd = "?";
+                    break;
+                case KeyEvent.VK_PAGE_DOWN:
+                    cmd = "/";
+                    break;
+                case KeyEvent.VK_DELETE:
+                    cmd = "-";
+                    break;
+                case KeyEvent.VK_END:
+                    cmd = "k";
+                    break;
+                case KeyEvent.VK_F1:
+                    cmd = "1";
+                    break;
+                case KeyEvent.VK_F2:
+                    cmd = "2";
+                    break;
+                case KeyEvent.VK_F3:
+                    cmd = "3";
+                    break;
+                case KeyEvent.VK_F4:
+                    cmd = "4";
+                    break;
+                case KeyEvent.VK_F5:
+                    cmd = "5";
+                    break;
+                case KeyEvent.VK_F6:
+                    cmd = "6";
+                    break;
+                case KeyEvent.VK_F7:
+                    cmd = "7";
+                    break;
+                case KeyEvent.VK_F8:
+                    cmd = "8";
+                    break;
+                case KeyEvent.VK_F9:
+                    cmd = "9";
+                    break;
+                case KeyEvent.VK_F10:
+                    cmd = "0";
+                    break;
+                case KeyEvent.VK_F11:
+                    cmd = "!";
+                    break;
+                case KeyEvent.VK_F12:
+                    cmd = "@";
+                    break;
+            }
+            byte arr[] = new byte[4];
+            
+            if(e.isAltDown()){
+                arr[0] = '\u001b';arr[1] = '^';arr[2] = 'A';arr[3] = (byte)c;
+                this.sendBytes(arr);
+                c = KeyEvent.CHAR_UNDEFINED;
+                terminal.keyHandler(c, keyCode, mod);
+                return;
+            }else            
+            if(e.isControlDown()){
+                arr[0] = '\u001b';arr[1] = '^';arr[2] = 'C';arr[3] = (byte)SpecialKeysUTF8.getKeyValue(c);
+                this.sendBytes(arr);
+                c = KeyEvent.CHAR_UNDEFINED;
+                terminal.keyHandler(c, keyCode, mod);
+                return;
+            }else            
+            if(e.isShiftDown()){
+                arr[0] = '\u001b';arr[1] = '^';arr[2] = 'S';arr[3] = (byte)c;
+                c = KeyEvent.CHAR_UNDEFINED;
+                terminal.keyHandler(c, keyCode, mod);
+                this.sendBytes(arr);
+                return;
+            }else
+            if(! "".equals(cmd) && cmd.length() > 0){
+                arr = new byte[2];
+                //needed for avoiding wrong byte conversion
+                arr[0] = '\u001b';
+                arr[1] = (byte)cmd.charAt(0);
+                this.sendBytes(arr);
+                return;
+            }
+        }
+        
         terminal.keyHandler(c, keyCode, mod);
     }
 
@@ -2038,11 +2147,15 @@
             seed.removeEntropyGenerator(display.getAWTComponent());
             seed = null;
         }
-        display.delKeyListener(this);
-        display.windowClosed();
-        display = null;
-        terminal.close();
-        terminal = null;
+        if(display!=null) {
+	        display.delKeyListener(this);
+	        display.windowClosed();
+	        display = null;
+        }
+        if(terminal!=null) {
+	        terminal.close();
+	        terminal = null;
+        }
         virtualKeyboard = null;
         printer = null;
         clipboard = null;
@@ -2102,6 +2215,9 @@
         case KeyEvent.VK_F11:
         case KeyEvent.VK_F12:
         case KeyEvent.VK_TAB:
+        case KeyEvent.VK_CONTROL:
+        case KeyEvent.VK_ALT:
+        case KeyEvent.VK_SHIFT:            
             processKey(e, false);
         }
     }
@@ -2117,6 +2233,10 @@
             System.out.println(e.paramString());
         }
 
+    	// [CYCLADES-START]
+        lastKeyTyped = c;    	
+        // [CYCLADES-END]
+        
         processKey(e, false);
     }
 
@@ -2131,10 +2251,15 @@
         switch(virtKey) {
         case KeyEvent.VK_ALT:
             altKeyKludge = false;
+            lastSpecialKeyTyped = 0;
             break;
         case KeyEvent.VK_CONTROL:
             ctrlKeyKludge = false;
+            lastSpecialKeyTyped = 0;
             break;
+        case KeyEvent.VK_SHIFT:
+            lastSpecialKeyTyped = 0;
+            break;            
         case 0x87 /*KeyEvent.VK_DEAD_DIAERESIS*/:
             // kludge for ~ on swedish keyboards
             if (mod != 0 && (mod & InputEvent.SHIFT_MASK) == 0)
@@ -2142,4 +2267,32 @@
             break;
         }
     }
+    
+   // [CYCLADES-START]
+   public Terminal getTerminal() {
+		return terminal;
+	}
+   
+   /**
+    * Added by Eduardo Murai Soares
+    * @return Last char typed by user
+    */
+	public char getLastKeyTyped() {
+		return lastKeyTyped;
+	}
+	
+    public DisplayView getDisplayView() {
+    	return display;
+    }
+	
+    //added by Ivan Gardino
+    public boolean isSpecialKeysUTF8() {
+        return specialKeysUTF8;
+    }
+
+    public void setSpecialKeysUTF8(boolean specialKeysUTF8) {
+        this.specialKeysUTF8 = specialKeysUTF8;
+    }
+    
+    // [CYCLADES-END]    
 }
diff -ruN mindterm_3.1.2.org/com/mindbright/terminal/TerminalXTerm.java mindterm_3.1.2/com/mindbright/terminal/TerminalXTerm.java
--- mindterm_3.1.2.org/com/mindbright/terminal/TerminalXTerm.java	2006-03-22 07:33:18.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/terminal/TerminalXTerm.java	2009-06-18 12:10:45.000000000 -0700
@@ -168,7 +168,13 @@
     public final static int CASE_REP           = 85;
     public final static int CASE_VPA           = 86;
     public final static int CASE_ANSI_PRINTER  = 87;
-
+    public final static int CASE_IBM3151_SGR   = 90;
+    public final static int CASE_ESC_CHAR      = 91;
+    public final static int CASE_IBM3151_CUP   = 92;
+    public final static int CASE_IBM3151_ACS   = 93;
+    public final static int CASE_IBM3151_ISRS  = 94;
+    public final static int CASE_IBM3151_PRN   = 95;
+    
     public final static int[] asciiLineDrawChars = {
                 ' ',  // 0x5f - _
                 '+',  // 0x60 - `
@@ -294,8 +300,9 @@
     public final static int EMUL_VT100    = 7;
     public final static int EMUL_ANSI     = 8;
     public final static int EMUL_VT52     = 9;
+    public final static int EMUL_IBM3151  = 10;
 
-    public final static int EMUL_ALTERNATENAME = 10;
+    public final static int EMUL_ALTERNATENAME = 11;
     public final static int EMUL_XTERMCOL      = EMUL_ALTERNATENAME + EMUL_XTERM;
     public final static int EMUL_LINUXLAT      = EMUL_ALTERNATENAME + EMUL_LINUX;
     public final static int EMUL_AT386         = EMUL_ALTERNATENAME + EMUL_ATT6386;
@@ -315,7 +322,7 @@
 
     public final static String[] terminalTypes = {
         "xterm", "linux", "scoansi",  "att6386", "sun", "aixterm",
-        "vt220", "vt100", "ansi",  "vt52",
+        "vt220", "vt100", "ansi",  "vt52", "ibm3151",
         "xterm-color", "linux-lat", "", "at386", "", "", "vt320", "vt102"
     };
 
@@ -324,117 +331,117 @@
     boolean dumbMode = false;
 
     public final static String[][] specialKeyMap = {
-                //xterm   linux   scoansi att6386 sun     aixterm vt220   vt100   ansi    vt52
-                { "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A"  },
-                { "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B"  },
-                { "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C"  },
-                { "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D"  },
-
-                { "5~",   "5~",   "I",    "V",    "216z", "150q", "5~",   "5~",   "5~",   "5~" },
-                { "6~",   "6~",   "G",    "U",    "222z", "154q", "6~",   "6~",   "6~",   "6~" },
-                { "F",    "4~",   "F",    "Y",    "220z", "146q", "4~",   "4~",   "4~",   "4~" },
-                { "H",    "1~",   "H",    "H",    "214z", "H",    "1~",   "1~",   "1~",   "1~" },
-                { "2~",   "2~",   "L",    "@",    "2~",   "139q", "2~",   "2~",   "L",    "L"  },
-
-                { "11~",  "[A",   "M",    "P",    "224z", "001q", "P",    "P",    "P",    "P"  },
-                { "12~",  "[B",   "N",    "Q",    "225z", "002q", "Q",    "Q",    "Q",    "Q"  },
-                { "13~",  "[C",   "O",    "R",    "226z", "003q", "R",    "R",    "R",    "R"  },
-                { "14~",  "[D",   "P",    "S",    "227z", "004q", "S",    "S",    "S",    "S"  },
-                { "15~",  "[E",   "Q",    "T",    "228z", "005q", "15~",  null,   null,   null },
-                { "17~",  "17~",  "R",    "U",    "229z", "006q", "17~",  null,   null,   null },
-                { "18~",  "18~",  "S",    "V",    "230z", "007q", "18~",  null,   null,   null },
-                { "19~",  "19~",  "T",    "W",    "231z", "008q", "19~",  null,   null,   null },
-                { "20~",  "20~",  "U",    "X",    "232z", "009q", "20~",  null,   null,   null },
-                { "21~",  "21~",  "V",    "Y",    "233z", "010q", "21~",  null,   null,   null },
-                { "23~",  "23~",  "W",    "Z",    "234z", "011q", "23~",  null,   null,   null },
-                { "24~",  "24~",  "X",    "A",    "235z", "012q", "24~",  null,   null,   null },
+                //xterm   linux   scoansi att6386 sun     aixterm vt220   vt100   ansi    vt52    ibm3151
+                { "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A"  },
+                { "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B"  },
+                { "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C"  },
+                { "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D"  },
+
+                { "5~",   "5~",   "I",    "V",    "216z", "150q", "5~",   "5~",   "5~",   "5~",   null  },
+                { "6~",   "6~",   "G",    "U",    "222z", "154q", "6~",   "6~",   "6~",   "6~",   null  },
+                { "F",    "4~",   "F",    "Y",    "220z", "146q", "4~",   "4~",   "4~",   "4~",   null  },
+                { "H",    "1~",   "H",    "H",    "214z", "H",    "1~",   "1~",   "1~",   "1~",   "H"  },
+                { "2~",   "2~",   "L",    "@",    "2~",   "139q", "2~",   "2~",   "L",    "L",    "P \b"  },
+
+                { "11~",  "[A",   "M",    "P",    "224z", "001q", "P",    "P",    "P",    "P",    "a\r"  },
+                { "12~",  "[B",   "N",    "Q",    "225z", "002q", "Q",    "Q",    "Q",    "Q",    "b\r"  },
+                { "13~",  "[C",   "O",    "R",    "226z", "003q", "R",    "R",    "R",    "R",    "c\r"  },
+                { "14~",  "[D",   "P",    "S",    "227z", "004q", "S",    "S",    "S",    "S",    "d\r"  },
+                { "15~",  "[E",   "Q",    "T",    "228z", "005q", "17~",  null,   null,   null,   "e\r"  },
+                { "17~",  "17~",  "R",    "U",    "229z", "006q", "18~",  null,   null,   null,   "f\r"  },
+                { "18~",  "18~",  "S",    "V",    "230z", "007q", "19~",  null,   null,   null,   "g\r"  },
+                { "19~",  "19~",  "T",    "W",    "231z", "008q", "20~",  null,   null,   null,   "h\r"  },
+                { "20~",  "20~",  "U",    "X",    "232z", "009q", "21~",  null,   null,   null,   "i\r"  },
+                { "21~",  "21~",  "V",    "Y",    "233z", "010q", "29~",  null,   null,   null,   "j\r"  },
+                { "23~",  "23~",  "W",    "Z",    "234z", "011q", null,   null,   null,   null,   "k\r"  },
+                { "24~",  "24~",  "X",    "A",    "235z", "012q", null,   null,   null,   null,   "l\r"  },
 
                 // !!! NUMPAD missing, this is not trivial given java's messy so called virtual keys... :-(
             };
 
     public final static String[][] specialKeyMapShift = {
-                //xterm   linux   scoansi att6386 sun     aixterm vt220   vt100   ansi    vt52
-                { "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A"  },
-                { "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B"  },
-                { "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C"  },
-                { "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D"  },
-
-                { "5~",   "5~",   "I",    "V",    "216z", "150q", "5~",   "5~",   "5~",   "5~" },
-                { "6~",   "6~",   "G",    "U",    "222z", "154q", "6~",   "6~",   "6~",   "6~" },
-                { "4~",   "4~",   "F",    "Y",    "220z", "146q", "4~",   "4~",   "4~",   "4~" },
-                { "@",    "1~",   "H",    "H",    "214z", "H",    "1~",   "1~",   "1~",   "1~" },
-                { "2~",   "2~",   "L",    "@",    "2~",   "139q", "2~",   "2~",   "L",    "L"  },
-
-                { "23~",  "23~",  "Y",    "P",    "224z", "013q", "23~",  "P",    "P",    "P"  },
-                { "24~",  "24~",  "Z",    "Q",    "225z", "014q", "24~",  "Q",    "Q",    "Q"  },
-                { "25~",  "25~",  "a",    "R",    "226z", "015q", "25~",  "R",    "R",    "R"  },
-                { "26~",  "26~",  "b",    "S",    "227z", "016q", "26~",  "S",    "S",    "S"  },
-                { "28~",  "28~",  "c",    "T",    "228z", "017q", "28~",  null,   null,   null },
-                { "29~",  "29~",  "d",    "U",    "229z", "018q", "29~",  null,   null,   null },
-                { "31~",  "31~",  "e",    "V",    "230z", "019q", "31~",  null,   null,   null },
-                { "32~",  "32~",  "f",    "W",    "231z", "020q", "32~",  null,   null,   null },
-                { "33~",  "33~",  "g",    "X",    "232z", "021q", "33~",  null,   null,   null },
-                { "34~",  "34~",  "h",    "Y",    "233z", "022q", "34~",  null,   null,   null },
-                { "23$",  null,   "i",    "Z",    "234z", "023q", null,   null,   null,   null },
-                { "24$",  null,   "j",    "A",    "235z", "024q", null,   null,   null,   null },
+                //xterm   linux   scoansi att6386 sun     aixterm vt220   vt100   ansi    vt52    ibm3151
+                { "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A"  },
+                { "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B"  },
+                { "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C"  },
+                { "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D"  },
+
+                { "5~",   "5~",   "I",    "V",    "216z", "150q", "5~",   "5~",   "5~",   "5~",   null  },
+                { "6~",   "6~",   "G",    "U",    "222z", "154q", "6~",   "6~",   "6~",   "6~",   null  },
+                { "4~",   "4~",   "F",    "Y",    "220z", "146q", "4~",   "4~",   "4~",   "4~",   null  },
+                { "@",    "1~",   "H",    "H",    "214z", "H",    "1~",   "1~",   "1~",   "1~",   "H"  },
+                { "2~",   "2~",   "L",    "@",    "2~",   "139q", "2~",   "2~",   "L",    "L",    "P \b"  },
+
+                { "23~",  "23~",  "Y",    "P",    "224z", "013q", "P",    "P",    "P",    "P",    "!a\r"  },
+                { "24~",  "24~",  "Z",    "Q",    "225z", "014q", "Q",    "Q",    "Q",    "Q",    "!b\r"  },
+                { "25~",  "25~",  "a",    "R",    "226z", "015q", "R",    "R",    "R",    "R",    "!c\r"  },
+                { "26~",  "26~",  "b",    "S",    "227z", "016q", "S",    "S",    "S",    "S",    "!d\r"  },
+                { "28~",  "28~",  "c",    "T",    "228z", "017q", "17~",  null,   null,   null,   "!e\r"  },
+                { "29~",  "29~",  "d",    "U",    "229z", "018q", "18~",  null,   null,   null,   "!f\r"  },
+                { "31~",  "31~",  "e",    "V",    "230z", "019q", "19~",  null,   null,   null,   "!g\r"  },
+                { "32~",  "32~",  "f",    "W",    "231z", "020q", "20~",  null,   null,   null,   "!h\r"  },
+                { "33~",  "33~",  "g",    "X",    "232z", "021q", "21~",  null,   null,   null,   "!i\r"  },
+                { "34~",  "34~",  "h",    "Y",    "233z", "022q", "29~",  null,   null,   null,   "!j\r"  },
+                { "23$",  null,   "i",    "Z",    "234z", "023q", null,   null,   null,   null,   "!k\r"  },
+                { "24$",  null,   "j",    "A",    "235z", "024q", null,   null,   null,   null,   "!l\r"  },
 
                 // !!! NUMPAD missing, this is not trivial given java's messy so called virtual keys... :-(
             };
 
     public final static String[][] specialKeyMapCtrl = {
-                //xterm   linux   scoansi att6386 sun     aixterm vt220   vt100   ansi    vt52
-                { "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A"  },
-                { "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B"  },
-                { "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C"  },
-                { "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D"  },
-
-                { "5~",   "5~",   "I",    "V",    "216z", "150q", "5~",   "5~",   "5~",   "5~" },
-                { "6~",   "6~",   "G",    "U",    "222z", "154q", "6~",   "6~",   "6~",   "6~" },
-                { "4~",   "4~",   "F",    "Y",    "220z", "146q", "4~",   "4~",   "4~",   "4~" },
-                { "@",    "1~",   "H",    "H",    "214z", "H",    "1~",   "1~",   "1~",   "1~" },
-                { "2~",   "2~",   "L",    "@",    "2~",   "139q", "2~",   "2~",   "L",    "L"  },
-
-                { "11^",  null,   "k",    "P",    "224z", "025q", "P",    "P",    "P",    "P"  },
-                { "12^",  null,   "l",    "Q",    "225z", "026q", "Q",    "Q",    "Q",    "Q"  },
-                { "13^",  null,   "m",    "R",    "226z", "027q", "R",    "R",    "R",    "R"  },
-                { "14^",  null,   "n",    "S",    "227z", "028q", "S",    "S",    "S",    "S"  },
-                { "15^",  null,   "o",    "T",    "228z", "029q", null,   null,   null,   null },
-                { "17^",  null,   "p",    "U",    "229z", "030q", null,   null,   null,   null },
-                { "18^",  null,   "q",    "V",    "230z", "031q", null,   null,   null,   null },
-                { "19^",  null,   "r",    "W",    "231z", "032q", null,   null,   null,   null },
-                { "20^",  null,   "s",    "X",    "232z", "033q", null,   null,   null,   null },
-                { "21^",  null,   "t",    "Y",    "233z", "034q", null,   null,   null,   null },
-                { "23^",  null,   "u",    "Z",    "234z", "035q", null,   null,   null,   null },
-                { "24^",  null,   "v",    "A",    "235z", "036q", null,   null,   null,   null },
+                //xterm   linux   scoansi att6386 sun     aixterm vt220   vt100   ansi    vt52    ibm3151
+                { "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A"  },
+                { "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B"  },
+                { "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C"  },
+                { "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D"  },
+
+                { "5~",   "5~",   "I",    "V",    "216z", "150q", "5~",   "5~",   "5~",   "5~",   null  },
+                { "6~",   "6~",   "G",    "U",    "222z", "154q", "6~",   "6~",   "6~",   "6~",   null  },
+                { "4~",   "4~",   "F",    "Y",    "220z", "146q", "4~",   "4~",   "4~",   "4~",   null  },
+                { "@",    "1~",   "H",    "H",    "214z", "H",    "1~",   "1~",   "1~",   "1~",   "H"  },
+                { "2~",   "2~",   "L",    "@",    "2~",   "139q", "2~",   "2~",   "L",    "L",    "P \b"  },
+
+                { "11^",  null,   "k",    "P",    "224z", "025q", "P",    "P",    "P",    "P",    null  },
+                { "12^",  null,   "l",    "Q",    "225z", "026q", "Q",    "Q",    "Q",    "Q",    null  },
+                { "13^",  null,   "m",    "R",    "226z", "027q", "R",    "R",    "R",    "R",    null  },
+                { "14^",  null,   "n",    "S",    "227z", "028q", "S",    "S",    "S",    "S",    null  },
+                { "15^",  null,   "o",    "T",    "228z", "029q", "17~",  null,   null,   null,   null  },
+                { "17^",  null,   "p",    "U",    "229z", "030q", "18~",  null,   null,   null,   null  },
+                { "18^",  null,   "q",    "V",    "230z", "031q", "19~",  null,   null,   null,   null  },
+                { "19^",  null,   "r",    "W",    "231z", "032q", "20~",  null,   null,   null,   null  },
+                { "20^",  null,   "s",    "X",    "232z", "033q", "21~",  null,   null,   null,   null  },
+                { "21^",  null,   "t",    "Y",    "233z", "034q", "29~",  null,   null,   null,   null  },
+                { "23^",  null,   "u",    "Z",    "234z", "035q", null,   null,   null,   null,   null  },
+                { "24^",  null,   "v",    "A",    "235z", "036q", null,   null,   null,   null,   null  },
 
                 // !!! NUMPAD missing, this is not trivial given java's messy so called virtual keys... :-(
             };
 
     public final static String[][] specialKeyMapCtrlShift = {
                 //xterm   linux   scoansi att6386 sun     aixterm vt220   vt100   ansi    vt52
-                { "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A"  },
-                { "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B"  },
-                { "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C"  },
-                { "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D"  },
-
-                { "5~",   "5~",   "I",    "V",    "216z", "150q", "5~",   "5~",   "5~",   "5~" },
-                { "6~",   "6~",   "G",    "U",    "222z", "154q", "6~",   "6~",   "6~",   "6~" },
-                { "4~",   "4~",   "F",    "Y",    "220z", "146q", "4~",   "4~",   "4~",   "4~" },
-                { "@",    "1~",   "H",    "H",    "214z", "H",    "1~",   "1~",   "1~",   "1~" },
-                { "2~",   "2~",   "L",    "@",    "2~",   "139q", "2~",   "2~",   "L",    "L"  },
-
-                { "23^",  null,   "w",    "P",    "224z", "001q", "P",    "P",    "P",    "P"  },
-                { "24^",  null,   "x",    "Q",    "225z", "002q", "Q",    "Q",    "Q",    "Q"  },
-                { "25^",  null,   "y",    "R",    "226z", "003q", "R",    "R",    "R",    "R"  },
-                { "26^",  null,   "z",    "S",    "227z", "004q", "S",    "S",    "S",    "S"  },
-                { "28^",  null,   "@",    "T",    "228z", "005q", null,   null,   null,   null },
-                { "29^",  null,   "[",    "U",    "229z", "006q", null,   null,   null,   null },
-                { "31^",  null,   "\\",   "V",    "230z", "007q", null,   null,   null,   null },
-                { "32^",  null,   "]",    "W",    "231z", "008q", null,   null,   null,   null },
-                { "33^",  null,   "^",    "X",    "232z", "009q", null,   null,   null,   null },
-                { "34^",  null,   "_",    "Y",    "233z", "010q", null,   null,   null,   null },
-                { "23@",  null,   "`",    "Z",    "234z", "011q", null,   null,   null,   null },
-                { "24@",  null,   "{",    "A",    "235z", "012q", null,   null,   null,   null },
+                { "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A",    "A"  },
+                { "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B",    "B"  },
+                { "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C",    "C"  },
+                { "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D",    "D"  },
+
+                { "5~",   "5~",   "I",    "V",    "216z", "150q", "5~",   "5~",   "5~",   "5~",   null  },
+                { "6~",   "6~",   "G",    "U",    "222z", "154q", "6~",   "6~",   "6~",   "6~",   null  },
+                { "4~",   "4~",   "F",    "Y",    "220z", "146q", "4~",   "4~",   "4~",   "4~",   null  },
+                { "@",    "1~",   "H",    "H",    "214z", "H",    "1~",   "1~",   "1~",   "1~",   "H"  },
+                { "2~",   "2~",   "L",    "@",    "2~",   "139q", "2~",   "2~",   "L",    "L",    "P \b"  },
+
+                { "23^",  null,   "w",    "P",    "224z", "001q", "P",    "P",    "P",    "P",    null  },
+                { "24^",  null,   "x",    "Q",    "225z", "002q", "Q",    "Q",    "Q",    "Q",    null  },
+                { "25^",  null,   "y",    "R",    "226z", "003q", "R",    "R",    "R",    "R",    null  },
+                { "26^",  null,   "z",    "S",    "227z", "004q", "S",    "S",    "S",    "S",    null  },
+                { "28^",  null,   "@",    "T",    "228z", "005q", "17~",  null,   null,   null,   null  },
+                { "29^",  null,   "[",    "U",    "229z", "006q", "18~",  null,   null,   null,   null  },
+                { "31^",  null,   "\\",   "V",    "230z", "007q", "19~",  null,   null,   null,   null  },
+                { "32^",  null,   "]",    "W",    "231z", "008q", "20~",  null,   null,   null,   null  },
+                { "33^",  null,   "^",    "X",    "232z", "009q", "21~",  null,   null,   null,   null  },
+                { "34^",  null,   "_",    "Y",    "233z", "010q", "29~",  null,   null,   null,   null  },
+                { "23@",  null,   "`",    "Z",    "234z", "011q", null,   null,   null,   null,   null  },
+                { "24@",  null,   "{",    "A",    "235z", "012q", null,   null,   null,   null,   null  },
 
                 // !!! NUMPAD missing, this is not trivial given java's messy so called virtual keys... :-(
             };
@@ -504,10 +511,35 @@
 
     public TerminalXTerm() {
         this(DEFAULT_TERM);
+
+        /*System.out.println("groundTable = "+groundTable);
+    	System.out.println("csiTable = "+csiTable);
+    	System.out.println("decTable = "+decTable);
+    	System.out.println("oscTable = "+oscTable);
+    	System.out.println("xtermSeqTable = "+xtermSeqTable);
+    	System.out.println("eigTable = "+eigTable);
+    	System.out.println("escTable = "+escTable);
+    	System.out.println("iesTable = "+iesTable);
+    	System.out.println("ignTable = "+ignTable);
+    	System.out.println("scrTable = "+scrTable);
+    	System.out.println("scsTable = "+scsTable);*/
+
     }
 
     public TerminalXTerm(int personality) {
         try {
+        	/*System.out.println("groundTable = "+groundTable);
+        	System.out.println("csiTable = "+csiTable);
+        	System.out.println("decTable = "+decTable);
+        	System.out.println("oscTable = "+oscTable);
+        	System.out.println("xtermSeqTable = "+xtermSeqTable);
+        	System.out.println("eigTable = "+eigTable);
+        	System.out.println("escTable = "+escTable);
+        	System.out.println("iesTable = "+iesTable);
+        	System.out.println("ignTable = "+ignTable);
+        	System.out.println("scrTable = "+scrTable);
+        	System.out.println("scsTable = "+scsTable);*/
+
             setTerminalType(personality);
         } catch (NoSuchElementException e) {
             try {
@@ -687,6 +719,52 @@
         return c;
     }
 
+    final char mapLineDrawToIBM3151(char c) {
+        switch(c) {
+        case ' ':
+            c = ' ';
+            break;
+        case '\352':
+            c = 'j';
+            break;
+        case '\353':
+            c = 'k';
+            break;
+        case '\354':
+            c = 'l';
+            break;
+        case '\355':
+            c = 'm';
+            break;
+        case '\356':
+            c = 'n';
+            break;
+        case '\361':
+            c = 'q';
+            break;
+        case '\364':
+            c = 't';
+            break;
+        case '\365':
+            c = 'u';
+            break;
+        case '\366':
+            c = 'v';
+            break;
+        case '\367':
+            c = 'w';
+            break;
+        case '\370':
+            c = 'x';
+            break;
+        default:
+            if(DEBUGNOTIMPL)
+                notImplemented("ibm3151 line-draw-char: " + c + " (" + ((int)c) + ")");
+            break;
+        }
+        return c;
+    }
+
     final char mapLineDrawToATT6386(char c) {
         switch(c) {
         case ' ':
@@ -791,14 +869,18 @@
 
         switch(parseState[c]) {
         case CASE_PRINT:
-            if(DEBUGPRINT)
+            if(DEBUGPRINT) {
                 System.out.println("PRINT: " + c + "(" + ((int)c) + ") " + curGL);
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+(int)parseState[c]);
+            }
             int ic = IGNORE;
             int graphic;
             if (c >= 128 && curGR != -1) {
+            	//System.out.println("graphic = curGR = "+curGR);
                 graphic = curGR;
                 c -= 128;
             } else {
+            	//System.out.println("graphic = curGL = "+curGL);
                 graphic = curGL;
             }
             switch(gSets[graphic]) {
@@ -819,7 +901,11 @@
                 // this in TerminalWin but this is simpler...)
                 //
                 if(ic < 32) {
-                    if(ic == 0 && hasNullPadding(whoAmIReally))
+                	if(whoAmIReally==EMUL_IBM3151 & ic==16) {
+                		parseState = prnTable_ibm3151;
+                		return IGNORE;
+                	}
+                	if(ic == 0 && hasNullPadding(whoAmIReally))
                         return IGNORE;
                     term.write('^');
                     ic += 64;
@@ -835,7 +921,9 @@
                             c = mapLineDrawToLinux(c);
                         } else if (whoAmIReally == EMUL_ATT6386) {
                             c = mapLineDrawToATT6386(c);
-                        }
+                        } /*else if (whoAmIReally == EMUL_IBM3151) {
+                        	c = mapLineDrawToIBM3151(c);
+                        }*/
                         term.writeLineDrawChar(c);
                     }
                 } else {
@@ -848,92 +936,133 @@
             }
             return ic;
         case CASE_GROUND_STATE:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("GND_STATE");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             parseState = groundTable;
             break;
         case CASE_IGNORE_STATE:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("IGN_STATE");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             parseState = ignTable;
             break;
         case CASE_IGNORE_ESC:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("IGN_ESC");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             parseState = iesTable;
             break;
         case CASE_IGNORE:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("IGNORE");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             break;
         case CASE_BELL:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("BELL");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.doBell();
             break;
         case CASE_BS:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("BS");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.doBS();
             break;
         case CASE_CR:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CR");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.doCR();
             parseState = groundTable;
             break;
         case CASE_ESC:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("ESC");
-            parseState = escTable;
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+            if(whoAmIReally==EMUL_IBM3151) {
+            	param[0] = PARAMNOTUSED;
+            	nparam = 1;
+            	parseState = escTable_ibm3151;
+            }
+            else {
+            	parseState = escTable;
+            }
             break;
         case CASE_VMOT:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("VMOT");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.doLF();
             parseState = groundTable;
             break;
         case CASE_TAB:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("TAB");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.doTab();
             break;
         case CASE_SI:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SI(curGL = 0)");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             curGL = 0;
             break;
         case CASE_SO:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("S0(curGL = 1)");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             curGL = 1;
             break;
         case CASE_SCR_STATE:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("SCR_STATE");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             parseState = scrTable;
             break;
         case CASE_SCS0_STATE:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SCS0");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             scsType    = 0;
             parseState = scsTable;
             break;
         case CASE_SCS1_STATE:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SCS1");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             scsType    = 1;
             parseState = scsTable;
             break;
         case CASE_SCS2_STATE:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SCS2");
-            scsType    = 2;
+                //System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+        	scsType    = 2;
             parseState = scsTable;
             break;
         case CASE_SCS3_STATE:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SCS3");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             scsType    = 3;
             parseState = scsTable;
             break;
@@ -943,33 +1072,51 @@
             parseState = eigTable;
             break;
         case CASE_ESC_DIGIT:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("ESC_DIGIT (" + ((int)(c - '0')) + ")");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[nparam - 1];
             if(val == PARAMNOTUSED)
                 val = 0;
             param[nparam - 1] = 10 * val + (c - '0');
             break;
+        case CASE_ESC_CHAR:
+            if(DEBUGSTATE) {
+                System.out.println("ESC_CHAR ("+c+")");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+            param[nparam - 1] = c;
+            param[nparam++] = PARAMNOTUSED;
+            break;
         case CASE_ESC_SEMI:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("ESC_SEMI");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             param[nparam++] = PARAMNOTUSED;
             break;
         case CASE_ESC_SEMIOSC:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("ESC_SEMIOSC");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             param[nparam++] = PARAMNOTUSED;
             xtermSeq   = "";
             parseState = xtermSeqTable;
             break;
         case CASE_DEC_STATE:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("DEC_STATE");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             parseState = decTable;
             break;
         case CASE_ICH:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("ICH");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val < 1)
                 val = 1;
@@ -980,8 +1127,10 @@
             term.doCR();
             // Fall through
         case CASE_CUU:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CUU/CPL");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val < 1)
                 val = 1;
@@ -992,8 +1141,10 @@
             term.doCR();
             // Fall through
         case CASE_CUD:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CUD/CNL");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val < 1)
                 val = 1;
@@ -1001,8 +1152,10 @@
             parseState = groundTable;
             break;
         case CASE_CUF:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CUF");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val < 1)
                 val = 1;
@@ -1010,8 +1163,10 @@
             parseState = groundTable;
             break;
         case CASE_CUB:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CUB");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val < 1)
                 val = 1;
@@ -1021,8 +1176,10 @@
         case CASE_CUP:
             v = param[0];
             h = param[1];
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CUP " + v + " " + h);
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             if(v < 1)
                 v = 1;
             if(nparam < 2 || h < 1)
@@ -1030,9 +1187,96 @@
             term.cursorSetPos(v - 1, h - 1, windowRelative);
             parseState = groundTable;
             break;
+        case CASE_IBM3151_CUP:
+        	if(DEBUG) {
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+        	if((param[nparam-1]==PARAMNOTUSED)&(nparam==1)&(c=='Y')) {
+        		parseState = cupTable_ibm3151;
+        	}
+        	else {
+        		param[nparam-1] = (int)(c - ' ');
+        		param[nparam++] = PARAMNOTUSED;
+        		if(nparam==3) {
+        			v = param[0];
+        			h = param[1];
+                	if(DEBUG) {
+                        System.out.println("IBM3151_CUP "+(v+1)+" "+(h+1));
+                    	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+                    }
+                    term.cursorSetPos(v, h, windowRelative);
+                    parseState = groundTable;
+        		}
+        	}
+            break;
+        case CASE_IBM3151_PRN:
+        	int mc = c==20? 4 : 5;
+        	if(DEBUG) {
+                System.out.println("IBM3151_PRN MC"+mc);
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+			ansiPrinterCtrl(mc);
+        	parseState = groundTable;
+        	break;
+        case CASE_IBM3151_ACS:
+        	if(DEBUG) {
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+        	if((param[nparam-1]==PARAMNOTUSED)&(nparam==1)) {
+        		if (c=='>') {
+    				parseState = acsTable_ibm3151;
+        		}
+        		else {
+        			param[nparam-1] = c;
+        			param[nparam] = PARAMNOTUSED;
+        			nparam++;
+        			switch(c) {
+	        			case 'A':
+	        				curGR = 1;
+	        				if (DEBUG) System.out.println("IBM3151_ACS A");
+	        				break;
+	        			case 'B':
+	        				curGR = 0;
+	        				if (DEBUG) System.out.println("IBM3151_ACS B");
+	        				break;
+	        			default:
+	        				if(DEBUG) System.out.println("IBM3151_ACS unknown");
+	        		}
+    				parseState = groundTable;
+        		}
+        	}
+        	else {
+        		parseState = groundTable;
+        	}
+            break;
+        case CASE_IBM3151_ISRS:
+        	if(DEBUG) {
+                System.out.println("IBM3151_ISRS");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+        	if((param[nparam-1]==PARAMNOTUSED)&(nparam==1)) {
+        		if (c==' ') {
+    				parseState = isrsTable_ibm3151;
+        		}
+        		else if (c=='S'){
+        			param[nparam-1] = c;
+        			param[nparam] = PARAMNOTUSED;
+        			nparam++;
+                    term.clearAllAttributes();
+                    term.clearScreen();
+                    term.cursorSetPos(0, 0, windowRelative);
+   				parseState = groundTable;
+        		}
+        	}
+        	else {
+        		parseState = groundTable;
+        	}
+            break;
         case CASE_ED:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("ED: " + param[0]);
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             switch(param[0]) {
             case PARAMNOTUSED:
             case 0:
@@ -1049,8 +1293,10 @@
             parseState = groundTable;
             break;
         case CASE_EL:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("EL");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             switch(param[0]) {
             case PARAMNOTUSED:
             case 0:
@@ -1066,8 +1312,10 @@
             parseState = groundTable;
             break;
         case CASE_IL:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("IL");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val < 1)
                 val = 1;
@@ -1075,8 +1323,10 @@
             parseState = groundTable;
             break;
         case CASE_DL:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DL");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val < 1)
                 val = 1;
@@ -1084,8 +1334,10 @@
             parseState = groundTable;
             break;
         case CASE_DCH:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DCH");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val < 1)
                 val = 1;
@@ -1098,8 +1350,10 @@
             param[0] = PARAMNOTUSED;
             // Fall through
         case CASE_DA1:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DA1");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             reply = replyTypes[R_CSI] + "?1;2c";
             term.sendBytes(reply.getBytes());
             parseState = groundTable;
@@ -1109,8 +1363,10 @@
                 notImplemented("TRACK_MOUSE");
             break;
         case CASE_TBC:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("TBC " + "(" + term.getCursorH() + ")");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             if(param[0] <= 0) {
                 term.clearTab(term.getCursorH());
             } else if(param[0] == 3) {
@@ -1119,26 +1375,37 @@
             parseState = groundTable;
             break;
         case CASE_SET:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SET");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             ansiModes(true);
             parseState = groundTable;
             break;
         case CASE_RST:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("RST");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             ansiModes(false);
             parseState = groundTable;
             break;
         case CASE_SGR:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SGR");
-            sgrModes();
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+            if(whoAmIReally==EMUL_IBM3151)
+            	sgrModes(c);
+            else
+            	sgrModes();
             parseState = groundTable;
             break;
         case CASE_CPR:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CPR");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             reply = null;
             if(param[0] == 5)
                 reply = replyTypes[R_CSI] + "0n";
@@ -1149,8 +1416,10 @@
             parseState = groundTable;
             break;
         case CASE_DECSTBM:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECSTBM");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             int top = param[0];
             int bot = param[1];
             if(top < 1)
@@ -1164,8 +1433,10 @@
             parseState = groundTable;
             break;
         case CASE_DECREQTPARM:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECREQTPARM");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             if(param[0] == PARAMNOTUSED || param[0] == 1 || param[0] == 0)
                 reply = (replyTypes[R_CSI] + String.valueOf((term.getCursorV() + 2)) + ";1;1;112;112;1;0x");
             if(reply != null)
@@ -1173,54 +1444,70 @@
             parseState = groundTable;
             break;
         case CASE_DECSET:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECSET");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             dpModes(true);
             parseState = groundTable;
             break;
         case CASE_DECRST:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECRST");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             dpModes(false);
             parseState = groundTable;
             break;
         case CASE_DECALN:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECALN");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.fillScreen('E');
             parseState = groundTable;
             break;
         case CASE_GSETS:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("GSETS: '" + c + "'");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             gSets[scsType] = c;
             parseState = groundTable;
             break;
         case CASE_DECSC:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECSC");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.cursorSave();
             curGLDECSC = curGL;
             System.arraycopy(gSets, 0, gSetsDECSC, 0, 4);
             parseState = groundTable;
             break;
         case CASE_DECRC:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECRC");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.cursorRestore();
             curGL = curGLDECSC;
             System.arraycopy(gSetsDECSC, 0, gSets, 0, 4);
             parseState = groundTable;
             break;
         case CASE_DECKPAM:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECKPAM");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             keypadAppl = true;
             parseState = groundTable;
             break;
         case CASE_DECKPNM:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("DECKPNM");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             keypadAppl = false;
             parseState = groundTable;
             break;
@@ -1229,21 +1516,27 @@
             parseState = groundTable;
             break;
         case CASE_NEL:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("NEL");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.cursorIndex(1);
             term.doCR();
             parseState = groundTable;
             break;
         case CASE_HTS:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("HTS (" + term.getCursorH() + ")");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.setTab(term.getCursorH());
             parseState = groundTable;
             break;
         case CASE_RI:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("RI");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             term.cursorIndexRev(1);
             parseState = groundTable;
             break;
@@ -1256,50 +1549,73 @@
             parseState = groundTable;
             break;
         case CASE_CSI_STATE:
-            if(DEBUGSTATE)
+            if(DEBUGSTATE) {
                 System.out.println("CSI_STATE");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             param[0]   = PARAMNOTUSED;
             nparam     = 1;
             parseState = csiTable;
             break;
+        case CASE_IBM3151_SGR:
+            if(DEBUGSTATE) {
+                System.out.println("IBM3151_SGR_STATE");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
+            param[0]   = PARAMNOTUSED;
+            nparam     = 1;
+            parseState = sgrTable_ibm3151;
+            break;
         case CASE_OSC:
             param[0] = PARAMNOTUSED;
             nparam   = 1;
             parseState = oscTable;
             break;
         case CASE_RIS:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("RIS");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             vtReset();
             parseState = groundTable;
             break;
         case CASE_LS2:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SI(curGL = 2)");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             curGL = 2;
             parseState = groundTable;
             break;
         case CASE_LS3:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SI(curGL = 3)");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             curGL = 3;
             parseState = groundTable;
             break;
         case CASE_LS3R:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("LS3R");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             parseState = groundTable;
             curGR = 3;
             break;
         case CASE_LS2R:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("LS2R");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             parseState = groundTable;
             curGR = 2;
             break;
         case CASE_LS1R:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("LS1R");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             curGR = 1;
             parseState = groundTable;
             break;
@@ -1331,8 +1647,10 @@
             parseState = groundTable;
             break;
         case CASE_XTERM_SEQ:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("XTERM_SEQ");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             xtermModes();
             parseState = groundTable;
             break;
@@ -1348,8 +1666,10 @@
             xtermWinCtrl();
             parseState = groundTable;
         case CASE_CHT:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CHT");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val == PARAMNOTUSED)
                 val = 1;
@@ -1357,8 +1677,10 @@
             parseState = groundTable;
             break;
         case CASE_SU:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SU");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val == PARAMNOTUSED)
                 val = 1;
@@ -1366,8 +1688,10 @@
             parseState = groundTable;
             break;
         case CASE_SD:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("SD");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val == PARAMNOTUSED)
                 val = 1;
@@ -1375,8 +1699,10 @@
             parseState = groundTable;
             break;
         case CASE_ECH:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("ECH");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val == PARAMNOTUSED)
                 val = 1;
@@ -1384,8 +1710,10 @@
             parseState = groundTable;
             break;
         case CASE_CBT:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("CBT");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val == PARAMNOTUSED)
                 val = 1;
@@ -1394,8 +1722,10 @@
             break;
         case CASE_CHA:
         case CASE_HPA:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("HPA/CHA");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             h = param[0];
             if(h < 1)
                 h = 1;
@@ -1403,13 +1733,17 @@
             parseState = groundTable;
             break;
         case CASE_REP:
-            if(DEBUGNOTIMPL)
+            if(DEBUGNOTIMPL) {
                 notImplemented("REP");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             parseState = groundTable;
             break;
         case CASE_VPA:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("VPA");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             v = param[0];
             if(v < 1)
                 v = 1;
@@ -1417,8 +1751,10 @@
             parseState = groundTable;
             break;
         case CASE_ANSI_PRINTER:
-            if(DEBUG)
+            if(DEBUG) {
                 System.out.println("ANSI_PRINTER");
+            	//System.out.println("TerminalXTerm.interpretChar("+c+"):"+parseState+"["+(int)c+"] = "+parseState[c]);
+            }
             val = param[0];
             if(val == PARAMNOTUSED)
                 val = 0;
@@ -1564,6 +1900,66 @@
         }
     }
 
+    protected void sgrModes(char c) {
+    	//System.out.println("sgrModes(char c):nparam= "+nparam);
+        for(int i = 0; i < nparam; i++) {
+        	if(c=='@') {
+        		term.clearAllAttributes();
+        	}
+        	else if(c=='a') {
+	            switch((char)param[i]) {
+	            case (char)PARAMNOTUSED:
+	            	break;
+	            case '(':
+	            case '$':
+	                // !!! Should be Hilite/blinking...
+	                term.setAttribute(CompatTerminal.ATTR_BOLD, true);
+	                break;
+	            case '"':
+	                term.setAttribute(CompatTerminal.ATTR_UNDERLINE, true);
+	                break;
+	            case '!':
+	                term.setAttribute(CompatTerminal.ATTR_INVERSE, true);
+	                break;
+	            case '0':
+	                term.setAttribute(CompatTerminal.ATTR_INVISIBLE, true);
+	                break;
+	            default:
+	                if(DEBUGNOTIMPL)
+	                    notImplemented("IBM3151_SGR: " + param[i]);
+	            }
+        	}
+        	else if(c=='b') {
+	            switch((char)param[i]) {
+	            case (char)PARAMNOTUSED:
+	            	break;
+	            case '=':
+	                term.setAttribute(CompatTerminal.ATTR_UNDERLINE, false);
+	                break;
+	            case '>':
+	                term.setAttribute(CompatTerminal.ATTR_INVERSE, false);
+	                break;
+	            default:
+	                if(DEBUGNOTIMPL)
+	                    notImplemented("IBM3151_SGR: " + param[i]);
+	            }
+        	}
+        	else if(c=='B') {
+	            switch((char)param[i]) {
+	            case (char)PARAMNOTUSED:
+	            	break;
+	            case '>':
+	            	if(i==2&nparam==4&param[0]=='@'&param[1]=='\033') {
+	            		term.clearAllAttributes();
+	            	}
+	            default:
+	                if(DEBUGNOTIMPL)
+	                    notImplemented("IBM3151_SGR: " + param[i]);
+	            }
+        	}
+        }
+    }
+
     protected void dpModes(boolean set) {
         for(int i = 0; i < nparam; i++) {
             switch(param[i]) {
@@ -1934,7 +2330,9 @@
         case KeyEvent.VK_DOWN:
         case KeyEvent.VK_RIGHT:
         case KeyEvent.VK_LEFT:
-            if(cursorKeysMode)
+            if(whoAmIReally == EMUL_IBM3151)
+            	prefix = replyTypes[R_ESC];
+            else if(cursorKeysMode)
                 prefix = replyTypes[R_SS3];
             else
                 prefix = replyTypes[R_CSI];
@@ -1945,12 +2343,18 @@
         case KeyEvent.VK_END:
         case KeyEvent.VK_HOME:
             if(!term.getOption(CompatTerminal.OPT_LOCAL_PGKEYS)) {
-                prefix = replyTypes[R_CSI];
+            	if(whoAmIReally == EMUL_IBM3151)
+            		prefix = replyTypes[R_ESC];
+            	else
+            		prefix = replyTypes[R_CSI];
                 specialKey = mapSpecialKeys(virtualKey, modifiers);
             }
             break;
         case KeyEvent.VK_INSERT:
-            prefix = replyTypes[R_CSI];
+        	if(whoAmIReally == EMUL_IBM3151)
+        		prefix = replyTypes[R_ESC];
+        	else
+        		prefix = replyTypes[R_CSI];
             specialKey = mapSpecialKeys(virtualKey, modifiers);
             break;
         case KeyEvent.VK_F1:
@@ -1972,7 +2376,7 @@
                     prefix = replyTypes[R_CSI];
                 else
                     prefix = replyTypes[R_SS3];
-            } else if(whoAmIReally == EMUL_VT52) {
+            } else if(whoAmIReally == EMUL_VT52 || whoAmIReally == EMUL_IBM3151) {
                 prefix = replyTypes[R_ESC];
             } else {
                 prefix = replyTypes[R_CSI];
@@ -4358,6 +4762,1951 @@
             CASE_GROUND_STATE,
         };
 
+    // ESC IBM3151
+    public final static int[] escTable_ibm3151 =
+        {
+            /*	NUL		SOH		STX		ETX	*/
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*	EOT		ENQ		ACK		BEL	*/
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_BELL,
+            /*	BS		HT		NL		VT	*/
+            CASE_BS,
+            CASE_TAB,
+            CASE_VMOT,
+            CASE_VMOT,
+            /*	NP		CR		SO		SI	*/
+            CASE_VMOT,
+            CASE_CR,
+            CASE_SO,
+            CASE_SI,
+            /*	DLE		DC1		DC2		DC3	*/
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*	DC4		NAK		SYN		ETB	*/
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*	CAN		EM		SUB		ESC	*/
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_ESC,
+            /*	FS		GS		RS		US	*/
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*	SP		!		"		#	*/
+            CASE_IBM3151_ISRS,
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            /*	$		%		&		'	*/
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            /*	(		)		*		+	*/
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            /*	,		-		.		/	*/
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            CASE_ESC_IGNORE,
+            /*	0		1		2		3	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	4		5		6		7	*/
+            CASE_IBM3151_SGR,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	8		9		:		;	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	<		=		>		?	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_IBM3151_ACS,
+            CASE_GROUND_STATE,
+            /*	@		A		B		C	*/
+            CASE_GROUND_STATE,
+            CASE_CUU,
+            CASE_CUD,
+            CASE_CUF,
+            /*	D		E		F		G	*/
+            CASE_CUB,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	H		I		J		K	*/
+            CASE_CUP,
+            CASE_EL,
+            CASE_ED,
+            CASE_GROUND_STATE,
+            /*	L		M		N		O	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_IL,
+            CASE_DL,
+            /*	P		Q		R		S	*/
+            CASE_GROUND_STATE,
+            CASE_DCH,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	T		U		V		W	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	X		Y		Z		[	*/
+            CASE_GROUND_STATE,
+            CASE_IBM3151_CUP,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	\		]		^		_	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_IGNORE_STATE,
+            CASE_IGNORE_STATE,
+            /*	`		a		b		c	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	d		e		f		g	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	h		i		j		k	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	l		m		n		o	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	p		q		r		s	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	t		u		v		w	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	x		y		z		{	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*	|		}		~		DEL	*/
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      0x80            0x81            0x82            0x83    */
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*      0x84            0x85            0x86            0x87    */
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*      0x88            0x89            0x8a            0x8b    */
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*      0x8c            0x8d            0x8e            0x8f    */
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*      0x90            0x91            0x92            0x93    */
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*      0x94            0x95            0x96            0x97    */
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*      0x99            0x99            0x9a            0x9b    */
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*      0x9c            0x9d            0x9e            0x9f    */
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            CASE_IGNORE,
+            /*      nobreakspace    exclamdown      cent            sterling        */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      currency        yen             brokenbar       section         */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      diaeresis       copyright       ordfeminine     guillemotleft   */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      notsign         hyphen          registered      macron          */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      degree          plusminus       twosuperior     threesuperior   */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      acute           mu              paragraph       periodcentered  */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      cedilla         onesuperior     masculine       guillemotright  */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      onequarter      onehalf         threequarters   questiondown    */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      Agrave          Aacute          Acircumflex     Atilde          */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      Adiaeresis      Aring           AE              Ccedilla        */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      Egrave          Eacute          Ecircumflex     Ediaeresis      */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      Igrave          Iacute          Icircumflex     Idiaeresis      */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      Eth             Ntilde          Ograve          Oacute          */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      Ocircumflex     Otilde          Odiaeresis      multiply        */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      Ooblique        Ugrave          Uacute          Ucircumflex     */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      Udiaeresis      Yacute          Thorn           ssharp          */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      agrave          aacute          acircumflex     atilde          */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      adiaeresis      aring           ae              ccedilla        */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      egrave          eacute          ecircumflex     ediaeresis      */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      igrave          iacute          icircumflex     idiaeresis      */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      eth             ntilde          ograve          oacute          */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      ocircumflex     otilde          odiaeresis      division        */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      oslash          ugrave          uacute          ucircumflex     */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            /*      udiaeresis      yacute          thorn           ydiaeresis      */
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+            CASE_GROUND_STATE,
+        };
+
+    public final static int[] sgrTable_ibm3151=
+    {
+        /*	NUL		SOH		STX		ETX	*/
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*	EOT		ENQ		ACK		BEL	*/
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_BELL,
+        /*	BS		HT		NL		VT	*/
+        CASE_BS,
+        CASE_TAB,
+        CASE_VMOT,
+        CASE_VMOT,
+        /*	NP		CR		SO		SI	*/
+        CASE_VMOT,
+        CASE_CR,
+        CASE_SO,
+        CASE_SI,
+        /*	DLE		DC1		DC2		DC3	*/
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*	DC4		NAK		SYN		ETB	*/
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*	CAN		EM		SUB		ESC	*/
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_ESC_CHAR,
+        /*	FS		GS		RS		US	*/
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*	SP		!		"		#	*/
+        CASE_ESC_IGNORE,
+        CASE_ESC_CHAR,
+        CASE_ESC_CHAR,
+        CASE_ESC_IGNORE,
+        /*	$		%		&		'	*/
+        CASE_ESC_CHAR,
+        CASE_ESC_IGNORE,
+        CASE_ESC_IGNORE,
+        CASE_ESC_IGNORE,
+        /*	(		)		*		+	*/
+        CASE_ESC_CHAR,
+        CASE_ESC_IGNORE,
+        CASE_ESC_IGNORE,
+        CASE_ESC_IGNORE,
+        /*	,		-		.		/	*/
+        CASE_ESC_IGNORE,
+        CASE_ESC_IGNORE,
+        CASE_ESC_IGNORE,
+        CASE_ESC_IGNORE,
+        /*	0		1		2		3	*/
+        CASE_ESC_CHAR,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	4		5		6		7	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	8		9		:		;	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	<		=		>		?	*/
+        CASE_GROUND_STATE,
+        CASE_ESC_CHAR,
+        CASE_ESC_CHAR,
+        CASE_GROUND_STATE,
+        /*	@		A		B		C	*/
+        CASE_SGR,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	D		E		F		G	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	H		I		J		K	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	L		M		N		O	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	P		Q		R		S	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	T		U		V		W	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	X		Y		Z		[	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	\		]		^		_	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	`		a		b		c	*/
+        CASE_GROUND_STATE,
+        CASE_SGR,
+        CASE_SGR,
+        CASE_GROUND_STATE,
+        /*	d		e		f		g	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	h		i		j		k	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	l		m		n		o	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	p		q		r		s	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	t		u		v		w	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	x		y		z		{	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	|		}		~		DEL	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x80            0x81            0x82            0x83    */
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*      0x84            0x85            0x86            0x87    */
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*      0x88            0x89            0x8a            0x8b    */
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*      0x8c            0x8d            0x8e            0x8f    */
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*      0x90            0x91            0x92            0x93    */
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*      0x94            0x95            0x96            0x97    */
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*      0x99            0x99            0x9a            0x9b    */
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*      0x9c            0x9d            0x9e            0x9f    */
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        CASE_IGNORE,
+        /*      nobreakspace    exclamdown      cent            sterling        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      currency        yen             brokenbar       section         */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      diaeresis       copyright       ordfeminine     guillemotleft   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      notsign         hyphen          registered      macron          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      degree          plusminus       twosuperior     threesuperior   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      acute           mu              paragraph       periodcentered  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      cedilla         onesuperior     masculine       guillemotright  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      onequarter      onehalf         threequarters   questiondown    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Agrave          Aacute          Acircumflex     Atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Adiaeresis      Aring           AE              Ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Egrave          Eacute          Ecircumflex     Ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Igrave          Iacute          Icircumflex     Idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Eth             Ntilde          Ograve          Oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ocircumflex     Otilde          Odiaeresis      multiply        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ooblique        Ugrave          Uacute          Ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Udiaeresis      Yacute          Thorn           ssharp          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      agrave          aacute          acircumflex     atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      adiaeresis      aring           ae              ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      egrave          eacute          ecircumflex     ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      igrave          iacute          icircumflex     idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      eth             ntilde          ograve          oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      ocircumflex     otilde          odiaeresis      division        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      oslash          ugrave          uacute          ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      udiaeresis      yacute          thorn           ydiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+    };
+    
+    public final static int[] cupTable_ibm3151=
+    {
+        /*	NUL		SOH		STX		ETX	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	EOT		ENQ		ACK		BEL	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	BS		HT		NL		VT	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	NP		CR		SO		SI	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	DLE		DC1		DC2		DC3	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	DC4		NAK		SYN		ETB	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	CAN		EM		SUB		ESC	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	FS		GS		RS		US	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	SP		!		"		#	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	$		%		&		'	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	(		)		*		+	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	,		-		.		/	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	0		1		2		3	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	4		5		6		7	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	8		9		:		;	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	<		=		>		?	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	@		A		B		C	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	D		E		F		G	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	H		I		J		K	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	L		M		N		O	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	P		Q		R		S	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	T		U		V		W	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	X		Y		Z		[	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	\		]		^		_	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	`		a		b		c	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	d		e		f		g	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	h		i		j		k	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	l		m		n		o	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	p		q		r		s	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	t		u		v		w	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	x		y		z		{	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*	|		}		~		DEL	*/
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*      0x80            0x81            0x82            0x83    */
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*      0x84            0x85            0x86            0x87    */
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*      0x88            0x89            0x8a            0x8b    */
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*      0x8c            0x8d            0x8e            0x8f    */
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        CASE_IBM3151_CUP,
+        /*      0x90            0x91            0x92            0x93    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x94            0x95            0x96            0x97    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x99            0x99            0x9a            0x9b    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x9c            0x9d            0x9e            0x9f    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      nobreakspace    exclamdown      cent            sterling        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      currency        yen             brokenbar       section         */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      diaeresis       copyright       ordfeminine     guillemotleft   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      notsign         hyphen          registered      macron          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      degree          plusminus       twosuperior     threesuperior   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      acute           mu              paragraph       periodcentered  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      cedilla         onesuperior     masculine       guillemotright  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      onequarter      onehalf         threequarters   questiondown    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Agrave          Aacute          Acircumflex     Atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Adiaeresis      Aring           AE              Ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Egrave          Eacute          Ecircumflex     Ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Igrave          Iacute          Icircumflex     Idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Eth             Ntilde          Ograve          Oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ocircumflex     Otilde          Odiaeresis      multiply        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ooblique        Ugrave          Uacute          Ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Udiaeresis      Yacute          Thorn           ssharp          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      agrave          aacute          acircumflex     atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      adiaeresis      aring           ae              ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      egrave          eacute          ecircumflex     ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      igrave          iacute          icircumflex     idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      eth             ntilde          ograve          oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      ocircumflex     otilde          odiaeresis      division        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      oslash          ugrave          uacute          ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      udiaeresis      yacute          thorn           ydiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+    };
+    
+    public final static int[] prnTable_ibm3151=
+    {
+        /*	NUL		SOH		STX		ETX	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	EOT		ENQ		ACK		BEL	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	BS		HT		NL		VT	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	NP		CR		SO		SI	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	DLE		DC1		DC2		DC3	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_IBM3151_PRN,
+        CASE_GROUND_STATE,
+        /*	DC4		NAK		SYN		ETB	*/
+        CASE_IBM3151_PRN,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	CAN		EM		SUB		ESC	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	FS		GS		RS		US	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	SP		!		"		#	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	$		%		&		'	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	(		)		*		+	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	,		-		.		/	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	0		1		2		3	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	4		5		6		7	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	8		9		:		;	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	<		=		>		?	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	@		A		B		C	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	D		E		F		G	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	H		I		J		K	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	L		M		N		O	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	P		Q		R		S	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	T		U		V		W	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	X		Y		Z		[	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	\		]		^		_	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	`		a		b		c	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	d		e		f		g	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	h		i		j		k	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	l		m		n		o	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	p		q		r		s	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	t		u		v		w	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	x		y		z		{	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	|		}		~		DEL	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x80            0x81            0x82            0x83    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x84            0x85            0x86            0x87    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x88            0x89            0x8a            0x8b    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x8c            0x8d            0x8e            0x8f    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x90            0x91            0x92            0x93    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x94            0x95            0x96            0x97    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x99            0x99            0x9a            0x9b    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x9c            0x9d            0x9e            0x9f    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      nobreakspace    exclamdown      cent            sterling        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      currency        yen             brokenbar       section         */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      diaeresis       copyright       ordfeminine     guillemotleft   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      notsign         hyphen          registered      macron          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      degree          plusminus       twosuperior     threesuperior   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      acute           mu              paragraph       periodcentered  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      cedilla         onesuperior     masculine       guillemotright  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      onequarter      onehalf         threequarters   questiondown    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Agrave          Aacute          Acircumflex     Atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Adiaeresis      Aring           AE              Ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Egrave          Eacute          Ecircumflex     Ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Igrave          Iacute          Icircumflex     Idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Eth             Ntilde          Ograve          Oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ocircumflex     Otilde          Odiaeresis      multiply        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ooblique        Ugrave          Uacute          Ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Udiaeresis      Yacute          Thorn           ssharp          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      agrave          aacute          acircumflex     atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      adiaeresis      aring           ae              ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      egrave          eacute          ecircumflex     ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      igrave          iacute          icircumflex     idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      eth             ntilde          ograve          oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      ocircumflex     otilde          odiaeresis      division        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      oslash          ugrave          uacute          ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      udiaeresis      yacute          thorn           ydiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+    };
+    
+    public final static int[] isrsTable_ibm3151=
+    {
+        /*	NUL		SOH		STX		ETX	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	EOT		ENQ		ACK		BEL	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	BS		HT		NL		VT	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	NP		CR		SO		SI	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	DLE		DC1		DC2		DC3	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	DC4		NAK		SYN		ETB	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	CAN		EM		SUB		ESC	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	FS		GS		RS		US	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	SP		!		"		#	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	$		%		&		'	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	(		)		*		+	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	,		-		.		/	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	0		1		2		3	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	4		5		6		7	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	8		9		:		;	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	<		=		>		?	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	@		A		B		C	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	D		E		F		G	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	H		I		J		K	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	L		M		N		O	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	P		Q		R		S	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_IBM3151_ISRS,
+        /*	T		U		V		W	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	X		Y		Z		[	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	\		]		^		_	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	`		a		b		c	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	d		e		f		g	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	h		i		j		k	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	l		m		n		o	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	p		q		r		s	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	t		u		v		w	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	x		y		z		{	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	|		}		~		DEL	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x80            0x81            0x82            0x83    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x84            0x85            0x86            0x87    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x88            0x89            0x8a            0x8b    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x8c            0x8d            0x8e            0x8f    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x90            0x91            0x92            0x93    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x94            0x95            0x96            0x97    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x99            0x99            0x9a            0x9b    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x9c            0x9d            0x9e            0x9f    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      nobreakspace    exclamdown      cent            sterling        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      currency        yen             brokenbar       section         */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      diaeresis       copyright       ordfeminine     guillemotleft   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      notsign         hyphen          registered      macron          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      degree          plusminus       twosuperior     threesuperior   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      acute           mu              paragraph       periodcentered  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      cedilla         onesuperior     masculine       guillemotright  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      onequarter      onehalf         threequarters   questiondown    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Agrave          Aacute          Acircumflex     Atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Adiaeresis      Aring           AE              Ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Egrave          Eacute          Ecircumflex     Ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Igrave          Iacute          Icircumflex     Idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Eth             Ntilde          Ograve          Oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ocircumflex     Otilde          Odiaeresis      multiply        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ooblique        Ugrave          Uacute          Ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Udiaeresis      Yacute          Thorn           ssharp          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      agrave          aacute          acircumflex     atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      adiaeresis      aring           ae              ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      egrave          eacute          ecircumflex     ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      igrave          iacute          icircumflex     idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      eth             ntilde          ograve          oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      ocircumflex     otilde          odiaeresis      division        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      oslash          ugrave          uacute          ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      udiaeresis      yacute          thorn           ydiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+    };
+    
+    public final static int[] acsTable_ibm3151=
+    {
+        /*	NUL		SOH		STX		ETX	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	EOT		ENQ		ACK		BEL	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	BS		HT		NL		VT	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	NP		CR		SO		SI	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	DLE		DC1		DC2		DC3	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	DC4		NAK		SYN		ETB	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	CAN		EM		SUB		ESC	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	FS		GS		RS		US	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	SP		!		"		#	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	$		%		&		'	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	(		)		*		+	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	,		-		.		/	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	0		1		2		3	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	4		5		6		7	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	8		9		:		;	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	<		=		>		?	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	@		A		B		C	*/
+        CASE_GROUND_STATE,
+        CASE_IBM3151_ACS,
+        CASE_IBM3151_ACS,
+        CASE_GROUND_STATE,
+        /*	D		E		F		G	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	H		I		J		K	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	L		M		N		O	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	P		Q		R		S	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	T		U		V		W	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	X		Y		Z		[	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	\		]		^		_	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	`		a		b		c	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	d		e		f		g	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	h		i		j		k	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	l		m		n		o	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	p		q		r		s	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	t		u		v		w	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	x		y		z		{	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*	|		}		~		DEL	*/
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x80            0x81            0x82            0x83    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x84            0x85            0x86            0x87    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x88            0x89            0x8a            0x8b    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x8c            0x8d            0x8e            0x8f    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x90            0x91            0x92            0x93    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x94            0x95            0x96            0x97    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x99            0x99            0x9a            0x9b    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      0x9c            0x9d            0x9e            0x9f    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      nobreakspace    exclamdown      cent            sterling        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      currency        yen             brokenbar       section         */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      diaeresis       copyright       ordfeminine     guillemotleft   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      notsign         hyphen          registered      macron          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      degree          plusminus       twosuperior     threesuperior   */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      acute           mu              paragraph       periodcentered  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      cedilla         onesuperior     masculine       guillemotright  */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      onequarter      onehalf         threequarters   questiondown    */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Agrave          Aacute          Acircumflex     Atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Adiaeresis      Aring           AE              Ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Egrave          Eacute          Ecircumflex     Ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Igrave          Iacute          Icircumflex     Idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Eth             Ntilde          Ograve          Oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ocircumflex     Otilde          Odiaeresis      multiply        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Ooblique        Ugrave          Uacute          Ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      Udiaeresis      Yacute          Thorn           ssharp          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      agrave          aacute          acircumflex     atilde          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      adiaeresis      aring           ae              ccedilla        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      egrave          eacute          ecircumflex     ediaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      igrave          iacute          icircumflex     idiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      eth             ntilde          ograve          oacute          */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      ocircumflex     otilde          odiaeresis      division        */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      oslash          ugrave          uacute          ucircumflex     */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        /*      udiaeresis      yacute          thorn           ydiaeresis      */
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+        CASE_GROUND_STATE,
+    };
+
     // CASE_IGNORE_ESC
     public final static int[] iesTable =
         {
diff -ruN mindterm_3.1.2.org/com/mindbright/util/EncryptedProperties.java mindterm_3.1.2/com/mindbright/util/EncryptedProperties.java
--- mindterm_3.1.2.org/com/mindbright/util/EncryptedProperties.java	2005-11-17 06:03:05.000000000 -0800
+++ mindterm_3.1.2/com/mindbright/util/EncryptedProperties.java	2009-06-18 12:10:45.000000000 -0700
@@ -57,7 +57,7 @@
      * Property identifying the file
      */
     public final static String PROPS_HEADER = "Sealed with com.mindbright.util.EncryptedProperties" +
-            "(ver. $Name: v3_1_2 $" + "$Date: 2005/11/17 14:03:05 $)";
+            "(ver. $Name:  $" + "$Date: 2007/04/10 13:01:59 $)";
 
     private boolean isNormalPropsFile;
 
diff -ruN mindterm_3.1.2.org/filesets.xml mindterm_3.1.2/filesets.xml
--- mindterm_3.1.2.org/filesets.xml	2006-11-10 11:30:52.000000000 -0800
+++ mindterm_3.1.2/filesets.xml	2009-06-18 12:10:45.000000000 -0700
@@ -1,7 +1,10 @@
+<!-- [CYCLADES-START] com/cyclades/** added in base_classes_common [CYCLADES-END] -->
+<project name="filesets">
 <fileset
   id="base_classes_common"
   dir="${build.mindterm}"
   includes="
+    com/cyclades/**
     com/isnetworks/ssh/AbstractFileBrowser.class
     com/isnetworks/ssh/FileBrowser.class
     com/isnetworks/ssh/FileDisplayControl.class
@@ -250,6 +253,8 @@
     com/mindbright/ssh2/SSH2TransportEventAdapter.class
     com/mindbright/ssh2/SSH2TransportEventHandler.class
     com/mindbright/ssh2/SSH2TransportPDU.class
+    com/mindbright/ssh2/SSH2TransportPDUPool$InPDU.class
+    com/mindbright/ssh2/SSH2TransportPDUPool$OutPDU.class
     com/mindbright/ssh2/SSH2TransportPDUPool$PoolPDU.class
     com/mindbright/ssh2/SSH2TransportPDUPool.class
     com/mindbright/ssh2/SSH2UserAuth.class
@@ -336,11 +341,16 @@
   id="mindterm_classes_common"
   dir="${build.mindterm}"
   includes="
+    com/mindbright/application/MindTerm$StateTO.class
+    com/mindbright/application/MindTerm$1.class
     com/mindbright/application/MindTerm.class
     com/mindbright/application/ModuleBaseTerminal.class
+    com/mindbright/application/ModuleBaseTerminal$1.class
     com/mindbright/application/ModuleTelnetImpl$ChaffedTelnet.class
     com/mindbright/application/ModuleTelnetImpl.class
+    com/mindbright/application/ModuleTelnetImpl$1.class
     com/mindbright/application/ModuleTerminalImpl.class
+    com/mindbright/application/CustomJTextField.class
     com/mindbright/asn1/ASN1.class
     com/mindbright/asn1/ASN1Any$ASN1AnyStructure.class
     com/mindbright/asn1/ASN1Any$ASN1SequenceOfAny.class
@@ -761,3 +771,4 @@
     com/mindbright/application
     examples"
 />
+</project>
